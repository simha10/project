
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model UlbMaster
 * 
 */
export type UlbMaster = $Result.DefaultSelection<Prisma.$UlbMasterPayload>
/**
 * Model ZoneMaster
 * 
 */
export type ZoneMaster = $Result.DefaultSelection<Prisma.$ZoneMasterPayload>
/**
 * Model WardMaster
 * 
 */
export type WardMaster = $Result.DefaultSelection<Prisma.$WardMasterPayload>
/**
 * Model MohallaMaster
 * 
 */
export type MohallaMaster = $Result.DefaultSelection<Prisma.$MohallaMasterPayload>
/**
 * Model ResponseTypeMaster
 * 
 */
export type ResponseTypeMaster = $Result.DefaultSelection<Prisma.$ResponseTypeMasterPayload>
/**
 * Model PropertyTypeMaster
 * 
 */
export type PropertyTypeMaster = $Result.DefaultSelection<Prisma.$PropertyTypeMasterPayload>
/**
 * Model RespondentStatusMaster
 * 
 */
export type RespondentStatusMaster = $Result.DefaultSelection<Prisma.$RespondentStatusMasterPayload>
/**
 * Model RoadTypeMaster
 * 
 */
export type RoadTypeMaster = $Result.DefaultSelection<Prisma.$RoadTypeMasterPayload>
/**
 * Model ConstructionTypeMaster
 * 
 */
export type ConstructionTypeMaster = $Result.DefaultSelection<Prisma.$ConstructionTypeMasterPayload>
/**
 * Model WaterSourceMaster
 * 
 */
export type WaterSourceMaster = $Result.DefaultSelection<Prisma.$WaterSourceMasterPayload>
/**
 * Model DisposalTypeMaster
 * 
 */
export type DisposalTypeMaster = $Result.DefaultSelection<Prisma.$DisposalTypeMasterPayload>
/**
 * Model NrPropertyCategoryMaster
 * 
 */
export type NrPropertyCategoryMaster = $Result.DefaultSelection<Prisma.$NrPropertyCategoryMasterPayload>
/**
 * Model NrPropertySubCategoryMaster
 * 
 */
export type NrPropertySubCategoryMaster = $Result.DefaultSelection<Prisma.$NrPropertySubCategoryMasterPayload>
/**
 * Model ConstructionNatureMaster
 * 
 */
export type ConstructionNatureMaster = $Result.DefaultSelection<Prisma.$ConstructionNatureMasterPayload>
/**
 * Model SurveyTypeMaster
 * 
 */
export type SurveyTypeMaster = $Result.DefaultSelection<Prisma.$SurveyTypeMasterPayload>
/**
 * Model OccupancyStatusMaster
 * 
 */
export type OccupancyStatusMaster = $Result.DefaultSelection<Prisma.$OccupancyStatusMasterPayload>
/**
 * Model SurveyStatusMaster
 * 
 */
export type SurveyStatusMaster = $Result.DefaultSelection<Prisma.$SurveyStatusMasterPayload>
/**
 * Model WardStatusMaster
 * 
 */
export type WardStatusMaster = $Result.DefaultSelection<Prisma.$WardStatusMasterPayload>
/**
 * Model UsersMaster
 * 
 */
export type UsersMaster = $Result.DefaultSelection<Prisma.$UsersMasterPayload>
/**
 * Model RolePermissionMaster
 * 
 */
export type RolePermissionMaster = $Result.DefaultSelection<Prisma.$RolePermissionMasterPayload>
/**
 * Model UlbZoneMapping
 * 
 */
export type UlbZoneMapping = $Result.DefaultSelection<Prisma.$UlbZoneMappingPayload>
/**
 * Model ZoneWardMapping
 * 
 */
export type ZoneWardMapping = $Result.DefaultSelection<Prisma.$ZoneWardMappingPayload>
/**
 * Model WardMohallaMapping
 * 
 */
export type WardMohallaMapping = $Result.DefaultSelection<Prisma.$WardMohallaMappingPayload>
/**
 * Model SurveyorAssignment
 * 
 */
export type SurveyorAssignment = $Result.DefaultSelection<Prisma.$SurveyorAssignmentPayload>
/**
 * Model WardStatusMapping
 * 
 */
export type WardStatusMapping = $Result.DefaultSelection<Prisma.$WardStatusMappingPayload>
/**
 * Model SurveyStatusMapping
 * 
 */
export type SurveyStatusMapping = $Result.DefaultSelection<Prisma.$SurveyStatusMappingPayload>
/**
 * Model UserRoleMapping
 * 
 */
export type UserRoleMapping = $Result.DefaultSelection<Prisma.$UserRoleMappingPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Surveyors
 * 
 */
export type Surveyors = $Result.DefaultSelection<Prisma.$SurveyorsPayload>
/**
 * Model Supervisors
 * 
 */
export type Supervisors = $Result.DefaultSelection<Prisma.$SupervisorsPayload>
/**
 * Model Admins
 * 
 */
export type Admins = $Result.DefaultSelection<Prisma.$AdminsPayload>
/**
 * Model SurveyDetails
 * 
 */
export type SurveyDetails = $Result.DefaultSelection<Prisma.$SurveyDetailsPayload>
/**
 * Model PropertyDetails
 * 
 */
export type PropertyDetails = $Result.DefaultSelection<Prisma.$PropertyDetailsPayload>
/**
 * Model OwnerDetails
 * 
 */
export type OwnerDetails = $Result.DefaultSelection<Prisma.$OwnerDetailsPayload>
/**
 * Model LocationDetails
 * 
 */
export type LocationDetails = $Result.DefaultSelection<Prisma.$LocationDetailsPayload>
/**
 * Model OtherDetails
 * 
 */
export type OtherDetails = $Result.DefaultSelection<Prisma.$OtherDetailsPayload>
/**
 * Model ResidentialPropertyAssessment
 * 
 */
export type ResidentialPropertyAssessment = $Result.DefaultSelection<Prisma.$ResidentialPropertyAssessmentPayload>
/**
 * Model NonResidentialPropertyAssessment
 * 
 */
export type NonResidentialPropertyAssessment = $Result.DefaultSelection<Prisma.$NonResidentialPropertyAssessmentPayload>
/**
 * Model PropertyAttachmentDetails
 * 
 */
export type PropertyAttachmentDetails = $Result.DefaultSelection<Prisma.$PropertyAttachmentDetailsPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more UlbMasters
 * const ulbMasters = await prisma.ulbMaster.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more UlbMasters
   * const ulbMasters = await prisma.ulbMaster.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.ulbMaster`: Exposes CRUD operations for the **UlbMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UlbMasters
    * const ulbMasters = await prisma.ulbMaster.findMany()
    * ```
    */
  get ulbMaster(): Prisma.UlbMasterDelegate<ExtArgs>;

  /**
   * `prisma.zoneMaster`: Exposes CRUD operations for the **ZoneMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ZoneMasters
    * const zoneMasters = await prisma.zoneMaster.findMany()
    * ```
    */
  get zoneMaster(): Prisma.ZoneMasterDelegate<ExtArgs>;

  /**
   * `prisma.wardMaster`: Exposes CRUD operations for the **WardMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WardMasters
    * const wardMasters = await prisma.wardMaster.findMany()
    * ```
    */
  get wardMaster(): Prisma.WardMasterDelegate<ExtArgs>;

  /**
   * `prisma.mohallaMaster`: Exposes CRUD operations for the **MohallaMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MohallaMasters
    * const mohallaMasters = await prisma.mohallaMaster.findMany()
    * ```
    */
  get mohallaMaster(): Prisma.MohallaMasterDelegate<ExtArgs>;

  /**
   * `prisma.responseTypeMaster`: Exposes CRUD operations for the **ResponseTypeMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResponseTypeMasters
    * const responseTypeMasters = await prisma.responseTypeMaster.findMany()
    * ```
    */
  get responseTypeMaster(): Prisma.ResponseTypeMasterDelegate<ExtArgs>;

  /**
   * `prisma.propertyTypeMaster`: Exposes CRUD operations for the **PropertyTypeMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyTypeMasters
    * const propertyTypeMasters = await prisma.propertyTypeMaster.findMany()
    * ```
    */
  get propertyTypeMaster(): Prisma.PropertyTypeMasterDelegate<ExtArgs>;

  /**
   * `prisma.respondentStatusMaster`: Exposes CRUD operations for the **RespondentStatusMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RespondentStatusMasters
    * const respondentStatusMasters = await prisma.respondentStatusMaster.findMany()
    * ```
    */
  get respondentStatusMaster(): Prisma.RespondentStatusMasterDelegate<ExtArgs>;

  /**
   * `prisma.roadTypeMaster`: Exposes CRUD operations for the **RoadTypeMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoadTypeMasters
    * const roadTypeMasters = await prisma.roadTypeMaster.findMany()
    * ```
    */
  get roadTypeMaster(): Prisma.RoadTypeMasterDelegate<ExtArgs>;

  /**
   * `prisma.constructionTypeMaster`: Exposes CRUD operations for the **ConstructionTypeMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConstructionTypeMasters
    * const constructionTypeMasters = await prisma.constructionTypeMaster.findMany()
    * ```
    */
  get constructionTypeMaster(): Prisma.ConstructionTypeMasterDelegate<ExtArgs>;

  /**
   * `prisma.waterSourceMaster`: Exposes CRUD operations for the **WaterSourceMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WaterSourceMasters
    * const waterSourceMasters = await prisma.waterSourceMaster.findMany()
    * ```
    */
  get waterSourceMaster(): Prisma.WaterSourceMasterDelegate<ExtArgs>;

  /**
   * `prisma.disposalTypeMaster`: Exposes CRUD operations for the **DisposalTypeMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisposalTypeMasters
    * const disposalTypeMasters = await prisma.disposalTypeMaster.findMany()
    * ```
    */
  get disposalTypeMaster(): Prisma.DisposalTypeMasterDelegate<ExtArgs>;

  /**
   * `prisma.nrPropertyCategoryMaster`: Exposes CRUD operations for the **NrPropertyCategoryMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NrPropertyCategoryMasters
    * const nrPropertyCategoryMasters = await prisma.nrPropertyCategoryMaster.findMany()
    * ```
    */
  get nrPropertyCategoryMaster(): Prisma.NrPropertyCategoryMasterDelegate<ExtArgs>;

  /**
   * `prisma.nrPropertySubCategoryMaster`: Exposes CRUD operations for the **NrPropertySubCategoryMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NrPropertySubCategoryMasters
    * const nrPropertySubCategoryMasters = await prisma.nrPropertySubCategoryMaster.findMany()
    * ```
    */
  get nrPropertySubCategoryMaster(): Prisma.NrPropertySubCategoryMasterDelegate<ExtArgs>;

  /**
   * `prisma.constructionNatureMaster`: Exposes CRUD operations for the **ConstructionNatureMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConstructionNatureMasters
    * const constructionNatureMasters = await prisma.constructionNatureMaster.findMany()
    * ```
    */
  get constructionNatureMaster(): Prisma.ConstructionNatureMasterDelegate<ExtArgs>;

  /**
   * `prisma.surveyTypeMaster`: Exposes CRUD operations for the **SurveyTypeMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyTypeMasters
    * const surveyTypeMasters = await prisma.surveyTypeMaster.findMany()
    * ```
    */
  get surveyTypeMaster(): Prisma.SurveyTypeMasterDelegate<ExtArgs>;

  /**
   * `prisma.occupancyStatusMaster`: Exposes CRUD operations for the **OccupancyStatusMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OccupancyStatusMasters
    * const occupancyStatusMasters = await prisma.occupancyStatusMaster.findMany()
    * ```
    */
  get occupancyStatusMaster(): Prisma.OccupancyStatusMasterDelegate<ExtArgs>;

  /**
   * `prisma.surveyStatusMaster`: Exposes CRUD operations for the **SurveyStatusMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyStatusMasters
    * const surveyStatusMasters = await prisma.surveyStatusMaster.findMany()
    * ```
    */
  get surveyStatusMaster(): Prisma.SurveyStatusMasterDelegate<ExtArgs>;

  /**
   * `prisma.wardStatusMaster`: Exposes CRUD operations for the **WardStatusMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WardStatusMasters
    * const wardStatusMasters = await prisma.wardStatusMaster.findMany()
    * ```
    */
  get wardStatusMaster(): Prisma.WardStatusMasterDelegate<ExtArgs>;

  /**
   * `prisma.usersMaster`: Exposes CRUD operations for the **UsersMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsersMasters
    * const usersMasters = await prisma.usersMaster.findMany()
    * ```
    */
  get usersMaster(): Prisma.UsersMasterDelegate<ExtArgs>;

  /**
   * `prisma.rolePermissionMaster`: Exposes CRUD operations for the **RolePermissionMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissionMasters
    * const rolePermissionMasters = await prisma.rolePermissionMaster.findMany()
    * ```
    */
  get rolePermissionMaster(): Prisma.RolePermissionMasterDelegate<ExtArgs>;

  /**
   * `prisma.ulbZoneMapping`: Exposes CRUD operations for the **UlbZoneMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UlbZoneMappings
    * const ulbZoneMappings = await prisma.ulbZoneMapping.findMany()
    * ```
    */
  get ulbZoneMapping(): Prisma.UlbZoneMappingDelegate<ExtArgs>;

  /**
   * `prisma.zoneWardMapping`: Exposes CRUD operations for the **ZoneWardMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ZoneWardMappings
    * const zoneWardMappings = await prisma.zoneWardMapping.findMany()
    * ```
    */
  get zoneWardMapping(): Prisma.ZoneWardMappingDelegate<ExtArgs>;

  /**
   * `prisma.wardMohallaMapping`: Exposes CRUD operations for the **WardMohallaMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WardMohallaMappings
    * const wardMohallaMappings = await prisma.wardMohallaMapping.findMany()
    * ```
    */
  get wardMohallaMapping(): Prisma.WardMohallaMappingDelegate<ExtArgs>;

  /**
   * `prisma.surveyorAssignment`: Exposes CRUD operations for the **SurveyorAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyorAssignments
    * const surveyorAssignments = await prisma.surveyorAssignment.findMany()
    * ```
    */
  get surveyorAssignment(): Prisma.SurveyorAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.wardStatusMapping`: Exposes CRUD operations for the **WardStatusMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WardStatusMappings
    * const wardStatusMappings = await prisma.wardStatusMapping.findMany()
    * ```
    */
  get wardStatusMapping(): Prisma.WardStatusMappingDelegate<ExtArgs>;

  /**
   * `prisma.surveyStatusMapping`: Exposes CRUD operations for the **SurveyStatusMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyStatusMappings
    * const surveyStatusMappings = await prisma.surveyStatusMapping.findMany()
    * ```
    */
  get surveyStatusMapping(): Prisma.SurveyStatusMappingDelegate<ExtArgs>;

  /**
   * `prisma.userRoleMapping`: Exposes CRUD operations for the **UserRoleMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoleMappings
    * const userRoleMappings = await prisma.userRoleMapping.findMany()
    * ```
    */
  get userRoleMapping(): Prisma.UserRoleMappingDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.surveyors`: Exposes CRUD operations for the **Surveyors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Surveyors
    * const surveyors = await prisma.surveyors.findMany()
    * ```
    */
  get surveyors(): Prisma.SurveyorsDelegate<ExtArgs>;

  /**
   * `prisma.supervisors`: Exposes CRUD operations for the **Supervisors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Supervisors
    * const supervisors = await prisma.supervisors.findMany()
    * ```
    */
  get supervisors(): Prisma.SupervisorsDelegate<ExtArgs>;

  /**
   * `prisma.admins`: Exposes CRUD operations for the **Admins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admins.findMany()
    * ```
    */
  get admins(): Prisma.AdminsDelegate<ExtArgs>;

  /**
   * `prisma.surveyDetails`: Exposes CRUD operations for the **SurveyDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyDetails
    * const surveyDetails = await prisma.surveyDetails.findMany()
    * ```
    */
  get surveyDetails(): Prisma.SurveyDetailsDelegate<ExtArgs>;

  /**
   * `prisma.propertyDetails`: Exposes CRUD operations for the **PropertyDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyDetails
    * const propertyDetails = await prisma.propertyDetails.findMany()
    * ```
    */
  get propertyDetails(): Prisma.PropertyDetailsDelegate<ExtArgs>;

  /**
   * `prisma.ownerDetails`: Exposes CRUD operations for the **OwnerDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OwnerDetails
    * const ownerDetails = await prisma.ownerDetails.findMany()
    * ```
    */
  get ownerDetails(): Prisma.OwnerDetailsDelegate<ExtArgs>;

  /**
   * `prisma.locationDetails`: Exposes CRUD operations for the **LocationDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocationDetails
    * const locationDetails = await prisma.locationDetails.findMany()
    * ```
    */
  get locationDetails(): Prisma.LocationDetailsDelegate<ExtArgs>;

  /**
   * `prisma.otherDetails`: Exposes CRUD operations for the **OtherDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OtherDetails
    * const otherDetails = await prisma.otherDetails.findMany()
    * ```
    */
  get otherDetails(): Prisma.OtherDetailsDelegate<ExtArgs>;

  /**
   * `prisma.residentialPropertyAssessment`: Exposes CRUD operations for the **ResidentialPropertyAssessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResidentialPropertyAssessments
    * const residentialPropertyAssessments = await prisma.residentialPropertyAssessment.findMany()
    * ```
    */
  get residentialPropertyAssessment(): Prisma.ResidentialPropertyAssessmentDelegate<ExtArgs>;

  /**
   * `prisma.nonResidentialPropertyAssessment`: Exposes CRUD operations for the **NonResidentialPropertyAssessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NonResidentialPropertyAssessments
    * const nonResidentialPropertyAssessments = await prisma.nonResidentialPropertyAssessment.findMany()
    * ```
    */
  get nonResidentialPropertyAssessment(): Prisma.NonResidentialPropertyAssessmentDelegate<ExtArgs>;

  /**
   * `prisma.propertyAttachmentDetails`: Exposes CRUD operations for the **PropertyAttachmentDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyAttachmentDetails
    * const propertyAttachmentDetails = await prisma.propertyAttachmentDetails.findMany()
    * ```
    */
  get propertyAttachmentDetails(): Prisma.PropertyAttachmentDetailsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    UlbMaster: 'UlbMaster',
    ZoneMaster: 'ZoneMaster',
    WardMaster: 'WardMaster',
    MohallaMaster: 'MohallaMaster',
    ResponseTypeMaster: 'ResponseTypeMaster',
    PropertyTypeMaster: 'PropertyTypeMaster',
    RespondentStatusMaster: 'RespondentStatusMaster',
    RoadTypeMaster: 'RoadTypeMaster',
    ConstructionTypeMaster: 'ConstructionTypeMaster',
    WaterSourceMaster: 'WaterSourceMaster',
    DisposalTypeMaster: 'DisposalTypeMaster',
    NrPropertyCategoryMaster: 'NrPropertyCategoryMaster',
    NrPropertySubCategoryMaster: 'NrPropertySubCategoryMaster',
    ConstructionNatureMaster: 'ConstructionNatureMaster',
    SurveyTypeMaster: 'SurveyTypeMaster',
    OccupancyStatusMaster: 'OccupancyStatusMaster',
    SurveyStatusMaster: 'SurveyStatusMaster',
    WardStatusMaster: 'WardStatusMaster',
    UsersMaster: 'UsersMaster',
    RolePermissionMaster: 'RolePermissionMaster',
    UlbZoneMapping: 'UlbZoneMapping',
    ZoneWardMapping: 'ZoneWardMapping',
    WardMohallaMapping: 'WardMohallaMapping',
    SurveyorAssignment: 'SurveyorAssignment',
    WardStatusMapping: 'WardStatusMapping',
    SurveyStatusMapping: 'SurveyStatusMapping',
    UserRoleMapping: 'UserRoleMapping',
    Session: 'Session',
    Surveyors: 'Surveyors',
    Supervisors: 'Supervisors',
    Admins: 'Admins',
    SurveyDetails: 'SurveyDetails',
    PropertyDetails: 'PropertyDetails',
    OwnerDetails: 'OwnerDetails',
    LocationDetails: 'LocationDetails',
    OtherDetails: 'OtherDetails',
    ResidentialPropertyAssessment: 'ResidentialPropertyAssessment',
    NonResidentialPropertyAssessment: 'NonResidentialPropertyAssessment',
    PropertyAttachmentDetails: 'PropertyAttachmentDetails'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "ulbMaster" | "zoneMaster" | "wardMaster" | "mohallaMaster" | "responseTypeMaster" | "propertyTypeMaster" | "respondentStatusMaster" | "roadTypeMaster" | "constructionTypeMaster" | "waterSourceMaster" | "disposalTypeMaster" | "nrPropertyCategoryMaster" | "nrPropertySubCategoryMaster" | "constructionNatureMaster" | "surveyTypeMaster" | "occupancyStatusMaster" | "surveyStatusMaster" | "wardStatusMaster" | "usersMaster" | "rolePermissionMaster" | "ulbZoneMapping" | "zoneWardMapping" | "wardMohallaMapping" | "surveyorAssignment" | "wardStatusMapping" | "surveyStatusMapping" | "userRoleMapping" | "session" | "surveyors" | "supervisors" | "admins" | "surveyDetails" | "propertyDetails" | "ownerDetails" | "locationDetails" | "otherDetails" | "residentialPropertyAssessment" | "nonResidentialPropertyAssessment" | "propertyAttachmentDetails"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      UlbMaster: {
        payload: Prisma.$UlbMasterPayload<ExtArgs>
        fields: Prisma.UlbMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UlbMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UlbMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbMasterPayload>
          }
          findFirst: {
            args: Prisma.UlbMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UlbMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbMasterPayload>
          }
          findMany: {
            args: Prisma.UlbMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbMasterPayload>[]
          }
          create: {
            args: Prisma.UlbMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbMasterPayload>
          }
          createMany: {
            args: Prisma.UlbMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UlbMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbMasterPayload>[]
          }
          delete: {
            args: Prisma.UlbMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbMasterPayload>
          }
          update: {
            args: Prisma.UlbMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbMasterPayload>
          }
          deleteMany: {
            args: Prisma.UlbMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UlbMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UlbMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbMasterPayload>
          }
          aggregate: {
            args: Prisma.UlbMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUlbMaster>
          }
          groupBy: {
            args: Prisma.UlbMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<UlbMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.UlbMasterCountArgs<ExtArgs>
            result: $Utils.Optional<UlbMasterCountAggregateOutputType> | number
          }
        }
      }
      ZoneMaster: {
        payload: Prisma.$ZoneMasterPayload<ExtArgs>
        fields: Prisma.ZoneMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoneMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoneMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneMasterPayload>
          }
          findFirst: {
            args: Prisma.ZoneMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoneMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneMasterPayload>
          }
          findMany: {
            args: Prisma.ZoneMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneMasterPayload>[]
          }
          create: {
            args: Prisma.ZoneMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneMasterPayload>
          }
          createMany: {
            args: Prisma.ZoneMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZoneMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneMasterPayload>[]
          }
          delete: {
            args: Prisma.ZoneMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneMasterPayload>
          }
          update: {
            args: Prisma.ZoneMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneMasterPayload>
          }
          deleteMany: {
            args: Prisma.ZoneMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZoneMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ZoneMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneMasterPayload>
          }
          aggregate: {
            args: Prisma.ZoneMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZoneMaster>
          }
          groupBy: {
            args: Prisma.ZoneMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoneMasterCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneMasterCountAggregateOutputType> | number
          }
        }
      }
      WardMaster: {
        payload: Prisma.$WardMasterPayload<ExtArgs>
        fields: Prisma.WardMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WardMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WardMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMasterPayload>
          }
          findFirst: {
            args: Prisma.WardMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WardMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMasterPayload>
          }
          findMany: {
            args: Prisma.WardMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMasterPayload>[]
          }
          create: {
            args: Prisma.WardMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMasterPayload>
          }
          createMany: {
            args: Prisma.WardMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WardMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMasterPayload>[]
          }
          delete: {
            args: Prisma.WardMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMasterPayload>
          }
          update: {
            args: Prisma.WardMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMasterPayload>
          }
          deleteMany: {
            args: Prisma.WardMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WardMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WardMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMasterPayload>
          }
          aggregate: {
            args: Prisma.WardMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWardMaster>
          }
          groupBy: {
            args: Prisma.WardMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<WardMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.WardMasterCountArgs<ExtArgs>
            result: $Utils.Optional<WardMasterCountAggregateOutputType> | number
          }
        }
      }
      MohallaMaster: {
        payload: Prisma.$MohallaMasterPayload<ExtArgs>
        fields: Prisma.MohallaMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MohallaMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MohallaMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaMasterPayload>
          }
          findFirst: {
            args: Prisma.MohallaMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MohallaMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaMasterPayload>
          }
          findMany: {
            args: Prisma.MohallaMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaMasterPayload>[]
          }
          create: {
            args: Prisma.MohallaMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaMasterPayload>
          }
          createMany: {
            args: Prisma.MohallaMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MohallaMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaMasterPayload>[]
          }
          delete: {
            args: Prisma.MohallaMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaMasterPayload>
          }
          update: {
            args: Prisma.MohallaMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaMasterPayload>
          }
          deleteMany: {
            args: Prisma.MohallaMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MohallaMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MohallaMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaMasterPayload>
          }
          aggregate: {
            args: Prisma.MohallaMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMohallaMaster>
          }
          groupBy: {
            args: Prisma.MohallaMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<MohallaMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.MohallaMasterCountArgs<ExtArgs>
            result: $Utils.Optional<MohallaMasterCountAggregateOutputType> | number
          }
        }
      }
      ResponseTypeMaster: {
        payload: Prisma.$ResponseTypeMasterPayload<ExtArgs>
        fields: Prisma.ResponseTypeMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResponseTypeMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTypeMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResponseTypeMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTypeMasterPayload>
          }
          findFirst: {
            args: Prisma.ResponseTypeMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTypeMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResponseTypeMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTypeMasterPayload>
          }
          findMany: {
            args: Prisma.ResponseTypeMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTypeMasterPayload>[]
          }
          create: {
            args: Prisma.ResponseTypeMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTypeMasterPayload>
          }
          createMany: {
            args: Prisma.ResponseTypeMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResponseTypeMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTypeMasterPayload>[]
          }
          delete: {
            args: Prisma.ResponseTypeMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTypeMasterPayload>
          }
          update: {
            args: Prisma.ResponseTypeMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTypeMasterPayload>
          }
          deleteMany: {
            args: Prisma.ResponseTypeMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResponseTypeMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResponseTypeMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTypeMasterPayload>
          }
          aggregate: {
            args: Prisma.ResponseTypeMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponseTypeMaster>
          }
          groupBy: {
            args: Prisma.ResponseTypeMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResponseTypeMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResponseTypeMasterCountArgs<ExtArgs>
            result: $Utils.Optional<ResponseTypeMasterCountAggregateOutputType> | number
          }
        }
      }
      PropertyTypeMaster: {
        payload: Prisma.$PropertyTypeMasterPayload<ExtArgs>
        fields: Prisma.PropertyTypeMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyTypeMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyTypeMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
          }
          findFirst: {
            args: Prisma.PropertyTypeMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyTypeMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
          }
          findMany: {
            args: Prisma.PropertyTypeMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>[]
          }
          create: {
            args: Prisma.PropertyTypeMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
          }
          createMany: {
            args: Prisma.PropertyTypeMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyTypeMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>[]
          }
          delete: {
            args: Prisma.PropertyTypeMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
          }
          update: {
            args: Prisma.PropertyTypeMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
          }
          deleteMany: {
            args: Prisma.PropertyTypeMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyTypeMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropertyTypeMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
          }
          aggregate: {
            args: Prisma.PropertyTypeMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyTypeMaster>
          }
          groupBy: {
            args: Prisma.PropertyTypeMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyTypeMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyTypeMasterCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyTypeMasterCountAggregateOutputType> | number
          }
        }
      }
      RespondentStatusMaster: {
        payload: Prisma.$RespondentStatusMasterPayload<ExtArgs>
        fields: Prisma.RespondentStatusMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RespondentStatusMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespondentStatusMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RespondentStatusMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespondentStatusMasterPayload>
          }
          findFirst: {
            args: Prisma.RespondentStatusMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespondentStatusMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RespondentStatusMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespondentStatusMasterPayload>
          }
          findMany: {
            args: Prisma.RespondentStatusMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespondentStatusMasterPayload>[]
          }
          create: {
            args: Prisma.RespondentStatusMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespondentStatusMasterPayload>
          }
          createMany: {
            args: Prisma.RespondentStatusMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RespondentStatusMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespondentStatusMasterPayload>[]
          }
          delete: {
            args: Prisma.RespondentStatusMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespondentStatusMasterPayload>
          }
          update: {
            args: Prisma.RespondentStatusMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespondentStatusMasterPayload>
          }
          deleteMany: {
            args: Prisma.RespondentStatusMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RespondentStatusMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RespondentStatusMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespondentStatusMasterPayload>
          }
          aggregate: {
            args: Prisma.RespondentStatusMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRespondentStatusMaster>
          }
          groupBy: {
            args: Prisma.RespondentStatusMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<RespondentStatusMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.RespondentStatusMasterCountArgs<ExtArgs>
            result: $Utils.Optional<RespondentStatusMasterCountAggregateOutputType> | number
          }
        }
      }
      RoadTypeMaster: {
        payload: Prisma.$RoadTypeMasterPayload<ExtArgs>
        fields: Prisma.RoadTypeMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadTypeMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadTypeMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMasterPayload>
          }
          findFirst: {
            args: Prisma.RoadTypeMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadTypeMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMasterPayload>
          }
          findMany: {
            args: Prisma.RoadTypeMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMasterPayload>[]
          }
          create: {
            args: Prisma.RoadTypeMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMasterPayload>
          }
          createMany: {
            args: Prisma.RoadTypeMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoadTypeMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMasterPayload>[]
          }
          delete: {
            args: Prisma.RoadTypeMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMasterPayload>
          }
          update: {
            args: Prisma.RoadTypeMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMasterPayload>
          }
          deleteMany: {
            args: Prisma.RoadTypeMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadTypeMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoadTypeMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMasterPayload>
          }
          aggregate: {
            args: Prisma.RoadTypeMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadTypeMaster>
          }
          groupBy: {
            args: Prisma.RoadTypeMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadTypeMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadTypeMasterCountArgs<ExtArgs>
            result: $Utils.Optional<RoadTypeMasterCountAggregateOutputType> | number
          }
        }
      }
      ConstructionTypeMaster: {
        payload: Prisma.$ConstructionTypeMasterPayload<ExtArgs>
        fields: Prisma.ConstructionTypeMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConstructionTypeMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConstructionTypeMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMasterPayload>
          }
          findFirst: {
            args: Prisma.ConstructionTypeMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConstructionTypeMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMasterPayload>
          }
          findMany: {
            args: Prisma.ConstructionTypeMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMasterPayload>[]
          }
          create: {
            args: Prisma.ConstructionTypeMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMasterPayload>
          }
          createMany: {
            args: Prisma.ConstructionTypeMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConstructionTypeMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMasterPayload>[]
          }
          delete: {
            args: Prisma.ConstructionTypeMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMasterPayload>
          }
          update: {
            args: Prisma.ConstructionTypeMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMasterPayload>
          }
          deleteMany: {
            args: Prisma.ConstructionTypeMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConstructionTypeMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConstructionTypeMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMasterPayload>
          }
          aggregate: {
            args: Prisma.ConstructionTypeMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConstructionTypeMaster>
          }
          groupBy: {
            args: Prisma.ConstructionTypeMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConstructionTypeMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConstructionTypeMasterCountArgs<ExtArgs>
            result: $Utils.Optional<ConstructionTypeMasterCountAggregateOutputType> | number
          }
        }
      }
      WaterSourceMaster: {
        payload: Prisma.$WaterSourceMasterPayload<ExtArgs>
        fields: Prisma.WaterSourceMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WaterSourceMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaterSourceMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WaterSourceMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaterSourceMasterPayload>
          }
          findFirst: {
            args: Prisma.WaterSourceMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaterSourceMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WaterSourceMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaterSourceMasterPayload>
          }
          findMany: {
            args: Prisma.WaterSourceMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaterSourceMasterPayload>[]
          }
          create: {
            args: Prisma.WaterSourceMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaterSourceMasterPayload>
          }
          createMany: {
            args: Prisma.WaterSourceMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WaterSourceMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaterSourceMasterPayload>[]
          }
          delete: {
            args: Prisma.WaterSourceMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaterSourceMasterPayload>
          }
          update: {
            args: Prisma.WaterSourceMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaterSourceMasterPayload>
          }
          deleteMany: {
            args: Prisma.WaterSourceMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WaterSourceMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WaterSourceMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaterSourceMasterPayload>
          }
          aggregate: {
            args: Prisma.WaterSourceMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWaterSourceMaster>
          }
          groupBy: {
            args: Prisma.WaterSourceMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<WaterSourceMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.WaterSourceMasterCountArgs<ExtArgs>
            result: $Utils.Optional<WaterSourceMasterCountAggregateOutputType> | number
          }
        }
      }
      DisposalTypeMaster: {
        payload: Prisma.$DisposalTypeMasterPayload<ExtArgs>
        fields: Prisma.DisposalTypeMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisposalTypeMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisposalTypeMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisposalTypeMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisposalTypeMasterPayload>
          }
          findFirst: {
            args: Prisma.DisposalTypeMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisposalTypeMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisposalTypeMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisposalTypeMasterPayload>
          }
          findMany: {
            args: Prisma.DisposalTypeMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisposalTypeMasterPayload>[]
          }
          create: {
            args: Prisma.DisposalTypeMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisposalTypeMasterPayload>
          }
          createMany: {
            args: Prisma.DisposalTypeMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisposalTypeMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisposalTypeMasterPayload>[]
          }
          delete: {
            args: Prisma.DisposalTypeMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisposalTypeMasterPayload>
          }
          update: {
            args: Prisma.DisposalTypeMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisposalTypeMasterPayload>
          }
          deleteMany: {
            args: Prisma.DisposalTypeMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisposalTypeMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DisposalTypeMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisposalTypeMasterPayload>
          }
          aggregate: {
            args: Prisma.DisposalTypeMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisposalTypeMaster>
          }
          groupBy: {
            args: Prisma.DisposalTypeMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisposalTypeMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisposalTypeMasterCountArgs<ExtArgs>
            result: $Utils.Optional<DisposalTypeMasterCountAggregateOutputType> | number
          }
        }
      }
      NrPropertyCategoryMaster: {
        payload: Prisma.$NrPropertyCategoryMasterPayload<ExtArgs>
        fields: Prisma.NrPropertyCategoryMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NrPropertyCategoryMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertyCategoryMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NrPropertyCategoryMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertyCategoryMasterPayload>
          }
          findFirst: {
            args: Prisma.NrPropertyCategoryMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertyCategoryMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NrPropertyCategoryMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertyCategoryMasterPayload>
          }
          findMany: {
            args: Prisma.NrPropertyCategoryMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertyCategoryMasterPayload>[]
          }
          create: {
            args: Prisma.NrPropertyCategoryMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertyCategoryMasterPayload>
          }
          createMany: {
            args: Prisma.NrPropertyCategoryMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NrPropertyCategoryMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertyCategoryMasterPayload>[]
          }
          delete: {
            args: Prisma.NrPropertyCategoryMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertyCategoryMasterPayload>
          }
          update: {
            args: Prisma.NrPropertyCategoryMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertyCategoryMasterPayload>
          }
          deleteMany: {
            args: Prisma.NrPropertyCategoryMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NrPropertyCategoryMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NrPropertyCategoryMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertyCategoryMasterPayload>
          }
          aggregate: {
            args: Prisma.NrPropertyCategoryMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNrPropertyCategoryMaster>
          }
          groupBy: {
            args: Prisma.NrPropertyCategoryMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<NrPropertyCategoryMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.NrPropertyCategoryMasterCountArgs<ExtArgs>
            result: $Utils.Optional<NrPropertyCategoryMasterCountAggregateOutputType> | number
          }
        }
      }
      NrPropertySubCategoryMaster: {
        payload: Prisma.$NrPropertySubCategoryMasterPayload<ExtArgs>
        fields: Prisma.NrPropertySubCategoryMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NrPropertySubCategoryMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertySubCategoryMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NrPropertySubCategoryMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertySubCategoryMasterPayload>
          }
          findFirst: {
            args: Prisma.NrPropertySubCategoryMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertySubCategoryMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NrPropertySubCategoryMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertySubCategoryMasterPayload>
          }
          findMany: {
            args: Prisma.NrPropertySubCategoryMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertySubCategoryMasterPayload>[]
          }
          create: {
            args: Prisma.NrPropertySubCategoryMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertySubCategoryMasterPayload>
          }
          createMany: {
            args: Prisma.NrPropertySubCategoryMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NrPropertySubCategoryMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertySubCategoryMasterPayload>[]
          }
          delete: {
            args: Prisma.NrPropertySubCategoryMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertySubCategoryMasterPayload>
          }
          update: {
            args: Prisma.NrPropertySubCategoryMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertySubCategoryMasterPayload>
          }
          deleteMany: {
            args: Prisma.NrPropertySubCategoryMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NrPropertySubCategoryMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NrPropertySubCategoryMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NrPropertySubCategoryMasterPayload>
          }
          aggregate: {
            args: Prisma.NrPropertySubCategoryMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNrPropertySubCategoryMaster>
          }
          groupBy: {
            args: Prisma.NrPropertySubCategoryMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<NrPropertySubCategoryMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.NrPropertySubCategoryMasterCountArgs<ExtArgs>
            result: $Utils.Optional<NrPropertySubCategoryMasterCountAggregateOutputType> | number
          }
        }
      }
      ConstructionNatureMaster: {
        payload: Prisma.$ConstructionNatureMasterPayload<ExtArgs>
        fields: Prisma.ConstructionNatureMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConstructionNatureMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionNatureMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConstructionNatureMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionNatureMasterPayload>
          }
          findFirst: {
            args: Prisma.ConstructionNatureMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionNatureMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConstructionNatureMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionNatureMasterPayload>
          }
          findMany: {
            args: Prisma.ConstructionNatureMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionNatureMasterPayload>[]
          }
          create: {
            args: Prisma.ConstructionNatureMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionNatureMasterPayload>
          }
          createMany: {
            args: Prisma.ConstructionNatureMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConstructionNatureMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionNatureMasterPayload>[]
          }
          delete: {
            args: Prisma.ConstructionNatureMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionNatureMasterPayload>
          }
          update: {
            args: Prisma.ConstructionNatureMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionNatureMasterPayload>
          }
          deleteMany: {
            args: Prisma.ConstructionNatureMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConstructionNatureMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConstructionNatureMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionNatureMasterPayload>
          }
          aggregate: {
            args: Prisma.ConstructionNatureMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConstructionNatureMaster>
          }
          groupBy: {
            args: Prisma.ConstructionNatureMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConstructionNatureMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConstructionNatureMasterCountArgs<ExtArgs>
            result: $Utils.Optional<ConstructionNatureMasterCountAggregateOutputType> | number
          }
        }
      }
      SurveyTypeMaster: {
        payload: Prisma.$SurveyTypeMasterPayload<ExtArgs>
        fields: Prisma.SurveyTypeMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyTypeMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyTypeMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyTypeMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyTypeMasterPayload>
          }
          findFirst: {
            args: Prisma.SurveyTypeMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyTypeMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyTypeMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyTypeMasterPayload>
          }
          findMany: {
            args: Prisma.SurveyTypeMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyTypeMasterPayload>[]
          }
          create: {
            args: Prisma.SurveyTypeMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyTypeMasterPayload>
          }
          createMany: {
            args: Prisma.SurveyTypeMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurveyTypeMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyTypeMasterPayload>[]
          }
          delete: {
            args: Prisma.SurveyTypeMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyTypeMasterPayload>
          }
          update: {
            args: Prisma.SurveyTypeMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyTypeMasterPayload>
          }
          deleteMany: {
            args: Prisma.SurveyTypeMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyTypeMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SurveyTypeMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyTypeMasterPayload>
          }
          aggregate: {
            args: Prisma.SurveyTypeMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyTypeMaster>
          }
          groupBy: {
            args: Prisma.SurveyTypeMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyTypeMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyTypeMasterCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyTypeMasterCountAggregateOutputType> | number
          }
        }
      }
      OccupancyStatusMaster: {
        payload: Prisma.$OccupancyStatusMasterPayload<ExtArgs>
        fields: Prisma.OccupancyStatusMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OccupancyStatusMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupancyStatusMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OccupancyStatusMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupancyStatusMasterPayload>
          }
          findFirst: {
            args: Prisma.OccupancyStatusMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupancyStatusMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OccupancyStatusMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupancyStatusMasterPayload>
          }
          findMany: {
            args: Prisma.OccupancyStatusMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupancyStatusMasterPayload>[]
          }
          create: {
            args: Prisma.OccupancyStatusMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupancyStatusMasterPayload>
          }
          createMany: {
            args: Prisma.OccupancyStatusMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OccupancyStatusMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupancyStatusMasterPayload>[]
          }
          delete: {
            args: Prisma.OccupancyStatusMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupancyStatusMasterPayload>
          }
          update: {
            args: Prisma.OccupancyStatusMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupancyStatusMasterPayload>
          }
          deleteMany: {
            args: Prisma.OccupancyStatusMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OccupancyStatusMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OccupancyStatusMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupancyStatusMasterPayload>
          }
          aggregate: {
            args: Prisma.OccupancyStatusMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOccupancyStatusMaster>
          }
          groupBy: {
            args: Prisma.OccupancyStatusMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<OccupancyStatusMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.OccupancyStatusMasterCountArgs<ExtArgs>
            result: $Utils.Optional<OccupancyStatusMasterCountAggregateOutputType> | number
          }
        }
      }
      SurveyStatusMaster: {
        payload: Prisma.$SurveyStatusMasterPayload<ExtArgs>
        fields: Prisma.SurveyStatusMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyStatusMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyStatusMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMasterPayload>
          }
          findFirst: {
            args: Prisma.SurveyStatusMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyStatusMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMasterPayload>
          }
          findMany: {
            args: Prisma.SurveyStatusMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMasterPayload>[]
          }
          create: {
            args: Prisma.SurveyStatusMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMasterPayload>
          }
          createMany: {
            args: Prisma.SurveyStatusMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurveyStatusMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMasterPayload>[]
          }
          delete: {
            args: Prisma.SurveyStatusMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMasterPayload>
          }
          update: {
            args: Prisma.SurveyStatusMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMasterPayload>
          }
          deleteMany: {
            args: Prisma.SurveyStatusMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyStatusMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SurveyStatusMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMasterPayload>
          }
          aggregate: {
            args: Prisma.SurveyStatusMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyStatusMaster>
          }
          groupBy: {
            args: Prisma.SurveyStatusMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyStatusMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyStatusMasterCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyStatusMasterCountAggregateOutputType> | number
          }
        }
      }
      WardStatusMaster: {
        payload: Prisma.$WardStatusMasterPayload<ExtArgs>
        fields: Prisma.WardStatusMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WardStatusMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WardStatusMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMasterPayload>
          }
          findFirst: {
            args: Prisma.WardStatusMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WardStatusMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMasterPayload>
          }
          findMany: {
            args: Prisma.WardStatusMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMasterPayload>[]
          }
          create: {
            args: Prisma.WardStatusMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMasterPayload>
          }
          createMany: {
            args: Prisma.WardStatusMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WardStatusMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMasterPayload>[]
          }
          delete: {
            args: Prisma.WardStatusMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMasterPayload>
          }
          update: {
            args: Prisma.WardStatusMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMasterPayload>
          }
          deleteMany: {
            args: Prisma.WardStatusMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WardStatusMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WardStatusMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMasterPayload>
          }
          aggregate: {
            args: Prisma.WardStatusMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWardStatusMaster>
          }
          groupBy: {
            args: Prisma.WardStatusMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<WardStatusMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.WardStatusMasterCountArgs<ExtArgs>
            result: $Utils.Optional<WardStatusMasterCountAggregateOutputType> | number
          }
        }
      }
      UsersMaster: {
        payload: Prisma.$UsersMasterPayload<ExtArgs>
        fields: Prisma.UsersMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersMasterPayload>
          }
          findFirst: {
            args: Prisma.UsersMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersMasterPayload>
          }
          findMany: {
            args: Prisma.UsersMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersMasterPayload>[]
          }
          create: {
            args: Prisma.UsersMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersMasterPayload>
          }
          createMany: {
            args: Prisma.UsersMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsersMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersMasterPayload>[]
          }
          delete: {
            args: Prisma.UsersMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersMasterPayload>
          }
          update: {
            args: Prisma.UsersMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersMasterPayload>
          }
          deleteMany: {
            args: Prisma.UsersMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersMasterPayload>
          }
          aggregate: {
            args: Prisma.UsersMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsersMaster>
          }
          groupBy: {
            args: Prisma.UsersMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersMasterCountArgs<ExtArgs>
            result: $Utils.Optional<UsersMasterCountAggregateOutputType> | number
          }
        }
      }
      RolePermissionMaster: {
        payload: Prisma.$RolePermissionMasterPayload<ExtArgs>
        fields: Prisma.RolePermissionMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionMasterPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionMasterPayload>
          }
          findMany: {
            args: Prisma.RolePermissionMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionMasterPayload>[]
          }
          create: {
            args: Prisma.RolePermissionMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionMasterPayload>
          }
          createMany: {
            args: Prisma.RolePermissionMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionMasterPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionMasterPayload>
          }
          update: {
            args: Prisma.RolePermissionMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionMasterPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionMasterPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermissionMaster>
          }
          groupBy: {
            args: Prisma.RolePermissionMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionMasterCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionMasterCountAggregateOutputType> | number
          }
        }
      }
      UlbZoneMapping: {
        payload: Prisma.$UlbZoneMappingPayload<ExtArgs>
        fields: Prisma.UlbZoneMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UlbZoneMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbZoneMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UlbZoneMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbZoneMappingPayload>
          }
          findFirst: {
            args: Prisma.UlbZoneMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbZoneMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UlbZoneMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbZoneMappingPayload>
          }
          findMany: {
            args: Prisma.UlbZoneMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbZoneMappingPayload>[]
          }
          create: {
            args: Prisma.UlbZoneMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbZoneMappingPayload>
          }
          createMany: {
            args: Prisma.UlbZoneMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UlbZoneMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbZoneMappingPayload>[]
          }
          delete: {
            args: Prisma.UlbZoneMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbZoneMappingPayload>
          }
          update: {
            args: Prisma.UlbZoneMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbZoneMappingPayload>
          }
          deleteMany: {
            args: Prisma.UlbZoneMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UlbZoneMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UlbZoneMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UlbZoneMappingPayload>
          }
          aggregate: {
            args: Prisma.UlbZoneMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUlbZoneMapping>
          }
          groupBy: {
            args: Prisma.UlbZoneMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UlbZoneMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UlbZoneMappingCountArgs<ExtArgs>
            result: $Utils.Optional<UlbZoneMappingCountAggregateOutputType> | number
          }
        }
      }
      ZoneWardMapping: {
        payload: Prisma.$ZoneWardMappingPayload<ExtArgs>
        fields: Prisma.ZoneWardMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoneWardMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneWardMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoneWardMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneWardMappingPayload>
          }
          findFirst: {
            args: Prisma.ZoneWardMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneWardMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoneWardMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneWardMappingPayload>
          }
          findMany: {
            args: Prisma.ZoneWardMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneWardMappingPayload>[]
          }
          create: {
            args: Prisma.ZoneWardMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneWardMappingPayload>
          }
          createMany: {
            args: Prisma.ZoneWardMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZoneWardMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneWardMappingPayload>[]
          }
          delete: {
            args: Prisma.ZoneWardMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneWardMappingPayload>
          }
          update: {
            args: Prisma.ZoneWardMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneWardMappingPayload>
          }
          deleteMany: {
            args: Prisma.ZoneWardMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZoneWardMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ZoneWardMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneWardMappingPayload>
          }
          aggregate: {
            args: Prisma.ZoneWardMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZoneWardMapping>
          }
          groupBy: {
            args: Prisma.ZoneWardMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneWardMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoneWardMappingCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneWardMappingCountAggregateOutputType> | number
          }
        }
      }
      WardMohallaMapping: {
        payload: Prisma.$WardMohallaMappingPayload<ExtArgs>
        fields: Prisma.WardMohallaMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WardMohallaMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMohallaMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WardMohallaMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMohallaMappingPayload>
          }
          findFirst: {
            args: Prisma.WardMohallaMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMohallaMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WardMohallaMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMohallaMappingPayload>
          }
          findMany: {
            args: Prisma.WardMohallaMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMohallaMappingPayload>[]
          }
          create: {
            args: Prisma.WardMohallaMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMohallaMappingPayload>
          }
          createMany: {
            args: Prisma.WardMohallaMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WardMohallaMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMohallaMappingPayload>[]
          }
          delete: {
            args: Prisma.WardMohallaMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMohallaMappingPayload>
          }
          update: {
            args: Prisma.WardMohallaMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMohallaMappingPayload>
          }
          deleteMany: {
            args: Prisma.WardMohallaMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WardMohallaMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WardMohallaMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardMohallaMappingPayload>
          }
          aggregate: {
            args: Prisma.WardMohallaMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWardMohallaMapping>
          }
          groupBy: {
            args: Prisma.WardMohallaMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<WardMohallaMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.WardMohallaMappingCountArgs<ExtArgs>
            result: $Utils.Optional<WardMohallaMappingCountAggregateOutputType> | number
          }
        }
      }
      SurveyorAssignment: {
        payload: Prisma.$SurveyorAssignmentPayload<ExtArgs>
        fields: Prisma.SurveyorAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyorAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyorAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorAssignmentPayload>
          }
          findFirst: {
            args: Prisma.SurveyorAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyorAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorAssignmentPayload>
          }
          findMany: {
            args: Prisma.SurveyorAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorAssignmentPayload>[]
          }
          create: {
            args: Prisma.SurveyorAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorAssignmentPayload>
          }
          createMany: {
            args: Prisma.SurveyorAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurveyorAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorAssignmentPayload>[]
          }
          delete: {
            args: Prisma.SurveyorAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorAssignmentPayload>
          }
          update: {
            args: Prisma.SurveyorAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.SurveyorAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyorAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SurveyorAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorAssignmentPayload>
          }
          aggregate: {
            args: Prisma.SurveyorAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyorAssignment>
          }
          groupBy: {
            args: Prisma.SurveyorAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyorAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyorAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyorAssignmentCountAggregateOutputType> | number
          }
        }
      }
      WardStatusMapping: {
        payload: Prisma.$WardStatusMappingPayload<ExtArgs>
        fields: Prisma.WardStatusMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WardStatusMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WardStatusMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMappingPayload>
          }
          findFirst: {
            args: Prisma.WardStatusMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WardStatusMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMappingPayload>
          }
          findMany: {
            args: Prisma.WardStatusMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMappingPayload>[]
          }
          create: {
            args: Prisma.WardStatusMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMappingPayload>
          }
          createMany: {
            args: Prisma.WardStatusMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WardStatusMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMappingPayload>[]
          }
          delete: {
            args: Prisma.WardStatusMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMappingPayload>
          }
          update: {
            args: Prisma.WardStatusMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMappingPayload>
          }
          deleteMany: {
            args: Prisma.WardStatusMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WardStatusMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WardStatusMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardStatusMappingPayload>
          }
          aggregate: {
            args: Prisma.WardStatusMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWardStatusMapping>
          }
          groupBy: {
            args: Prisma.WardStatusMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<WardStatusMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.WardStatusMappingCountArgs<ExtArgs>
            result: $Utils.Optional<WardStatusMappingCountAggregateOutputType> | number
          }
        }
      }
      SurveyStatusMapping: {
        payload: Prisma.$SurveyStatusMappingPayload<ExtArgs>
        fields: Prisma.SurveyStatusMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyStatusMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyStatusMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMappingPayload>
          }
          findFirst: {
            args: Prisma.SurveyStatusMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyStatusMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMappingPayload>
          }
          findMany: {
            args: Prisma.SurveyStatusMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMappingPayload>[]
          }
          create: {
            args: Prisma.SurveyStatusMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMappingPayload>
          }
          createMany: {
            args: Prisma.SurveyStatusMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurveyStatusMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMappingPayload>[]
          }
          delete: {
            args: Prisma.SurveyStatusMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMappingPayload>
          }
          update: {
            args: Prisma.SurveyStatusMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMappingPayload>
          }
          deleteMany: {
            args: Prisma.SurveyStatusMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyStatusMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SurveyStatusMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyStatusMappingPayload>
          }
          aggregate: {
            args: Prisma.SurveyStatusMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyStatusMapping>
          }
          groupBy: {
            args: Prisma.SurveyStatusMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyStatusMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyStatusMappingCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyStatusMappingCountAggregateOutputType> | number
          }
        }
      }
      UserRoleMapping: {
        payload: Prisma.$UserRoleMappingPayload<ExtArgs>
        fields: Prisma.UserRoleMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload>
          }
          findFirst: {
            args: Prisma.UserRoleMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload>
          }
          findMany: {
            args: Prisma.UserRoleMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload>[]
          }
          create: {
            args: Prisma.UserRoleMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload>
          }
          createMany: {
            args: Prisma.UserRoleMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload>[]
          }
          delete: {
            args: Prisma.UserRoleMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload>
          }
          update: {
            args: Prisma.UserRoleMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload>
          }
          deleteMany: {
            args: Prisma.UserRoleMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload>
          }
          aggregate: {
            args: Prisma.UserRoleMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRoleMapping>
          }
          groupBy: {
            args: Prisma.UserRoleMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleMappingCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleMappingCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Surveyors: {
        payload: Prisma.$SurveyorsPayload<ExtArgs>
        fields: Prisma.SurveyorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorsPayload>
          }
          findFirst: {
            args: Prisma.SurveyorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorsPayload>
          }
          findMany: {
            args: Prisma.SurveyorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorsPayload>[]
          }
          create: {
            args: Prisma.SurveyorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorsPayload>
          }
          createMany: {
            args: Prisma.SurveyorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurveyorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorsPayload>[]
          }
          delete: {
            args: Prisma.SurveyorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorsPayload>
          }
          update: {
            args: Prisma.SurveyorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorsPayload>
          }
          deleteMany: {
            args: Prisma.SurveyorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SurveyorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyorsPayload>
          }
          aggregate: {
            args: Prisma.SurveyorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyors>
          }
          groupBy: {
            args: Prisma.SurveyorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyorsCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyorsCountAggregateOutputType> | number
          }
        }
      }
      Supervisors: {
        payload: Prisma.$SupervisorsPayload<ExtArgs>
        fields: Prisma.SupervisorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupervisorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupervisorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupervisorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupervisorsPayload>
          }
          findFirst: {
            args: Prisma.SupervisorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupervisorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupervisorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupervisorsPayload>
          }
          findMany: {
            args: Prisma.SupervisorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupervisorsPayload>[]
          }
          create: {
            args: Prisma.SupervisorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupervisorsPayload>
          }
          createMany: {
            args: Prisma.SupervisorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupervisorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupervisorsPayload>[]
          }
          delete: {
            args: Prisma.SupervisorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupervisorsPayload>
          }
          update: {
            args: Prisma.SupervisorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupervisorsPayload>
          }
          deleteMany: {
            args: Prisma.SupervisorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupervisorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupervisorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupervisorsPayload>
          }
          aggregate: {
            args: Prisma.SupervisorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupervisors>
          }
          groupBy: {
            args: Prisma.SupervisorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupervisorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupervisorsCountArgs<ExtArgs>
            result: $Utils.Optional<SupervisorsCountAggregateOutputType> | number
          }
        }
      }
      Admins: {
        payload: Prisma.$AdminsPayload<ExtArgs>
        fields: Prisma.AdminsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          findFirst: {
            args: Prisma.AdminsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          findMany: {
            args: Prisma.AdminsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>[]
          }
          create: {
            args: Prisma.AdminsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          createMany: {
            args: Prisma.AdminsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>[]
          }
          delete: {
            args: Prisma.AdminsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          update: {
            args: Prisma.AdminsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          deleteMany: {
            args: Prisma.AdminsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          aggregate: {
            args: Prisma.AdminsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmins>
          }
          groupBy: {
            args: Prisma.AdminsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminsCountArgs<ExtArgs>
            result: $Utils.Optional<AdminsCountAggregateOutputType> | number
          }
        }
      }
      SurveyDetails: {
        payload: Prisma.$SurveyDetailsPayload<ExtArgs>
        fields: Prisma.SurveyDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyDetailsPayload>
          }
          findFirst: {
            args: Prisma.SurveyDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyDetailsPayload>
          }
          findMany: {
            args: Prisma.SurveyDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyDetailsPayload>[]
          }
          create: {
            args: Prisma.SurveyDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyDetailsPayload>
          }
          createMany: {
            args: Prisma.SurveyDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurveyDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyDetailsPayload>[]
          }
          delete: {
            args: Prisma.SurveyDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyDetailsPayload>
          }
          update: {
            args: Prisma.SurveyDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyDetailsPayload>
          }
          deleteMany: {
            args: Prisma.SurveyDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SurveyDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyDetailsPayload>
          }
          aggregate: {
            args: Prisma.SurveyDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyDetails>
          }
          groupBy: {
            args: Prisma.SurveyDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyDetailsCountAggregateOutputType> | number
          }
        }
      }
      PropertyDetails: {
        payload: Prisma.$PropertyDetailsPayload<ExtArgs>
        fields: Prisma.PropertyDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload>
          }
          findFirst: {
            args: Prisma.PropertyDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload>
          }
          findMany: {
            args: Prisma.PropertyDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload>[]
          }
          create: {
            args: Prisma.PropertyDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload>
          }
          createMany: {
            args: Prisma.PropertyDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload>[]
          }
          delete: {
            args: Prisma.PropertyDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload>
          }
          update: {
            args: Prisma.PropertyDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropertyDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload>
          }
          aggregate: {
            args: Prisma.PropertyDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyDetails>
          }
          groupBy: {
            args: Prisma.PropertyDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyDetailsCountAggregateOutputType> | number
          }
        }
      }
      OwnerDetails: {
        payload: Prisma.$OwnerDetailsPayload<ExtArgs>
        fields: Prisma.OwnerDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnerDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnerDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload>
          }
          findFirst: {
            args: Prisma.OwnerDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnerDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload>
          }
          findMany: {
            args: Prisma.OwnerDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload>[]
          }
          create: {
            args: Prisma.OwnerDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload>
          }
          createMany: {
            args: Prisma.OwnerDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OwnerDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload>[]
          }
          delete: {
            args: Prisma.OwnerDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload>
          }
          update: {
            args: Prisma.OwnerDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload>
          }
          deleteMany: {
            args: Prisma.OwnerDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OwnerDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OwnerDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload>
          }
          aggregate: {
            args: Prisma.OwnerDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwnerDetails>
          }
          groupBy: {
            args: Prisma.OwnerDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OwnerDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnerDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<OwnerDetailsCountAggregateOutputType> | number
          }
        }
      }
      LocationDetails: {
        payload: Prisma.$LocationDetailsPayload<ExtArgs>
        fields: Prisma.LocationDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload>
          }
          findFirst: {
            args: Prisma.LocationDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload>
          }
          findMany: {
            args: Prisma.LocationDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload>[]
          }
          create: {
            args: Prisma.LocationDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload>
          }
          createMany: {
            args: Prisma.LocationDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload>[]
          }
          delete: {
            args: Prisma.LocationDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload>
          }
          update: {
            args: Prisma.LocationDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload>
          }
          deleteMany: {
            args: Prisma.LocationDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload>
          }
          aggregate: {
            args: Prisma.LocationDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocationDetails>
          }
          groupBy: {
            args: Prisma.LocationDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<LocationDetailsCountAggregateOutputType> | number
          }
        }
      }
      OtherDetails: {
        payload: Prisma.$OtherDetailsPayload<ExtArgs>
        fields: Prisma.OtherDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtherDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtherDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload>
          }
          findFirst: {
            args: Prisma.OtherDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtherDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload>
          }
          findMany: {
            args: Prisma.OtherDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload>[]
          }
          create: {
            args: Prisma.OtherDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload>
          }
          createMany: {
            args: Prisma.OtherDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OtherDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload>[]
          }
          delete: {
            args: Prisma.OtherDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload>
          }
          update: {
            args: Prisma.OtherDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload>
          }
          deleteMany: {
            args: Prisma.OtherDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtherDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OtherDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload>
          }
          aggregate: {
            args: Prisma.OtherDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtherDetails>
          }
          groupBy: {
            args: Prisma.OtherDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtherDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtherDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<OtherDetailsCountAggregateOutputType> | number
          }
        }
      }
      ResidentialPropertyAssessment: {
        payload: Prisma.$ResidentialPropertyAssessmentPayload<ExtArgs>
        fields: Prisma.ResidentialPropertyAssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResidentialPropertyAssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentialPropertyAssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResidentialPropertyAssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentialPropertyAssessmentPayload>
          }
          findFirst: {
            args: Prisma.ResidentialPropertyAssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentialPropertyAssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResidentialPropertyAssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentialPropertyAssessmentPayload>
          }
          findMany: {
            args: Prisma.ResidentialPropertyAssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentialPropertyAssessmentPayload>[]
          }
          create: {
            args: Prisma.ResidentialPropertyAssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentialPropertyAssessmentPayload>
          }
          createMany: {
            args: Prisma.ResidentialPropertyAssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResidentialPropertyAssessmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentialPropertyAssessmentPayload>[]
          }
          delete: {
            args: Prisma.ResidentialPropertyAssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentialPropertyAssessmentPayload>
          }
          update: {
            args: Prisma.ResidentialPropertyAssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentialPropertyAssessmentPayload>
          }
          deleteMany: {
            args: Prisma.ResidentialPropertyAssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResidentialPropertyAssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResidentialPropertyAssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentialPropertyAssessmentPayload>
          }
          aggregate: {
            args: Prisma.ResidentialPropertyAssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResidentialPropertyAssessment>
          }
          groupBy: {
            args: Prisma.ResidentialPropertyAssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResidentialPropertyAssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResidentialPropertyAssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<ResidentialPropertyAssessmentCountAggregateOutputType> | number
          }
        }
      }
      NonResidentialPropertyAssessment: {
        payload: Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>
        fields: Prisma.NonResidentialPropertyAssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NonResidentialPropertyAssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonResidentialPropertyAssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NonResidentialPropertyAssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonResidentialPropertyAssessmentPayload>
          }
          findFirst: {
            args: Prisma.NonResidentialPropertyAssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonResidentialPropertyAssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NonResidentialPropertyAssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonResidentialPropertyAssessmentPayload>
          }
          findMany: {
            args: Prisma.NonResidentialPropertyAssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonResidentialPropertyAssessmentPayload>[]
          }
          create: {
            args: Prisma.NonResidentialPropertyAssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonResidentialPropertyAssessmentPayload>
          }
          createMany: {
            args: Prisma.NonResidentialPropertyAssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NonResidentialPropertyAssessmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonResidentialPropertyAssessmentPayload>[]
          }
          delete: {
            args: Prisma.NonResidentialPropertyAssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonResidentialPropertyAssessmentPayload>
          }
          update: {
            args: Prisma.NonResidentialPropertyAssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonResidentialPropertyAssessmentPayload>
          }
          deleteMany: {
            args: Prisma.NonResidentialPropertyAssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NonResidentialPropertyAssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NonResidentialPropertyAssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonResidentialPropertyAssessmentPayload>
          }
          aggregate: {
            args: Prisma.NonResidentialPropertyAssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNonResidentialPropertyAssessment>
          }
          groupBy: {
            args: Prisma.NonResidentialPropertyAssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<NonResidentialPropertyAssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.NonResidentialPropertyAssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<NonResidentialPropertyAssessmentCountAggregateOutputType> | number
          }
        }
      }
      PropertyAttachmentDetails: {
        payload: Prisma.$PropertyAttachmentDetailsPayload<ExtArgs>
        fields: Prisma.PropertyAttachmentDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyAttachmentDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyAttachmentDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentDetailsPayload>
          }
          findFirst: {
            args: Prisma.PropertyAttachmentDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyAttachmentDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentDetailsPayload>
          }
          findMany: {
            args: Prisma.PropertyAttachmentDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentDetailsPayload>[]
          }
          create: {
            args: Prisma.PropertyAttachmentDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentDetailsPayload>
          }
          createMany: {
            args: Prisma.PropertyAttachmentDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyAttachmentDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentDetailsPayload>[]
          }
          delete: {
            args: Prisma.PropertyAttachmentDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentDetailsPayload>
          }
          update: {
            args: Prisma.PropertyAttachmentDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentDetailsPayload>
          }
          deleteMany: {
            args: Prisma.PropertyAttachmentDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyAttachmentDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropertyAttachmentDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentDetailsPayload>
          }
          aggregate: {
            args: Prisma.PropertyAttachmentDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyAttachmentDetails>
          }
          groupBy: {
            args: Prisma.PropertyAttachmentDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyAttachmentDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyAttachmentDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyAttachmentDetailsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UlbMasterCountOutputType
   */

  export type UlbMasterCountOutputType = {
    ulbZoneMaps: number
    surveyDetails: number
  }

  export type UlbMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ulbZoneMaps?: boolean | UlbMasterCountOutputTypeCountUlbZoneMapsArgs
    surveyDetails?: boolean | UlbMasterCountOutputTypeCountSurveyDetailsArgs
  }

  // Custom InputTypes
  /**
   * UlbMasterCountOutputType without action
   */
  export type UlbMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbMasterCountOutputType
     */
    select?: UlbMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UlbMasterCountOutputType without action
   */
  export type UlbMasterCountOutputTypeCountUlbZoneMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UlbZoneMappingWhereInput
  }

  /**
   * UlbMasterCountOutputType without action
   */
  export type UlbMasterCountOutputTypeCountSurveyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyDetailsWhereInput
  }


  /**
   * Count Type ZoneMasterCountOutputType
   */

  export type ZoneMasterCountOutputType = {
    ulbZoneMaps: number
    zoneWardMaps: number
    surveyDetails: number
  }

  export type ZoneMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ulbZoneMaps?: boolean | ZoneMasterCountOutputTypeCountUlbZoneMapsArgs
    zoneWardMaps?: boolean | ZoneMasterCountOutputTypeCountZoneWardMapsArgs
    surveyDetails?: boolean | ZoneMasterCountOutputTypeCountSurveyDetailsArgs
  }

  // Custom InputTypes
  /**
   * ZoneMasterCountOutputType without action
   */
  export type ZoneMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneMasterCountOutputType
     */
    select?: ZoneMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZoneMasterCountOutputType without action
   */
  export type ZoneMasterCountOutputTypeCountUlbZoneMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UlbZoneMappingWhereInput
  }

  /**
   * ZoneMasterCountOutputType without action
   */
  export type ZoneMasterCountOutputTypeCountZoneWardMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWardMappingWhereInput
  }

  /**
   * ZoneMasterCountOutputType without action
   */
  export type ZoneMasterCountOutputTypeCountSurveyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyDetailsWhereInput
  }


  /**
   * Count Type WardMasterCountOutputType
   */

  export type WardMasterCountOutputType = {
    zoneWardMaps: number
    wardMohallaMaps: number
    surveyorAssignments: number
    wardStatusMaps: number
    surveyDetails: number
    supervisors: number
  }

  export type WardMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zoneWardMaps?: boolean | WardMasterCountOutputTypeCountZoneWardMapsArgs
    wardMohallaMaps?: boolean | WardMasterCountOutputTypeCountWardMohallaMapsArgs
    surveyorAssignments?: boolean | WardMasterCountOutputTypeCountSurveyorAssignmentsArgs
    wardStatusMaps?: boolean | WardMasterCountOutputTypeCountWardStatusMapsArgs
    surveyDetails?: boolean | WardMasterCountOutputTypeCountSurveyDetailsArgs
    supervisors?: boolean | WardMasterCountOutputTypeCountSupervisorsArgs
  }

  // Custom InputTypes
  /**
   * WardMasterCountOutputType without action
   */
  export type WardMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMasterCountOutputType
     */
    select?: WardMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WardMasterCountOutputType without action
   */
  export type WardMasterCountOutputTypeCountZoneWardMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWardMappingWhereInput
  }

  /**
   * WardMasterCountOutputType without action
   */
  export type WardMasterCountOutputTypeCountWardMohallaMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardMohallaMappingWhereInput
  }

  /**
   * WardMasterCountOutputType without action
   */
  export type WardMasterCountOutputTypeCountSurveyorAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyorAssignmentWhereInput
  }

  /**
   * WardMasterCountOutputType without action
   */
  export type WardMasterCountOutputTypeCountWardStatusMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardStatusMappingWhereInput
  }

  /**
   * WardMasterCountOutputType without action
   */
  export type WardMasterCountOutputTypeCountSurveyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyDetailsWhereInput
  }

  /**
   * WardMasterCountOutputType without action
   */
  export type WardMasterCountOutputTypeCountSupervisorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupervisorsWhereInput
  }


  /**
   * Count Type MohallaMasterCountOutputType
   */

  export type MohallaMasterCountOutputType = {
    wardMohallaMaps: number
    surveyorAssignments: number
    surveyDetails: number
  }

  export type MohallaMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wardMohallaMaps?: boolean | MohallaMasterCountOutputTypeCountWardMohallaMapsArgs
    surveyorAssignments?: boolean | MohallaMasterCountOutputTypeCountSurveyorAssignmentsArgs
    surveyDetails?: boolean | MohallaMasterCountOutputTypeCountSurveyDetailsArgs
  }

  // Custom InputTypes
  /**
   * MohallaMasterCountOutputType without action
   */
  export type MohallaMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MohallaMasterCountOutputType
     */
    select?: MohallaMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MohallaMasterCountOutputType without action
   */
  export type MohallaMasterCountOutputTypeCountWardMohallaMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardMohallaMappingWhereInput
  }

  /**
   * MohallaMasterCountOutputType without action
   */
  export type MohallaMasterCountOutputTypeCountSurveyorAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyorAssignmentWhereInput
  }

  /**
   * MohallaMasterCountOutputType without action
   */
  export type MohallaMasterCountOutputTypeCountSurveyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyDetailsWhereInput
  }


  /**
   * Count Type ResponseTypeMasterCountOutputType
   */

  export type ResponseTypeMasterCountOutputType = {
    propertyDetails: number
  }

  export type ResponseTypeMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyDetails?: boolean | ResponseTypeMasterCountOutputTypeCountPropertyDetailsArgs
  }

  // Custom InputTypes
  /**
   * ResponseTypeMasterCountOutputType without action
   */
  export type ResponseTypeMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTypeMasterCountOutputType
     */
    select?: ResponseTypeMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResponseTypeMasterCountOutputType without action
   */
  export type ResponseTypeMasterCountOutputTypeCountPropertyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyDetailsWhereInput
  }


  /**
   * Count Type PropertyTypeMasterCountOutputType
   */

  export type PropertyTypeMasterCountOutputType = {
    locationDetails: number
  }

  export type PropertyTypeMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locationDetails?: boolean | PropertyTypeMasterCountOutputTypeCountLocationDetailsArgs
  }

  // Custom InputTypes
  /**
   * PropertyTypeMasterCountOutputType without action
   */
  export type PropertyTypeMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMasterCountOutputType
     */
    select?: PropertyTypeMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyTypeMasterCountOutputType without action
   */
  export type PropertyTypeMasterCountOutputTypeCountLocationDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationDetailsWhereInput
  }


  /**
   * Count Type RespondentStatusMasterCountOutputType
   */

  export type RespondentStatusMasterCountOutputType = {
    propertyDetails: number
  }

  export type RespondentStatusMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyDetails?: boolean | RespondentStatusMasterCountOutputTypeCountPropertyDetailsArgs
  }

  // Custom InputTypes
  /**
   * RespondentStatusMasterCountOutputType without action
   */
  export type RespondentStatusMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespondentStatusMasterCountOutputType
     */
    select?: RespondentStatusMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RespondentStatusMasterCountOutputType without action
   */
  export type RespondentStatusMasterCountOutputTypeCountPropertyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyDetailsWhereInput
  }


  /**
   * Count Type RoadTypeMasterCountOutputType
   */

  export type RoadTypeMasterCountOutputType = {
    locationDetails: number
  }

  export type RoadTypeMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locationDetails?: boolean | RoadTypeMasterCountOutputTypeCountLocationDetailsArgs
  }

  // Custom InputTypes
  /**
   * RoadTypeMasterCountOutputType without action
   */
  export type RoadTypeMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMasterCountOutputType
     */
    select?: RoadTypeMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoadTypeMasterCountOutputType without action
   */
  export type RoadTypeMasterCountOutputTypeCountLocationDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationDetailsWhereInput
  }


  /**
   * Count Type ConstructionTypeMasterCountOutputType
   */

  export type ConstructionTypeMasterCountOutputType = {
    locationDetails: number
  }

  export type ConstructionTypeMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locationDetails?: boolean | ConstructionTypeMasterCountOutputTypeCountLocationDetailsArgs
  }

  // Custom InputTypes
  /**
   * ConstructionTypeMasterCountOutputType without action
   */
  export type ConstructionTypeMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMasterCountOutputType
     */
    select?: ConstructionTypeMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConstructionTypeMasterCountOutputType without action
   */
  export type ConstructionTypeMasterCountOutputTypeCountLocationDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationDetailsWhereInput
  }


  /**
   * Count Type WaterSourceMasterCountOutputType
   */

  export type WaterSourceMasterCountOutputType = {
    otherDetails: number
  }

  export type WaterSourceMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    otherDetails?: boolean | WaterSourceMasterCountOutputTypeCountOtherDetailsArgs
  }

  // Custom InputTypes
  /**
   * WaterSourceMasterCountOutputType without action
   */
  export type WaterSourceMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSourceMasterCountOutputType
     */
    select?: WaterSourceMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WaterSourceMasterCountOutputType without action
   */
  export type WaterSourceMasterCountOutputTypeCountOtherDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtherDetailsWhereInput
  }


  /**
   * Count Type DisposalTypeMasterCountOutputType
   */

  export type DisposalTypeMasterCountOutputType = {
    otherDetails: number
  }

  export type DisposalTypeMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    otherDetails?: boolean | DisposalTypeMasterCountOutputTypeCountOtherDetailsArgs
  }

  // Custom InputTypes
  /**
   * DisposalTypeMasterCountOutputType without action
   */
  export type DisposalTypeMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisposalTypeMasterCountOutputType
     */
    select?: DisposalTypeMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DisposalTypeMasterCountOutputType without action
   */
  export type DisposalTypeMasterCountOutputTypeCountOtherDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtherDetailsWhereInput
  }


  /**
   * Count Type NrPropertyCategoryMasterCountOutputType
   */

  export type NrPropertyCategoryMasterCountOutputType = {
    subCategories: number
    nonResidentialPropertyAssessments: number
  }

  export type NrPropertyCategoryMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCategories?: boolean | NrPropertyCategoryMasterCountOutputTypeCountSubCategoriesArgs
    nonResidentialPropertyAssessments?: boolean | NrPropertyCategoryMasterCountOutputTypeCountNonResidentialPropertyAssessmentsArgs
  }

  // Custom InputTypes
  /**
   * NrPropertyCategoryMasterCountOutputType without action
   */
  export type NrPropertyCategoryMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertyCategoryMasterCountOutputType
     */
    select?: NrPropertyCategoryMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NrPropertyCategoryMasterCountOutputType without action
   */
  export type NrPropertyCategoryMasterCountOutputTypeCountSubCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NrPropertySubCategoryMasterWhereInput
  }

  /**
   * NrPropertyCategoryMasterCountOutputType without action
   */
  export type NrPropertyCategoryMasterCountOutputTypeCountNonResidentialPropertyAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NonResidentialPropertyAssessmentWhereInput
  }


  /**
   * Count Type NrPropertySubCategoryMasterCountOutputType
   */

  export type NrPropertySubCategoryMasterCountOutputType = {
    nonResidentialPropertyAssessments: number
  }

  export type NrPropertySubCategoryMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nonResidentialPropertyAssessments?: boolean | NrPropertySubCategoryMasterCountOutputTypeCountNonResidentialPropertyAssessmentsArgs
  }

  // Custom InputTypes
  /**
   * NrPropertySubCategoryMasterCountOutputType without action
   */
  export type NrPropertySubCategoryMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertySubCategoryMasterCountOutputType
     */
    select?: NrPropertySubCategoryMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NrPropertySubCategoryMasterCountOutputType without action
   */
  export type NrPropertySubCategoryMasterCountOutputTypeCountNonResidentialPropertyAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NonResidentialPropertyAssessmentWhereInput
  }


  /**
   * Count Type ConstructionNatureMasterCountOutputType
   */

  export type ConstructionNatureMasterCountOutputType = {
    residentialPropertyAssessments: number
    nonResidentialPropertyAssessments: number
  }

  export type ConstructionNatureMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    residentialPropertyAssessments?: boolean | ConstructionNatureMasterCountOutputTypeCountResidentialPropertyAssessmentsArgs
    nonResidentialPropertyAssessments?: boolean | ConstructionNatureMasterCountOutputTypeCountNonResidentialPropertyAssessmentsArgs
  }

  // Custom InputTypes
  /**
   * ConstructionNatureMasterCountOutputType without action
   */
  export type ConstructionNatureMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionNatureMasterCountOutputType
     */
    select?: ConstructionNatureMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConstructionNatureMasterCountOutputType without action
   */
  export type ConstructionNatureMasterCountOutputTypeCountResidentialPropertyAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResidentialPropertyAssessmentWhereInput
  }

  /**
   * ConstructionNatureMasterCountOutputType without action
   */
  export type ConstructionNatureMasterCountOutputTypeCountNonResidentialPropertyAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NonResidentialPropertyAssessmentWhereInput
  }


  /**
   * Count Type SurveyTypeMasterCountOutputType
   */

  export type SurveyTypeMasterCountOutputType = {
    surveyDetails: number
  }

  export type SurveyTypeMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyDetails?: boolean | SurveyTypeMasterCountOutputTypeCountSurveyDetailsArgs
  }

  // Custom InputTypes
  /**
   * SurveyTypeMasterCountOutputType without action
   */
  export type SurveyTypeMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyTypeMasterCountOutputType
     */
    select?: SurveyTypeMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SurveyTypeMasterCountOutputType without action
   */
  export type SurveyTypeMasterCountOutputTypeCountSurveyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyDetailsWhereInput
  }


  /**
   * Count Type OccupancyStatusMasterCountOutputType
   */

  export type OccupancyStatusMasterCountOutputType = {
    residentialPropertyAssessments: number
    nonResidentialPropertyAssessments: number
  }

  export type OccupancyStatusMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    residentialPropertyAssessments?: boolean | OccupancyStatusMasterCountOutputTypeCountResidentialPropertyAssessmentsArgs
    nonResidentialPropertyAssessments?: boolean | OccupancyStatusMasterCountOutputTypeCountNonResidentialPropertyAssessmentsArgs
  }

  // Custom InputTypes
  /**
   * OccupancyStatusMasterCountOutputType without action
   */
  export type OccupancyStatusMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupancyStatusMasterCountOutputType
     */
    select?: OccupancyStatusMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OccupancyStatusMasterCountOutputType without action
   */
  export type OccupancyStatusMasterCountOutputTypeCountResidentialPropertyAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResidentialPropertyAssessmentWhereInput
  }

  /**
   * OccupancyStatusMasterCountOutputType without action
   */
  export type OccupancyStatusMasterCountOutputTypeCountNonResidentialPropertyAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NonResidentialPropertyAssessmentWhereInput
  }


  /**
   * Count Type SurveyStatusMasterCountOutputType
   */

  export type SurveyStatusMasterCountOutputType = {
    surveyStatusMaps: number
    surveyStatusMapsReverted: number
  }

  export type SurveyStatusMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyStatusMaps?: boolean | SurveyStatusMasterCountOutputTypeCountSurveyStatusMapsArgs
    surveyStatusMapsReverted?: boolean | SurveyStatusMasterCountOutputTypeCountSurveyStatusMapsRevertedArgs
  }

  // Custom InputTypes
  /**
   * SurveyStatusMasterCountOutputType without action
   */
  export type SurveyStatusMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMasterCountOutputType
     */
    select?: SurveyStatusMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SurveyStatusMasterCountOutputType without action
   */
  export type SurveyStatusMasterCountOutputTypeCountSurveyStatusMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyStatusMappingWhereInput
  }

  /**
   * SurveyStatusMasterCountOutputType without action
   */
  export type SurveyStatusMasterCountOutputTypeCountSurveyStatusMapsRevertedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyStatusMappingWhereInput
  }


  /**
   * Count Type WardStatusMasterCountOutputType
   */

  export type WardStatusMasterCountOutputType = {
    wardStatusMaps: number
  }

  export type WardStatusMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wardStatusMaps?: boolean | WardStatusMasterCountOutputTypeCountWardStatusMapsArgs
  }

  // Custom InputTypes
  /**
   * WardStatusMasterCountOutputType without action
   */
  export type WardStatusMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMasterCountOutputType
     */
    select?: WardStatusMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WardStatusMasterCountOutputType without action
   */
  export type WardStatusMasterCountOutputTypeCountWardStatusMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardStatusMappingWhereInput
  }


  /**
   * Count Type UsersMasterCountOutputType
   */

  export type UsersMasterCountOutputType = {
    surveyorAssignments: number
    surveyorAssignmentsAssignedBy: number
    wardStatusMaps: number
    surveyStatusMaps: number
    userRoleMaps: number
    sessions: number
    surveyors: number
    supervisors: number
    admins: number
  }

  export type UsersMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyorAssignments?: boolean | UsersMasterCountOutputTypeCountSurveyorAssignmentsArgs
    surveyorAssignmentsAssignedBy?: boolean | UsersMasterCountOutputTypeCountSurveyorAssignmentsAssignedByArgs
    wardStatusMaps?: boolean | UsersMasterCountOutputTypeCountWardStatusMapsArgs
    surveyStatusMaps?: boolean | UsersMasterCountOutputTypeCountSurveyStatusMapsArgs
    userRoleMaps?: boolean | UsersMasterCountOutputTypeCountUserRoleMapsArgs
    sessions?: boolean | UsersMasterCountOutputTypeCountSessionsArgs
    surveyors?: boolean | UsersMasterCountOutputTypeCountSurveyorsArgs
    supervisors?: boolean | UsersMasterCountOutputTypeCountSupervisorsArgs
    admins?: boolean | UsersMasterCountOutputTypeCountAdminsArgs
  }

  // Custom InputTypes
  /**
   * UsersMasterCountOutputType without action
   */
  export type UsersMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersMasterCountOutputType
     */
    select?: UsersMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersMasterCountOutputType without action
   */
  export type UsersMasterCountOutputTypeCountSurveyorAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyorAssignmentWhereInput
  }

  /**
   * UsersMasterCountOutputType without action
   */
  export type UsersMasterCountOutputTypeCountSurveyorAssignmentsAssignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyorAssignmentWhereInput
  }

  /**
   * UsersMasterCountOutputType without action
   */
  export type UsersMasterCountOutputTypeCountWardStatusMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardStatusMappingWhereInput
  }

  /**
   * UsersMasterCountOutputType without action
   */
  export type UsersMasterCountOutputTypeCountSurveyStatusMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyStatusMappingWhereInput
  }

  /**
   * UsersMasterCountOutputType without action
   */
  export type UsersMasterCountOutputTypeCountUserRoleMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleMappingWhereInput
  }

  /**
   * UsersMasterCountOutputType without action
   */
  export type UsersMasterCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UsersMasterCountOutputType without action
   */
  export type UsersMasterCountOutputTypeCountSurveyorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyorsWhereInput
  }

  /**
   * UsersMasterCountOutputType without action
   */
  export type UsersMasterCountOutputTypeCountSupervisorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupervisorsWhereInput
  }

  /**
   * UsersMasterCountOutputType without action
   */
  export type UsersMasterCountOutputTypeCountAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminsWhereInput
  }


  /**
   * Count Type RolePermissionMasterCountOutputType
   */

  export type RolePermissionMasterCountOutputType = {
    userRoleMaps: number
  }

  export type RolePermissionMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoleMaps?: boolean | RolePermissionMasterCountOutputTypeCountUserRoleMapsArgs
  }

  // Custom InputTypes
  /**
   * RolePermissionMasterCountOutputType without action
   */
  export type RolePermissionMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissionMasterCountOutputType
     */
    select?: RolePermissionMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolePermissionMasterCountOutputType without action
   */
  export type RolePermissionMasterCountOutputTypeCountUserRoleMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleMappingWhereInput
  }


  /**
   * Count Type UlbZoneMappingCountOutputType
   */

  export type UlbZoneMappingCountOutputType = {
    surveyors: number
  }

  export type UlbZoneMappingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyors?: boolean | UlbZoneMappingCountOutputTypeCountSurveyorsArgs
  }

  // Custom InputTypes
  /**
   * UlbZoneMappingCountOutputType without action
   */
  export type UlbZoneMappingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbZoneMappingCountOutputType
     */
    select?: UlbZoneMappingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UlbZoneMappingCountOutputType without action
   */
  export type UlbZoneMappingCountOutputTypeCountSurveyorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyorsWhereInput
  }


  /**
   * Count Type ZoneWardMappingCountOutputType
   */

  export type ZoneWardMappingCountOutputType = {
    surveyors: number
  }

  export type ZoneWardMappingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyors?: boolean | ZoneWardMappingCountOutputTypeCountSurveyorsArgs
  }

  // Custom InputTypes
  /**
   * ZoneWardMappingCountOutputType without action
   */
  export type ZoneWardMappingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneWardMappingCountOutputType
     */
    select?: ZoneWardMappingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZoneWardMappingCountOutputType without action
   */
  export type ZoneWardMappingCountOutputTypeCountSurveyorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyorsWhereInput
  }


  /**
   * Count Type WardMohallaMappingCountOutputType
   */

  export type WardMohallaMappingCountOutputType = {
    surveyorAssignments: number
    surveyors: number
  }

  export type WardMohallaMappingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyorAssignments?: boolean | WardMohallaMappingCountOutputTypeCountSurveyorAssignmentsArgs
    surveyors?: boolean | WardMohallaMappingCountOutputTypeCountSurveyorsArgs
  }

  // Custom InputTypes
  /**
   * WardMohallaMappingCountOutputType without action
   */
  export type WardMohallaMappingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMohallaMappingCountOutputType
     */
    select?: WardMohallaMappingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WardMohallaMappingCountOutputType without action
   */
  export type WardMohallaMappingCountOutputTypeCountSurveyorAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyorAssignmentWhereInput
  }

  /**
   * WardMohallaMappingCountOutputType without action
   */
  export type WardMohallaMappingCountOutputTypeCountSurveyorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyorsWhereInput
  }


  /**
   * Count Type SurveyDetailsCountOutputType
   */

  export type SurveyDetailsCountOutputType = {
    propertyDetails: number
    ownerDetails: number
    locationDetails: number
    otherDetails: number
    residentialPropertyAssessments: number
    nonResidentialPropertyAssessments: number
    propertyAttachments: number
    surveyStatusMaps: number
  }

  export type SurveyDetailsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyDetails?: boolean | SurveyDetailsCountOutputTypeCountPropertyDetailsArgs
    ownerDetails?: boolean | SurveyDetailsCountOutputTypeCountOwnerDetailsArgs
    locationDetails?: boolean | SurveyDetailsCountOutputTypeCountLocationDetailsArgs
    otherDetails?: boolean | SurveyDetailsCountOutputTypeCountOtherDetailsArgs
    residentialPropertyAssessments?: boolean | SurveyDetailsCountOutputTypeCountResidentialPropertyAssessmentsArgs
    nonResidentialPropertyAssessments?: boolean | SurveyDetailsCountOutputTypeCountNonResidentialPropertyAssessmentsArgs
    propertyAttachments?: boolean | SurveyDetailsCountOutputTypeCountPropertyAttachmentsArgs
    surveyStatusMaps?: boolean | SurveyDetailsCountOutputTypeCountSurveyStatusMapsArgs
  }

  // Custom InputTypes
  /**
   * SurveyDetailsCountOutputType without action
   */
  export type SurveyDetailsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyDetailsCountOutputType
     */
    select?: SurveyDetailsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SurveyDetailsCountOutputType without action
   */
  export type SurveyDetailsCountOutputTypeCountPropertyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyDetailsWhereInput
  }

  /**
   * SurveyDetailsCountOutputType without action
   */
  export type SurveyDetailsCountOutputTypeCountOwnerDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerDetailsWhereInput
  }

  /**
   * SurveyDetailsCountOutputType without action
   */
  export type SurveyDetailsCountOutputTypeCountLocationDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationDetailsWhereInput
  }

  /**
   * SurveyDetailsCountOutputType without action
   */
  export type SurveyDetailsCountOutputTypeCountOtherDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtherDetailsWhereInput
  }

  /**
   * SurveyDetailsCountOutputType without action
   */
  export type SurveyDetailsCountOutputTypeCountResidentialPropertyAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResidentialPropertyAssessmentWhereInput
  }

  /**
   * SurveyDetailsCountOutputType without action
   */
  export type SurveyDetailsCountOutputTypeCountNonResidentialPropertyAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NonResidentialPropertyAssessmentWhereInput
  }

  /**
   * SurveyDetailsCountOutputType without action
   */
  export type SurveyDetailsCountOutputTypeCountPropertyAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyAttachmentDetailsWhereInput
  }

  /**
   * SurveyDetailsCountOutputType without action
   */
  export type SurveyDetailsCountOutputTypeCountSurveyStatusMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyStatusMappingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model UlbMaster
   */

  export type AggregateUlbMaster = {
    _count: UlbMasterCountAggregateOutputType | null
    _min: UlbMasterMinAggregateOutputType | null
    _max: UlbMasterMaxAggregateOutputType | null
  }

  export type UlbMasterMinAggregateOutputType = {
    ulbId: string | null
    ulbName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type UlbMasterMaxAggregateOutputType = {
    ulbId: string | null
    ulbName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type UlbMasterCountAggregateOutputType = {
    ulbId: number
    ulbName: number
    isActive: number
    description: number
    _all: number
  }


  export type UlbMasterMinAggregateInputType = {
    ulbId?: true
    ulbName?: true
    isActive?: true
    description?: true
  }

  export type UlbMasterMaxAggregateInputType = {
    ulbId?: true
    ulbName?: true
    isActive?: true
    description?: true
  }

  export type UlbMasterCountAggregateInputType = {
    ulbId?: true
    ulbName?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type UlbMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UlbMaster to aggregate.
     */
    where?: UlbMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UlbMasters to fetch.
     */
    orderBy?: UlbMasterOrderByWithRelationInput | UlbMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UlbMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UlbMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UlbMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UlbMasters
    **/
    _count?: true | UlbMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UlbMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UlbMasterMaxAggregateInputType
  }

  export type GetUlbMasterAggregateType<T extends UlbMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateUlbMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUlbMaster[P]>
      : GetScalarType<T[P], AggregateUlbMaster[P]>
  }




  export type UlbMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UlbMasterWhereInput
    orderBy?: UlbMasterOrderByWithAggregationInput | UlbMasterOrderByWithAggregationInput[]
    by: UlbMasterScalarFieldEnum[] | UlbMasterScalarFieldEnum
    having?: UlbMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UlbMasterCountAggregateInputType | true
    _min?: UlbMasterMinAggregateInputType
    _max?: UlbMasterMaxAggregateInputType
  }

  export type UlbMasterGroupByOutputType = {
    ulbId: string
    ulbName: string
    isActive: boolean
    description: string | null
    _count: UlbMasterCountAggregateOutputType | null
    _min: UlbMasterMinAggregateOutputType | null
    _max: UlbMasterMaxAggregateOutputType | null
  }

  type GetUlbMasterGroupByPayload<T extends UlbMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UlbMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UlbMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UlbMasterGroupByOutputType[P]>
            : GetScalarType<T[P], UlbMasterGroupByOutputType[P]>
        }
      >
    >


  export type UlbMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ulbId?: boolean
    ulbName?: boolean
    isActive?: boolean
    description?: boolean
    ulbZoneMaps?: boolean | UlbMaster$ulbZoneMapsArgs<ExtArgs>
    surveyDetails?: boolean | UlbMaster$surveyDetailsArgs<ExtArgs>
    _count?: boolean | UlbMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ulbMaster"]>

  export type UlbMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ulbId?: boolean
    ulbName?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["ulbMaster"]>

  export type UlbMasterSelectScalar = {
    ulbId?: boolean
    ulbName?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type UlbMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ulbZoneMaps?: boolean | UlbMaster$ulbZoneMapsArgs<ExtArgs>
    surveyDetails?: boolean | UlbMaster$surveyDetailsArgs<ExtArgs>
    _count?: boolean | UlbMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UlbMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UlbMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UlbMaster"
    objects: {
      ulbZoneMaps: Prisma.$UlbZoneMappingPayload<ExtArgs>[]
      surveyDetails: Prisma.$SurveyDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ulbId: string
      ulbName: string
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["ulbMaster"]>
    composites: {}
  }

  type UlbMasterGetPayload<S extends boolean | null | undefined | UlbMasterDefaultArgs> = $Result.GetResult<Prisma.$UlbMasterPayload, S>

  type UlbMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UlbMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UlbMasterCountAggregateInputType | true
    }

  export interface UlbMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UlbMaster'], meta: { name: 'UlbMaster' } }
    /**
     * Find zero or one UlbMaster that matches the filter.
     * @param {UlbMasterFindUniqueArgs} args - Arguments to find a UlbMaster
     * @example
     * // Get one UlbMaster
     * const ulbMaster = await prisma.ulbMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UlbMasterFindUniqueArgs>(args: SelectSubset<T, UlbMasterFindUniqueArgs<ExtArgs>>): Prisma__UlbMasterClient<$Result.GetResult<Prisma.$UlbMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UlbMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UlbMasterFindUniqueOrThrowArgs} args - Arguments to find a UlbMaster
     * @example
     * // Get one UlbMaster
     * const ulbMaster = await prisma.ulbMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UlbMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, UlbMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UlbMasterClient<$Result.GetResult<Prisma.$UlbMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UlbMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UlbMasterFindFirstArgs} args - Arguments to find a UlbMaster
     * @example
     * // Get one UlbMaster
     * const ulbMaster = await prisma.ulbMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UlbMasterFindFirstArgs>(args?: SelectSubset<T, UlbMasterFindFirstArgs<ExtArgs>>): Prisma__UlbMasterClient<$Result.GetResult<Prisma.$UlbMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UlbMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UlbMasterFindFirstOrThrowArgs} args - Arguments to find a UlbMaster
     * @example
     * // Get one UlbMaster
     * const ulbMaster = await prisma.ulbMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UlbMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, UlbMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__UlbMasterClient<$Result.GetResult<Prisma.$UlbMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UlbMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UlbMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UlbMasters
     * const ulbMasters = await prisma.ulbMaster.findMany()
     * 
     * // Get first 10 UlbMasters
     * const ulbMasters = await prisma.ulbMaster.findMany({ take: 10 })
     * 
     * // Only select the `ulbId`
     * const ulbMasterWithUlbIdOnly = await prisma.ulbMaster.findMany({ select: { ulbId: true } })
     * 
     */
    findMany<T extends UlbMasterFindManyArgs>(args?: SelectSubset<T, UlbMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UlbMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UlbMaster.
     * @param {UlbMasterCreateArgs} args - Arguments to create a UlbMaster.
     * @example
     * // Create one UlbMaster
     * const UlbMaster = await prisma.ulbMaster.create({
     *   data: {
     *     // ... data to create a UlbMaster
     *   }
     * })
     * 
     */
    create<T extends UlbMasterCreateArgs>(args: SelectSubset<T, UlbMasterCreateArgs<ExtArgs>>): Prisma__UlbMasterClient<$Result.GetResult<Prisma.$UlbMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UlbMasters.
     * @param {UlbMasterCreateManyArgs} args - Arguments to create many UlbMasters.
     * @example
     * // Create many UlbMasters
     * const ulbMaster = await prisma.ulbMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UlbMasterCreateManyArgs>(args?: SelectSubset<T, UlbMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UlbMasters and returns the data saved in the database.
     * @param {UlbMasterCreateManyAndReturnArgs} args - Arguments to create many UlbMasters.
     * @example
     * // Create many UlbMasters
     * const ulbMaster = await prisma.ulbMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UlbMasters and only return the `ulbId`
     * const ulbMasterWithUlbIdOnly = await prisma.ulbMaster.createManyAndReturn({ 
     *   select: { ulbId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UlbMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, UlbMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UlbMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UlbMaster.
     * @param {UlbMasterDeleteArgs} args - Arguments to delete one UlbMaster.
     * @example
     * // Delete one UlbMaster
     * const UlbMaster = await prisma.ulbMaster.delete({
     *   where: {
     *     // ... filter to delete one UlbMaster
     *   }
     * })
     * 
     */
    delete<T extends UlbMasterDeleteArgs>(args: SelectSubset<T, UlbMasterDeleteArgs<ExtArgs>>): Prisma__UlbMasterClient<$Result.GetResult<Prisma.$UlbMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UlbMaster.
     * @param {UlbMasterUpdateArgs} args - Arguments to update one UlbMaster.
     * @example
     * // Update one UlbMaster
     * const ulbMaster = await prisma.ulbMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UlbMasterUpdateArgs>(args: SelectSubset<T, UlbMasterUpdateArgs<ExtArgs>>): Prisma__UlbMasterClient<$Result.GetResult<Prisma.$UlbMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UlbMasters.
     * @param {UlbMasterDeleteManyArgs} args - Arguments to filter UlbMasters to delete.
     * @example
     * // Delete a few UlbMasters
     * const { count } = await prisma.ulbMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UlbMasterDeleteManyArgs>(args?: SelectSubset<T, UlbMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UlbMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UlbMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UlbMasters
     * const ulbMaster = await prisma.ulbMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UlbMasterUpdateManyArgs>(args: SelectSubset<T, UlbMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UlbMaster.
     * @param {UlbMasterUpsertArgs} args - Arguments to update or create a UlbMaster.
     * @example
     * // Update or create a UlbMaster
     * const ulbMaster = await prisma.ulbMaster.upsert({
     *   create: {
     *     // ... data to create a UlbMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UlbMaster we want to update
     *   }
     * })
     */
    upsert<T extends UlbMasterUpsertArgs>(args: SelectSubset<T, UlbMasterUpsertArgs<ExtArgs>>): Prisma__UlbMasterClient<$Result.GetResult<Prisma.$UlbMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UlbMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UlbMasterCountArgs} args - Arguments to filter UlbMasters to count.
     * @example
     * // Count the number of UlbMasters
     * const count = await prisma.ulbMaster.count({
     *   where: {
     *     // ... the filter for the UlbMasters we want to count
     *   }
     * })
    **/
    count<T extends UlbMasterCountArgs>(
      args?: Subset<T, UlbMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UlbMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UlbMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UlbMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UlbMasterAggregateArgs>(args: Subset<T, UlbMasterAggregateArgs>): Prisma.PrismaPromise<GetUlbMasterAggregateType<T>>

    /**
     * Group by UlbMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UlbMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UlbMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UlbMasterGroupByArgs['orderBy'] }
        : { orderBy?: UlbMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UlbMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUlbMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UlbMaster model
   */
  readonly fields: UlbMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UlbMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UlbMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ulbZoneMaps<T extends UlbMaster$ulbZoneMapsArgs<ExtArgs> = {}>(args?: Subset<T, UlbMaster$ulbZoneMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UlbZoneMappingPayload<ExtArgs>, T, "findMany"> | Null>
    surveyDetails<T extends UlbMaster$surveyDetailsArgs<ExtArgs> = {}>(args?: Subset<T, UlbMaster$surveyDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UlbMaster model
   */ 
  interface UlbMasterFieldRefs {
    readonly ulbId: FieldRef<"UlbMaster", 'String'>
    readonly ulbName: FieldRef<"UlbMaster", 'String'>
    readonly isActive: FieldRef<"UlbMaster", 'Boolean'>
    readonly description: FieldRef<"UlbMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UlbMaster findUnique
   */
  export type UlbMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbMaster
     */
    select?: UlbMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbMasterInclude<ExtArgs> | null
    /**
     * Filter, which UlbMaster to fetch.
     */
    where: UlbMasterWhereUniqueInput
  }

  /**
   * UlbMaster findUniqueOrThrow
   */
  export type UlbMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbMaster
     */
    select?: UlbMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbMasterInclude<ExtArgs> | null
    /**
     * Filter, which UlbMaster to fetch.
     */
    where: UlbMasterWhereUniqueInput
  }

  /**
   * UlbMaster findFirst
   */
  export type UlbMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbMaster
     */
    select?: UlbMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbMasterInclude<ExtArgs> | null
    /**
     * Filter, which UlbMaster to fetch.
     */
    where?: UlbMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UlbMasters to fetch.
     */
    orderBy?: UlbMasterOrderByWithRelationInput | UlbMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UlbMasters.
     */
    cursor?: UlbMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UlbMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UlbMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UlbMasters.
     */
    distinct?: UlbMasterScalarFieldEnum | UlbMasterScalarFieldEnum[]
  }

  /**
   * UlbMaster findFirstOrThrow
   */
  export type UlbMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbMaster
     */
    select?: UlbMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbMasterInclude<ExtArgs> | null
    /**
     * Filter, which UlbMaster to fetch.
     */
    where?: UlbMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UlbMasters to fetch.
     */
    orderBy?: UlbMasterOrderByWithRelationInput | UlbMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UlbMasters.
     */
    cursor?: UlbMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UlbMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UlbMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UlbMasters.
     */
    distinct?: UlbMasterScalarFieldEnum | UlbMasterScalarFieldEnum[]
  }

  /**
   * UlbMaster findMany
   */
  export type UlbMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbMaster
     */
    select?: UlbMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbMasterInclude<ExtArgs> | null
    /**
     * Filter, which UlbMasters to fetch.
     */
    where?: UlbMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UlbMasters to fetch.
     */
    orderBy?: UlbMasterOrderByWithRelationInput | UlbMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UlbMasters.
     */
    cursor?: UlbMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UlbMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UlbMasters.
     */
    skip?: number
    distinct?: UlbMasterScalarFieldEnum | UlbMasterScalarFieldEnum[]
  }

  /**
   * UlbMaster create
   */
  export type UlbMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbMaster
     */
    select?: UlbMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a UlbMaster.
     */
    data: XOR<UlbMasterCreateInput, UlbMasterUncheckedCreateInput>
  }

  /**
   * UlbMaster createMany
   */
  export type UlbMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UlbMasters.
     */
    data: UlbMasterCreateManyInput | UlbMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UlbMaster createManyAndReturn
   */
  export type UlbMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbMaster
     */
    select?: UlbMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UlbMasters.
     */
    data: UlbMasterCreateManyInput | UlbMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UlbMaster update
   */
  export type UlbMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbMaster
     */
    select?: UlbMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a UlbMaster.
     */
    data: XOR<UlbMasterUpdateInput, UlbMasterUncheckedUpdateInput>
    /**
     * Choose, which UlbMaster to update.
     */
    where: UlbMasterWhereUniqueInput
  }

  /**
   * UlbMaster updateMany
   */
  export type UlbMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UlbMasters.
     */
    data: XOR<UlbMasterUpdateManyMutationInput, UlbMasterUncheckedUpdateManyInput>
    /**
     * Filter which UlbMasters to update
     */
    where?: UlbMasterWhereInput
  }

  /**
   * UlbMaster upsert
   */
  export type UlbMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbMaster
     */
    select?: UlbMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the UlbMaster to update in case it exists.
     */
    where: UlbMasterWhereUniqueInput
    /**
     * In case the UlbMaster found by the `where` argument doesn't exist, create a new UlbMaster with this data.
     */
    create: XOR<UlbMasterCreateInput, UlbMasterUncheckedCreateInput>
    /**
     * In case the UlbMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UlbMasterUpdateInput, UlbMasterUncheckedUpdateInput>
  }

  /**
   * UlbMaster delete
   */
  export type UlbMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbMaster
     */
    select?: UlbMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbMasterInclude<ExtArgs> | null
    /**
     * Filter which UlbMaster to delete.
     */
    where: UlbMasterWhereUniqueInput
  }

  /**
   * UlbMaster deleteMany
   */
  export type UlbMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UlbMasters to delete
     */
    where?: UlbMasterWhereInput
  }

  /**
   * UlbMaster.ulbZoneMaps
   */
  export type UlbMaster$ulbZoneMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbZoneMapping
     */
    select?: UlbZoneMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbZoneMappingInclude<ExtArgs> | null
    where?: UlbZoneMappingWhereInput
    orderBy?: UlbZoneMappingOrderByWithRelationInput | UlbZoneMappingOrderByWithRelationInput[]
    cursor?: UlbZoneMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UlbZoneMappingScalarFieldEnum | UlbZoneMappingScalarFieldEnum[]
  }

  /**
   * UlbMaster.surveyDetails
   */
  export type UlbMaster$surveyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyDetails
     */
    select?: SurveyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyDetailsInclude<ExtArgs> | null
    where?: SurveyDetailsWhereInput
    orderBy?: SurveyDetailsOrderByWithRelationInput | SurveyDetailsOrderByWithRelationInput[]
    cursor?: SurveyDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyDetailsScalarFieldEnum | SurveyDetailsScalarFieldEnum[]
  }

  /**
   * UlbMaster without action
   */
  export type UlbMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbMaster
     */
    select?: UlbMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbMasterInclude<ExtArgs> | null
  }


  /**
   * Model ZoneMaster
   */

  export type AggregateZoneMaster = {
    _count: ZoneMasterCountAggregateOutputType | null
    _min: ZoneMasterMinAggregateOutputType | null
    _max: ZoneMasterMaxAggregateOutputType | null
  }

  export type ZoneMasterMinAggregateOutputType = {
    zoneId: string | null
    zoneNumber: string | null
    isActive: boolean | null
    description: string | null
  }

  export type ZoneMasterMaxAggregateOutputType = {
    zoneId: string | null
    zoneNumber: string | null
    isActive: boolean | null
    description: string | null
  }

  export type ZoneMasterCountAggregateOutputType = {
    zoneId: number
    zoneNumber: number
    isActive: number
    description: number
    _all: number
  }


  export type ZoneMasterMinAggregateInputType = {
    zoneId?: true
    zoneNumber?: true
    isActive?: true
    description?: true
  }

  export type ZoneMasterMaxAggregateInputType = {
    zoneId?: true
    zoneNumber?: true
    isActive?: true
    description?: true
  }

  export type ZoneMasterCountAggregateInputType = {
    zoneId?: true
    zoneNumber?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type ZoneMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZoneMaster to aggregate.
     */
    where?: ZoneMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoneMasters to fetch.
     */
    orderBy?: ZoneMasterOrderByWithRelationInput | ZoneMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoneMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoneMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoneMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ZoneMasters
    **/
    _count?: true | ZoneMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneMasterMaxAggregateInputType
  }

  export type GetZoneMasterAggregateType<T extends ZoneMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateZoneMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZoneMaster[P]>
      : GetScalarType<T[P], AggregateZoneMaster[P]>
  }




  export type ZoneMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneMasterWhereInput
    orderBy?: ZoneMasterOrderByWithAggregationInput | ZoneMasterOrderByWithAggregationInput[]
    by: ZoneMasterScalarFieldEnum[] | ZoneMasterScalarFieldEnum
    having?: ZoneMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneMasterCountAggregateInputType | true
    _min?: ZoneMasterMinAggregateInputType
    _max?: ZoneMasterMaxAggregateInputType
  }

  export type ZoneMasterGroupByOutputType = {
    zoneId: string
    zoneNumber: string
    isActive: boolean
    description: string | null
    _count: ZoneMasterCountAggregateOutputType | null
    _min: ZoneMasterMinAggregateOutputType | null
    _max: ZoneMasterMaxAggregateOutputType | null
  }

  type GetZoneMasterGroupByPayload<T extends ZoneMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneMasterGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneMasterGroupByOutputType[P]>
        }
      >
    >


  export type ZoneMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    zoneId?: boolean
    zoneNumber?: boolean
    isActive?: boolean
    description?: boolean
    ulbZoneMaps?: boolean | ZoneMaster$ulbZoneMapsArgs<ExtArgs>
    zoneWardMaps?: boolean | ZoneMaster$zoneWardMapsArgs<ExtArgs>
    surveyDetails?: boolean | ZoneMaster$surveyDetailsArgs<ExtArgs>
    _count?: boolean | ZoneMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zoneMaster"]>

  export type ZoneMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    zoneId?: boolean
    zoneNumber?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["zoneMaster"]>

  export type ZoneMasterSelectScalar = {
    zoneId?: boolean
    zoneNumber?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type ZoneMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ulbZoneMaps?: boolean | ZoneMaster$ulbZoneMapsArgs<ExtArgs>
    zoneWardMaps?: boolean | ZoneMaster$zoneWardMapsArgs<ExtArgs>
    surveyDetails?: boolean | ZoneMaster$surveyDetailsArgs<ExtArgs>
    _count?: boolean | ZoneMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ZoneMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ZoneMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ZoneMaster"
    objects: {
      ulbZoneMaps: Prisma.$UlbZoneMappingPayload<ExtArgs>[]
      zoneWardMaps: Prisma.$ZoneWardMappingPayload<ExtArgs>[]
      surveyDetails: Prisma.$SurveyDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      zoneId: string
      zoneNumber: string
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["zoneMaster"]>
    composites: {}
  }

  type ZoneMasterGetPayload<S extends boolean | null | undefined | ZoneMasterDefaultArgs> = $Result.GetResult<Prisma.$ZoneMasterPayload, S>

  type ZoneMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ZoneMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ZoneMasterCountAggregateInputType | true
    }

  export interface ZoneMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ZoneMaster'], meta: { name: 'ZoneMaster' } }
    /**
     * Find zero or one ZoneMaster that matches the filter.
     * @param {ZoneMasterFindUniqueArgs} args - Arguments to find a ZoneMaster
     * @example
     * // Get one ZoneMaster
     * const zoneMaster = await prisma.zoneMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZoneMasterFindUniqueArgs>(args: SelectSubset<T, ZoneMasterFindUniqueArgs<ExtArgs>>): Prisma__ZoneMasterClient<$Result.GetResult<Prisma.$ZoneMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ZoneMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ZoneMasterFindUniqueOrThrowArgs} args - Arguments to find a ZoneMaster
     * @example
     * // Get one ZoneMaster
     * const zoneMaster = await prisma.zoneMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZoneMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, ZoneMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZoneMasterClient<$Result.GetResult<Prisma.$ZoneMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ZoneMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneMasterFindFirstArgs} args - Arguments to find a ZoneMaster
     * @example
     * // Get one ZoneMaster
     * const zoneMaster = await prisma.zoneMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZoneMasterFindFirstArgs>(args?: SelectSubset<T, ZoneMasterFindFirstArgs<ExtArgs>>): Prisma__ZoneMasterClient<$Result.GetResult<Prisma.$ZoneMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ZoneMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneMasterFindFirstOrThrowArgs} args - Arguments to find a ZoneMaster
     * @example
     * // Get one ZoneMaster
     * const zoneMaster = await prisma.zoneMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZoneMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, ZoneMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZoneMasterClient<$Result.GetResult<Prisma.$ZoneMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ZoneMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ZoneMasters
     * const zoneMasters = await prisma.zoneMaster.findMany()
     * 
     * // Get first 10 ZoneMasters
     * const zoneMasters = await prisma.zoneMaster.findMany({ take: 10 })
     * 
     * // Only select the `zoneId`
     * const zoneMasterWithZoneIdOnly = await prisma.zoneMaster.findMany({ select: { zoneId: true } })
     * 
     */
    findMany<T extends ZoneMasterFindManyArgs>(args?: SelectSubset<T, ZoneMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoneMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ZoneMaster.
     * @param {ZoneMasterCreateArgs} args - Arguments to create a ZoneMaster.
     * @example
     * // Create one ZoneMaster
     * const ZoneMaster = await prisma.zoneMaster.create({
     *   data: {
     *     // ... data to create a ZoneMaster
     *   }
     * })
     * 
     */
    create<T extends ZoneMasterCreateArgs>(args: SelectSubset<T, ZoneMasterCreateArgs<ExtArgs>>): Prisma__ZoneMasterClient<$Result.GetResult<Prisma.$ZoneMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ZoneMasters.
     * @param {ZoneMasterCreateManyArgs} args - Arguments to create many ZoneMasters.
     * @example
     * // Create many ZoneMasters
     * const zoneMaster = await prisma.zoneMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZoneMasterCreateManyArgs>(args?: SelectSubset<T, ZoneMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ZoneMasters and returns the data saved in the database.
     * @param {ZoneMasterCreateManyAndReturnArgs} args - Arguments to create many ZoneMasters.
     * @example
     * // Create many ZoneMasters
     * const zoneMaster = await prisma.zoneMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ZoneMasters and only return the `zoneId`
     * const zoneMasterWithZoneIdOnly = await prisma.zoneMaster.createManyAndReturn({ 
     *   select: { zoneId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZoneMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, ZoneMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoneMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ZoneMaster.
     * @param {ZoneMasterDeleteArgs} args - Arguments to delete one ZoneMaster.
     * @example
     * // Delete one ZoneMaster
     * const ZoneMaster = await prisma.zoneMaster.delete({
     *   where: {
     *     // ... filter to delete one ZoneMaster
     *   }
     * })
     * 
     */
    delete<T extends ZoneMasterDeleteArgs>(args: SelectSubset<T, ZoneMasterDeleteArgs<ExtArgs>>): Prisma__ZoneMasterClient<$Result.GetResult<Prisma.$ZoneMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ZoneMaster.
     * @param {ZoneMasterUpdateArgs} args - Arguments to update one ZoneMaster.
     * @example
     * // Update one ZoneMaster
     * const zoneMaster = await prisma.zoneMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZoneMasterUpdateArgs>(args: SelectSubset<T, ZoneMasterUpdateArgs<ExtArgs>>): Prisma__ZoneMasterClient<$Result.GetResult<Prisma.$ZoneMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ZoneMasters.
     * @param {ZoneMasterDeleteManyArgs} args - Arguments to filter ZoneMasters to delete.
     * @example
     * // Delete a few ZoneMasters
     * const { count } = await prisma.zoneMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZoneMasterDeleteManyArgs>(args?: SelectSubset<T, ZoneMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZoneMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ZoneMasters
     * const zoneMaster = await prisma.zoneMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZoneMasterUpdateManyArgs>(args: SelectSubset<T, ZoneMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ZoneMaster.
     * @param {ZoneMasterUpsertArgs} args - Arguments to update or create a ZoneMaster.
     * @example
     * // Update or create a ZoneMaster
     * const zoneMaster = await prisma.zoneMaster.upsert({
     *   create: {
     *     // ... data to create a ZoneMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ZoneMaster we want to update
     *   }
     * })
     */
    upsert<T extends ZoneMasterUpsertArgs>(args: SelectSubset<T, ZoneMasterUpsertArgs<ExtArgs>>): Prisma__ZoneMasterClient<$Result.GetResult<Prisma.$ZoneMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ZoneMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneMasterCountArgs} args - Arguments to filter ZoneMasters to count.
     * @example
     * // Count the number of ZoneMasters
     * const count = await prisma.zoneMaster.count({
     *   where: {
     *     // ... the filter for the ZoneMasters we want to count
     *   }
     * })
    **/
    count<T extends ZoneMasterCountArgs>(
      args?: Subset<T, ZoneMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ZoneMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneMasterAggregateArgs>(args: Subset<T, ZoneMasterAggregateArgs>): Prisma.PrismaPromise<GetZoneMasterAggregateType<T>>

    /**
     * Group by ZoneMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoneMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoneMasterGroupByArgs['orderBy'] }
        : { orderBy?: ZoneMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoneMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ZoneMaster model
   */
  readonly fields: ZoneMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ZoneMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoneMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ulbZoneMaps<T extends ZoneMaster$ulbZoneMapsArgs<ExtArgs> = {}>(args?: Subset<T, ZoneMaster$ulbZoneMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UlbZoneMappingPayload<ExtArgs>, T, "findMany"> | Null>
    zoneWardMaps<T extends ZoneMaster$zoneWardMapsArgs<ExtArgs> = {}>(args?: Subset<T, ZoneMaster$zoneWardMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoneWardMappingPayload<ExtArgs>, T, "findMany"> | Null>
    surveyDetails<T extends ZoneMaster$surveyDetailsArgs<ExtArgs> = {}>(args?: Subset<T, ZoneMaster$surveyDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ZoneMaster model
   */ 
  interface ZoneMasterFieldRefs {
    readonly zoneId: FieldRef<"ZoneMaster", 'String'>
    readonly zoneNumber: FieldRef<"ZoneMaster", 'String'>
    readonly isActive: FieldRef<"ZoneMaster", 'Boolean'>
    readonly description: FieldRef<"ZoneMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ZoneMaster findUnique
   */
  export type ZoneMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneMaster
     */
    select?: ZoneMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneMasterInclude<ExtArgs> | null
    /**
     * Filter, which ZoneMaster to fetch.
     */
    where: ZoneMasterWhereUniqueInput
  }

  /**
   * ZoneMaster findUniqueOrThrow
   */
  export type ZoneMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneMaster
     */
    select?: ZoneMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneMasterInclude<ExtArgs> | null
    /**
     * Filter, which ZoneMaster to fetch.
     */
    where: ZoneMasterWhereUniqueInput
  }

  /**
   * ZoneMaster findFirst
   */
  export type ZoneMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneMaster
     */
    select?: ZoneMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneMasterInclude<ExtArgs> | null
    /**
     * Filter, which ZoneMaster to fetch.
     */
    where?: ZoneMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoneMasters to fetch.
     */
    orderBy?: ZoneMasterOrderByWithRelationInput | ZoneMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZoneMasters.
     */
    cursor?: ZoneMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoneMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoneMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZoneMasters.
     */
    distinct?: ZoneMasterScalarFieldEnum | ZoneMasterScalarFieldEnum[]
  }

  /**
   * ZoneMaster findFirstOrThrow
   */
  export type ZoneMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneMaster
     */
    select?: ZoneMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneMasterInclude<ExtArgs> | null
    /**
     * Filter, which ZoneMaster to fetch.
     */
    where?: ZoneMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoneMasters to fetch.
     */
    orderBy?: ZoneMasterOrderByWithRelationInput | ZoneMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZoneMasters.
     */
    cursor?: ZoneMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoneMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoneMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZoneMasters.
     */
    distinct?: ZoneMasterScalarFieldEnum | ZoneMasterScalarFieldEnum[]
  }

  /**
   * ZoneMaster findMany
   */
  export type ZoneMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneMaster
     */
    select?: ZoneMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneMasterInclude<ExtArgs> | null
    /**
     * Filter, which ZoneMasters to fetch.
     */
    where?: ZoneMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoneMasters to fetch.
     */
    orderBy?: ZoneMasterOrderByWithRelationInput | ZoneMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ZoneMasters.
     */
    cursor?: ZoneMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoneMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoneMasters.
     */
    skip?: number
    distinct?: ZoneMasterScalarFieldEnum | ZoneMasterScalarFieldEnum[]
  }

  /**
   * ZoneMaster create
   */
  export type ZoneMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneMaster
     */
    select?: ZoneMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a ZoneMaster.
     */
    data: XOR<ZoneMasterCreateInput, ZoneMasterUncheckedCreateInput>
  }

  /**
   * ZoneMaster createMany
   */
  export type ZoneMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ZoneMasters.
     */
    data: ZoneMasterCreateManyInput | ZoneMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ZoneMaster createManyAndReturn
   */
  export type ZoneMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneMaster
     */
    select?: ZoneMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ZoneMasters.
     */
    data: ZoneMasterCreateManyInput | ZoneMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ZoneMaster update
   */
  export type ZoneMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneMaster
     */
    select?: ZoneMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a ZoneMaster.
     */
    data: XOR<ZoneMasterUpdateInput, ZoneMasterUncheckedUpdateInput>
    /**
     * Choose, which ZoneMaster to update.
     */
    where: ZoneMasterWhereUniqueInput
  }

  /**
   * ZoneMaster updateMany
   */
  export type ZoneMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ZoneMasters.
     */
    data: XOR<ZoneMasterUpdateManyMutationInput, ZoneMasterUncheckedUpdateManyInput>
    /**
     * Filter which ZoneMasters to update
     */
    where?: ZoneMasterWhereInput
  }

  /**
   * ZoneMaster upsert
   */
  export type ZoneMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneMaster
     */
    select?: ZoneMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the ZoneMaster to update in case it exists.
     */
    where: ZoneMasterWhereUniqueInput
    /**
     * In case the ZoneMaster found by the `where` argument doesn't exist, create a new ZoneMaster with this data.
     */
    create: XOR<ZoneMasterCreateInput, ZoneMasterUncheckedCreateInput>
    /**
     * In case the ZoneMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoneMasterUpdateInput, ZoneMasterUncheckedUpdateInput>
  }

  /**
   * ZoneMaster delete
   */
  export type ZoneMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneMaster
     */
    select?: ZoneMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneMasterInclude<ExtArgs> | null
    /**
     * Filter which ZoneMaster to delete.
     */
    where: ZoneMasterWhereUniqueInput
  }

  /**
   * ZoneMaster deleteMany
   */
  export type ZoneMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZoneMasters to delete
     */
    where?: ZoneMasterWhereInput
  }

  /**
   * ZoneMaster.ulbZoneMaps
   */
  export type ZoneMaster$ulbZoneMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbZoneMapping
     */
    select?: UlbZoneMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbZoneMappingInclude<ExtArgs> | null
    where?: UlbZoneMappingWhereInput
    orderBy?: UlbZoneMappingOrderByWithRelationInput | UlbZoneMappingOrderByWithRelationInput[]
    cursor?: UlbZoneMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UlbZoneMappingScalarFieldEnum | UlbZoneMappingScalarFieldEnum[]
  }

  /**
   * ZoneMaster.zoneWardMaps
   */
  export type ZoneMaster$zoneWardMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneWardMapping
     */
    select?: ZoneWardMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneWardMappingInclude<ExtArgs> | null
    where?: ZoneWardMappingWhereInput
    orderBy?: ZoneWardMappingOrderByWithRelationInput | ZoneWardMappingOrderByWithRelationInput[]
    cursor?: ZoneWardMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoneWardMappingScalarFieldEnum | ZoneWardMappingScalarFieldEnum[]
  }

  /**
   * ZoneMaster.surveyDetails
   */
  export type ZoneMaster$surveyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyDetails
     */
    select?: SurveyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyDetailsInclude<ExtArgs> | null
    where?: SurveyDetailsWhereInput
    orderBy?: SurveyDetailsOrderByWithRelationInput | SurveyDetailsOrderByWithRelationInput[]
    cursor?: SurveyDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyDetailsScalarFieldEnum | SurveyDetailsScalarFieldEnum[]
  }

  /**
   * ZoneMaster without action
   */
  export type ZoneMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneMaster
     */
    select?: ZoneMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneMasterInclude<ExtArgs> | null
  }


  /**
   * Model WardMaster
   */

  export type AggregateWardMaster = {
    _count: WardMasterCountAggregateOutputType | null
    _min: WardMasterMinAggregateOutputType | null
    _max: WardMasterMaxAggregateOutputType | null
  }

  export type WardMasterMinAggregateOutputType = {
    wardId: string | null
    wardNumber: string | null
    isActive: boolean | null
    wardName: string | null
    description: string | null
  }

  export type WardMasterMaxAggregateOutputType = {
    wardId: string | null
    wardNumber: string | null
    isActive: boolean | null
    wardName: string | null
    description: string | null
  }

  export type WardMasterCountAggregateOutputType = {
    wardId: number
    wardNumber: number
    isActive: number
    wardName: number
    description: number
    _all: number
  }


  export type WardMasterMinAggregateInputType = {
    wardId?: true
    wardNumber?: true
    isActive?: true
    wardName?: true
    description?: true
  }

  export type WardMasterMaxAggregateInputType = {
    wardId?: true
    wardNumber?: true
    isActive?: true
    wardName?: true
    description?: true
  }

  export type WardMasterCountAggregateInputType = {
    wardId?: true
    wardNumber?: true
    isActive?: true
    wardName?: true
    description?: true
    _all?: true
  }

  export type WardMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WardMaster to aggregate.
     */
    where?: WardMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardMasters to fetch.
     */
    orderBy?: WardMasterOrderByWithRelationInput | WardMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WardMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WardMasters
    **/
    _count?: true | WardMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WardMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WardMasterMaxAggregateInputType
  }

  export type GetWardMasterAggregateType<T extends WardMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateWardMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWardMaster[P]>
      : GetScalarType<T[P], AggregateWardMaster[P]>
  }




  export type WardMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardMasterWhereInput
    orderBy?: WardMasterOrderByWithAggregationInput | WardMasterOrderByWithAggregationInput[]
    by: WardMasterScalarFieldEnum[] | WardMasterScalarFieldEnum
    having?: WardMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WardMasterCountAggregateInputType | true
    _min?: WardMasterMinAggregateInputType
    _max?: WardMasterMaxAggregateInputType
  }

  export type WardMasterGroupByOutputType = {
    wardId: string
    wardNumber: string
    isActive: boolean
    wardName: string
    description: string | null
    _count: WardMasterCountAggregateOutputType | null
    _min: WardMasterMinAggregateOutputType | null
    _max: WardMasterMaxAggregateOutputType | null
  }

  type GetWardMasterGroupByPayload<T extends WardMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WardMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WardMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WardMasterGroupByOutputType[P]>
            : GetScalarType<T[P], WardMasterGroupByOutputType[P]>
        }
      >
    >


  export type WardMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    wardId?: boolean
    wardNumber?: boolean
    isActive?: boolean
    wardName?: boolean
    description?: boolean
    zoneWardMaps?: boolean | WardMaster$zoneWardMapsArgs<ExtArgs>
    wardMohallaMaps?: boolean | WardMaster$wardMohallaMapsArgs<ExtArgs>
    surveyorAssignments?: boolean | WardMaster$surveyorAssignmentsArgs<ExtArgs>
    wardStatusMaps?: boolean | WardMaster$wardStatusMapsArgs<ExtArgs>
    surveyDetails?: boolean | WardMaster$surveyDetailsArgs<ExtArgs>
    supervisors?: boolean | WardMaster$supervisorsArgs<ExtArgs>
    _count?: boolean | WardMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wardMaster"]>

  export type WardMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    wardId?: boolean
    wardNumber?: boolean
    isActive?: boolean
    wardName?: boolean
    description?: boolean
  }, ExtArgs["result"]["wardMaster"]>

  export type WardMasterSelectScalar = {
    wardId?: boolean
    wardNumber?: boolean
    isActive?: boolean
    wardName?: boolean
    description?: boolean
  }

  export type WardMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zoneWardMaps?: boolean | WardMaster$zoneWardMapsArgs<ExtArgs>
    wardMohallaMaps?: boolean | WardMaster$wardMohallaMapsArgs<ExtArgs>
    surveyorAssignments?: boolean | WardMaster$surveyorAssignmentsArgs<ExtArgs>
    wardStatusMaps?: boolean | WardMaster$wardStatusMapsArgs<ExtArgs>
    surveyDetails?: boolean | WardMaster$surveyDetailsArgs<ExtArgs>
    supervisors?: boolean | WardMaster$supervisorsArgs<ExtArgs>
    _count?: boolean | WardMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WardMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WardMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WardMaster"
    objects: {
      zoneWardMaps: Prisma.$ZoneWardMappingPayload<ExtArgs>[]
      wardMohallaMaps: Prisma.$WardMohallaMappingPayload<ExtArgs>[]
      surveyorAssignments: Prisma.$SurveyorAssignmentPayload<ExtArgs>[]
      wardStatusMaps: Prisma.$WardStatusMappingPayload<ExtArgs>[]
      surveyDetails: Prisma.$SurveyDetailsPayload<ExtArgs>[]
      supervisors: Prisma.$SupervisorsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      wardId: string
      wardNumber: string
      isActive: boolean
      wardName: string
      description: string | null
    }, ExtArgs["result"]["wardMaster"]>
    composites: {}
  }

  type WardMasterGetPayload<S extends boolean | null | undefined | WardMasterDefaultArgs> = $Result.GetResult<Prisma.$WardMasterPayload, S>

  type WardMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WardMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WardMasterCountAggregateInputType | true
    }

  export interface WardMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WardMaster'], meta: { name: 'WardMaster' } }
    /**
     * Find zero or one WardMaster that matches the filter.
     * @param {WardMasterFindUniqueArgs} args - Arguments to find a WardMaster
     * @example
     * // Get one WardMaster
     * const wardMaster = await prisma.wardMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WardMasterFindUniqueArgs>(args: SelectSubset<T, WardMasterFindUniqueArgs<ExtArgs>>): Prisma__WardMasterClient<$Result.GetResult<Prisma.$WardMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WardMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WardMasterFindUniqueOrThrowArgs} args - Arguments to find a WardMaster
     * @example
     * // Get one WardMaster
     * const wardMaster = await prisma.wardMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WardMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, WardMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WardMasterClient<$Result.GetResult<Prisma.$WardMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WardMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardMasterFindFirstArgs} args - Arguments to find a WardMaster
     * @example
     * // Get one WardMaster
     * const wardMaster = await prisma.wardMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WardMasterFindFirstArgs>(args?: SelectSubset<T, WardMasterFindFirstArgs<ExtArgs>>): Prisma__WardMasterClient<$Result.GetResult<Prisma.$WardMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WardMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardMasterFindFirstOrThrowArgs} args - Arguments to find a WardMaster
     * @example
     * // Get one WardMaster
     * const wardMaster = await prisma.wardMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WardMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, WardMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__WardMasterClient<$Result.GetResult<Prisma.$WardMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WardMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WardMasters
     * const wardMasters = await prisma.wardMaster.findMany()
     * 
     * // Get first 10 WardMasters
     * const wardMasters = await prisma.wardMaster.findMany({ take: 10 })
     * 
     * // Only select the `wardId`
     * const wardMasterWithWardIdOnly = await prisma.wardMaster.findMany({ select: { wardId: true } })
     * 
     */
    findMany<T extends WardMasterFindManyArgs>(args?: SelectSubset<T, WardMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WardMaster.
     * @param {WardMasterCreateArgs} args - Arguments to create a WardMaster.
     * @example
     * // Create one WardMaster
     * const WardMaster = await prisma.wardMaster.create({
     *   data: {
     *     // ... data to create a WardMaster
     *   }
     * })
     * 
     */
    create<T extends WardMasterCreateArgs>(args: SelectSubset<T, WardMasterCreateArgs<ExtArgs>>): Prisma__WardMasterClient<$Result.GetResult<Prisma.$WardMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WardMasters.
     * @param {WardMasterCreateManyArgs} args - Arguments to create many WardMasters.
     * @example
     * // Create many WardMasters
     * const wardMaster = await prisma.wardMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WardMasterCreateManyArgs>(args?: SelectSubset<T, WardMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WardMasters and returns the data saved in the database.
     * @param {WardMasterCreateManyAndReturnArgs} args - Arguments to create many WardMasters.
     * @example
     * // Create many WardMasters
     * const wardMaster = await prisma.wardMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WardMasters and only return the `wardId`
     * const wardMasterWithWardIdOnly = await prisma.wardMaster.createManyAndReturn({ 
     *   select: { wardId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WardMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, WardMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WardMaster.
     * @param {WardMasterDeleteArgs} args - Arguments to delete one WardMaster.
     * @example
     * // Delete one WardMaster
     * const WardMaster = await prisma.wardMaster.delete({
     *   where: {
     *     // ... filter to delete one WardMaster
     *   }
     * })
     * 
     */
    delete<T extends WardMasterDeleteArgs>(args: SelectSubset<T, WardMasterDeleteArgs<ExtArgs>>): Prisma__WardMasterClient<$Result.GetResult<Prisma.$WardMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WardMaster.
     * @param {WardMasterUpdateArgs} args - Arguments to update one WardMaster.
     * @example
     * // Update one WardMaster
     * const wardMaster = await prisma.wardMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WardMasterUpdateArgs>(args: SelectSubset<T, WardMasterUpdateArgs<ExtArgs>>): Prisma__WardMasterClient<$Result.GetResult<Prisma.$WardMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WardMasters.
     * @param {WardMasterDeleteManyArgs} args - Arguments to filter WardMasters to delete.
     * @example
     * // Delete a few WardMasters
     * const { count } = await prisma.wardMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WardMasterDeleteManyArgs>(args?: SelectSubset<T, WardMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WardMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WardMasters
     * const wardMaster = await prisma.wardMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WardMasterUpdateManyArgs>(args: SelectSubset<T, WardMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WardMaster.
     * @param {WardMasterUpsertArgs} args - Arguments to update or create a WardMaster.
     * @example
     * // Update or create a WardMaster
     * const wardMaster = await prisma.wardMaster.upsert({
     *   create: {
     *     // ... data to create a WardMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WardMaster we want to update
     *   }
     * })
     */
    upsert<T extends WardMasterUpsertArgs>(args: SelectSubset<T, WardMasterUpsertArgs<ExtArgs>>): Prisma__WardMasterClient<$Result.GetResult<Prisma.$WardMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WardMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardMasterCountArgs} args - Arguments to filter WardMasters to count.
     * @example
     * // Count the number of WardMasters
     * const count = await prisma.wardMaster.count({
     *   where: {
     *     // ... the filter for the WardMasters we want to count
     *   }
     * })
    **/
    count<T extends WardMasterCountArgs>(
      args?: Subset<T, WardMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WardMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WardMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WardMasterAggregateArgs>(args: Subset<T, WardMasterAggregateArgs>): Prisma.PrismaPromise<GetWardMasterAggregateType<T>>

    /**
     * Group by WardMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WardMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WardMasterGroupByArgs['orderBy'] }
        : { orderBy?: WardMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WardMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWardMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WardMaster model
   */
  readonly fields: WardMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WardMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WardMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zoneWardMaps<T extends WardMaster$zoneWardMapsArgs<ExtArgs> = {}>(args?: Subset<T, WardMaster$zoneWardMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoneWardMappingPayload<ExtArgs>, T, "findMany"> | Null>
    wardMohallaMaps<T extends WardMaster$wardMohallaMapsArgs<ExtArgs> = {}>(args?: Subset<T, WardMaster$wardMohallaMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardMohallaMappingPayload<ExtArgs>, T, "findMany"> | Null>
    surveyorAssignments<T extends WardMaster$surveyorAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, WardMaster$surveyorAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyorAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    wardStatusMaps<T extends WardMaster$wardStatusMapsArgs<ExtArgs> = {}>(args?: Subset<T, WardMaster$wardStatusMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardStatusMappingPayload<ExtArgs>, T, "findMany"> | Null>
    surveyDetails<T extends WardMaster$surveyDetailsArgs<ExtArgs> = {}>(args?: Subset<T, WardMaster$surveyDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    supervisors<T extends WardMaster$supervisorsArgs<ExtArgs> = {}>(args?: Subset<T, WardMaster$supervisorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupervisorsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WardMaster model
   */ 
  interface WardMasterFieldRefs {
    readonly wardId: FieldRef<"WardMaster", 'String'>
    readonly wardNumber: FieldRef<"WardMaster", 'String'>
    readonly isActive: FieldRef<"WardMaster", 'Boolean'>
    readonly wardName: FieldRef<"WardMaster", 'String'>
    readonly description: FieldRef<"WardMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WardMaster findUnique
   */
  export type WardMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMaster
     */
    select?: WardMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMasterInclude<ExtArgs> | null
    /**
     * Filter, which WardMaster to fetch.
     */
    where: WardMasterWhereUniqueInput
  }

  /**
   * WardMaster findUniqueOrThrow
   */
  export type WardMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMaster
     */
    select?: WardMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMasterInclude<ExtArgs> | null
    /**
     * Filter, which WardMaster to fetch.
     */
    where: WardMasterWhereUniqueInput
  }

  /**
   * WardMaster findFirst
   */
  export type WardMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMaster
     */
    select?: WardMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMasterInclude<ExtArgs> | null
    /**
     * Filter, which WardMaster to fetch.
     */
    where?: WardMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardMasters to fetch.
     */
    orderBy?: WardMasterOrderByWithRelationInput | WardMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WardMasters.
     */
    cursor?: WardMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WardMasters.
     */
    distinct?: WardMasterScalarFieldEnum | WardMasterScalarFieldEnum[]
  }

  /**
   * WardMaster findFirstOrThrow
   */
  export type WardMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMaster
     */
    select?: WardMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMasterInclude<ExtArgs> | null
    /**
     * Filter, which WardMaster to fetch.
     */
    where?: WardMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardMasters to fetch.
     */
    orderBy?: WardMasterOrderByWithRelationInput | WardMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WardMasters.
     */
    cursor?: WardMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WardMasters.
     */
    distinct?: WardMasterScalarFieldEnum | WardMasterScalarFieldEnum[]
  }

  /**
   * WardMaster findMany
   */
  export type WardMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMaster
     */
    select?: WardMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMasterInclude<ExtArgs> | null
    /**
     * Filter, which WardMasters to fetch.
     */
    where?: WardMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardMasters to fetch.
     */
    orderBy?: WardMasterOrderByWithRelationInput | WardMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WardMasters.
     */
    cursor?: WardMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardMasters.
     */
    skip?: number
    distinct?: WardMasterScalarFieldEnum | WardMasterScalarFieldEnum[]
  }

  /**
   * WardMaster create
   */
  export type WardMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMaster
     */
    select?: WardMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a WardMaster.
     */
    data: XOR<WardMasterCreateInput, WardMasterUncheckedCreateInput>
  }

  /**
   * WardMaster createMany
   */
  export type WardMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WardMasters.
     */
    data: WardMasterCreateManyInput | WardMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WardMaster createManyAndReturn
   */
  export type WardMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMaster
     */
    select?: WardMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WardMasters.
     */
    data: WardMasterCreateManyInput | WardMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WardMaster update
   */
  export type WardMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMaster
     */
    select?: WardMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a WardMaster.
     */
    data: XOR<WardMasterUpdateInput, WardMasterUncheckedUpdateInput>
    /**
     * Choose, which WardMaster to update.
     */
    where: WardMasterWhereUniqueInput
  }

  /**
   * WardMaster updateMany
   */
  export type WardMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WardMasters.
     */
    data: XOR<WardMasterUpdateManyMutationInput, WardMasterUncheckedUpdateManyInput>
    /**
     * Filter which WardMasters to update
     */
    where?: WardMasterWhereInput
  }

  /**
   * WardMaster upsert
   */
  export type WardMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMaster
     */
    select?: WardMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the WardMaster to update in case it exists.
     */
    where: WardMasterWhereUniqueInput
    /**
     * In case the WardMaster found by the `where` argument doesn't exist, create a new WardMaster with this data.
     */
    create: XOR<WardMasterCreateInput, WardMasterUncheckedCreateInput>
    /**
     * In case the WardMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WardMasterUpdateInput, WardMasterUncheckedUpdateInput>
  }

  /**
   * WardMaster delete
   */
  export type WardMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMaster
     */
    select?: WardMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMasterInclude<ExtArgs> | null
    /**
     * Filter which WardMaster to delete.
     */
    where: WardMasterWhereUniqueInput
  }

  /**
   * WardMaster deleteMany
   */
  export type WardMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WardMasters to delete
     */
    where?: WardMasterWhereInput
  }

  /**
   * WardMaster.zoneWardMaps
   */
  export type WardMaster$zoneWardMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneWardMapping
     */
    select?: ZoneWardMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneWardMappingInclude<ExtArgs> | null
    where?: ZoneWardMappingWhereInput
    orderBy?: ZoneWardMappingOrderByWithRelationInput | ZoneWardMappingOrderByWithRelationInput[]
    cursor?: ZoneWardMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoneWardMappingScalarFieldEnum | ZoneWardMappingScalarFieldEnum[]
  }

  /**
   * WardMaster.wardMohallaMaps
   */
  export type WardMaster$wardMohallaMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMohallaMapping
     */
    select?: WardMohallaMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMohallaMappingInclude<ExtArgs> | null
    where?: WardMohallaMappingWhereInput
    orderBy?: WardMohallaMappingOrderByWithRelationInput | WardMohallaMappingOrderByWithRelationInput[]
    cursor?: WardMohallaMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WardMohallaMappingScalarFieldEnum | WardMohallaMappingScalarFieldEnum[]
  }

  /**
   * WardMaster.surveyorAssignments
   */
  export type WardMaster$surveyorAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyorAssignment
     */
    select?: SurveyorAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorAssignmentInclude<ExtArgs> | null
    where?: SurveyorAssignmentWhereInput
    orderBy?: SurveyorAssignmentOrderByWithRelationInput | SurveyorAssignmentOrderByWithRelationInput[]
    cursor?: SurveyorAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyorAssignmentScalarFieldEnum | SurveyorAssignmentScalarFieldEnum[]
  }

  /**
   * WardMaster.wardStatusMaps
   */
  export type WardMaster$wardStatusMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMapping
     */
    select?: WardStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMappingInclude<ExtArgs> | null
    where?: WardStatusMappingWhereInput
    orderBy?: WardStatusMappingOrderByWithRelationInput | WardStatusMappingOrderByWithRelationInput[]
    cursor?: WardStatusMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WardStatusMappingScalarFieldEnum | WardStatusMappingScalarFieldEnum[]
  }

  /**
   * WardMaster.surveyDetails
   */
  export type WardMaster$surveyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyDetails
     */
    select?: SurveyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyDetailsInclude<ExtArgs> | null
    where?: SurveyDetailsWhereInput
    orderBy?: SurveyDetailsOrderByWithRelationInput | SurveyDetailsOrderByWithRelationInput[]
    cursor?: SurveyDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyDetailsScalarFieldEnum | SurveyDetailsScalarFieldEnum[]
  }

  /**
   * WardMaster.supervisors
   */
  export type WardMaster$supervisorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supervisors
     */
    select?: SupervisorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupervisorsInclude<ExtArgs> | null
    where?: SupervisorsWhereInput
    orderBy?: SupervisorsOrderByWithRelationInput | SupervisorsOrderByWithRelationInput[]
    cursor?: SupervisorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupervisorsScalarFieldEnum | SupervisorsScalarFieldEnum[]
  }

  /**
   * WardMaster without action
   */
  export type WardMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMaster
     */
    select?: WardMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMasterInclude<ExtArgs> | null
  }


  /**
   * Model MohallaMaster
   */

  export type AggregateMohallaMaster = {
    _count: MohallaMasterCountAggregateOutputType | null
    _min: MohallaMasterMinAggregateOutputType | null
    _max: MohallaMasterMaxAggregateOutputType | null
  }

  export type MohallaMasterMinAggregateOutputType = {
    mohallaId: string | null
    mohallaName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type MohallaMasterMaxAggregateOutputType = {
    mohallaId: string | null
    mohallaName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type MohallaMasterCountAggregateOutputType = {
    mohallaId: number
    mohallaName: number
    isActive: number
    description: number
    _all: number
  }


  export type MohallaMasterMinAggregateInputType = {
    mohallaId?: true
    mohallaName?: true
    isActive?: true
    description?: true
  }

  export type MohallaMasterMaxAggregateInputType = {
    mohallaId?: true
    mohallaName?: true
    isActive?: true
    description?: true
  }

  export type MohallaMasterCountAggregateInputType = {
    mohallaId?: true
    mohallaName?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type MohallaMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MohallaMaster to aggregate.
     */
    where?: MohallaMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MohallaMasters to fetch.
     */
    orderBy?: MohallaMasterOrderByWithRelationInput | MohallaMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MohallaMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MohallaMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MohallaMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MohallaMasters
    **/
    _count?: true | MohallaMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MohallaMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MohallaMasterMaxAggregateInputType
  }

  export type GetMohallaMasterAggregateType<T extends MohallaMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateMohallaMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMohallaMaster[P]>
      : GetScalarType<T[P], AggregateMohallaMaster[P]>
  }




  export type MohallaMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MohallaMasterWhereInput
    orderBy?: MohallaMasterOrderByWithAggregationInput | MohallaMasterOrderByWithAggregationInput[]
    by: MohallaMasterScalarFieldEnum[] | MohallaMasterScalarFieldEnum
    having?: MohallaMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MohallaMasterCountAggregateInputType | true
    _min?: MohallaMasterMinAggregateInputType
    _max?: MohallaMasterMaxAggregateInputType
  }

  export type MohallaMasterGroupByOutputType = {
    mohallaId: string
    mohallaName: string
    isActive: boolean
    description: string | null
    _count: MohallaMasterCountAggregateOutputType | null
    _min: MohallaMasterMinAggregateOutputType | null
    _max: MohallaMasterMaxAggregateOutputType | null
  }

  type GetMohallaMasterGroupByPayload<T extends MohallaMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MohallaMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MohallaMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MohallaMasterGroupByOutputType[P]>
            : GetScalarType<T[P], MohallaMasterGroupByOutputType[P]>
        }
      >
    >


  export type MohallaMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mohallaId?: boolean
    mohallaName?: boolean
    isActive?: boolean
    description?: boolean
    wardMohallaMaps?: boolean | MohallaMaster$wardMohallaMapsArgs<ExtArgs>
    surveyorAssignments?: boolean | MohallaMaster$surveyorAssignmentsArgs<ExtArgs>
    surveyDetails?: boolean | MohallaMaster$surveyDetailsArgs<ExtArgs>
    _count?: boolean | MohallaMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mohallaMaster"]>

  export type MohallaMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mohallaId?: boolean
    mohallaName?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["mohallaMaster"]>

  export type MohallaMasterSelectScalar = {
    mohallaId?: boolean
    mohallaName?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type MohallaMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wardMohallaMaps?: boolean | MohallaMaster$wardMohallaMapsArgs<ExtArgs>
    surveyorAssignments?: boolean | MohallaMaster$surveyorAssignmentsArgs<ExtArgs>
    surveyDetails?: boolean | MohallaMaster$surveyDetailsArgs<ExtArgs>
    _count?: boolean | MohallaMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MohallaMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MohallaMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MohallaMaster"
    objects: {
      wardMohallaMaps: Prisma.$WardMohallaMappingPayload<ExtArgs>[]
      surveyorAssignments: Prisma.$SurveyorAssignmentPayload<ExtArgs>[]
      surveyDetails: Prisma.$SurveyDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      mohallaId: string
      mohallaName: string
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["mohallaMaster"]>
    composites: {}
  }

  type MohallaMasterGetPayload<S extends boolean | null | undefined | MohallaMasterDefaultArgs> = $Result.GetResult<Prisma.$MohallaMasterPayload, S>

  type MohallaMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MohallaMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MohallaMasterCountAggregateInputType | true
    }

  export interface MohallaMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MohallaMaster'], meta: { name: 'MohallaMaster' } }
    /**
     * Find zero or one MohallaMaster that matches the filter.
     * @param {MohallaMasterFindUniqueArgs} args - Arguments to find a MohallaMaster
     * @example
     * // Get one MohallaMaster
     * const mohallaMaster = await prisma.mohallaMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MohallaMasterFindUniqueArgs>(args: SelectSubset<T, MohallaMasterFindUniqueArgs<ExtArgs>>): Prisma__MohallaMasterClient<$Result.GetResult<Prisma.$MohallaMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MohallaMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MohallaMasterFindUniqueOrThrowArgs} args - Arguments to find a MohallaMaster
     * @example
     * // Get one MohallaMaster
     * const mohallaMaster = await prisma.mohallaMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MohallaMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, MohallaMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MohallaMasterClient<$Result.GetResult<Prisma.$MohallaMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MohallaMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MohallaMasterFindFirstArgs} args - Arguments to find a MohallaMaster
     * @example
     * // Get one MohallaMaster
     * const mohallaMaster = await prisma.mohallaMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MohallaMasterFindFirstArgs>(args?: SelectSubset<T, MohallaMasterFindFirstArgs<ExtArgs>>): Prisma__MohallaMasterClient<$Result.GetResult<Prisma.$MohallaMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MohallaMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MohallaMasterFindFirstOrThrowArgs} args - Arguments to find a MohallaMaster
     * @example
     * // Get one MohallaMaster
     * const mohallaMaster = await prisma.mohallaMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MohallaMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, MohallaMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__MohallaMasterClient<$Result.GetResult<Prisma.$MohallaMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MohallaMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MohallaMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MohallaMasters
     * const mohallaMasters = await prisma.mohallaMaster.findMany()
     * 
     * // Get first 10 MohallaMasters
     * const mohallaMasters = await prisma.mohallaMaster.findMany({ take: 10 })
     * 
     * // Only select the `mohallaId`
     * const mohallaMasterWithMohallaIdOnly = await prisma.mohallaMaster.findMany({ select: { mohallaId: true } })
     * 
     */
    findMany<T extends MohallaMasterFindManyArgs>(args?: SelectSubset<T, MohallaMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MohallaMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MohallaMaster.
     * @param {MohallaMasterCreateArgs} args - Arguments to create a MohallaMaster.
     * @example
     * // Create one MohallaMaster
     * const MohallaMaster = await prisma.mohallaMaster.create({
     *   data: {
     *     // ... data to create a MohallaMaster
     *   }
     * })
     * 
     */
    create<T extends MohallaMasterCreateArgs>(args: SelectSubset<T, MohallaMasterCreateArgs<ExtArgs>>): Prisma__MohallaMasterClient<$Result.GetResult<Prisma.$MohallaMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MohallaMasters.
     * @param {MohallaMasterCreateManyArgs} args - Arguments to create many MohallaMasters.
     * @example
     * // Create many MohallaMasters
     * const mohallaMaster = await prisma.mohallaMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MohallaMasterCreateManyArgs>(args?: SelectSubset<T, MohallaMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MohallaMasters and returns the data saved in the database.
     * @param {MohallaMasterCreateManyAndReturnArgs} args - Arguments to create many MohallaMasters.
     * @example
     * // Create many MohallaMasters
     * const mohallaMaster = await prisma.mohallaMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MohallaMasters and only return the `mohallaId`
     * const mohallaMasterWithMohallaIdOnly = await prisma.mohallaMaster.createManyAndReturn({ 
     *   select: { mohallaId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MohallaMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, MohallaMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MohallaMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MohallaMaster.
     * @param {MohallaMasterDeleteArgs} args - Arguments to delete one MohallaMaster.
     * @example
     * // Delete one MohallaMaster
     * const MohallaMaster = await prisma.mohallaMaster.delete({
     *   where: {
     *     // ... filter to delete one MohallaMaster
     *   }
     * })
     * 
     */
    delete<T extends MohallaMasterDeleteArgs>(args: SelectSubset<T, MohallaMasterDeleteArgs<ExtArgs>>): Prisma__MohallaMasterClient<$Result.GetResult<Prisma.$MohallaMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MohallaMaster.
     * @param {MohallaMasterUpdateArgs} args - Arguments to update one MohallaMaster.
     * @example
     * // Update one MohallaMaster
     * const mohallaMaster = await prisma.mohallaMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MohallaMasterUpdateArgs>(args: SelectSubset<T, MohallaMasterUpdateArgs<ExtArgs>>): Prisma__MohallaMasterClient<$Result.GetResult<Prisma.$MohallaMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MohallaMasters.
     * @param {MohallaMasterDeleteManyArgs} args - Arguments to filter MohallaMasters to delete.
     * @example
     * // Delete a few MohallaMasters
     * const { count } = await prisma.mohallaMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MohallaMasterDeleteManyArgs>(args?: SelectSubset<T, MohallaMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MohallaMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MohallaMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MohallaMasters
     * const mohallaMaster = await prisma.mohallaMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MohallaMasterUpdateManyArgs>(args: SelectSubset<T, MohallaMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MohallaMaster.
     * @param {MohallaMasterUpsertArgs} args - Arguments to update or create a MohallaMaster.
     * @example
     * // Update or create a MohallaMaster
     * const mohallaMaster = await prisma.mohallaMaster.upsert({
     *   create: {
     *     // ... data to create a MohallaMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MohallaMaster we want to update
     *   }
     * })
     */
    upsert<T extends MohallaMasterUpsertArgs>(args: SelectSubset<T, MohallaMasterUpsertArgs<ExtArgs>>): Prisma__MohallaMasterClient<$Result.GetResult<Prisma.$MohallaMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MohallaMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MohallaMasterCountArgs} args - Arguments to filter MohallaMasters to count.
     * @example
     * // Count the number of MohallaMasters
     * const count = await prisma.mohallaMaster.count({
     *   where: {
     *     // ... the filter for the MohallaMasters we want to count
     *   }
     * })
    **/
    count<T extends MohallaMasterCountArgs>(
      args?: Subset<T, MohallaMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MohallaMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MohallaMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MohallaMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MohallaMasterAggregateArgs>(args: Subset<T, MohallaMasterAggregateArgs>): Prisma.PrismaPromise<GetMohallaMasterAggregateType<T>>

    /**
     * Group by MohallaMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MohallaMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MohallaMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MohallaMasterGroupByArgs['orderBy'] }
        : { orderBy?: MohallaMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MohallaMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMohallaMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MohallaMaster model
   */
  readonly fields: MohallaMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MohallaMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MohallaMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wardMohallaMaps<T extends MohallaMaster$wardMohallaMapsArgs<ExtArgs> = {}>(args?: Subset<T, MohallaMaster$wardMohallaMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardMohallaMappingPayload<ExtArgs>, T, "findMany"> | Null>
    surveyorAssignments<T extends MohallaMaster$surveyorAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, MohallaMaster$surveyorAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyorAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    surveyDetails<T extends MohallaMaster$surveyDetailsArgs<ExtArgs> = {}>(args?: Subset<T, MohallaMaster$surveyDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MohallaMaster model
   */ 
  interface MohallaMasterFieldRefs {
    readonly mohallaId: FieldRef<"MohallaMaster", 'String'>
    readonly mohallaName: FieldRef<"MohallaMaster", 'String'>
    readonly isActive: FieldRef<"MohallaMaster", 'Boolean'>
    readonly description: FieldRef<"MohallaMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MohallaMaster findUnique
   */
  export type MohallaMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MohallaMaster
     */
    select?: MohallaMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaMasterInclude<ExtArgs> | null
    /**
     * Filter, which MohallaMaster to fetch.
     */
    where: MohallaMasterWhereUniqueInput
  }

  /**
   * MohallaMaster findUniqueOrThrow
   */
  export type MohallaMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MohallaMaster
     */
    select?: MohallaMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaMasterInclude<ExtArgs> | null
    /**
     * Filter, which MohallaMaster to fetch.
     */
    where: MohallaMasterWhereUniqueInput
  }

  /**
   * MohallaMaster findFirst
   */
  export type MohallaMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MohallaMaster
     */
    select?: MohallaMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaMasterInclude<ExtArgs> | null
    /**
     * Filter, which MohallaMaster to fetch.
     */
    where?: MohallaMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MohallaMasters to fetch.
     */
    orderBy?: MohallaMasterOrderByWithRelationInput | MohallaMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MohallaMasters.
     */
    cursor?: MohallaMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MohallaMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MohallaMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MohallaMasters.
     */
    distinct?: MohallaMasterScalarFieldEnum | MohallaMasterScalarFieldEnum[]
  }

  /**
   * MohallaMaster findFirstOrThrow
   */
  export type MohallaMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MohallaMaster
     */
    select?: MohallaMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaMasterInclude<ExtArgs> | null
    /**
     * Filter, which MohallaMaster to fetch.
     */
    where?: MohallaMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MohallaMasters to fetch.
     */
    orderBy?: MohallaMasterOrderByWithRelationInput | MohallaMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MohallaMasters.
     */
    cursor?: MohallaMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MohallaMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MohallaMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MohallaMasters.
     */
    distinct?: MohallaMasterScalarFieldEnum | MohallaMasterScalarFieldEnum[]
  }

  /**
   * MohallaMaster findMany
   */
  export type MohallaMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MohallaMaster
     */
    select?: MohallaMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaMasterInclude<ExtArgs> | null
    /**
     * Filter, which MohallaMasters to fetch.
     */
    where?: MohallaMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MohallaMasters to fetch.
     */
    orderBy?: MohallaMasterOrderByWithRelationInput | MohallaMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MohallaMasters.
     */
    cursor?: MohallaMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MohallaMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MohallaMasters.
     */
    skip?: number
    distinct?: MohallaMasterScalarFieldEnum | MohallaMasterScalarFieldEnum[]
  }

  /**
   * MohallaMaster create
   */
  export type MohallaMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MohallaMaster
     */
    select?: MohallaMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a MohallaMaster.
     */
    data: XOR<MohallaMasterCreateInput, MohallaMasterUncheckedCreateInput>
  }

  /**
   * MohallaMaster createMany
   */
  export type MohallaMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MohallaMasters.
     */
    data: MohallaMasterCreateManyInput | MohallaMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MohallaMaster createManyAndReturn
   */
  export type MohallaMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MohallaMaster
     */
    select?: MohallaMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MohallaMasters.
     */
    data: MohallaMasterCreateManyInput | MohallaMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MohallaMaster update
   */
  export type MohallaMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MohallaMaster
     */
    select?: MohallaMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a MohallaMaster.
     */
    data: XOR<MohallaMasterUpdateInput, MohallaMasterUncheckedUpdateInput>
    /**
     * Choose, which MohallaMaster to update.
     */
    where: MohallaMasterWhereUniqueInput
  }

  /**
   * MohallaMaster updateMany
   */
  export type MohallaMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MohallaMasters.
     */
    data: XOR<MohallaMasterUpdateManyMutationInput, MohallaMasterUncheckedUpdateManyInput>
    /**
     * Filter which MohallaMasters to update
     */
    where?: MohallaMasterWhereInput
  }

  /**
   * MohallaMaster upsert
   */
  export type MohallaMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MohallaMaster
     */
    select?: MohallaMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the MohallaMaster to update in case it exists.
     */
    where: MohallaMasterWhereUniqueInput
    /**
     * In case the MohallaMaster found by the `where` argument doesn't exist, create a new MohallaMaster with this data.
     */
    create: XOR<MohallaMasterCreateInput, MohallaMasterUncheckedCreateInput>
    /**
     * In case the MohallaMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MohallaMasterUpdateInput, MohallaMasterUncheckedUpdateInput>
  }

  /**
   * MohallaMaster delete
   */
  export type MohallaMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MohallaMaster
     */
    select?: MohallaMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaMasterInclude<ExtArgs> | null
    /**
     * Filter which MohallaMaster to delete.
     */
    where: MohallaMasterWhereUniqueInput
  }

  /**
   * MohallaMaster deleteMany
   */
  export type MohallaMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MohallaMasters to delete
     */
    where?: MohallaMasterWhereInput
  }

  /**
   * MohallaMaster.wardMohallaMaps
   */
  export type MohallaMaster$wardMohallaMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMohallaMapping
     */
    select?: WardMohallaMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMohallaMappingInclude<ExtArgs> | null
    where?: WardMohallaMappingWhereInput
    orderBy?: WardMohallaMappingOrderByWithRelationInput | WardMohallaMappingOrderByWithRelationInput[]
    cursor?: WardMohallaMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WardMohallaMappingScalarFieldEnum | WardMohallaMappingScalarFieldEnum[]
  }

  /**
   * MohallaMaster.surveyorAssignments
   */
  export type MohallaMaster$surveyorAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyorAssignment
     */
    select?: SurveyorAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorAssignmentInclude<ExtArgs> | null
    where?: SurveyorAssignmentWhereInput
    orderBy?: SurveyorAssignmentOrderByWithRelationInput | SurveyorAssignmentOrderByWithRelationInput[]
    cursor?: SurveyorAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyorAssignmentScalarFieldEnum | SurveyorAssignmentScalarFieldEnum[]
  }

  /**
   * MohallaMaster.surveyDetails
   */
  export type MohallaMaster$surveyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyDetails
     */
    select?: SurveyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyDetailsInclude<ExtArgs> | null
    where?: SurveyDetailsWhereInput
    orderBy?: SurveyDetailsOrderByWithRelationInput | SurveyDetailsOrderByWithRelationInput[]
    cursor?: SurveyDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyDetailsScalarFieldEnum | SurveyDetailsScalarFieldEnum[]
  }

  /**
   * MohallaMaster without action
   */
  export type MohallaMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MohallaMaster
     */
    select?: MohallaMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaMasterInclude<ExtArgs> | null
  }


  /**
   * Model ResponseTypeMaster
   */

  export type AggregateResponseTypeMaster = {
    _count: ResponseTypeMasterCountAggregateOutputType | null
    _min: ResponseTypeMasterMinAggregateOutputType | null
    _max: ResponseTypeMasterMaxAggregateOutputType | null
  }

  export type ResponseTypeMasterMinAggregateOutputType = {
    responseTypeId: string | null
    responseTypeName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type ResponseTypeMasterMaxAggregateOutputType = {
    responseTypeId: string | null
    responseTypeName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type ResponseTypeMasterCountAggregateOutputType = {
    responseTypeId: number
    responseTypeName: number
    isActive: number
    description: number
    _all: number
  }


  export type ResponseTypeMasterMinAggregateInputType = {
    responseTypeId?: true
    responseTypeName?: true
    isActive?: true
    description?: true
  }

  export type ResponseTypeMasterMaxAggregateInputType = {
    responseTypeId?: true
    responseTypeName?: true
    isActive?: true
    description?: true
  }

  export type ResponseTypeMasterCountAggregateInputType = {
    responseTypeId?: true
    responseTypeName?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type ResponseTypeMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResponseTypeMaster to aggregate.
     */
    where?: ResponseTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponseTypeMasters to fetch.
     */
    orderBy?: ResponseTypeMasterOrderByWithRelationInput | ResponseTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResponseTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponseTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponseTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResponseTypeMasters
    **/
    _count?: true | ResponseTypeMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResponseTypeMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResponseTypeMasterMaxAggregateInputType
  }

  export type GetResponseTypeMasterAggregateType<T extends ResponseTypeMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateResponseTypeMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponseTypeMaster[P]>
      : GetScalarType<T[P], AggregateResponseTypeMaster[P]>
  }




  export type ResponseTypeMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponseTypeMasterWhereInput
    orderBy?: ResponseTypeMasterOrderByWithAggregationInput | ResponseTypeMasterOrderByWithAggregationInput[]
    by: ResponseTypeMasterScalarFieldEnum[] | ResponseTypeMasterScalarFieldEnum
    having?: ResponseTypeMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResponseTypeMasterCountAggregateInputType | true
    _min?: ResponseTypeMasterMinAggregateInputType
    _max?: ResponseTypeMasterMaxAggregateInputType
  }

  export type ResponseTypeMasterGroupByOutputType = {
    responseTypeId: string
    responseTypeName: string
    isActive: boolean
    description: string | null
    _count: ResponseTypeMasterCountAggregateOutputType | null
    _min: ResponseTypeMasterMinAggregateOutputType | null
    _max: ResponseTypeMasterMaxAggregateOutputType | null
  }

  type GetResponseTypeMasterGroupByPayload<T extends ResponseTypeMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResponseTypeMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResponseTypeMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResponseTypeMasterGroupByOutputType[P]>
            : GetScalarType<T[P], ResponseTypeMasterGroupByOutputType[P]>
        }
      >
    >


  export type ResponseTypeMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    responseTypeId?: boolean
    responseTypeName?: boolean
    isActive?: boolean
    description?: boolean
    propertyDetails?: boolean | ResponseTypeMaster$propertyDetailsArgs<ExtArgs>
    _count?: boolean | ResponseTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["responseTypeMaster"]>

  export type ResponseTypeMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    responseTypeId?: boolean
    responseTypeName?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["responseTypeMaster"]>

  export type ResponseTypeMasterSelectScalar = {
    responseTypeId?: boolean
    responseTypeName?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type ResponseTypeMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyDetails?: boolean | ResponseTypeMaster$propertyDetailsArgs<ExtArgs>
    _count?: boolean | ResponseTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResponseTypeMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ResponseTypeMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResponseTypeMaster"
    objects: {
      propertyDetails: Prisma.$PropertyDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      responseTypeId: string
      responseTypeName: string
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["responseTypeMaster"]>
    composites: {}
  }

  type ResponseTypeMasterGetPayload<S extends boolean | null | undefined | ResponseTypeMasterDefaultArgs> = $Result.GetResult<Prisma.$ResponseTypeMasterPayload, S>

  type ResponseTypeMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResponseTypeMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResponseTypeMasterCountAggregateInputType | true
    }

  export interface ResponseTypeMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResponseTypeMaster'], meta: { name: 'ResponseTypeMaster' } }
    /**
     * Find zero or one ResponseTypeMaster that matches the filter.
     * @param {ResponseTypeMasterFindUniqueArgs} args - Arguments to find a ResponseTypeMaster
     * @example
     * // Get one ResponseTypeMaster
     * const responseTypeMaster = await prisma.responseTypeMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResponseTypeMasterFindUniqueArgs>(args: SelectSubset<T, ResponseTypeMasterFindUniqueArgs<ExtArgs>>): Prisma__ResponseTypeMasterClient<$Result.GetResult<Prisma.$ResponseTypeMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ResponseTypeMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResponseTypeMasterFindUniqueOrThrowArgs} args - Arguments to find a ResponseTypeMaster
     * @example
     * // Get one ResponseTypeMaster
     * const responseTypeMaster = await prisma.responseTypeMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResponseTypeMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, ResponseTypeMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResponseTypeMasterClient<$Result.GetResult<Prisma.$ResponseTypeMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ResponseTypeMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseTypeMasterFindFirstArgs} args - Arguments to find a ResponseTypeMaster
     * @example
     * // Get one ResponseTypeMaster
     * const responseTypeMaster = await prisma.responseTypeMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResponseTypeMasterFindFirstArgs>(args?: SelectSubset<T, ResponseTypeMasterFindFirstArgs<ExtArgs>>): Prisma__ResponseTypeMasterClient<$Result.GetResult<Prisma.$ResponseTypeMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ResponseTypeMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseTypeMasterFindFirstOrThrowArgs} args - Arguments to find a ResponseTypeMaster
     * @example
     * // Get one ResponseTypeMaster
     * const responseTypeMaster = await prisma.responseTypeMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResponseTypeMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, ResponseTypeMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResponseTypeMasterClient<$Result.GetResult<Prisma.$ResponseTypeMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ResponseTypeMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseTypeMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResponseTypeMasters
     * const responseTypeMasters = await prisma.responseTypeMaster.findMany()
     * 
     * // Get first 10 ResponseTypeMasters
     * const responseTypeMasters = await prisma.responseTypeMaster.findMany({ take: 10 })
     * 
     * // Only select the `responseTypeId`
     * const responseTypeMasterWithResponseTypeIdOnly = await prisma.responseTypeMaster.findMany({ select: { responseTypeId: true } })
     * 
     */
    findMany<T extends ResponseTypeMasterFindManyArgs>(args?: SelectSubset<T, ResponseTypeMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponseTypeMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ResponseTypeMaster.
     * @param {ResponseTypeMasterCreateArgs} args - Arguments to create a ResponseTypeMaster.
     * @example
     * // Create one ResponseTypeMaster
     * const ResponseTypeMaster = await prisma.responseTypeMaster.create({
     *   data: {
     *     // ... data to create a ResponseTypeMaster
     *   }
     * })
     * 
     */
    create<T extends ResponseTypeMasterCreateArgs>(args: SelectSubset<T, ResponseTypeMasterCreateArgs<ExtArgs>>): Prisma__ResponseTypeMasterClient<$Result.GetResult<Prisma.$ResponseTypeMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ResponseTypeMasters.
     * @param {ResponseTypeMasterCreateManyArgs} args - Arguments to create many ResponseTypeMasters.
     * @example
     * // Create many ResponseTypeMasters
     * const responseTypeMaster = await prisma.responseTypeMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResponseTypeMasterCreateManyArgs>(args?: SelectSubset<T, ResponseTypeMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResponseTypeMasters and returns the data saved in the database.
     * @param {ResponseTypeMasterCreateManyAndReturnArgs} args - Arguments to create many ResponseTypeMasters.
     * @example
     * // Create many ResponseTypeMasters
     * const responseTypeMaster = await prisma.responseTypeMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResponseTypeMasters and only return the `responseTypeId`
     * const responseTypeMasterWithResponseTypeIdOnly = await prisma.responseTypeMaster.createManyAndReturn({ 
     *   select: { responseTypeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResponseTypeMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, ResponseTypeMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponseTypeMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ResponseTypeMaster.
     * @param {ResponseTypeMasterDeleteArgs} args - Arguments to delete one ResponseTypeMaster.
     * @example
     * // Delete one ResponseTypeMaster
     * const ResponseTypeMaster = await prisma.responseTypeMaster.delete({
     *   where: {
     *     // ... filter to delete one ResponseTypeMaster
     *   }
     * })
     * 
     */
    delete<T extends ResponseTypeMasterDeleteArgs>(args: SelectSubset<T, ResponseTypeMasterDeleteArgs<ExtArgs>>): Prisma__ResponseTypeMasterClient<$Result.GetResult<Prisma.$ResponseTypeMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ResponseTypeMaster.
     * @param {ResponseTypeMasterUpdateArgs} args - Arguments to update one ResponseTypeMaster.
     * @example
     * // Update one ResponseTypeMaster
     * const responseTypeMaster = await prisma.responseTypeMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResponseTypeMasterUpdateArgs>(args: SelectSubset<T, ResponseTypeMasterUpdateArgs<ExtArgs>>): Prisma__ResponseTypeMasterClient<$Result.GetResult<Prisma.$ResponseTypeMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ResponseTypeMasters.
     * @param {ResponseTypeMasterDeleteManyArgs} args - Arguments to filter ResponseTypeMasters to delete.
     * @example
     * // Delete a few ResponseTypeMasters
     * const { count } = await prisma.responseTypeMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResponseTypeMasterDeleteManyArgs>(args?: SelectSubset<T, ResponseTypeMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResponseTypeMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseTypeMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResponseTypeMasters
     * const responseTypeMaster = await prisma.responseTypeMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResponseTypeMasterUpdateManyArgs>(args: SelectSubset<T, ResponseTypeMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResponseTypeMaster.
     * @param {ResponseTypeMasterUpsertArgs} args - Arguments to update or create a ResponseTypeMaster.
     * @example
     * // Update or create a ResponseTypeMaster
     * const responseTypeMaster = await prisma.responseTypeMaster.upsert({
     *   create: {
     *     // ... data to create a ResponseTypeMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResponseTypeMaster we want to update
     *   }
     * })
     */
    upsert<T extends ResponseTypeMasterUpsertArgs>(args: SelectSubset<T, ResponseTypeMasterUpsertArgs<ExtArgs>>): Prisma__ResponseTypeMasterClient<$Result.GetResult<Prisma.$ResponseTypeMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ResponseTypeMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseTypeMasterCountArgs} args - Arguments to filter ResponseTypeMasters to count.
     * @example
     * // Count the number of ResponseTypeMasters
     * const count = await prisma.responseTypeMaster.count({
     *   where: {
     *     // ... the filter for the ResponseTypeMasters we want to count
     *   }
     * })
    **/
    count<T extends ResponseTypeMasterCountArgs>(
      args?: Subset<T, ResponseTypeMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResponseTypeMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResponseTypeMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseTypeMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResponseTypeMasterAggregateArgs>(args: Subset<T, ResponseTypeMasterAggregateArgs>): Prisma.PrismaPromise<GetResponseTypeMasterAggregateType<T>>

    /**
     * Group by ResponseTypeMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseTypeMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResponseTypeMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResponseTypeMasterGroupByArgs['orderBy'] }
        : { orderBy?: ResponseTypeMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResponseTypeMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponseTypeMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResponseTypeMaster model
   */
  readonly fields: ResponseTypeMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResponseTypeMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResponseTypeMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    propertyDetails<T extends ResponseTypeMaster$propertyDetailsArgs<ExtArgs> = {}>(args?: Subset<T, ResponseTypeMaster$propertyDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResponseTypeMaster model
   */ 
  interface ResponseTypeMasterFieldRefs {
    readonly responseTypeId: FieldRef<"ResponseTypeMaster", 'String'>
    readonly responseTypeName: FieldRef<"ResponseTypeMaster", 'String'>
    readonly isActive: FieldRef<"ResponseTypeMaster", 'Boolean'>
    readonly description: FieldRef<"ResponseTypeMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ResponseTypeMaster findUnique
   */
  export type ResponseTypeMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTypeMaster
     */
    select?: ResponseTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which ResponseTypeMaster to fetch.
     */
    where: ResponseTypeMasterWhereUniqueInput
  }

  /**
   * ResponseTypeMaster findUniqueOrThrow
   */
  export type ResponseTypeMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTypeMaster
     */
    select?: ResponseTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which ResponseTypeMaster to fetch.
     */
    where: ResponseTypeMasterWhereUniqueInput
  }

  /**
   * ResponseTypeMaster findFirst
   */
  export type ResponseTypeMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTypeMaster
     */
    select?: ResponseTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which ResponseTypeMaster to fetch.
     */
    where?: ResponseTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponseTypeMasters to fetch.
     */
    orderBy?: ResponseTypeMasterOrderByWithRelationInput | ResponseTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResponseTypeMasters.
     */
    cursor?: ResponseTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponseTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponseTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResponseTypeMasters.
     */
    distinct?: ResponseTypeMasterScalarFieldEnum | ResponseTypeMasterScalarFieldEnum[]
  }

  /**
   * ResponseTypeMaster findFirstOrThrow
   */
  export type ResponseTypeMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTypeMaster
     */
    select?: ResponseTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which ResponseTypeMaster to fetch.
     */
    where?: ResponseTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponseTypeMasters to fetch.
     */
    orderBy?: ResponseTypeMasterOrderByWithRelationInput | ResponseTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResponseTypeMasters.
     */
    cursor?: ResponseTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponseTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponseTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResponseTypeMasters.
     */
    distinct?: ResponseTypeMasterScalarFieldEnum | ResponseTypeMasterScalarFieldEnum[]
  }

  /**
   * ResponseTypeMaster findMany
   */
  export type ResponseTypeMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTypeMaster
     */
    select?: ResponseTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which ResponseTypeMasters to fetch.
     */
    where?: ResponseTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponseTypeMasters to fetch.
     */
    orderBy?: ResponseTypeMasterOrderByWithRelationInput | ResponseTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResponseTypeMasters.
     */
    cursor?: ResponseTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponseTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponseTypeMasters.
     */
    skip?: number
    distinct?: ResponseTypeMasterScalarFieldEnum | ResponseTypeMasterScalarFieldEnum[]
  }

  /**
   * ResponseTypeMaster create
   */
  export type ResponseTypeMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTypeMaster
     */
    select?: ResponseTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTypeMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a ResponseTypeMaster.
     */
    data: XOR<ResponseTypeMasterCreateInput, ResponseTypeMasterUncheckedCreateInput>
  }

  /**
   * ResponseTypeMaster createMany
   */
  export type ResponseTypeMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResponseTypeMasters.
     */
    data: ResponseTypeMasterCreateManyInput | ResponseTypeMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResponseTypeMaster createManyAndReturn
   */
  export type ResponseTypeMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTypeMaster
     */
    select?: ResponseTypeMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ResponseTypeMasters.
     */
    data: ResponseTypeMasterCreateManyInput | ResponseTypeMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResponseTypeMaster update
   */
  export type ResponseTypeMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTypeMaster
     */
    select?: ResponseTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTypeMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a ResponseTypeMaster.
     */
    data: XOR<ResponseTypeMasterUpdateInput, ResponseTypeMasterUncheckedUpdateInput>
    /**
     * Choose, which ResponseTypeMaster to update.
     */
    where: ResponseTypeMasterWhereUniqueInput
  }

  /**
   * ResponseTypeMaster updateMany
   */
  export type ResponseTypeMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResponseTypeMasters.
     */
    data: XOR<ResponseTypeMasterUpdateManyMutationInput, ResponseTypeMasterUncheckedUpdateManyInput>
    /**
     * Filter which ResponseTypeMasters to update
     */
    where?: ResponseTypeMasterWhereInput
  }

  /**
   * ResponseTypeMaster upsert
   */
  export type ResponseTypeMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTypeMaster
     */
    select?: ResponseTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTypeMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the ResponseTypeMaster to update in case it exists.
     */
    where: ResponseTypeMasterWhereUniqueInput
    /**
     * In case the ResponseTypeMaster found by the `where` argument doesn't exist, create a new ResponseTypeMaster with this data.
     */
    create: XOR<ResponseTypeMasterCreateInput, ResponseTypeMasterUncheckedCreateInput>
    /**
     * In case the ResponseTypeMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResponseTypeMasterUpdateInput, ResponseTypeMasterUncheckedUpdateInput>
  }

  /**
   * ResponseTypeMaster delete
   */
  export type ResponseTypeMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTypeMaster
     */
    select?: ResponseTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTypeMasterInclude<ExtArgs> | null
    /**
     * Filter which ResponseTypeMaster to delete.
     */
    where: ResponseTypeMasterWhereUniqueInput
  }

  /**
   * ResponseTypeMaster deleteMany
   */
  export type ResponseTypeMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResponseTypeMasters to delete
     */
    where?: ResponseTypeMasterWhereInput
  }

  /**
   * ResponseTypeMaster.propertyDetails
   */
  export type ResponseTypeMaster$propertyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    where?: PropertyDetailsWhereInput
    orderBy?: PropertyDetailsOrderByWithRelationInput | PropertyDetailsOrderByWithRelationInput[]
    cursor?: PropertyDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyDetailsScalarFieldEnum | PropertyDetailsScalarFieldEnum[]
  }

  /**
   * ResponseTypeMaster without action
   */
  export type ResponseTypeMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTypeMaster
     */
    select?: ResponseTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTypeMasterInclude<ExtArgs> | null
  }


  /**
   * Model PropertyTypeMaster
   */

  export type AggregatePropertyTypeMaster = {
    _count: PropertyTypeMasterCountAggregateOutputType | null
    _min: PropertyTypeMasterMinAggregateOutputType | null
    _max: PropertyTypeMasterMaxAggregateOutputType | null
  }

  export type PropertyTypeMasterMinAggregateOutputType = {
    propertyTypeId: string | null
    propertyTypeName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type PropertyTypeMasterMaxAggregateOutputType = {
    propertyTypeId: string | null
    propertyTypeName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type PropertyTypeMasterCountAggregateOutputType = {
    propertyTypeId: number
    propertyTypeName: number
    isActive: number
    description: number
    _all: number
  }


  export type PropertyTypeMasterMinAggregateInputType = {
    propertyTypeId?: true
    propertyTypeName?: true
    isActive?: true
    description?: true
  }

  export type PropertyTypeMasterMaxAggregateInputType = {
    propertyTypeId?: true
    propertyTypeName?: true
    isActive?: true
    description?: true
  }

  export type PropertyTypeMasterCountAggregateInputType = {
    propertyTypeId?: true
    propertyTypeName?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type PropertyTypeMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyTypeMaster to aggregate.
     */
    where?: PropertyTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTypeMasters to fetch.
     */
    orderBy?: PropertyTypeMasterOrderByWithRelationInput | PropertyTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyTypeMasters
    **/
    _count?: true | PropertyTypeMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyTypeMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyTypeMasterMaxAggregateInputType
  }

  export type GetPropertyTypeMasterAggregateType<T extends PropertyTypeMasterAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyTypeMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyTypeMaster[P]>
      : GetScalarType<T[P], AggregatePropertyTypeMaster[P]>
  }




  export type PropertyTypeMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyTypeMasterWhereInput
    orderBy?: PropertyTypeMasterOrderByWithAggregationInput | PropertyTypeMasterOrderByWithAggregationInput[]
    by: PropertyTypeMasterScalarFieldEnum[] | PropertyTypeMasterScalarFieldEnum
    having?: PropertyTypeMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyTypeMasterCountAggregateInputType | true
    _min?: PropertyTypeMasterMinAggregateInputType
    _max?: PropertyTypeMasterMaxAggregateInputType
  }

  export type PropertyTypeMasterGroupByOutputType = {
    propertyTypeId: string
    propertyTypeName: string
    isActive: boolean
    description: string | null
    _count: PropertyTypeMasterCountAggregateOutputType | null
    _min: PropertyTypeMasterMinAggregateOutputType | null
    _max: PropertyTypeMasterMaxAggregateOutputType | null
  }

  type GetPropertyTypeMasterGroupByPayload<T extends PropertyTypeMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyTypeMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyTypeMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyTypeMasterGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyTypeMasterGroupByOutputType[P]>
        }
      >
    >


  export type PropertyTypeMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    propertyTypeId?: boolean
    propertyTypeName?: boolean
    isActive?: boolean
    description?: boolean
    locationDetails?: boolean | PropertyTypeMaster$locationDetailsArgs<ExtArgs>
    _count?: boolean | PropertyTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyTypeMaster"]>

  export type PropertyTypeMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    propertyTypeId?: boolean
    propertyTypeName?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["propertyTypeMaster"]>

  export type PropertyTypeMasterSelectScalar = {
    propertyTypeId?: boolean
    propertyTypeName?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type PropertyTypeMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locationDetails?: boolean | PropertyTypeMaster$locationDetailsArgs<ExtArgs>
    _count?: boolean | PropertyTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyTypeMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PropertyTypeMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyTypeMaster"
    objects: {
      locationDetails: Prisma.$LocationDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      propertyTypeId: string
      propertyTypeName: string
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["propertyTypeMaster"]>
    composites: {}
  }

  type PropertyTypeMasterGetPayload<S extends boolean | null | undefined | PropertyTypeMasterDefaultArgs> = $Result.GetResult<Prisma.$PropertyTypeMasterPayload, S>

  type PropertyTypeMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyTypeMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PropertyTypeMasterCountAggregateInputType | true
    }

  export interface PropertyTypeMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyTypeMaster'], meta: { name: 'PropertyTypeMaster' } }
    /**
     * Find zero or one PropertyTypeMaster that matches the filter.
     * @param {PropertyTypeMasterFindUniqueArgs} args - Arguments to find a PropertyTypeMaster
     * @example
     * // Get one PropertyTypeMaster
     * const propertyTypeMaster = await prisma.propertyTypeMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyTypeMasterFindUniqueArgs>(args: SelectSubset<T, PropertyTypeMasterFindUniqueArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PropertyTypeMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PropertyTypeMasterFindUniqueOrThrowArgs} args - Arguments to find a PropertyTypeMaster
     * @example
     * // Get one PropertyTypeMaster
     * const propertyTypeMaster = await prisma.propertyTypeMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyTypeMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyTypeMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PropertyTypeMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeMasterFindFirstArgs} args - Arguments to find a PropertyTypeMaster
     * @example
     * // Get one PropertyTypeMaster
     * const propertyTypeMaster = await prisma.propertyTypeMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyTypeMasterFindFirstArgs>(args?: SelectSubset<T, PropertyTypeMasterFindFirstArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PropertyTypeMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeMasterFindFirstOrThrowArgs} args - Arguments to find a PropertyTypeMaster
     * @example
     * // Get one PropertyTypeMaster
     * const propertyTypeMaster = await prisma.propertyTypeMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyTypeMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyTypeMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PropertyTypeMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyTypeMasters
     * const propertyTypeMasters = await prisma.propertyTypeMaster.findMany()
     * 
     * // Get first 10 PropertyTypeMasters
     * const propertyTypeMasters = await prisma.propertyTypeMaster.findMany({ take: 10 })
     * 
     * // Only select the `propertyTypeId`
     * const propertyTypeMasterWithPropertyTypeIdOnly = await prisma.propertyTypeMaster.findMany({ select: { propertyTypeId: true } })
     * 
     */
    findMany<T extends PropertyTypeMasterFindManyArgs>(args?: SelectSubset<T, PropertyTypeMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PropertyTypeMaster.
     * @param {PropertyTypeMasterCreateArgs} args - Arguments to create a PropertyTypeMaster.
     * @example
     * // Create one PropertyTypeMaster
     * const PropertyTypeMaster = await prisma.propertyTypeMaster.create({
     *   data: {
     *     // ... data to create a PropertyTypeMaster
     *   }
     * })
     * 
     */
    create<T extends PropertyTypeMasterCreateArgs>(args: SelectSubset<T, PropertyTypeMasterCreateArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PropertyTypeMasters.
     * @param {PropertyTypeMasterCreateManyArgs} args - Arguments to create many PropertyTypeMasters.
     * @example
     * // Create many PropertyTypeMasters
     * const propertyTypeMaster = await prisma.propertyTypeMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyTypeMasterCreateManyArgs>(args?: SelectSubset<T, PropertyTypeMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyTypeMasters and returns the data saved in the database.
     * @param {PropertyTypeMasterCreateManyAndReturnArgs} args - Arguments to create many PropertyTypeMasters.
     * @example
     * // Create many PropertyTypeMasters
     * const propertyTypeMaster = await prisma.propertyTypeMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyTypeMasters and only return the `propertyTypeId`
     * const propertyTypeMasterWithPropertyTypeIdOnly = await prisma.propertyTypeMaster.createManyAndReturn({ 
     *   select: { propertyTypeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyTypeMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyTypeMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PropertyTypeMaster.
     * @param {PropertyTypeMasterDeleteArgs} args - Arguments to delete one PropertyTypeMaster.
     * @example
     * // Delete one PropertyTypeMaster
     * const PropertyTypeMaster = await prisma.propertyTypeMaster.delete({
     *   where: {
     *     // ... filter to delete one PropertyTypeMaster
     *   }
     * })
     * 
     */
    delete<T extends PropertyTypeMasterDeleteArgs>(args: SelectSubset<T, PropertyTypeMasterDeleteArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PropertyTypeMaster.
     * @param {PropertyTypeMasterUpdateArgs} args - Arguments to update one PropertyTypeMaster.
     * @example
     * // Update one PropertyTypeMaster
     * const propertyTypeMaster = await prisma.propertyTypeMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyTypeMasterUpdateArgs>(args: SelectSubset<T, PropertyTypeMasterUpdateArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PropertyTypeMasters.
     * @param {PropertyTypeMasterDeleteManyArgs} args - Arguments to filter PropertyTypeMasters to delete.
     * @example
     * // Delete a few PropertyTypeMasters
     * const { count } = await prisma.propertyTypeMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyTypeMasterDeleteManyArgs>(args?: SelectSubset<T, PropertyTypeMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyTypeMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyTypeMasters
     * const propertyTypeMaster = await prisma.propertyTypeMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyTypeMasterUpdateManyArgs>(args: SelectSubset<T, PropertyTypeMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyTypeMaster.
     * @param {PropertyTypeMasterUpsertArgs} args - Arguments to update or create a PropertyTypeMaster.
     * @example
     * // Update or create a PropertyTypeMaster
     * const propertyTypeMaster = await prisma.propertyTypeMaster.upsert({
     *   create: {
     *     // ... data to create a PropertyTypeMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyTypeMaster we want to update
     *   }
     * })
     */
    upsert<T extends PropertyTypeMasterUpsertArgs>(args: SelectSubset<T, PropertyTypeMasterUpsertArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PropertyTypeMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeMasterCountArgs} args - Arguments to filter PropertyTypeMasters to count.
     * @example
     * // Count the number of PropertyTypeMasters
     * const count = await prisma.propertyTypeMaster.count({
     *   where: {
     *     // ... the filter for the PropertyTypeMasters we want to count
     *   }
     * })
    **/
    count<T extends PropertyTypeMasterCountArgs>(
      args?: Subset<T, PropertyTypeMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyTypeMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyTypeMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyTypeMasterAggregateArgs>(args: Subset<T, PropertyTypeMasterAggregateArgs>): Prisma.PrismaPromise<GetPropertyTypeMasterAggregateType<T>>

    /**
     * Group by PropertyTypeMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyTypeMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyTypeMasterGroupByArgs['orderBy'] }
        : { orderBy?: PropertyTypeMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyTypeMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyTypeMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyTypeMaster model
   */
  readonly fields: PropertyTypeMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyTypeMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyTypeMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    locationDetails<T extends PropertyTypeMaster$locationDetailsArgs<ExtArgs> = {}>(args?: Subset<T, PropertyTypeMaster$locationDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyTypeMaster model
   */ 
  interface PropertyTypeMasterFieldRefs {
    readonly propertyTypeId: FieldRef<"PropertyTypeMaster", 'String'>
    readonly propertyTypeName: FieldRef<"PropertyTypeMaster", 'String'>
    readonly isActive: FieldRef<"PropertyTypeMaster", 'Boolean'>
    readonly description: FieldRef<"PropertyTypeMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PropertyTypeMaster findUnique
   */
  export type PropertyTypeMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTypeMaster to fetch.
     */
    where: PropertyTypeMasterWhereUniqueInput
  }

  /**
   * PropertyTypeMaster findUniqueOrThrow
   */
  export type PropertyTypeMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTypeMaster to fetch.
     */
    where: PropertyTypeMasterWhereUniqueInput
  }

  /**
   * PropertyTypeMaster findFirst
   */
  export type PropertyTypeMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTypeMaster to fetch.
     */
    where?: PropertyTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTypeMasters to fetch.
     */
    orderBy?: PropertyTypeMasterOrderByWithRelationInput | PropertyTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyTypeMasters.
     */
    cursor?: PropertyTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyTypeMasters.
     */
    distinct?: PropertyTypeMasterScalarFieldEnum | PropertyTypeMasterScalarFieldEnum[]
  }

  /**
   * PropertyTypeMaster findFirstOrThrow
   */
  export type PropertyTypeMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTypeMaster to fetch.
     */
    where?: PropertyTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTypeMasters to fetch.
     */
    orderBy?: PropertyTypeMasterOrderByWithRelationInput | PropertyTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyTypeMasters.
     */
    cursor?: PropertyTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyTypeMasters.
     */
    distinct?: PropertyTypeMasterScalarFieldEnum | PropertyTypeMasterScalarFieldEnum[]
  }

  /**
   * PropertyTypeMaster findMany
   */
  export type PropertyTypeMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTypeMasters to fetch.
     */
    where?: PropertyTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTypeMasters to fetch.
     */
    orderBy?: PropertyTypeMasterOrderByWithRelationInput | PropertyTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyTypeMasters.
     */
    cursor?: PropertyTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTypeMasters.
     */
    skip?: number
    distinct?: PropertyTypeMasterScalarFieldEnum | PropertyTypeMasterScalarFieldEnum[]
  }

  /**
   * PropertyTypeMaster create
   */
  export type PropertyTypeMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyTypeMaster.
     */
    data: XOR<PropertyTypeMasterCreateInput, PropertyTypeMasterUncheckedCreateInput>
  }

  /**
   * PropertyTypeMaster createMany
   */
  export type PropertyTypeMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyTypeMasters.
     */
    data: PropertyTypeMasterCreateManyInput | PropertyTypeMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyTypeMaster createManyAndReturn
   */
  export type PropertyTypeMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PropertyTypeMasters.
     */
    data: PropertyTypeMasterCreateManyInput | PropertyTypeMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyTypeMaster update
   */
  export type PropertyTypeMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyTypeMaster.
     */
    data: XOR<PropertyTypeMasterUpdateInput, PropertyTypeMasterUncheckedUpdateInput>
    /**
     * Choose, which PropertyTypeMaster to update.
     */
    where: PropertyTypeMasterWhereUniqueInput
  }

  /**
   * PropertyTypeMaster updateMany
   */
  export type PropertyTypeMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyTypeMasters.
     */
    data: XOR<PropertyTypeMasterUpdateManyMutationInput, PropertyTypeMasterUncheckedUpdateManyInput>
    /**
     * Filter which PropertyTypeMasters to update
     */
    where?: PropertyTypeMasterWhereInput
  }

  /**
   * PropertyTypeMaster upsert
   */
  export type PropertyTypeMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyTypeMaster to update in case it exists.
     */
    where: PropertyTypeMasterWhereUniqueInput
    /**
     * In case the PropertyTypeMaster found by the `where` argument doesn't exist, create a new PropertyTypeMaster with this data.
     */
    create: XOR<PropertyTypeMasterCreateInput, PropertyTypeMasterUncheckedCreateInput>
    /**
     * In case the PropertyTypeMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyTypeMasterUpdateInput, PropertyTypeMasterUncheckedUpdateInput>
  }

  /**
   * PropertyTypeMaster delete
   */
  export type PropertyTypeMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter which PropertyTypeMaster to delete.
     */
    where: PropertyTypeMasterWhereUniqueInput
  }

  /**
   * PropertyTypeMaster deleteMany
   */
  export type PropertyTypeMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyTypeMasters to delete
     */
    where?: PropertyTypeMasterWhereInput
  }

  /**
   * PropertyTypeMaster.locationDetails
   */
  export type PropertyTypeMaster$locationDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    where?: LocationDetailsWhereInput
    orderBy?: LocationDetailsOrderByWithRelationInput | LocationDetailsOrderByWithRelationInput[]
    cursor?: LocationDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationDetailsScalarFieldEnum | LocationDetailsScalarFieldEnum[]
  }

  /**
   * PropertyTypeMaster without action
   */
  export type PropertyTypeMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
  }


  /**
   * Model RespondentStatusMaster
   */

  export type AggregateRespondentStatusMaster = {
    _count: RespondentStatusMasterCountAggregateOutputType | null
    _min: RespondentStatusMasterMinAggregateOutputType | null
    _max: RespondentStatusMasterMaxAggregateOutputType | null
  }

  export type RespondentStatusMasterMinAggregateOutputType = {
    respondentStatusId: string | null
    respondentStatusName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type RespondentStatusMasterMaxAggregateOutputType = {
    respondentStatusId: string | null
    respondentStatusName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type RespondentStatusMasterCountAggregateOutputType = {
    respondentStatusId: number
    respondentStatusName: number
    isActive: number
    description: number
    _all: number
  }


  export type RespondentStatusMasterMinAggregateInputType = {
    respondentStatusId?: true
    respondentStatusName?: true
    isActive?: true
    description?: true
  }

  export type RespondentStatusMasterMaxAggregateInputType = {
    respondentStatusId?: true
    respondentStatusName?: true
    isActive?: true
    description?: true
  }

  export type RespondentStatusMasterCountAggregateInputType = {
    respondentStatusId?: true
    respondentStatusName?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type RespondentStatusMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RespondentStatusMaster to aggregate.
     */
    where?: RespondentStatusMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RespondentStatusMasters to fetch.
     */
    orderBy?: RespondentStatusMasterOrderByWithRelationInput | RespondentStatusMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RespondentStatusMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RespondentStatusMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RespondentStatusMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RespondentStatusMasters
    **/
    _count?: true | RespondentStatusMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RespondentStatusMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RespondentStatusMasterMaxAggregateInputType
  }

  export type GetRespondentStatusMasterAggregateType<T extends RespondentStatusMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateRespondentStatusMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRespondentStatusMaster[P]>
      : GetScalarType<T[P], AggregateRespondentStatusMaster[P]>
  }




  export type RespondentStatusMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RespondentStatusMasterWhereInput
    orderBy?: RespondentStatusMasterOrderByWithAggregationInput | RespondentStatusMasterOrderByWithAggregationInput[]
    by: RespondentStatusMasterScalarFieldEnum[] | RespondentStatusMasterScalarFieldEnum
    having?: RespondentStatusMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RespondentStatusMasterCountAggregateInputType | true
    _min?: RespondentStatusMasterMinAggregateInputType
    _max?: RespondentStatusMasterMaxAggregateInputType
  }

  export type RespondentStatusMasterGroupByOutputType = {
    respondentStatusId: string
    respondentStatusName: string
    isActive: boolean
    description: string | null
    _count: RespondentStatusMasterCountAggregateOutputType | null
    _min: RespondentStatusMasterMinAggregateOutputType | null
    _max: RespondentStatusMasterMaxAggregateOutputType | null
  }

  type GetRespondentStatusMasterGroupByPayload<T extends RespondentStatusMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RespondentStatusMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RespondentStatusMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RespondentStatusMasterGroupByOutputType[P]>
            : GetScalarType<T[P], RespondentStatusMasterGroupByOutputType[P]>
        }
      >
    >


  export type RespondentStatusMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    respondentStatusId?: boolean
    respondentStatusName?: boolean
    isActive?: boolean
    description?: boolean
    propertyDetails?: boolean | RespondentStatusMaster$propertyDetailsArgs<ExtArgs>
    _count?: boolean | RespondentStatusMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["respondentStatusMaster"]>

  export type RespondentStatusMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    respondentStatusId?: boolean
    respondentStatusName?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["respondentStatusMaster"]>

  export type RespondentStatusMasterSelectScalar = {
    respondentStatusId?: boolean
    respondentStatusName?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type RespondentStatusMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyDetails?: boolean | RespondentStatusMaster$propertyDetailsArgs<ExtArgs>
    _count?: boolean | RespondentStatusMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RespondentStatusMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RespondentStatusMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RespondentStatusMaster"
    objects: {
      propertyDetails: Prisma.$PropertyDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      respondentStatusId: string
      respondentStatusName: string
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["respondentStatusMaster"]>
    composites: {}
  }

  type RespondentStatusMasterGetPayload<S extends boolean | null | undefined | RespondentStatusMasterDefaultArgs> = $Result.GetResult<Prisma.$RespondentStatusMasterPayload, S>

  type RespondentStatusMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RespondentStatusMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RespondentStatusMasterCountAggregateInputType | true
    }

  export interface RespondentStatusMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RespondentStatusMaster'], meta: { name: 'RespondentStatusMaster' } }
    /**
     * Find zero or one RespondentStatusMaster that matches the filter.
     * @param {RespondentStatusMasterFindUniqueArgs} args - Arguments to find a RespondentStatusMaster
     * @example
     * // Get one RespondentStatusMaster
     * const respondentStatusMaster = await prisma.respondentStatusMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RespondentStatusMasterFindUniqueArgs>(args: SelectSubset<T, RespondentStatusMasterFindUniqueArgs<ExtArgs>>): Prisma__RespondentStatusMasterClient<$Result.GetResult<Prisma.$RespondentStatusMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RespondentStatusMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RespondentStatusMasterFindUniqueOrThrowArgs} args - Arguments to find a RespondentStatusMaster
     * @example
     * // Get one RespondentStatusMaster
     * const respondentStatusMaster = await prisma.respondentStatusMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RespondentStatusMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, RespondentStatusMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RespondentStatusMasterClient<$Result.GetResult<Prisma.$RespondentStatusMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RespondentStatusMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespondentStatusMasterFindFirstArgs} args - Arguments to find a RespondentStatusMaster
     * @example
     * // Get one RespondentStatusMaster
     * const respondentStatusMaster = await prisma.respondentStatusMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RespondentStatusMasterFindFirstArgs>(args?: SelectSubset<T, RespondentStatusMasterFindFirstArgs<ExtArgs>>): Prisma__RespondentStatusMasterClient<$Result.GetResult<Prisma.$RespondentStatusMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RespondentStatusMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespondentStatusMasterFindFirstOrThrowArgs} args - Arguments to find a RespondentStatusMaster
     * @example
     * // Get one RespondentStatusMaster
     * const respondentStatusMaster = await prisma.respondentStatusMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RespondentStatusMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, RespondentStatusMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__RespondentStatusMasterClient<$Result.GetResult<Prisma.$RespondentStatusMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RespondentStatusMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespondentStatusMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RespondentStatusMasters
     * const respondentStatusMasters = await prisma.respondentStatusMaster.findMany()
     * 
     * // Get first 10 RespondentStatusMasters
     * const respondentStatusMasters = await prisma.respondentStatusMaster.findMany({ take: 10 })
     * 
     * // Only select the `respondentStatusId`
     * const respondentStatusMasterWithRespondentStatusIdOnly = await prisma.respondentStatusMaster.findMany({ select: { respondentStatusId: true } })
     * 
     */
    findMany<T extends RespondentStatusMasterFindManyArgs>(args?: SelectSubset<T, RespondentStatusMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RespondentStatusMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RespondentStatusMaster.
     * @param {RespondentStatusMasterCreateArgs} args - Arguments to create a RespondentStatusMaster.
     * @example
     * // Create one RespondentStatusMaster
     * const RespondentStatusMaster = await prisma.respondentStatusMaster.create({
     *   data: {
     *     // ... data to create a RespondentStatusMaster
     *   }
     * })
     * 
     */
    create<T extends RespondentStatusMasterCreateArgs>(args: SelectSubset<T, RespondentStatusMasterCreateArgs<ExtArgs>>): Prisma__RespondentStatusMasterClient<$Result.GetResult<Prisma.$RespondentStatusMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RespondentStatusMasters.
     * @param {RespondentStatusMasterCreateManyArgs} args - Arguments to create many RespondentStatusMasters.
     * @example
     * // Create many RespondentStatusMasters
     * const respondentStatusMaster = await prisma.respondentStatusMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RespondentStatusMasterCreateManyArgs>(args?: SelectSubset<T, RespondentStatusMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RespondentStatusMasters and returns the data saved in the database.
     * @param {RespondentStatusMasterCreateManyAndReturnArgs} args - Arguments to create many RespondentStatusMasters.
     * @example
     * // Create many RespondentStatusMasters
     * const respondentStatusMaster = await prisma.respondentStatusMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RespondentStatusMasters and only return the `respondentStatusId`
     * const respondentStatusMasterWithRespondentStatusIdOnly = await prisma.respondentStatusMaster.createManyAndReturn({ 
     *   select: { respondentStatusId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RespondentStatusMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, RespondentStatusMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RespondentStatusMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RespondentStatusMaster.
     * @param {RespondentStatusMasterDeleteArgs} args - Arguments to delete one RespondentStatusMaster.
     * @example
     * // Delete one RespondentStatusMaster
     * const RespondentStatusMaster = await prisma.respondentStatusMaster.delete({
     *   where: {
     *     // ... filter to delete one RespondentStatusMaster
     *   }
     * })
     * 
     */
    delete<T extends RespondentStatusMasterDeleteArgs>(args: SelectSubset<T, RespondentStatusMasterDeleteArgs<ExtArgs>>): Prisma__RespondentStatusMasterClient<$Result.GetResult<Prisma.$RespondentStatusMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RespondentStatusMaster.
     * @param {RespondentStatusMasterUpdateArgs} args - Arguments to update one RespondentStatusMaster.
     * @example
     * // Update one RespondentStatusMaster
     * const respondentStatusMaster = await prisma.respondentStatusMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RespondentStatusMasterUpdateArgs>(args: SelectSubset<T, RespondentStatusMasterUpdateArgs<ExtArgs>>): Prisma__RespondentStatusMasterClient<$Result.GetResult<Prisma.$RespondentStatusMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RespondentStatusMasters.
     * @param {RespondentStatusMasterDeleteManyArgs} args - Arguments to filter RespondentStatusMasters to delete.
     * @example
     * // Delete a few RespondentStatusMasters
     * const { count } = await prisma.respondentStatusMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RespondentStatusMasterDeleteManyArgs>(args?: SelectSubset<T, RespondentStatusMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RespondentStatusMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespondentStatusMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RespondentStatusMasters
     * const respondentStatusMaster = await prisma.respondentStatusMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RespondentStatusMasterUpdateManyArgs>(args: SelectSubset<T, RespondentStatusMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RespondentStatusMaster.
     * @param {RespondentStatusMasterUpsertArgs} args - Arguments to update or create a RespondentStatusMaster.
     * @example
     * // Update or create a RespondentStatusMaster
     * const respondentStatusMaster = await prisma.respondentStatusMaster.upsert({
     *   create: {
     *     // ... data to create a RespondentStatusMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RespondentStatusMaster we want to update
     *   }
     * })
     */
    upsert<T extends RespondentStatusMasterUpsertArgs>(args: SelectSubset<T, RespondentStatusMasterUpsertArgs<ExtArgs>>): Prisma__RespondentStatusMasterClient<$Result.GetResult<Prisma.$RespondentStatusMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RespondentStatusMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespondentStatusMasterCountArgs} args - Arguments to filter RespondentStatusMasters to count.
     * @example
     * // Count the number of RespondentStatusMasters
     * const count = await prisma.respondentStatusMaster.count({
     *   where: {
     *     // ... the filter for the RespondentStatusMasters we want to count
     *   }
     * })
    **/
    count<T extends RespondentStatusMasterCountArgs>(
      args?: Subset<T, RespondentStatusMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RespondentStatusMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RespondentStatusMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespondentStatusMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RespondentStatusMasterAggregateArgs>(args: Subset<T, RespondentStatusMasterAggregateArgs>): Prisma.PrismaPromise<GetRespondentStatusMasterAggregateType<T>>

    /**
     * Group by RespondentStatusMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespondentStatusMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RespondentStatusMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RespondentStatusMasterGroupByArgs['orderBy'] }
        : { orderBy?: RespondentStatusMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RespondentStatusMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRespondentStatusMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RespondentStatusMaster model
   */
  readonly fields: RespondentStatusMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RespondentStatusMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RespondentStatusMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    propertyDetails<T extends RespondentStatusMaster$propertyDetailsArgs<ExtArgs> = {}>(args?: Subset<T, RespondentStatusMaster$propertyDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RespondentStatusMaster model
   */ 
  interface RespondentStatusMasterFieldRefs {
    readonly respondentStatusId: FieldRef<"RespondentStatusMaster", 'String'>
    readonly respondentStatusName: FieldRef<"RespondentStatusMaster", 'String'>
    readonly isActive: FieldRef<"RespondentStatusMaster", 'Boolean'>
    readonly description: FieldRef<"RespondentStatusMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RespondentStatusMaster findUnique
   */
  export type RespondentStatusMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespondentStatusMaster
     */
    select?: RespondentStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespondentStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which RespondentStatusMaster to fetch.
     */
    where: RespondentStatusMasterWhereUniqueInput
  }

  /**
   * RespondentStatusMaster findUniqueOrThrow
   */
  export type RespondentStatusMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespondentStatusMaster
     */
    select?: RespondentStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespondentStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which RespondentStatusMaster to fetch.
     */
    where: RespondentStatusMasterWhereUniqueInput
  }

  /**
   * RespondentStatusMaster findFirst
   */
  export type RespondentStatusMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespondentStatusMaster
     */
    select?: RespondentStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespondentStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which RespondentStatusMaster to fetch.
     */
    where?: RespondentStatusMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RespondentStatusMasters to fetch.
     */
    orderBy?: RespondentStatusMasterOrderByWithRelationInput | RespondentStatusMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RespondentStatusMasters.
     */
    cursor?: RespondentStatusMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RespondentStatusMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RespondentStatusMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RespondentStatusMasters.
     */
    distinct?: RespondentStatusMasterScalarFieldEnum | RespondentStatusMasterScalarFieldEnum[]
  }

  /**
   * RespondentStatusMaster findFirstOrThrow
   */
  export type RespondentStatusMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespondentStatusMaster
     */
    select?: RespondentStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespondentStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which RespondentStatusMaster to fetch.
     */
    where?: RespondentStatusMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RespondentStatusMasters to fetch.
     */
    orderBy?: RespondentStatusMasterOrderByWithRelationInput | RespondentStatusMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RespondentStatusMasters.
     */
    cursor?: RespondentStatusMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RespondentStatusMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RespondentStatusMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RespondentStatusMasters.
     */
    distinct?: RespondentStatusMasterScalarFieldEnum | RespondentStatusMasterScalarFieldEnum[]
  }

  /**
   * RespondentStatusMaster findMany
   */
  export type RespondentStatusMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespondentStatusMaster
     */
    select?: RespondentStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespondentStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which RespondentStatusMasters to fetch.
     */
    where?: RespondentStatusMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RespondentStatusMasters to fetch.
     */
    orderBy?: RespondentStatusMasterOrderByWithRelationInput | RespondentStatusMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RespondentStatusMasters.
     */
    cursor?: RespondentStatusMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RespondentStatusMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RespondentStatusMasters.
     */
    skip?: number
    distinct?: RespondentStatusMasterScalarFieldEnum | RespondentStatusMasterScalarFieldEnum[]
  }

  /**
   * RespondentStatusMaster create
   */
  export type RespondentStatusMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespondentStatusMaster
     */
    select?: RespondentStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespondentStatusMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a RespondentStatusMaster.
     */
    data: XOR<RespondentStatusMasterCreateInput, RespondentStatusMasterUncheckedCreateInput>
  }

  /**
   * RespondentStatusMaster createMany
   */
  export type RespondentStatusMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RespondentStatusMasters.
     */
    data: RespondentStatusMasterCreateManyInput | RespondentStatusMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RespondentStatusMaster createManyAndReturn
   */
  export type RespondentStatusMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespondentStatusMaster
     */
    select?: RespondentStatusMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RespondentStatusMasters.
     */
    data: RespondentStatusMasterCreateManyInput | RespondentStatusMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RespondentStatusMaster update
   */
  export type RespondentStatusMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespondentStatusMaster
     */
    select?: RespondentStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespondentStatusMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a RespondentStatusMaster.
     */
    data: XOR<RespondentStatusMasterUpdateInput, RespondentStatusMasterUncheckedUpdateInput>
    /**
     * Choose, which RespondentStatusMaster to update.
     */
    where: RespondentStatusMasterWhereUniqueInput
  }

  /**
   * RespondentStatusMaster updateMany
   */
  export type RespondentStatusMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RespondentStatusMasters.
     */
    data: XOR<RespondentStatusMasterUpdateManyMutationInput, RespondentStatusMasterUncheckedUpdateManyInput>
    /**
     * Filter which RespondentStatusMasters to update
     */
    where?: RespondentStatusMasterWhereInput
  }

  /**
   * RespondentStatusMaster upsert
   */
  export type RespondentStatusMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespondentStatusMaster
     */
    select?: RespondentStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespondentStatusMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the RespondentStatusMaster to update in case it exists.
     */
    where: RespondentStatusMasterWhereUniqueInput
    /**
     * In case the RespondentStatusMaster found by the `where` argument doesn't exist, create a new RespondentStatusMaster with this data.
     */
    create: XOR<RespondentStatusMasterCreateInput, RespondentStatusMasterUncheckedCreateInput>
    /**
     * In case the RespondentStatusMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RespondentStatusMasterUpdateInput, RespondentStatusMasterUncheckedUpdateInput>
  }

  /**
   * RespondentStatusMaster delete
   */
  export type RespondentStatusMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespondentStatusMaster
     */
    select?: RespondentStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespondentStatusMasterInclude<ExtArgs> | null
    /**
     * Filter which RespondentStatusMaster to delete.
     */
    where: RespondentStatusMasterWhereUniqueInput
  }

  /**
   * RespondentStatusMaster deleteMany
   */
  export type RespondentStatusMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RespondentStatusMasters to delete
     */
    where?: RespondentStatusMasterWhereInput
  }

  /**
   * RespondentStatusMaster.propertyDetails
   */
  export type RespondentStatusMaster$propertyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    where?: PropertyDetailsWhereInput
    orderBy?: PropertyDetailsOrderByWithRelationInput | PropertyDetailsOrderByWithRelationInput[]
    cursor?: PropertyDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyDetailsScalarFieldEnum | PropertyDetailsScalarFieldEnum[]
  }

  /**
   * RespondentStatusMaster without action
   */
  export type RespondentStatusMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespondentStatusMaster
     */
    select?: RespondentStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespondentStatusMasterInclude<ExtArgs> | null
  }


  /**
   * Model RoadTypeMaster
   */

  export type AggregateRoadTypeMaster = {
    _count: RoadTypeMasterCountAggregateOutputType | null
    _min: RoadTypeMasterMinAggregateOutputType | null
    _max: RoadTypeMasterMaxAggregateOutputType | null
  }

  export type RoadTypeMasterMinAggregateOutputType = {
    roadTypeId: string | null
    roadTypeName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type RoadTypeMasterMaxAggregateOutputType = {
    roadTypeId: string | null
    roadTypeName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type RoadTypeMasterCountAggregateOutputType = {
    roadTypeId: number
    roadTypeName: number
    isActive: number
    description: number
    _all: number
  }


  export type RoadTypeMasterMinAggregateInputType = {
    roadTypeId?: true
    roadTypeName?: true
    isActive?: true
    description?: true
  }

  export type RoadTypeMasterMaxAggregateInputType = {
    roadTypeId?: true
    roadTypeName?: true
    isActive?: true
    description?: true
  }

  export type RoadTypeMasterCountAggregateInputType = {
    roadTypeId?: true
    roadTypeName?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type RoadTypeMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadTypeMaster to aggregate.
     */
    where?: RoadTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadTypeMasters to fetch.
     */
    orderBy?: RoadTypeMasterOrderByWithRelationInput | RoadTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoadTypeMasters
    **/
    _count?: true | RoadTypeMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadTypeMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadTypeMasterMaxAggregateInputType
  }

  export type GetRoadTypeMasterAggregateType<T extends RoadTypeMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadTypeMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadTypeMaster[P]>
      : GetScalarType<T[P], AggregateRoadTypeMaster[P]>
  }




  export type RoadTypeMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadTypeMasterWhereInput
    orderBy?: RoadTypeMasterOrderByWithAggregationInput | RoadTypeMasterOrderByWithAggregationInput[]
    by: RoadTypeMasterScalarFieldEnum[] | RoadTypeMasterScalarFieldEnum
    having?: RoadTypeMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadTypeMasterCountAggregateInputType | true
    _min?: RoadTypeMasterMinAggregateInputType
    _max?: RoadTypeMasterMaxAggregateInputType
  }

  export type RoadTypeMasterGroupByOutputType = {
    roadTypeId: string
    roadTypeName: string
    isActive: boolean
    description: string | null
    _count: RoadTypeMasterCountAggregateOutputType | null
    _min: RoadTypeMasterMinAggregateOutputType | null
    _max: RoadTypeMasterMaxAggregateOutputType | null
  }

  type GetRoadTypeMasterGroupByPayload<T extends RoadTypeMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadTypeMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadTypeMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadTypeMasterGroupByOutputType[P]>
            : GetScalarType<T[P], RoadTypeMasterGroupByOutputType[P]>
        }
      >
    >


  export type RoadTypeMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roadTypeId?: boolean
    roadTypeName?: boolean
    isActive?: boolean
    description?: boolean
    locationDetails?: boolean | RoadTypeMaster$locationDetailsArgs<ExtArgs>
    _count?: boolean | RoadTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadTypeMaster"]>

  export type RoadTypeMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roadTypeId?: boolean
    roadTypeName?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["roadTypeMaster"]>

  export type RoadTypeMasterSelectScalar = {
    roadTypeId?: boolean
    roadTypeName?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type RoadTypeMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locationDetails?: boolean | RoadTypeMaster$locationDetailsArgs<ExtArgs>
    _count?: boolean | RoadTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoadTypeMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RoadTypeMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoadTypeMaster"
    objects: {
      locationDetails: Prisma.$LocationDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      roadTypeId: string
      roadTypeName: string
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["roadTypeMaster"]>
    composites: {}
  }

  type RoadTypeMasterGetPayload<S extends boolean | null | undefined | RoadTypeMasterDefaultArgs> = $Result.GetResult<Prisma.$RoadTypeMasterPayload, S>

  type RoadTypeMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoadTypeMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoadTypeMasterCountAggregateInputType | true
    }

  export interface RoadTypeMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoadTypeMaster'], meta: { name: 'RoadTypeMaster' } }
    /**
     * Find zero or one RoadTypeMaster that matches the filter.
     * @param {RoadTypeMasterFindUniqueArgs} args - Arguments to find a RoadTypeMaster
     * @example
     * // Get one RoadTypeMaster
     * const roadTypeMaster = await prisma.roadTypeMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadTypeMasterFindUniqueArgs>(args: SelectSubset<T, RoadTypeMasterFindUniqueArgs<ExtArgs>>): Prisma__RoadTypeMasterClient<$Result.GetResult<Prisma.$RoadTypeMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoadTypeMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoadTypeMasterFindUniqueOrThrowArgs} args - Arguments to find a RoadTypeMaster
     * @example
     * // Get one RoadTypeMaster
     * const roadTypeMaster = await prisma.roadTypeMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadTypeMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadTypeMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadTypeMasterClient<$Result.GetResult<Prisma.$RoadTypeMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoadTypeMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadTypeMasterFindFirstArgs} args - Arguments to find a RoadTypeMaster
     * @example
     * // Get one RoadTypeMaster
     * const roadTypeMaster = await prisma.roadTypeMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadTypeMasterFindFirstArgs>(args?: SelectSubset<T, RoadTypeMasterFindFirstArgs<ExtArgs>>): Prisma__RoadTypeMasterClient<$Result.GetResult<Prisma.$RoadTypeMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoadTypeMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadTypeMasterFindFirstOrThrowArgs} args - Arguments to find a RoadTypeMaster
     * @example
     * // Get one RoadTypeMaster
     * const roadTypeMaster = await prisma.roadTypeMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadTypeMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadTypeMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadTypeMasterClient<$Result.GetResult<Prisma.$RoadTypeMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoadTypeMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadTypeMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoadTypeMasters
     * const roadTypeMasters = await prisma.roadTypeMaster.findMany()
     * 
     * // Get first 10 RoadTypeMasters
     * const roadTypeMasters = await prisma.roadTypeMaster.findMany({ take: 10 })
     * 
     * // Only select the `roadTypeId`
     * const roadTypeMasterWithRoadTypeIdOnly = await prisma.roadTypeMaster.findMany({ select: { roadTypeId: true } })
     * 
     */
    findMany<T extends RoadTypeMasterFindManyArgs>(args?: SelectSubset<T, RoadTypeMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadTypeMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoadTypeMaster.
     * @param {RoadTypeMasterCreateArgs} args - Arguments to create a RoadTypeMaster.
     * @example
     * // Create one RoadTypeMaster
     * const RoadTypeMaster = await prisma.roadTypeMaster.create({
     *   data: {
     *     // ... data to create a RoadTypeMaster
     *   }
     * })
     * 
     */
    create<T extends RoadTypeMasterCreateArgs>(args: SelectSubset<T, RoadTypeMasterCreateArgs<ExtArgs>>): Prisma__RoadTypeMasterClient<$Result.GetResult<Prisma.$RoadTypeMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoadTypeMasters.
     * @param {RoadTypeMasterCreateManyArgs} args - Arguments to create many RoadTypeMasters.
     * @example
     * // Create many RoadTypeMasters
     * const roadTypeMaster = await prisma.roadTypeMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadTypeMasterCreateManyArgs>(args?: SelectSubset<T, RoadTypeMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoadTypeMasters and returns the data saved in the database.
     * @param {RoadTypeMasterCreateManyAndReturnArgs} args - Arguments to create many RoadTypeMasters.
     * @example
     * // Create many RoadTypeMasters
     * const roadTypeMaster = await prisma.roadTypeMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoadTypeMasters and only return the `roadTypeId`
     * const roadTypeMasterWithRoadTypeIdOnly = await prisma.roadTypeMaster.createManyAndReturn({ 
     *   select: { roadTypeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoadTypeMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, RoadTypeMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadTypeMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoadTypeMaster.
     * @param {RoadTypeMasterDeleteArgs} args - Arguments to delete one RoadTypeMaster.
     * @example
     * // Delete one RoadTypeMaster
     * const RoadTypeMaster = await prisma.roadTypeMaster.delete({
     *   where: {
     *     // ... filter to delete one RoadTypeMaster
     *   }
     * })
     * 
     */
    delete<T extends RoadTypeMasterDeleteArgs>(args: SelectSubset<T, RoadTypeMasterDeleteArgs<ExtArgs>>): Prisma__RoadTypeMasterClient<$Result.GetResult<Prisma.$RoadTypeMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoadTypeMaster.
     * @param {RoadTypeMasterUpdateArgs} args - Arguments to update one RoadTypeMaster.
     * @example
     * // Update one RoadTypeMaster
     * const roadTypeMaster = await prisma.roadTypeMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadTypeMasterUpdateArgs>(args: SelectSubset<T, RoadTypeMasterUpdateArgs<ExtArgs>>): Prisma__RoadTypeMasterClient<$Result.GetResult<Prisma.$RoadTypeMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoadTypeMasters.
     * @param {RoadTypeMasterDeleteManyArgs} args - Arguments to filter RoadTypeMasters to delete.
     * @example
     * // Delete a few RoadTypeMasters
     * const { count } = await prisma.roadTypeMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadTypeMasterDeleteManyArgs>(args?: SelectSubset<T, RoadTypeMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoadTypeMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadTypeMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoadTypeMasters
     * const roadTypeMaster = await prisma.roadTypeMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadTypeMasterUpdateManyArgs>(args: SelectSubset<T, RoadTypeMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoadTypeMaster.
     * @param {RoadTypeMasterUpsertArgs} args - Arguments to update or create a RoadTypeMaster.
     * @example
     * // Update or create a RoadTypeMaster
     * const roadTypeMaster = await prisma.roadTypeMaster.upsert({
     *   create: {
     *     // ... data to create a RoadTypeMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoadTypeMaster we want to update
     *   }
     * })
     */
    upsert<T extends RoadTypeMasterUpsertArgs>(args: SelectSubset<T, RoadTypeMasterUpsertArgs<ExtArgs>>): Prisma__RoadTypeMasterClient<$Result.GetResult<Prisma.$RoadTypeMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoadTypeMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadTypeMasterCountArgs} args - Arguments to filter RoadTypeMasters to count.
     * @example
     * // Count the number of RoadTypeMasters
     * const count = await prisma.roadTypeMaster.count({
     *   where: {
     *     // ... the filter for the RoadTypeMasters we want to count
     *   }
     * })
    **/
    count<T extends RoadTypeMasterCountArgs>(
      args?: Subset<T, RoadTypeMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadTypeMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoadTypeMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadTypeMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadTypeMasterAggregateArgs>(args: Subset<T, RoadTypeMasterAggregateArgs>): Prisma.PrismaPromise<GetRoadTypeMasterAggregateType<T>>

    /**
     * Group by RoadTypeMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadTypeMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadTypeMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadTypeMasterGroupByArgs['orderBy'] }
        : { orderBy?: RoadTypeMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadTypeMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadTypeMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoadTypeMaster model
   */
  readonly fields: RoadTypeMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoadTypeMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadTypeMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    locationDetails<T extends RoadTypeMaster$locationDetailsArgs<ExtArgs> = {}>(args?: Subset<T, RoadTypeMaster$locationDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoadTypeMaster model
   */ 
  interface RoadTypeMasterFieldRefs {
    readonly roadTypeId: FieldRef<"RoadTypeMaster", 'String'>
    readonly roadTypeName: FieldRef<"RoadTypeMaster", 'String'>
    readonly isActive: FieldRef<"RoadTypeMaster", 'Boolean'>
    readonly description: FieldRef<"RoadTypeMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RoadTypeMaster findUnique
   */
  export type RoadTypeMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMaster
     */
    select?: RoadTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which RoadTypeMaster to fetch.
     */
    where: RoadTypeMasterWhereUniqueInput
  }

  /**
   * RoadTypeMaster findUniqueOrThrow
   */
  export type RoadTypeMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMaster
     */
    select?: RoadTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which RoadTypeMaster to fetch.
     */
    where: RoadTypeMasterWhereUniqueInput
  }

  /**
   * RoadTypeMaster findFirst
   */
  export type RoadTypeMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMaster
     */
    select?: RoadTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which RoadTypeMaster to fetch.
     */
    where?: RoadTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadTypeMasters to fetch.
     */
    orderBy?: RoadTypeMasterOrderByWithRelationInput | RoadTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadTypeMasters.
     */
    cursor?: RoadTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadTypeMasters.
     */
    distinct?: RoadTypeMasterScalarFieldEnum | RoadTypeMasterScalarFieldEnum[]
  }

  /**
   * RoadTypeMaster findFirstOrThrow
   */
  export type RoadTypeMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMaster
     */
    select?: RoadTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which RoadTypeMaster to fetch.
     */
    where?: RoadTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadTypeMasters to fetch.
     */
    orderBy?: RoadTypeMasterOrderByWithRelationInput | RoadTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadTypeMasters.
     */
    cursor?: RoadTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadTypeMasters.
     */
    distinct?: RoadTypeMasterScalarFieldEnum | RoadTypeMasterScalarFieldEnum[]
  }

  /**
   * RoadTypeMaster findMany
   */
  export type RoadTypeMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMaster
     */
    select?: RoadTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which RoadTypeMasters to fetch.
     */
    where?: RoadTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadTypeMasters to fetch.
     */
    orderBy?: RoadTypeMasterOrderByWithRelationInput | RoadTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoadTypeMasters.
     */
    cursor?: RoadTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadTypeMasters.
     */
    skip?: number
    distinct?: RoadTypeMasterScalarFieldEnum | RoadTypeMasterScalarFieldEnum[]
  }

  /**
   * RoadTypeMaster create
   */
  export type RoadTypeMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMaster
     */
    select?: RoadTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a RoadTypeMaster.
     */
    data: XOR<RoadTypeMasterCreateInput, RoadTypeMasterUncheckedCreateInput>
  }

  /**
   * RoadTypeMaster createMany
   */
  export type RoadTypeMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoadTypeMasters.
     */
    data: RoadTypeMasterCreateManyInput | RoadTypeMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoadTypeMaster createManyAndReturn
   */
  export type RoadTypeMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMaster
     */
    select?: RoadTypeMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoadTypeMasters.
     */
    data: RoadTypeMasterCreateManyInput | RoadTypeMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoadTypeMaster update
   */
  export type RoadTypeMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMaster
     */
    select?: RoadTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a RoadTypeMaster.
     */
    data: XOR<RoadTypeMasterUpdateInput, RoadTypeMasterUncheckedUpdateInput>
    /**
     * Choose, which RoadTypeMaster to update.
     */
    where: RoadTypeMasterWhereUniqueInput
  }

  /**
   * RoadTypeMaster updateMany
   */
  export type RoadTypeMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoadTypeMasters.
     */
    data: XOR<RoadTypeMasterUpdateManyMutationInput, RoadTypeMasterUncheckedUpdateManyInput>
    /**
     * Filter which RoadTypeMasters to update
     */
    where?: RoadTypeMasterWhereInput
  }

  /**
   * RoadTypeMaster upsert
   */
  export type RoadTypeMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMaster
     */
    select?: RoadTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the RoadTypeMaster to update in case it exists.
     */
    where: RoadTypeMasterWhereUniqueInput
    /**
     * In case the RoadTypeMaster found by the `where` argument doesn't exist, create a new RoadTypeMaster with this data.
     */
    create: XOR<RoadTypeMasterCreateInput, RoadTypeMasterUncheckedCreateInput>
    /**
     * In case the RoadTypeMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadTypeMasterUpdateInput, RoadTypeMasterUncheckedUpdateInput>
  }

  /**
   * RoadTypeMaster delete
   */
  export type RoadTypeMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMaster
     */
    select?: RoadTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMasterInclude<ExtArgs> | null
    /**
     * Filter which RoadTypeMaster to delete.
     */
    where: RoadTypeMasterWhereUniqueInput
  }

  /**
   * RoadTypeMaster deleteMany
   */
  export type RoadTypeMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadTypeMasters to delete
     */
    where?: RoadTypeMasterWhereInput
  }

  /**
   * RoadTypeMaster.locationDetails
   */
  export type RoadTypeMaster$locationDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    where?: LocationDetailsWhereInput
    orderBy?: LocationDetailsOrderByWithRelationInput | LocationDetailsOrderByWithRelationInput[]
    cursor?: LocationDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationDetailsScalarFieldEnum | LocationDetailsScalarFieldEnum[]
  }

  /**
   * RoadTypeMaster without action
   */
  export type RoadTypeMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMaster
     */
    select?: RoadTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMasterInclude<ExtArgs> | null
  }


  /**
   * Model ConstructionTypeMaster
   */

  export type AggregateConstructionTypeMaster = {
    _count: ConstructionTypeMasterCountAggregateOutputType | null
    _min: ConstructionTypeMasterMinAggregateOutputType | null
    _max: ConstructionTypeMasterMaxAggregateOutputType | null
  }

  export type ConstructionTypeMasterMinAggregateOutputType = {
    constructionTypeId: string | null
    constructionTypeName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type ConstructionTypeMasterMaxAggregateOutputType = {
    constructionTypeId: string | null
    constructionTypeName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type ConstructionTypeMasterCountAggregateOutputType = {
    constructionTypeId: number
    constructionTypeName: number
    isActive: number
    description: number
    _all: number
  }


  export type ConstructionTypeMasterMinAggregateInputType = {
    constructionTypeId?: true
    constructionTypeName?: true
    isActive?: true
    description?: true
  }

  export type ConstructionTypeMasterMaxAggregateInputType = {
    constructionTypeId?: true
    constructionTypeName?: true
    isActive?: true
    description?: true
  }

  export type ConstructionTypeMasterCountAggregateInputType = {
    constructionTypeId?: true
    constructionTypeName?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type ConstructionTypeMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConstructionTypeMaster to aggregate.
     */
    where?: ConstructionTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionTypeMasters to fetch.
     */
    orderBy?: ConstructionTypeMasterOrderByWithRelationInput | ConstructionTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConstructionTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConstructionTypeMasters
    **/
    _count?: true | ConstructionTypeMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConstructionTypeMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConstructionTypeMasterMaxAggregateInputType
  }

  export type GetConstructionTypeMasterAggregateType<T extends ConstructionTypeMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateConstructionTypeMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConstructionTypeMaster[P]>
      : GetScalarType<T[P], AggregateConstructionTypeMaster[P]>
  }




  export type ConstructionTypeMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConstructionTypeMasterWhereInput
    orderBy?: ConstructionTypeMasterOrderByWithAggregationInput | ConstructionTypeMasterOrderByWithAggregationInput[]
    by: ConstructionTypeMasterScalarFieldEnum[] | ConstructionTypeMasterScalarFieldEnum
    having?: ConstructionTypeMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConstructionTypeMasterCountAggregateInputType | true
    _min?: ConstructionTypeMasterMinAggregateInputType
    _max?: ConstructionTypeMasterMaxAggregateInputType
  }

  export type ConstructionTypeMasterGroupByOutputType = {
    constructionTypeId: string
    constructionTypeName: string
    isActive: boolean
    description: string | null
    _count: ConstructionTypeMasterCountAggregateOutputType | null
    _min: ConstructionTypeMasterMinAggregateOutputType | null
    _max: ConstructionTypeMasterMaxAggregateOutputType | null
  }

  type GetConstructionTypeMasterGroupByPayload<T extends ConstructionTypeMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConstructionTypeMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConstructionTypeMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConstructionTypeMasterGroupByOutputType[P]>
            : GetScalarType<T[P], ConstructionTypeMasterGroupByOutputType[P]>
        }
      >
    >


  export type ConstructionTypeMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    constructionTypeId?: boolean
    constructionTypeName?: boolean
    isActive?: boolean
    description?: boolean
    locationDetails?: boolean | ConstructionTypeMaster$locationDetailsArgs<ExtArgs>
    _count?: boolean | ConstructionTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["constructionTypeMaster"]>

  export type ConstructionTypeMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    constructionTypeId?: boolean
    constructionTypeName?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["constructionTypeMaster"]>

  export type ConstructionTypeMasterSelectScalar = {
    constructionTypeId?: boolean
    constructionTypeName?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type ConstructionTypeMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locationDetails?: boolean | ConstructionTypeMaster$locationDetailsArgs<ExtArgs>
    _count?: boolean | ConstructionTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConstructionTypeMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ConstructionTypeMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConstructionTypeMaster"
    objects: {
      locationDetails: Prisma.$LocationDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      constructionTypeId: string
      constructionTypeName: string
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["constructionTypeMaster"]>
    composites: {}
  }

  type ConstructionTypeMasterGetPayload<S extends boolean | null | undefined | ConstructionTypeMasterDefaultArgs> = $Result.GetResult<Prisma.$ConstructionTypeMasterPayload, S>

  type ConstructionTypeMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConstructionTypeMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConstructionTypeMasterCountAggregateInputType | true
    }

  export interface ConstructionTypeMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConstructionTypeMaster'], meta: { name: 'ConstructionTypeMaster' } }
    /**
     * Find zero or one ConstructionTypeMaster that matches the filter.
     * @param {ConstructionTypeMasterFindUniqueArgs} args - Arguments to find a ConstructionTypeMaster
     * @example
     * // Get one ConstructionTypeMaster
     * const constructionTypeMaster = await prisma.constructionTypeMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConstructionTypeMasterFindUniqueArgs>(args: SelectSubset<T, ConstructionTypeMasterFindUniqueArgs<ExtArgs>>): Prisma__ConstructionTypeMasterClient<$Result.GetResult<Prisma.$ConstructionTypeMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConstructionTypeMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConstructionTypeMasterFindUniqueOrThrowArgs} args - Arguments to find a ConstructionTypeMaster
     * @example
     * // Get one ConstructionTypeMaster
     * const constructionTypeMaster = await prisma.constructionTypeMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConstructionTypeMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, ConstructionTypeMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConstructionTypeMasterClient<$Result.GetResult<Prisma.$ConstructionTypeMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConstructionTypeMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTypeMasterFindFirstArgs} args - Arguments to find a ConstructionTypeMaster
     * @example
     * // Get one ConstructionTypeMaster
     * const constructionTypeMaster = await prisma.constructionTypeMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConstructionTypeMasterFindFirstArgs>(args?: SelectSubset<T, ConstructionTypeMasterFindFirstArgs<ExtArgs>>): Prisma__ConstructionTypeMasterClient<$Result.GetResult<Prisma.$ConstructionTypeMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConstructionTypeMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTypeMasterFindFirstOrThrowArgs} args - Arguments to find a ConstructionTypeMaster
     * @example
     * // Get one ConstructionTypeMaster
     * const constructionTypeMaster = await prisma.constructionTypeMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConstructionTypeMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, ConstructionTypeMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConstructionTypeMasterClient<$Result.GetResult<Prisma.$ConstructionTypeMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConstructionTypeMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTypeMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConstructionTypeMasters
     * const constructionTypeMasters = await prisma.constructionTypeMaster.findMany()
     * 
     * // Get first 10 ConstructionTypeMasters
     * const constructionTypeMasters = await prisma.constructionTypeMaster.findMany({ take: 10 })
     * 
     * // Only select the `constructionTypeId`
     * const constructionTypeMasterWithConstructionTypeIdOnly = await prisma.constructionTypeMaster.findMany({ select: { constructionTypeId: true } })
     * 
     */
    findMany<T extends ConstructionTypeMasterFindManyArgs>(args?: SelectSubset<T, ConstructionTypeMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionTypeMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConstructionTypeMaster.
     * @param {ConstructionTypeMasterCreateArgs} args - Arguments to create a ConstructionTypeMaster.
     * @example
     * // Create one ConstructionTypeMaster
     * const ConstructionTypeMaster = await prisma.constructionTypeMaster.create({
     *   data: {
     *     // ... data to create a ConstructionTypeMaster
     *   }
     * })
     * 
     */
    create<T extends ConstructionTypeMasterCreateArgs>(args: SelectSubset<T, ConstructionTypeMasterCreateArgs<ExtArgs>>): Prisma__ConstructionTypeMasterClient<$Result.GetResult<Prisma.$ConstructionTypeMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConstructionTypeMasters.
     * @param {ConstructionTypeMasterCreateManyArgs} args - Arguments to create many ConstructionTypeMasters.
     * @example
     * // Create many ConstructionTypeMasters
     * const constructionTypeMaster = await prisma.constructionTypeMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConstructionTypeMasterCreateManyArgs>(args?: SelectSubset<T, ConstructionTypeMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConstructionTypeMasters and returns the data saved in the database.
     * @param {ConstructionTypeMasterCreateManyAndReturnArgs} args - Arguments to create many ConstructionTypeMasters.
     * @example
     * // Create many ConstructionTypeMasters
     * const constructionTypeMaster = await prisma.constructionTypeMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConstructionTypeMasters and only return the `constructionTypeId`
     * const constructionTypeMasterWithConstructionTypeIdOnly = await prisma.constructionTypeMaster.createManyAndReturn({ 
     *   select: { constructionTypeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConstructionTypeMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, ConstructionTypeMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionTypeMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConstructionTypeMaster.
     * @param {ConstructionTypeMasterDeleteArgs} args - Arguments to delete one ConstructionTypeMaster.
     * @example
     * // Delete one ConstructionTypeMaster
     * const ConstructionTypeMaster = await prisma.constructionTypeMaster.delete({
     *   where: {
     *     // ... filter to delete one ConstructionTypeMaster
     *   }
     * })
     * 
     */
    delete<T extends ConstructionTypeMasterDeleteArgs>(args: SelectSubset<T, ConstructionTypeMasterDeleteArgs<ExtArgs>>): Prisma__ConstructionTypeMasterClient<$Result.GetResult<Prisma.$ConstructionTypeMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConstructionTypeMaster.
     * @param {ConstructionTypeMasterUpdateArgs} args - Arguments to update one ConstructionTypeMaster.
     * @example
     * // Update one ConstructionTypeMaster
     * const constructionTypeMaster = await prisma.constructionTypeMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConstructionTypeMasterUpdateArgs>(args: SelectSubset<T, ConstructionTypeMasterUpdateArgs<ExtArgs>>): Prisma__ConstructionTypeMasterClient<$Result.GetResult<Prisma.$ConstructionTypeMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConstructionTypeMasters.
     * @param {ConstructionTypeMasterDeleteManyArgs} args - Arguments to filter ConstructionTypeMasters to delete.
     * @example
     * // Delete a few ConstructionTypeMasters
     * const { count } = await prisma.constructionTypeMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConstructionTypeMasterDeleteManyArgs>(args?: SelectSubset<T, ConstructionTypeMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConstructionTypeMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTypeMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConstructionTypeMasters
     * const constructionTypeMaster = await prisma.constructionTypeMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConstructionTypeMasterUpdateManyArgs>(args: SelectSubset<T, ConstructionTypeMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConstructionTypeMaster.
     * @param {ConstructionTypeMasterUpsertArgs} args - Arguments to update or create a ConstructionTypeMaster.
     * @example
     * // Update or create a ConstructionTypeMaster
     * const constructionTypeMaster = await prisma.constructionTypeMaster.upsert({
     *   create: {
     *     // ... data to create a ConstructionTypeMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConstructionTypeMaster we want to update
     *   }
     * })
     */
    upsert<T extends ConstructionTypeMasterUpsertArgs>(args: SelectSubset<T, ConstructionTypeMasterUpsertArgs<ExtArgs>>): Prisma__ConstructionTypeMasterClient<$Result.GetResult<Prisma.$ConstructionTypeMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConstructionTypeMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTypeMasterCountArgs} args - Arguments to filter ConstructionTypeMasters to count.
     * @example
     * // Count the number of ConstructionTypeMasters
     * const count = await prisma.constructionTypeMaster.count({
     *   where: {
     *     // ... the filter for the ConstructionTypeMasters we want to count
     *   }
     * })
    **/
    count<T extends ConstructionTypeMasterCountArgs>(
      args?: Subset<T, ConstructionTypeMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConstructionTypeMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConstructionTypeMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTypeMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConstructionTypeMasterAggregateArgs>(args: Subset<T, ConstructionTypeMasterAggregateArgs>): Prisma.PrismaPromise<GetConstructionTypeMasterAggregateType<T>>

    /**
     * Group by ConstructionTypeMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTypeMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConstructionTypeMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConstructionTypeMasterGroupByArgs['orderBy'] }
        : { orderBy?: ConstructionTypeMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConstructionTypeMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConstructionTypeMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConstructionTypeMaster model
   */
  readonly fields: ConstructionTypeMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConstructionTypeMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConstructionTypeMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    locationDetails<T extends ConstructionTypeMaster$locationDetailsArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionTypeMaster$locationDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConstructionTypeMaster model
   */ 
  interface ConstructionTypeMasterFieldRefs {
    readonly constructionTypeId: FieldRef<"ConstructionTypeMaster", 'String'>
    readonly constructionTypeName: FieldRef<"ConstructionTypeMaster", 'String'>
    readonly isActive: FieldRef<"ConstructionTypeMaster", 'Boolean'>
    readonly description: FieldRef<"ConstructionTypeMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConstructionTypeMaster findUnique
   */
  export type ConstructionTypeMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMaster
     */
    select?: ConstructionTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionTypeMaster to fetch.
     */
    where: ConstructionTypeMasterWhereUniqueInput
  }

  /**
   * ConstructionTypeMaster findUniqueOrThrow
   */
  export type ConstructionTypeMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMaster
     */
    select?: ConstructionTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionTypeMaster to fetch.
     */
    where: ConstructionTypeMasterWhereUniqueInput
  }

  /**
   * ConstructionTypeMaster findFirst
   */
  export type ConstructionTypeMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMaster
     */
    select?: ConstructionTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionTypeMaster to fetch.
     */
    where?: ConstructionTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionTypeMasters to fetch.
     */
    orderBy?: ConstructionTypeMasterOrderByWithRelationInput | ConstructionTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConstructionTypeMasters.
     */
    cursor?: ConstructionTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConstructionTypeMasters.
     */
    distinct?: ConstructionTypeMasterScalarFieldEnum | ConstructionTypeMasterScalarFieldEnum[]
  }

  /**
   * ConstructionTypeMaster findFirstOrThrow
   */
  export type ConstructionTypeMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMaster
     */
    select?: ConstructionTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionTypeMaster to fetch.
     */
    where?: ConstructionTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionTypeMasters to fetch.
     */
    orderBy?: ConstructionTypeMasterOrderByWithRelationInput | ConstructionTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConstructionTypeMasters.
     */
    cursor?: ConstructionTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConstructionTypeMasters.
     */
    distinct?: ConstructionTypeMasterScalarFieldEnum | ConstructionTypeMasterScalarFieldEnum[]
  }

  /**
   * ConstructionTypeMaster findMany
   */
  export type ConstructionTypeMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMaster
     */
    select?: ConstructionTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionTypeMasters to fetch.
     */
    where?: ConstructionTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionTypeMasters to fetch.
     */
    orderBy?: ConstructionTypeMasterOrderByWithRelationInput | ConstructionTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConstructionTypeMasters.
     */
    cursor?: ConstructionTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionTypeMasters.
     */
    skip?: number
    distinct?: ConstructionTypeMasterScalarFieldEnum | ConstructionTypeMasterScalarFieldEnum[]
  }

  /**
   * ConstructionTypeMaster create
   */
  export type ConstructionTypeMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMaster
     */
    select?: ConstructionTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a ConstructionTypeMaster.
     */
    data: XOR<ConstructionTypeMasterCreateInput, ConstructionTypeMasterUncheckedCreateInput>
  }

  /**
   * ConstructionTypeMaster createMany
   */
  export type ConstructionTypeMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConstructionTypeMasters.
     */
    data: ConstructionTypeMasterCreateManyInput | ConstructionTypeMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConstructionTypeMaster createManyAndReturn
   */
  export type ConstructionTypeMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMaster
     */
    select?: ConstructionTypeMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConstructionTypeMasters.
     */
    data: ConstructionTypeMasterCreateManyInput | ConstructionTypeMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConstructionTypeMaster update
   */
  export type ConstructionTypeMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMaster
     */
    select?: ConstructionTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a ConstructionTypeMaster.
     */
    data: XOR<ConstructionTypeMasterUpdateInput, ConstructionTypeMasterUncheckedUpdateInput>
    /**
     * Choose, which ConstructionTypeMaster to update.
     */
    where: ConstructionTypeMasterWhereUniqueInput
  }

  /**
   * ConstructionTypeMaster updateMany
   */
  export type ConstructionTypeMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConstructionTypeMasters.
     */
    data: XOR<ConstructionTypeMasterUpdateManyMutationInput, ConstructionTypeMasterUncheckedUpdateManyInput>
    /**
     * Filter which ConstructionTypeMasters to update
     */
    where?: ConstructionTypeMasterWhereInput
  }

  /**
   * ConstructionTypeMaster upsert
   */
  export type ConstructionTypeMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMaster
     */
    select?: ConstructionTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the ConstructionTypeMaster to update in case it exists.
     */
    where: ConstructionTypeMasterWhereUniqueInput
    /**
     * In case the ConstructionTypeMaster found by the `where` argument doesn't exist, create a new ConstructionTypeMaster with this data.
     */
    create: XOR<ConstructionTypeMasterCreateInput, ConstructionTypeMasterUncheckedCreateInput>
    /**
     * In case the ConstructionTypeMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConstructionTypeMasterUpdateInput, ConstructionTypeMasterUncheckedUpdateInput>
  }

  /**
   * ConstructionTypeMaster delete
   */
  export type ConstructionTypeMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMaster
     */
    select?: ConstructionTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMasterInclude<ExtArgs> | null
    /**
     * Filter which ConstructionTypeMaster to delete.
     */
    where: ConstructionTypeMasterWhereUniqueInput
  }

  /**
   * ConstructionTypeMaster deleteMany
   */
  export type ConstructionTypeMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConstructionTypeMasters to delete
     */
    where?: ConstructionTypeMasterWhereInput
  }

  /**
   * ConstructionTypeMaster.locationDetails
   */
  export type ConstructionTypeMaster$locationDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    where?: LocationDetailsWhereInput
    orderBy?: LocationDetailsOrderByWithRelationInput | LocationDetailsOrderByWithRelationInput[]
    cursor?: LocationDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationDetailsScalarFieldEnum | LocationDetailsScalarFieldEnum[]
  }

  /**
   * ConstructionTypeMaster without action
   */
  export type ConstructionTypeMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMaster
     */
    select?: ConstructionTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMasterInclude<ExtArgs> | null
  }


  /**
   * Model WaterSourceMaster
   */

  export type AggregateWaterSourceMaster = {
    _count: WaterSourceMasterCountAggregateOutputType | null
    _min: WaterSourceMasterMinAggregateOutputType | null
    _max: WaterSourceMasterMaxAggregateOutputType | null
  }

  export type WaterSourceMasterMinAggregateOutputType = {
    waterSourceId: string | null
    waterSourceName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type WaterSourceMasterMaxAggregateOutputType = {
    waterSourceId: string | null
    waterSourceName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type WaterSourceMasterCountAggregateOutputType = {
    waterSourceId: number
    waterSourceName: number
    isActive: number
    description: number
    _all: number
  }


  export type WaterSourceMasterMinAggregateInputType = {
    waterSourceId?: true
    waterSourceName?: true
    isActive?: true
    description?: true
  }

  export type WaterSourceMasterMaxAggregateInputType = {
    waterSourceId?: true
    waterSourceName?: true
    isActive?: true
    description?: true
  }

  export type WaterSourceMasterCountAggregateInputType = {
    waterSourceId?: true
    waterSourceName?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type WaterSourceMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WaterSourceMaster to aggregate.
     */
    where?: WaterSourceMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaterSourceMasters to fetch.
     */
    orderBy?: WaterSourceMasterOrderByWithRelationInput | WaterSourceMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WaterSourceMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaterSourceMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaterSourceMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WaterSourceMasters
    **/
    _count?: true | WaterSourceMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WaterSourceMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WaterSourceMasterMaxAggregateInputType
  }

  export type GetWaterSourceMasterAggregateType<T extends WaterSourceMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateWaterSourceMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWaterSourceMaster[P]>
      : GetScalarType<T[P], AggregateWaterSourceMaster[P]>
  }




  export type WaterSourceMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaterSourceMasterWhereInput
    orderBy?: WaterSourceMasterOrderByWithAggregationInput | WaterSourceMasterOrderByWithAggregationInput[]
    by: WaterSourceMasterScalarFieldEnum[] | WaterSourceMasterScalarFieldEnum
    having?: WaterSourceMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WaterSourceMasterCountAggregateInputType | true
    _min?: WaterSourceMasterMinAggregateInputType
    _max?: WaterSourceMasterMaxAggregateInputType
  }

  export type WaterSourceMasterGroupByOutputType = {
    waterSourceId: string
    waterSourceName: string
    isActive: boolean
    description: string | null
    _count: WaterSourceMasterCountAggregateOutputType | null
    _min: WaterSourceMasterMinAggregateOutputType | null
    _max: WaterSourceMasterMaxAggregateOutputType | null
  }

  type GetWaterSourceMasterGroupByPayload<T extends WaterSourceMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WaterSourceMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WaterSourceMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WaterSourceMasterGroupByOutputType[P]>
            : GetScalarType<T[P], WaterSourceMasterGroupByOutputType[P]>
        }
      >
    >


  export type WaterSourceMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    waterSourceId?: boolean
    waterSourceName?: boolean
    isActive?: boolean
    description?: boolean
    otherDetails?: boolean | WaterSourceMaster$otherDetailsArgs<ExtArgs>
    _count?: boolean | WaterSourceMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["waterSourceMaster"]>

  export type WaterSourceMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    waterSourceId?: boolean
    waterSourceName?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["waterSourceMaster"]>

  export type WaterSourceMasterSelectScalar = {
    waterSourceId?: boolean
    waterSourceName?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type WaterSourceMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    otherDetails?: boolean | WaterSourceMaster$otherDetailsArgs<ExtArgs>
    _count?: boolean | WaterSourceMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WaterSourceMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WaterSourceMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WaterSourceMaster"
    objects: {
      otherDetails: Prisma.$OtherDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      waterSourceId: string
      waterSourceName: string
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["waterSourceMaster"]>
    composites: {}
  }

  type WaterSourceMasterGetPayload<S extends boolean | null | undefined | WaterSourceMasterDefaultArgs> = $Result.GetResult<Prisma.$WaterSourceMasterPayload, S>

  type WaterSourceMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WaterSourceMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WaterSourceMasterCountAggregateInputType | true
    }

  export interface WaterSourceMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WaterSourceMaster'], meta: { name: 'WaterSourceMaster' } }
    /**
     * Find zero or one WaterSourceMaster that matches the filter.
     * @param {WaterSourceMasterFindUniqueArgs} args - Arguments to find a WaterSourceMaster
     * @example
     * // Get one WaterSourceMaster
     * const waterSourceMaster = await prisma.waterSourceMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WaterSourceMasterFindUniqueArgs>(args: SelectSubset<T, WaterSourceMasterFindUniqueArgs<ExtArgs>>): Prisma__WaterSourceMasterClient<$Result.GetResult<Prisma.$WaterSourceMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WaterSourceMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WaterSourceMasterFindUniqueOrThrowArgs} args - Arguments to find a WaterSourceMaster
     * @example
     * // Get one WaterSourceMaster
     * const waterSourceMaster = await prisma.waterSourceMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WaterSourceMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, WaterSourceMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WaterSourceMasterClient<$Result.GetResult<Prisma.$WaterSourceMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WaterSourceMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterSourceMasterFindFirstArgs} args - Arguments to find a WaterSourceMaster
     * @example
     * // Get one WaterSourceMaster
     * const waterSourceMaster = await prisma.waterSourceMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WaterSourceMasterFindFirstArgs>(args?: SelectSubset<T, WaterSourceMasterFindFirstArgs<ExtArgs>>): Prisma__WaterSourceMasterClient<$Result.GetResult<Prisma.$WaterSourceMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WaterSourceMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterSourceMasterFindFirstOrThrowArgs} args - Arguments to find a WaterSourceMaster
     * @example
     * // Get one WaterSourceMaster
     * const waterSourceMaster = await prisma.waterSourceMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WaterSourceMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, WaterSourceMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__WaterSourceMasterClient<$Result.GetResult<Prisma.$WaterSourceMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WaterSourceMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterSourceMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WaterSourceMasters
     * const waterSourceMasters = await prisma.waterSourceMaster.findMany()
     * 
     * // Get first 10 WaterSourceMasters
     * const waterSourceMasters = await prisma.waterSourceMaster.findMany({ take: 10 })
     * 
     * // Only select the `waterSourceId`
     * const waterSourceMasterWithWaterSourceIdOnly = await prisma.waterSourceMaster.findMany({ select: { waterSourceId: true } })
     * 
     */
    findMany<T extends WaterSourceMasterFindManyArgs>(args?: SelectSubset<T, WaterSourceMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaterSourceMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WaterSourceMaster.
     * @param {WaterSourceMasterCreateArgs} args - Arguments to create a WaterSourceMaster.
     * @example
     * // Create one WaterSourceMaster
     * const WaterSourceMaster = await prisma.waterSourceMaster.create({
     *   data: {
     *     // ... data to create a WaterSourceMaster
     *   }
     * })
     * 
     */
    create<T extends WaterSourceMasterCreateArgs>(args: SelectSubset<T, WaterSourceMasterCreateArgs<ExtArgs>>): Prisma__WaterSourceMasterClient<$Result.GetResult<Prisma.$WaterSourceMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WaterSourceMasters.
     * @param {WaterSourceMasterCreateManyArgs} args - Arguments to create many WaterSourceMasters.
     * @example
     * // Create many WaterSourceMasters
     * const waterSourceMaster = await prisma.waterSourceMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WaterSourceMasterCreateManyArgs>(args?: SelectSubset<T, WaterSourceMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WaterSourceMasters and returns the data saved in the database.
     * @param {WaterSourceMasterCreateManyAndReturnArgs} args - Arguments to create many WaterSourceMasters.
     * @example
     * // Create many WaterSourceMasters
     * const waterSourceMaster = await prisma.waterSourceMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WaterSourceMasters and only return the `waterSourceId`
     * const waterSourceMasterWithWaterSourceIdOnly = await prisma.waterSourceMaster.createManyAndReturn({ 
     *   select: { waterSourceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WaterSourceMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, WaterSourceMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaterSourceMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WaterSourceMaster.
     * @param {WaterSourceMasterDeleteArgs} args - Arguments to delete one WaterSourceMaster.
     * @example
     * // Delete one WaterSourceMaster
     * const WaterSourceMaster = await prisma.waterSourceMaster.delete({
     *   where: {
     *     // ... filter to delete one WaterSourceMaster
     *   }
     * })
     * 
     */
    delete<T extends WaterSourceMasterDeleteArgs>(args: SelectSubset<T, WaterSourceMasterDeleteArgs<ExtArgs>>): Prisma__WaterSourceMasterClient<$Result.GetResult<Prisma.$WaterSourceMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WaterSourceMaster.
     * @param {WaterSourceMasterUpdateArgs} args - Arguments to update one WaterSourceMaster.
     * @example
     * // Update one WaterSourceMaster
     * const waterSourceMaster = await prisma.waterSourceMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WaterSourceMasterUpdateArgs>(args: SelectSubset<T, WaterSourceMasterUpdateArgs<ExtArgs>>): Prisma__WaterSourceMasterClient<$Result.GetResult<Prisma.$WaterSourceMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WaterSourceMasters.
     * @param {WaterSourceMasterDeleteManyArgs} args - Arguments to filter WaterSourceMasters to delete.
     * @example
     * // Delete a few WaterSourceMasters
     * const { count } = await prisma.waterSourceMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WaterSourceMasterDeleteManyArgs>(args?: SelectSubset<T, WaterSourceMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WaterSourceMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterSourceMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WaterSourceMasters
     * const waterSourceMaster = await prisma.waterSourceMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WaterSourceMasterUpdateManyArgs>(args: SelectSubset<T, WaterSourceMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WaterSourceMaster.
     * @param {WaterSourceMasterUpsertArgs} args - Arguments to update or create a WaterSourceMaster.
     * @example
     * // Update or create a WaterSourceMaster
     * const waterSourceMaster = await prisma.waterSourceMaster.upsert({
     *   create: {
     *     // ... data to create a WaterSourceMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WaterSourceMaster we want to update
     *   }
     * })
     */
    upsert<T extends WaterSourceMasterUpsertArgs>(args: SelectSubset<T, WaterSourceMasterUpsertArgs<ExtArgs>>): Prisma__WaterSourceMasterClient<$Result.GetResult<Prisma.$WaterSourceMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WaterSourceMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterSourceMasterCountArgs} args - Arguments to filter WaterSourceMasters to count.
     * @example
     * // Count the number of WaterSourceMasters
     * const count = await prisma.waterSourceMaster.count({
     *   where: {
     *     // ... the filter for the WaterSourceMasters we want to count
     *   }
     * })
    **/
    count<T extends WaterSourceMasterCountArgs>(
      args?: Subset<T, WaterSourceMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WaterSourceMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WaterSourceMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterSourceMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WaterSourceMasterAggregateArgs>(args: Subset<T, WaterSourceMasterAggregateArgs>): Prisma.PrismaPromise<GetWaterSourceMasterAggregateType<T>>

    /**
     * Group by WaterSourceMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterSourceMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WaterSourceMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WaterSourceMasterGroupByArgs['orderBy'] }
        : { orderBy?: WaterSourceMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WaterSourceMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWaterSourceMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WaterSourceMaster model
   */
  readonly fields: WaterSourceMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WaterSourceMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WaterSourceMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    otherDetails<T extends WaterSourceMaster$otherDetailsArgs<ExtArgs> = {}>(args?: Subset<T, WaterSourceMaster$otherDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WaterSourceMaster model
   */ 
  interface WaterSourceMasterFieldRefs {
    readonly waterSourceId: FieldRef<"WaterSourceMaster", 'String'>
    readonly waterSourceName: FieldRef<"WaterSourceMaster", 'String'>
    readonly isActive: FieldRef<"WaterSourceMaster", 'Boolean'>
    readonly description: FieldRef<"WaterSourceMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WaterSourceMaster findUnique
   */
  export type WaterSourceMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSourceMaster
     */
    select?: WaterSourceMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSourceMasterInclude<ExtArgs> | null
    /**
     * Filter, which WaterSourceMaster to fetch.
     */
    where: WaterSourceMasterWhereUniqueInput
  }

  /**
   * WaterSourceMaster findUniqueOrThrow
   */
  export type WaterSourceMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSourceMaster
     */
    select?: WaterSourceMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSourceMasterInclude<ExtArgs> | null
    /**
     * Filter, which WaterSourceMaster to fetch.
     */
    where: WaterSourceMasterWhereUniqueInput
  }

  /**
   * WaterSourceMaster findFirst
   */
  export type WaterSourceMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSourceMaster
     */
    select?: WaterSourceMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSourceMasterInclude<ExtArgs> | null
    /**
     * Filter, which WaterSourceMaster to fetch.
     */
    where?: WaterSourceMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaterSourceMasters to fetch.
     */
    orderBy?: WaterSourceMasterOrderByWithRelationInput | WaterSourceMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WaterSourceMasters.
     */
    cursor?: WaterSourceMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaterSourceMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaterSourceMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WaterSourceMasters.
     */
    distinct?: WaterSourceMasterScalarFieldEnum | WaterSourceMasterScalarFieldEnum[]
  }

  /**
   * WaterSourceMaster findFirstOrThrow
   */
  export type WaterSourceMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSourceMaster
     */
    select?: WaterSourceMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSourceMasterInclude<ExtArgs> | null
    /**
     * Filter, which WaterSourceMaster to fetch.
     */
    where?: WaterSourceMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaterSourceMasters to fetch.
     */
    orderBy?: WaterSourceMasterOrderByWithRelationInput | WaterSourceMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WaterSourceMasters.
     */
    cursor?: WaterSourceMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaterSourceMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaterSourceMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WaterSourceMasters.
     */
    distinct?: WaterSourceMasterScalarFieldEnum | WaterSourceMasterScalarFieldEnum[]
  }

  /**
   * WaterSourceMaster findMany
   */
  export type WaterSourceMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSourceMaster
     */
    select?: WaterSourceMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSourceMasterInclude<ExtArgs> | null
    /**
     * Filter, which WaterSourceMasters to fetch.
     */
    where?: WaterSourceMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaterSourceMasters to fetch.
     */
    orderBy?: WaterSourceMasterOrderByWithRelationInput | WaterSourceMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WaterSourceMasters.
     */
    cursor?: WaterSourceMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaterSourceMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaterSourceMasters.
     */
    skip?: number
    distinct?: WaterSourceMasterScalarFieldEnum | WaterSourceMasterScalarFieldEnum[]
  }

  /**
   * WaterSourceMaster create
   */
  export type WaterSourceMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSourceMaster
     */
    select?: WaterSourceMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSourceMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a WaterSourceMaster.
     */
    data: XOR<WaterSourceMasterCreateInput, WaterSourceMasterUncheckedCreateInput>
  }

  /**
   * WaterSourceMaster createMany
   */
  export type WaterSourceMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WaterSourceMasters.
     */
    data: WaterSourceMasterCreateManyInput | WaterSourceMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WaterSourceMaster createManyAndReturn
   */
  export type WaterSourceMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSourceMaster
     */
    select?: WaterSourceMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WaterSourceMasters.
     */
    data: WaterSourceMasterCreateManyInput | WaterSourceMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WaterSourceMaster update
   */
  export type WaterSourceMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSourceMaster
     */
    select?: WaterSourceMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSourceMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a WaterSourceMaster.
     */
    data: XOR<WaterSourceMasterUpdateInput, WaterSourceMasterUncheckedUpdateInput>
    /**
     * Choose, which WaterSourceMaster to update.
     */
    where: WaterSourceMasterWhereUniqueInput
  }

  /**
   * WaterSourceMaster updateMany
   */
  export type WaterSourceMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WaterSourceMasters.
     */
    data: XOR<WaterSourceMasterUpdateManyMutationInput, WaterSourceMasterUncheckedUpdateManyInput>
    /**
     * Filter which WaterSourceMasters to update
     */
    where?: WaterSourceMasterWhereInput
  }

  /**
   * WaterSourceMaster upsert
   */
  export type WaterSourceMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSourceMaster
     */
    select?: WaterSourceMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSourceMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the WaterSourceMaster to update in case it exists.
     */
    where: WaterSourceMasterWhereUniqueInput
    /**
     * In case the WaterSourceMaster found by the `where` argument doesn't exist, create a new WaterSourceMaster with this data.
     */
    create: XOR<WaterSourceMasterCreateInput, WaterSourceMasterUncheckedCreateInput>
    /**
     * In case the WaterSourceMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WaterSourceMasterUpdateInput, WaterSourceMasterUncheckedUpdateInput>
  }

  /**
   * WaterSourceMaster delete
   */
  export type WaterSourceMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSourceMaster
     */
    select?: WaterSourceMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSourceMasterInclude<ExtArgs> | null
    /**
     * Filter which WaterSourceMaster to delete.
     */
    where: WaterSourceMasterWhereUniqueInput
  }

  /**
   * WaterSourceMaster deleteMany
   */
  export type WaterSourceMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WaterSourceMasters to delete
     */
    where?: WaterSourceMasterWhereInput
  }

  /**
   * WaterSourceMaster.otherDetails
   */
  export type WaterSourceMaster$otherDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    where?: OtherDetailsWhereInput
    orderBy?: OtherDetailsOrderByWithRelationInput | OtherDetailsOrderByWithRelationInput[]
    cursor?: OtherDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtherDetailsScalarFieldEnum | OtherDetailsScalarFieldEnum[]
  }

  /**
   * WaterSourceMaster without action
   */
  export type WaterSourceMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSourceMaster
     */
    select?: WaterSourceMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSourceMasterInclude<ExtArgs> | null
  }


  /**
   * Model DisposalTypeMaster
   */

  export type AggregateDisposalTypeMaster = {
    _count: DisposalTypeMasterCountAggregateOutputType | null
    _min: DisposalTypeMasterMinAggregateOutputType | null
    _max: DisposalTypeMasterMaxAggregateOutputType | null
  }

  export type DisposalTypeMasterMinAggregateOutputType = {
    disposalTypeId: string | null
    disposalTypeName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type DisposalTypeMasterMaxAggregateOutputType = {
    disposalTypeId: string | null
    disposalTypeName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type DisposalTypeMasterCountAggregateOutputType = {
    disposalTypeId: number
    disposalTypeName: number
    isActive: number
    description: number
    _all: number
  }


  export type DisposalTypeMasterMinAggregateInputType = {
    disposalTypeId?: true
    disposalTypeName?: true
    isActive?: true
    description?: true
  }

  export type DisposalTypeMasterMaxAggregateInputType = {
    disposalTypeId?: true
    disposalTypeName?: true
    isActive?: true
    description?: true
  }

  export type DisposalTypeMasterCountAggregateInputType = {
    disposalTypeId?: true
    disposalTypeName?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type DisposalTypeMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisposalTypeMaster to aggregate.
     */
    where?: DisposalTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisposalTypeMasters to fetch.
     */
    orderBy?: DisposalTypeMasterOrderByWithRelationInput | DisposalTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisposalTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisposalTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisposalTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisposalTypeMasters
    **/
    _count?: true | DisposalTypeMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisposalTypeMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisposalTypeMasterMaxAggregateInputType
  }

  export type GetDisposalTypeMasterAggregateType<T extends DisposalTypeMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateDisposalTypeMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisposalTypeMaster[P]>
      : GetScalarType<T[P], AggregateDisposalTypeMaster[P]>
  }




  export type DisposalTypeMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisposalTypeMasterWhereInput
    orderBy?: DisposalTypeMasterOrderByWithAggregationInput | DisposalTypeMasterOrderByWithAggregationInput[]
    by: DisposalTypeMasterScalarFieldEnum[] | DisposalTypeMasterScalarFieldEnum
    having?: DisposalTypeMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisposalTypeMasterCountAggregateInputType | true
    _min?: DisposalTypeMasterMinAggregateInputType
    _max?: DisposalTypeMasterMaxAggregateInputType
  }

  export type DisposalTypeMasterGroupByOutputType = {
    disposalTypeId: string
    disposalTypeName: string
    isActive: boolean
    description: string | null
    _count: DisposalTypeMasterCountAggregateOutputType | null
    _min: DisposalTypeMasterMinAggregateOutputType | null
    _max: DisposalTypeMasterMaxAggregateOutputType | null
  }

  type GetDisposalTypeMasterGroupByPayload<T extends DisposalTypeMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisposalTypeMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisposalTypeMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisposalTypeMasterGroupByOutputType[P]>
            : GetScalarType<T[P], DisposalTypeMasterGroupByOutputType[P]>
        }
      >
    >


  export type DisposalTypeMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    disposalTypeId?: boolean
    disposalTypeName?: boolean
    isActive?: boolean
    description?: boolean
    otherDetails?: boolean | DisposalTypeMaster$otherDetailsArgs<ExtArgs>
    _count?: boolean | DisposalTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disposalTypeMaster"]>

  export type DisposalTypeMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    disposalTypeId?: boolean
    disposalTypeName?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["disposalTypeMaster"]>

  export type DisposalTypeMasterSelectScalar = {
    disposalTypeId?: boolean
    disposalTypeName?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type DisposalTypeMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    otherDetails?: boolean | DisposalTypeMaster$otherDetailsArgs<ExtArgs>
    _count?: boolean | DisposalTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DisposalTypeMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DisposalTypeMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisposalTypeMaster"
    objects: {
      otherDetails: Prisma.$OtherDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      disposalTypeId: string
      disposalTypeName: string
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["disposalTypeMaster"]>
    composites: {}
  }

  type DisposalTypeMasterGetPayload<S extends boolean | null | undefined | DisposalTypeMasterDefaultArgs> = $Result.GetResult<Prisma.$DisposalTypeMasterPayload, S>

  type DisposalTypeMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DisposalTypeMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DisposalTypeMasterCountAggregateInputType | true
    }

  export interface DisposalTypeMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisposalTypeMaster'], meta: { name: 'DisposalTypeMaster' } }
    /**
     * Find zero or one DisposalTypeMaster that matches the filter.
     * @param {DisposalTypeMasterFindUniqueArgs} args - Arguments to find a DisposalTypeMaster
     * @example
     * // Get one DisposalTypeMaster
     * const disposalTypeMaster = await prisma.disposalTypeMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisposalTypeMasterFindUniqueArgs>(args: SelectSubset<T, DisposalTypeMasterFindUniqueArgs<ExtArgs>>): Prisma__DisposalTypeMasterClient<$Result.GetResult<Prisma.$DisposalTypeMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DisposalTypeMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DisposalTypeMasterFindUniqueOrThrowArgs} args - Arguments to find a DisposalTypeMaster
     * @example
     * // Get one DisposalTypeMaster
     * const disposalTypeMaster = await prisma.disposalTypeMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisposalTypeMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, DisposalTypeMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisposalTypeMasterClient<$Result.GetResult<Prisma.$DisposalTypeMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DisposalTypeMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisposalTypeMasterFindFirstArgs} args - Arguments to find a DisposalTypeMaster
     * @example
     * // Get one DisposalTypeMaster
     * const disposalTypeMaster = await prisma.disposalTypeMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisposalTypeMasterFindFirstArgs>(args?: SelectSubset<T, DisposalTypeMasterFindFirstArgs<ExtArgs>>): Prisma__DisposalTypeMasterClient<$Result.GetResult<Prisma.$DisposalTypeMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DisposalTypeMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisposalTypeMasterFindFirstOrThrowArgs} args - Arguments to find a DisposalTypeMaster
     * @example
     * // Get one DisposalTypeMaster
     * const disposalTypeMaster = await prisma.disposalTypeMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisposalTypeMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, DisposalTypeMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisposalTypeMasterClient<$Result.GetResult<Prisma.$DisposalTypeMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DisposalTypeMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisposalTypeMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisposalTypeMasters
     * const disposalTypeMasters = await prisma.disposalTypeMaster.findMany()
     * 
     * // Get first 10 DisposalTypeMasters
     * const disposalTypeMasters = await prisma.disposalTypeMaster.findMany({ take: 10 })
     * 
     * // Only select the `disposalTypeId`
     * const disposalTypeMasterWithDisposalTypeIdOnly = await prisma.disposalTypeMaster.findMany({ select: { disposalTypeId: true } })
     * 
     */
    findMany<T extends DisposalTypeMasterFindManyArgs>(args?: SelectSubset<T, DisposalTypeMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisposalTypeMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DisposalTypeMaster.
     * @param {DisposalTypeMasterCreateArgs} args - Arguments to create a DisposalTypeMaster.
     * @example
     * // Create one DisposalTypeMaster
     * const DisposalTypeMaster = await prisma.disposalTypeMaster.create({
     *   data: {
     *     // ... data to create a DisposalTypeMaster
     *   }
     * })
     * 
     */
    create<T extends DisposalTypeMasterCreateArgs>(args: SelectSubset<T, DisposalTypeMasterCreateArgs<ExtArgs>>): Prisma__DisposalTypeMasterClient<$Result.GetResult<Prisma.$DisposalTypeMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DisposalTypeMasters.
     * @param {DisposalTypeMasterCreateManyArgs} args - Arguments to create many DisposalTypeMasters.
     * @example
     * // Create many DisposalTypeMasters
     * const disposalTypeMaster = await prisma.disposalTypeMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisposalTypeMasterCreateManyArgs>(args?: SelectSubset<T, DisposalTypeMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DisposalTypeMasters and returns the data saved in the database.
     * @param {DisposalTypeMasterCreateManyAndReturnArgs} args - Arguments to create many DisposalTypeMasters.
     * @example
     * // Create many DisposalTypeMasters
     * const disposalTypeMaster = await prisma.disposalTypeMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DisposalTypeMasters and only return the `disposalTypeId`
     * const disposalTypeMasterWithDisposalTypeIdOnly = await prisma.disposalTypeMaster.createManyAndReturn({ 
     *   select: { disposalTypeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisposalTypeMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, DisposalTypeMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisposalTypeMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DisposalTypeMaster.
     * @param {DisposalTypeMasterDeleteArgs} args - Arguments to delete one DisposalTypeMaster.
     * @example
     * // Delete one DisposalTypeMaster
     * const DisposalTypeMaster = await prisma.disposalTypeMaster.delete({
     *   where: {
     *     // ... filter to delete one DisposalTypeMaster
     *   }
     * })
     * 
     */
    delete<T extends DisposalTypeMasterDeleteArgs>(args: SelectSubset<T, DisposalTypeMasterDeleteArgs<ExtArgs>>): Prisma__DisposalTypeMasterClient<$Result.GetResult<Prisma.$DisposalTypeMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DisposalTypeMaster.
     * @param {DisposalTypeMasterUpdateArgs} args - Arguments to update one DisposalTypeMaster.
     * @example
     * // Update one DisposalTypeMaster
     * const disposalTypeMaster = await prisma.disposalTypeMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisposalTypeMasterUpdateArgs>(args: SelectSubset<T, DisposalTypeMasterUpdateArgs<ExtArgs>>): Prisma__DisposalTypeMasterClient<$Result.GetResult<Prisma.$DisposalTypeMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DisposalTypeMasters.
     * @param {DisposalTypeMasterDeleteManyArgs} args - Arguments to filter DisposalTypeMasters to delete.
     * @example
     * // Delete a few DisposalTypeMasters
     * const { count } = await prisma.disposalTypeMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisposalTypeMasterDeleteManyArgs>(args?: SelectSubset<T, DisposalTypeMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisposalTypeMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisposalTypeMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisposalTypeMasters
     * const disposalTypeMaster = await prisma.disposalTypeMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisposalTypeMasterUpdateManyArgs>(args: SelectSubset<T, DisposalTypeMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DisposalTypeMaster.
     * @param {DisposalTypeMasterUpsertArgs} args - Arguments to update or create a DisposalTypeMaster.
     * @example
     * // Update or create a DisposalTypeMaster
     * const disposalTypeMaster = await prisma.disposalTypeMaster.upsert({
     *   create: {
     *     // ... data to create a DisposalTypeMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisposalTypeMaster we want to update
     *   }
     * })
     */
    upsert<T extends DisposalTypeMasterUpsertArgs>(args: SelectSubset<T, DisposalTypeMasterUpsertArgs<ExtArgs>>): Prisma__DisposalTypeMasterClient<$Result.GetResult<Prisma.$DisposalTypeMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DisposalTypeMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisposalTypeMasterCountArgs} args - Arguments to filter DisposalTypeMasters to count.
     * @example
     * // Count the number of DisposalTypeMasters
     * const count = await prisma.disposalTypeMaster.count({
     *   where: {
     *     // ... the filter for the DisposalTypeMasters we want to count
     *   }
     * })
    **/
    count<T extends DisposalTypeMasterCountArgs>(
      args?: Subset<T, DisposalTypeMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisposalTypeMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisposalTypeMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisposalTypeMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisposalTypeMasterAggregateArgs>(args: Subset<T, DisposalTypeMasterAggregateArgs>): Prisma.PrismaPromise<GetDisposalTypeMasterAggregateType<T>>

    /**
     * Group by DisposalTypeMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisposalTypeMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisposalTypeMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisposalTypeMasterGroupByArgs['orderBy'] }
        : { orderBy?: DisposalTypeMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisposalTypeMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisposalTypeMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisposalTypeMaster model
   */
  readonly fields: DisposalTypeMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisposalTypeMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisposalTypeMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    otherDetails<T extends DisposalTypeMaster$otherDetailsArgs<ExtArgs> = {}>(args?: Subset<T, DisposalTypeMaster$otherDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisposalTypeMaster model
   */ 
  interface DisposalTypeMasterFieldRefs {
    readonly disposalTypeId: FieldRef<"DisposalTypeMaster", 'String'>
    readonly disposalTypeName: FieldRef<"DisposalTypeMaster", 'String'>
    readonly isActive: FieldRef<"DisposalTypeMaster", 'Boolean'>
    readonly description: FieldRef<"DisposalTypeMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DisposalTypeMaster findUnique
   */
  export type DisposalTypeMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisposalTypeMaster
     */
    select?: DisposalTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisposalTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which DisposalTypeMaster to fetch.
     */
    where: DisposalTypeMasterWhereUniqueInput
  }

  /**
   * DisposalTypeMaster findUniqueOrThrow
   */
  export type DisposalTypeMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisposalTypeMaster
     */
    select?: DisposalTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisposalTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which DisposalTypeMaster to fetch.
     */
    where: DisposalTypeMasterWhereUniqueInput
  }

  /**
   * DisposalTypeMaster findFirst
   */
  export type DisposalTypeMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisposalTypeMaster
     */
    select?: DisposalTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisposalTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which DisposalTypeMaster to fetch.
     */
    where?: DisposalTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisposalTypeMasters to fetch.
     */
    orderBy?: DisposalTypeMasterOrderByWithRelationInput | DisposalTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisposalTypeMasters.
     */
    cursor?: DisposalTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisposalTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisposalTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisposalTypeMasters.
     */
    distinct?: DisposalTypeMasterScalarFieldEnum | DisposalTypeMasterScalarFieldEnum[]
  }

  /**
   * DisposalTypeMaster findFirstOrThrow
   */
  export type DisposalTypeMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisposalTypeMaster
     */
    select?: DisposalTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisposalTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which DisposalTypeMaster to fetch.
     */
    where?: DisposalTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisposalTypeMasters to fetch.
     */
    orderBy?: DisposalTypeMasterOrderByWithRelationInput | DisposalTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisposalTypeMasters.
     */
    cursor?: DisposalTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisposalTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisposalTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisposalTypeMasters.
     */
    distinct?: DisposalTypeMasterScalarFieldEnum | DisposalTypeMasterScalarFieldEnum[]
  }

  /**
   * DisposalTypeMaster findMany
   */
  export type DisposalTypeMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisposalTypeMaster
     */
    select?: DisposalTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisposalTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which DisposalTypeMasters to fetch.
     */
    where?: DisposalTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisposalTypeMasters to fetch.
     */
    orderBy?: DisposalTypeMasterOrderByWithRelationInput | DisposalTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisposalTypeMasters.
     */
    cursor?: DisposalTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisposalTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisposalTypeMasters.
     */
    skip?: number
    distinct?: DisposalTypeMasterScalarFieldEnum | DisposalTypeMasterScalarFieldEnum[]
  }

  /**
   * DisposalTypeMaster create
   */
  export type DisposalTypeMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisposalTypeMaster
     */
    select?: DisposalTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisposalTypeMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a DisposalTypeMaster.
     */
    data: XOR<DisposalTypeMasterCreateInput, DisposalTypeMasterUncheckedCreateInput>
  }

  /**
   * DisposalTypeMaster createMany
   */
  export type DisposalTypeMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisposalTypeMasters.
     */
    data: DisposalTypeMasterCreateManyInput | DisposalTypeMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DisposalTypeMaster createManyAndReturn
   */
  export type DisposalTypeMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisposalTypeMaster
     */
    select?: DisposalTypeMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DisposalTypeMasters.
     */
    data: DisposalTypeMasterCreateManyInput | DisposalTypeMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DisposalTypeMaster update
   */
  export type DisposalTypeMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisposalTypeMaster
     */
    select?: DisposalTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisposalTypeMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a DisposalTypeMaster.
     */
    data: XOR<DisposalTypeMasterUpdateInput, DisposalTypeMasterUncheckedUpdateInput>
    /**
     * Choose, which DisposalTypeMaster to update.
     */
    where: DisposalTypeMasterWhereUniqueInput
  }

  /**
   * DisposalTypeMaster updateMany
   */
  export type DisposalTypeMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisposalTypeMasters.
     */
    data: XOR<DisposalTypeMasterUpdateManyMutationInput, DisposalTypeMasterUncheckedUpdateManyInput>
    /**
     * Filter which DisposalTypeMasters to update
     */
    where?: DisposalTypeMasterWhereInput
  }

  /**
   * DisposalTypeMaster upsert
   */
  export type DisposalTypeMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisposalTypeMaster
     */
    select?: DisposalTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisposalTypeMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the DisposalTypeMaster to update in case it exists.
     */
    where: DisposalTypeMasterWhereUniqueInput
    /**
     * In case the DisposalTypeMaster found by the `where` argument doesn't exist, create a new DisposalTypeMaster with this data.
     */
    create: XOR<DisposalTypeMasterCreateInput, DisposalTypeMasterUncheckedCreateInput>
    /**
     * In case the DisposalTypeMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisposalTypeMasterUpdateInput, DisposalTypeMasterUncheckedUpdateInput>
  }

  /**
   * DisposalTypeMaster delete
   */
  export type DisposalTypeMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisposalTypeMaster
     */
    select?: DisposalTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisposalTypeMasterInclude<ExtArgs> | null
    /**
     * Filter which DisposalTypeMaster to delete.
     */
    where: DisposalTypeMasterWhereUniqueInput
  }

  /**
   * DisposalTypeMaster deleteMany
   */
  export type DisposalTypeMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisposalTypeMasters to delete
     */
    where?: DisposalTypeMasterWhereInput
  }

  /**
   * DisposalTypeMaster.otherDetails
   */
  export type DisposalTypeMaster$otherDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    where?: OtherDetailsWhereInput
    orderBy?: OtherDetailsOrderByWithRelationInput | OtherDetailsOrderByWithRelationInput[]
    cursor?: OtherDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtherDetailsScalarFieldEnum | OtherDetailsScalarFieldEnum[]
  }

  /**
   * DisposalTypeMaster without action
   */
  export type DisposalTypeMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisposalTypeMaster
     */
    select?: DisposalTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisposalTypeMasterInclude<ExtArgs> | null
  }


  /**
   * Model NrPropertyCategoryMaster
   */

  export type AggregateNrPropertyCategoryMaster = {
    _count: NrPropertyCategoryMasterCountAggregateOutputType | null
    _avg: NrPropertyCategoryMasterAvgAggregateOutputType | null
    _sum: NrPropertyCategoryMasterSumAggregateOutputType | null
    _min: NrPropertyCategoryMasterMinAggregateOutputType | null
    _max: NrPropertyCategoryMasterMaxAggregateOutputType | null
  }

  export type NrPropertyCategoryMasterAvgAggregateOutputType = {
    propertyCategoryNumber: number | null
  }

  export type NrPropertyCategoryMasterSumAggregateOutputType = {
    propertyCategoryNumber: number | null
  }

  export type NrPropertyCategoryMasterMinAggregateOutputType = {
    propertyCategoryId: string | null
    propertyCategoryNumber: number | null
    propertyCategoryName: string | null
    isActive: boolean | null
    description: string | null
    createdAt: Date | null
  }

  export type NrPropertyCategoryMasterMaxAggregateOutputType = {
    propertyCategoryId: string | null
    propertyCategoryNumber: number | null
    propertyCategoryName: string | null
    isActive: boolean | null
    description: string | null
    createdAt: Date | null
  }

  export type NrPropertyCategoryMasterCountAggregateOutputType = {
    propertyCategoryId: number
    propertyCategoryNumber: number
    propertyCategoryName: number
    isActive: number
    description: number
    createdAt: number
    _all: number
  }


  export type NrPropertyCategoryMasterAvgAggregateInputType = {
    propertyCategoryNumber?: true
  }

  export type NrPropertyCategoryMasterSumAggregateInputType = {
    propertyCategoryNumber?: true
  }

  export type NrPropertyCategoryMasterMinAggregateInputType = {
    propertyCategoryId?: true
    propertyCategoryNumber?: true
    propertyCategoryName?: true
    isActive?: true
    description?: true
    createdAt?: true
  }

  export type NrPropertyCategoryMasterMaxAggregateInputType = {
    propertyCategoryId?: true
    propertyCategoryNumber?: true
    propertyCategoryName?: true
    isActive?: true
    description?: true
    createdAt?: true
  }

  export type NrPropertyCategoryMasterCountAggregateInputType = {
    propertyCategoryId?: true
    propertyCategoryNumber?: true
    propertyCategoryName?: true
    isActive?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type NrPropertyCategoryMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NrPropertyCategoryMaster to aggregate.
     */
    where?: NrPropertyCategoryMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NrPropertyCategoryMasters to fetch.
     */
    orderBy?: NrPropertyCategoryMasterOrderByWithRelationInput | NrPropertyCategoryMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NrPropertyCategoryMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NrPropertyCategoryMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NrPropertyCategoryMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NrPropertyCategoryMasters
    **/
    _count?: true | NrPropertyCategoryMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NrPropertyCategoryMasterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NrPropertyCategoryMasterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NrPropertyCategoryMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NrPropertyCategoryMasterMaxAggregateInputType
  }

  export type GetNrPropertyCategoryMasterAggregateType<T extends NrPropertyCategoryMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateNrPropertyCategoryMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNrPropertyCategoryMaster[P]>
      : GetScalarType<T[P], AggregateNrPropertyCategoryMaster[P]>
  }




  export type NrPropertyCategoryMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NrPropertyCategoryMasterWhereInput
    orderBy?: NrPropertyCategoryMasterOrderByWithAggregationInput | NrPropertyCategoryMasterOrderByWithAggregationInput[]
    by: NrPropertyCategoryMasterScalarFieldEnum[] | NrPropertyCategoryMasterScalarFieldEnum
    having?: NrPropertyCategoryMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NrPropertyCategoryMasterCountAggregateInputType | true
    _avg?: NrPropertyCategoryMasterAvgAggregateInputType
    _sum?: NrPropertyCategoryMasterSumAggregateInputType
    _min?: NrPropertyCategoryMasterMinAggregateInputType
    _max?: NrPropertyCategoryMasterMaxAggregateInputType
  }

  export type NrPropertyCategoryMasterGroupByOutputType = {
    propertyCategoryId: string
    propertyCategoryNumber: number
    propertyCategoryName: string
    isActive: boolean
    description: string | null
    createdAt: Date
    _count: NrPropertyCategoryMasterCountAggregateOutputType | null
    _avg: NrPropertyCategoryMasterAvgAggregateOutputType | null
    _sum: NrPropertyCategoryMasterSumAggregateOutputType | null
    _min: NrPropertyCategoryMasterMinAggregateOutputType | null
    _max: NrPropertyCategoryMasterMaxAggregateOutputType | null
  }

  type GetNrPropertyCategoryMasterGroupByPayload<T extends NrPropertyCategoryMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NrPropertyCategoryMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NrPropertyCategoryMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NrPropertyCategoryMasterGroupByOutputType[P]>
            : GetScalarType<T[P], NrPropertyCategoryMasterGroupByOutputType[P]>
        }
      >
    >


  export type NrPropertyCategoryMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    propertyCategoryId?: boolean
    propertyCategoryNumber?: boolean
    propertyCategoryName?: boolean
    isActive?: boolean
    description?: boolean
    createdAt?: boolean
    subCategories?: boolean | NrPropertyCategoryMaster$subCategoriesArgs<ExtArgs>
    nonResidentialPropertyAssessments?: boolean | NrPropertyCategoryMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs>
    _count?: boolean | NrPropertyCategoryMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nrPropertyCategoryMaster"]>

  export type NrPropertyCategoryMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    propertyCategoryId?: boolean
    propertyCategoryNumber?: boolean
    propertyCategoryName?: boolean
    isActive?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["nrPropertyCategoryMaster"]>

  export type NrPropertyCategoryMasterSelectScalar = {
    propertyCategoryId?: boolean
    propertyCategoryNumber?: boolean
    propertyCategoryName?: boolean
    isActive?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type NrPropertyCategoryMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCategories?: boolean | NrPropertyCategoryMaster$subCategoriesArgs<ExtArgs>
    nonResidentialPropertyAssessments?: boolean | NrPropertyCategoryMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs>
    _count?: boolean | NrPropertyCategoryMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NrPropertyCategoryMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NrPropertyCategoryMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NrPropertyCategoryMaster"
    objects: {
      subCategories: Prisma.$NrPropertySubCategoryMasterPayload<ExtArgs>[]
      nonResidentialPropertyAssessments: Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      propertyCategoryId: string
      propertyCategoryNumber: number
      propertyCategoryName: string
      isActive: boolean
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["nrPropertyCategoryMaster"]>
    composites: {}
  }

  type NrPropertyCategoryMasterGetPayload<S extends boolean | null | undefined | NrPropertyCategoryMasterDefaultArgs> = $Result.GetResult<Prisma.$NrPropertyCategoryMasterPayload, S>

  type NrPropertyCategoryMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NrPropertyCategoryMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NrPropertyCategoryMasterCountAggregateInputType | true
    }

  export interface NrPropertyCategoryMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NrPropertyCategoryMaster'], meta: { name: 'NrPropertyCategoryMaster' } }
    /**
     * Find zero or one NrPropertyCategoryMaster that matches the filter.
     * @param {NrPropertyCategoryMasterFindUniqueArgs} args - Arguments to find a NrPropertyCategoryMaster
     * @example
     * // Get one NrPropertyCategoryMaster
     * const nrPropertyCategoryMaster = await prisma.nrPropertyCategoryMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NrPropertyCategoryMasterFindUniqueArgs>(args: SelectSubset<T, NrPropertyCategoryMasterFindUniqueArgs<ExtArgs>>): Prisma__NrPropertyCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertyCategoryMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NrPropertyCategoryMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NrPropertyCategoryMasterFindUniqueOrThrowArgs} args - Arguments to find a NrPropertyCategoryMaster
     * @example
     * // Get one NrPropertyCategoryMaster
     * const nrPropertyCategoryMaster = await prisma.nrPropertyCategoryMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NrPropertyCategoryMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, NrPropertyCategoryMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NrPropertyCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertyCategoryMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NrPropertyCategoryMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NrPropertyCategoryMasterFindFirstArgs} args - Arguments to find a NrPropertyCategoryMaster
     * @example
     * // Get one NrPropertyCategoryMaster
     * const nrPropertyCategoryMaster = await prisma.nrPropertyCategoryMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NrPropertyCategoryMasterFindFirstArgs>(args?: SelectSubset<T, NrPropertyCategoryMasterFindFirstArgs<ExtArgs>>): Prisma__NrPropertyCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertyCategoryMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NrPropertyCategoryMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NrPropertyCategoryMasterFindFirstOrThrowArgs} args - Arguments to find a NrPropertyCategoryMaster
     * @example
     * // Get one NrPropertyCategoryMaster
     * const nrPropertyCategoryMaster = await prisma.nrPropertyCategoryMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NrPropertyCategoryMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, NrPropertyCategoryMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__NrPropertyCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertyCategoryMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NrPropertyCategoryMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NrPropertyCategoryMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NrPropertyCategoryMasters
     * const nrPropertyCategoryMasters = await prisma.nrPropertyCategoryMaster.findMany()
     * 
     * // Get first 10 NrPropertyCategoryMasters
     * const nrPropertyCategoryMasters = await prisma.nrPropertyCategoryMaster.findMany({ take: 10 })
     * 
     * // Only select the `propertyCategoryId`
     * const nrPropertyCategoryMasterWithPropertyCategoryIdOnly = await prisma.nrPropertyCategoryMaster.findMany({ select: { propertyCategoryId: true } })
     * 
     */
    findMany<T extends NrPropertyCategoryMasterFindManyArgs>(args?: SelectSubset<T, NrPropertyCategoryMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NrPropertyCategoryMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NrPropertyCategoryMaster.
     * @param {NrPropertyCategoryMasterCreateArgs} args - Arguments to create a NrPropertyCategoryMaster.
     * @example
     * // Create one NrPropertyCategoryMaster
     * const NrPropertyCategoryMaster = await prisma.nrPropertyCategoryMaster.create({
     *   data: {
     *     // ... data to create a NrPropertyCategoryMaster
     *   }
     * })
     * 
     */
    create<T extends NrPropertyCategoryMasterCreateArgs>(args: SelectSubset<T, NrPropertyCategoryMasterCreateArgs<ExtArgs>>): Prisma__NrPropertyCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertyCategoryMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NrPropertyCategoryMasters.
     * @param {NrPropertyCategoryMasterCreateManyArgs} args - Arguments to create many NrPropertyCategoryMasters.
     * @example
     * // Create many NrPropertyCategoryMasters
     * const nrPropertyCategoryMaster = await prisma.nrPropertyCategoryMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NrPropertyCategoryMasterCreateManyArgs>(args?: SelectSubset<T, NrPropertyCategoryMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NrPropertyCategoryMasters and returns the data saved in the database.
     * @param {NrPropertyCategoryMasterCreateManyAndReturnArgs} args - Arguments to create many NrPropertyCategoryMasters.
     * @example
     * // Create many NrPropertyCategoryMasters
     * const nrPropertyCategoryMaster = await prisma.nrPropertyCategoryMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NrPropertyCategoryMasters and only return the `propertyCategoryId`
     * const nrPropertyCategoryMasterWithPropertyCategoryIdOnly = await prisma.nrPropertyCategoryMaster.createManyAndReturn({ 
     *   select: { propertyCategoryId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NrPropertyCategoryMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, NrPropertyCategoryMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NrPropertyCategoryMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NrPropertyCategoryMaster.
     * @param {NrPropertyCategoryMasterDeleteArgs} args - Arguments to delete one NrPropertyCategoryMaster.
     * @example
     * // Delete one NrPropertyCategoryMaster
     * const NrPropertyCategoryMaster = await prisma.nrPropertyCategoryMaster.delete({
     *   where: {
     *     // ... filter to delete one NrPropertyCategoryMaster
     *   }
     * })
     * 
     */
    delete<T extends NrPropertyCategoryMasterDeleteArgs>(args: SelectSubset<T, NrPropertyCategoryMasterDeleteArgs<ExtArgs>>): Prisma__NrPropertyCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertyCategoryMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NrPropertyCategoryMaster.
     * @param {NrPropertyCategoryMasterUpdateArgs} args - Arguments to update one NrPropertyCategoryMaster.
     * @example
     * // Update one NrPropertyCategoryMaster
     * const nrPropertyCategoryMaster = await prisma.nrPropertyCategoryMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NrPropertyCategoryMasterUpdateArgs>(args: SelectSubset<T, NrPropertyCategoryMasterUpdateArgs<ExtArgs>>): Prisma__NrPropertyCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertyCategoryMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NrPropertyCategoryMasters.
     * @param {NrPropertyCategoryMasterDeleteManyArgs} args - Arguments to filter NrPropertyCategoryMasters to delete.
     * @example
     * // Delete a few NrPropertyCategoryMasters
     * const { count } = await prisma.nrPropertyCategoryMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NrPropertyCategoryMasterDeleteManyArgs>(args?: SelectSubset<T, NrPropertyCategoryMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NrPropertyCategoryMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NrPropertyCategoryMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NrPropertyCategoryMasters
     * const nrPropertyCategoryMaster = await prisma.nrPropertyCategoryMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NrPropertyCategoryMasterUpdateManyArgs>(args: SelectSubset<T, NrPropertyCategoryMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NrPropertyCategoryMaster.
     * @param {NrPropertyCategoryMasterUpsertArgs} args - Arguments to update or create a NrPropertyCategoryMaster.
     * @example
     * // Update or create a NrPropertyCategoryMaster
     * const nrPropertyCategoryMaster = await prisma.nrPropertyCategoryMaster.upsert({
     *   create: {
     *     // ... data to create a NrPropertyCategoryMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NrPropertyCategoryMaster we want to update
     *   }
     * })
     */
    upsert<T extends NrPropertyCategoryMasterUpsertArgs>(args: SelectSubset<T, NrPropertyCategoryMasterUpsertArgs<ExtArgs>>): Prisma__NrPropertyCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertyCategoryMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NrPropertyCategoryMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NrPropertyCategoryMasterCountArgs} args - Arguments to filter NrPropertyCategoryMasters to count.
     * @example
     * // Count the number of NrPropertyCategoryMasters
     * const count = await prisma.nrPropertyCategoryMaster.count({
     *   where: {
     *     // ... the filter for the NrPropertyCategoryMasters we want to count
     *   }
     * })
    **/
    count<T extends NrPropertyCategoryMasterCountArgs>(
      args?: Subset<T, NrPropertyCategoryMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NrPropertyCategoryMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NrPropertyCategoryMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NrPropertyCategoryMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NrPropertyCategoryMasterAggregateArgs>(args: Subset<T, NrPropertyCategoryMasterAggregateArgs>): Prisma.PrismaPromise<GetNrPropertyCategoryMasterAggregateType<T>>

    /**
     * Group by NrPropertyCategoryMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NrPropertyCategoryMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NrPropertyCategoryMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NrPropertyCategoryMasterGroupByArgs['orderBy'] }
        : { orderBy?: NrPropertyCategoryMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NrPropertyCategoryMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNrPropertyCategoryMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NrPropertyCategoryMaster model
   */
  readonly fields: NrPropertyCategoryMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NrPropertyCategoryMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NrPropertyCategoryMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subCategories<T extends NrPropertyCategoryMaster$subCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, NrPropertyCategoryMaster$subCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NrPropertySubCategoryMasterPayload<ExtArgs>, T, "findMany"> | Null>
    nonResidentialPropertyAssessments<T extends NrPropertyCategoryMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs> = {}>(args?: Subset<T, NrPropertyCategoryMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NrPropertyCategoryMaster model
   */ 
  interface NrPropertyCategoryMasterFieldRefs {
    readonly propertyCategoryId: FieldRef<"NrPropertyCategoryMaster", 'String'>
    readonly propertyCategoryNumber: FieldRef<"NrPropertyCategoryMaster", 'Int'>
    readonly propertyCategoryName: FieldRef<"NrPropertyCategoryMaster", 'String'>
    readonly isActive: FieldRef<"NrPropertyCategoryMaster", 'Boolean'>
    readonly description: FieldRef<"NrPropertyCategoryMaster", 'String'>
    readonly createdAt: FieldRef<"NrPropertyCategoryMaster", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NrPropertyCategoryMaster findUnique
   */
  export type NrPropertyCategoryMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertyCategoryMaster
     */
    select?: NrPropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter, which NrPropertyCategoryMaster to fetch.
     */
    where: NrPropertyCategoryMasterWhereUniqueInput
  }

  /**
   * NrPropertyCategoryMaster findUniqueOrThrow
   */
  export type NrPropertyCategoryMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertyCategoryMaster
     */
    select?: NrPropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter, which NrPropertyCategoryMaster to fetch.
     */
    where: NrPropertyCategoryMasterWhereUniqueInput
  }

  /**
   * NrPropertyCategoryMaster findFirst
   */
  export type NrPropertyCategoryMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertyCategoryMaster
     */
    select?: NrPropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter, which NrPropertyCategoryMaster to fetch.
     */
    where?: NrPropertyCategoryMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NrPropertyCategoryMasters to fetch.
     */
    orderBy?: NrPropertyCategoryMasterOrderByWithRelationInput | NrPropertyCategoryMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NrPropertyCategoryMasters.
     */
    cursor?: NrPropertyCategoryMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NrPropertyCategoryMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NrPropertyCategoryMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NrPropertyCategoryMasters.
     */
    distinct?: NrPropertyCategoryMasterScalarFieldEnum | NrPropertyCategoryMasterScalarFieldEnum[]
  }

  /**
   * NrPropertyCategoryMaster findFirstOrThrow
   */
  export type NrPropertyCategoryMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertyCategoryMaster
     */
    select?: NrPropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter, which NrPropertyCategoryMaster to fetch.
     */
    where?: NrPropertyCategoryMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NrPropertyCategoryMasters to fetch.
     */
    orderBy?: NrPropertyCategoryMasterOrderByWithRelationInput | NrPropertyCategoryMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NrPropertyCategoryMasters.
     */
    cursor?: NrPropertyCategoryMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NrPropertyCategoryMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NrPropertyCategoryMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NrPropertyCategoryMasters.
     */
    distinct?: NrPropertyCategoryMasterScalarFieldEnum | NrPropertyCategoryMasterScalarFieldEnum[]
  }

  /**
   * NrPropertyCategoryMaster findMany
   */
  export type NrPropertyCategoryMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertyCategoryMaster
     */
    select?: NrPropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter, which NrPropertyCategoryMasters to fetch.
     */
    where?: NrPropertyCategoryMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NrPropertyCategoryMasters to fetch.
     */
    orderBy?: NrPropertyCategoryMasterOrderByWithRelationInput | NrPropertyCategoryMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NrPropertyCategoryMasters.
     */
    cursor?: NrPropertyCategoryMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NrPropertyCategoryMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NrPropertyCategoryMasters.
     */
    skip?: number
    distinct?: NrPropertyCategoryMasterScalarFieldEnum | NrPropertyCategoryMasterScalarFieldEnum[]
  }

  /**
   * NrPropertyCategoryMaster create
   */
  export type NrPropertyCategoryMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertyCategoryMaster
     */
    select?: NrPropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a NrPropertyCategoryMaster.
     */
    data: XOR<NrPropertyCategoryMasterCreateInput, NrPropertyCategoryMasterUncheckedCreateInput>
  }

  /**
   * NrPropertyCategoryMaster createMany
   */
  export type NrPropertyCategoryMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NrPropertyCategoryMasters.
     */
    data: NrPropertyCategoryMasterCreateManyInput | NrPropertyCategoryMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NrPropertyCategoryMaster createManyAndReturn
   */
  export type NrPropertyCategoryMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertyCategoryMaster
     */
    select?: NrPropertyCategoryMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NrPropertyCategoryMasters.
     */
    data: NrPropertyCategoryMasterCreateManyInput | NrPropertyCategoryMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NrPropertyCategoryMaster update
   */
  export type NrPropertyCategoryMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertyCategoryMaster
     */
    select?: NrPropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a NrPropertyCategoryMaster.
     */
    data: XOR<NrPropertyCategoryMasterUpdateInput, NrPropertyCategoryMasterUncheckedUpdateInput>
    /**
     * Choose, which NrPropertyCategoryMaster to update.
     */
    where: NrPropertyCategoryMasterWhereUniqueInput
  }

  /**
   * NrPropertyCategoryMaster updateMany
   */
  export type NrPropertyCategoryMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NrPropertyCategoryMasters.
     */
    data: XOR<NrPropertyCategoryMasterUpdateManyMutationInput, NrPropertyCategoryMasterUncheckedUpdateManyInput>
    /**
     * Filter which NrPropertyCategoryMasters to update
     */
    where?: NrPropertyCategoryMasterWhereInput
  }

  /**
   * NrPropertyCategoryMaster upsert
   */
  export type NrPropertyCategoryMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertyCategoryMaster
     */
    select?: NrPropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the NrPropertyCategoryMaster to update in case it exists.
     */
    where: NrPropertyCategoryMasterWhereUniqueInput
    /**
     * In case the NrPropertyCategoryMaster found by the `where` argument doesn't exist, create a new NrPropertyCategoryMaster with this data.
     */
    create: XOR<NrPropertyCategoryMasterCreateInput, NrPropertyCategoryMasterUncheckedCreateInput>
    /**
     * In case the NrPropertyCategoryMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NrPropertyCategoryMasterUpdateInput, NrPropertyCategoryMasterUncheckedUpdateInput>
  }

  /**
   * NrPropertyCategoryMaster delete
   */
  export type NrPropertyCategoryMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertyCategoryMaster
     */
    select?: NrPropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter which NrPropertyCategoryMaster to delete.
     */
    where: NrPropertyCategoryMasterWhereUniqueInput
  }

  /**
   * NrPropertyCategoryMaster deleteMany
   */
  export type NrPropertyCategoryMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NrPropertyCategoryMasters to delete
     */
    where?: NrPropertyCategoryMasterWhereInput
  }

  /**
   * NrPropertyCategoryMaster.subCategories
   */
  export type NrPropertyCategoryMaster$subCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertySubCategoryMaster
     */
    select?: NrPropertySubCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertySubCategoryMasterInclude<ExtArgs> | null
    where?: NrPropertySubCategoryMasterWhereInput
    orderBy?: NrPropertySubCategoryMasterOrderByWithRelationInput | NrPropertySubCategoryMasterOrderByWithRelationInput[]
    cursor?: NrPropertySubCategoryMasterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NrPropertySubCategoryMasterScalarFieldEnum | NrPropertySubCategoryMasterScalarFieldEnum[]
  }

  /**
   * NrPropertyCategoryMaster.nonResidentialPropertyAssessments
   */
  export type NrPropertyCategoryMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonResidentialPropertyAssessment
     */
    select?: NonResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonResidentialPropertyAssessmentInclude<ExtArgs> | null
    where?: NonResidentialPropertyAssessmentWhereInput
    orderBy?: NonResidentialPropertyAssessmentOrderByWithRelationInput | NonResidentialPropertyAssessmentOrderByWithRelationInput[]
    cursor?: NonResidentialPropertyAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NonResidentialPropertyAssessmentScalarFieldEnum | NonResidentialPropertyAssessmentScalarFieldEnum[]
  }

  /**
   * NrPropertyCategoryMaster without action
   */
  export type NrPropertyCategoryMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertyCategoryMaster
     */
    select?: NrPropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertyCategoryMasterInclude<ExtArgs> | null
  }


  /**
   * Model NrPropertySubCategoryMaster
   */

  export type AggregateNrPropertySubCategoryMaster = {
    _count: NrPropertySubCategoryMasterCountAggregateOutputType | null
    _avg: NrPropertySubCategoryMasterAvgAggregateOutputType | null
    _sum: NrPropertySubCategoryMasterSumAggregateOutputType | null
    _min: NrPropertySubCategoryMasterMinAggregateOutputType | null
    _max: NrPropertySubCategoryMasterMaxAggregateOutputType | null
  }

  export type NrPropertySubCategoryMasterAvgAggregateOutputType = {
    subCategoryNumber: number | null
  }

  export type NrPropertySubCategoryMasterSumAggregateOutputType = {
    subCategoryNumber: number | null
  }

  export type NrPropertySubCategoryMasterMinAggregateOutputType = {
    subCategoryId: string | null
    subCategoryNumber: number | null
    subCategoryName: string | null
    isActive: boolean | null
    description: string | null
    createdAt: Date | null
    propertyCategoryId: string | null
  }

  export type NrPropertySubCategoryMasterMaxAggregateOutputType = {
    subCategoryId: string | null
    subCategoryNumber: number | null
    subCategoryName: string | null
    isActive: boolean | null
    description: string | null
    createdAt: Date | null
    propertyCategoryId: string | null
  }

  export type NrPropertySubCategoryMasterCountAggregateOutputType = {
    subCategoryId: number
    subCategoryNumber: number
    subCategoryName: number
    isActive: number
    description: number
    createdAt: number
    propertyCategoryId: number
    _all: number
  }


  export type NrPropertySubCategoryMasterAvgAggregateInputType = {
    subCategoryNumber?: true
  }

  export type NrPropertySubCategoryMasterSumAggregateInputType = {
    subCategoryNumber?: true
  }

  export type NrPropertySubCategoryMasterMinAggregateInputType = {
    subCategoryId?: true
    subCategoryNumber?: true
    subCategoryName?: true
    isActive?: true
    description?: true
    createdAt?: true
    propertyCategoryId?: true
  }

  export type NrPropertySubCategoryMasterMaxAggregateInputType = {
    subCategoryId?: true
    subCategoryNumber?: true
    subCategoryName?: true
    isActive?: true
    description?: true
    createdAt?: true
    propertyCategoryId?: true
  }

  export type NrPropertySubCategoryMasterCountAggregateInputType = {
    subCategoryId?: true
    subCategoryNumber?: true
    subCategoryName?: true
    isActive?: true
    description?: true
    createdAt?: true
    propertyCategoryId?: true
    _all?: true
  }

  export type NrPropertySubCategoryMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NrPropertySubCategoryMaster to aggregate.
     */
    where?: NrPropertySubCategoryMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NrPropertySubCategoryMasters to fetch.
     */
    orderBy?: NrPropertySubCategoryMasterOrderByWithRelationInput | NrPropertySubCategoryMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NrPropertySubCategoryMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NrPropertySubCategoryMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NrPropertySubCategoryMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NrPropertySubCategoryMasters
    **/
    _count?: true | NrPropertySubCategoryMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NrPropertySubCategoryMasterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NrPropertySubCategoryMasterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NrPropertySubCategoryMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NrPropertySubCategoryMasterMaxAggregateInputType
  }

  export type GetNrPropertySubCategoryMasterAggregateType<T extends NrPropertySubCategoryMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateNrPropertySubCategoryMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNrPropertySubCategoryMaster[P]>
      : GetScalarType<T[P], AggregateNrPropertySubCategoryMaster[P]>
  }




  export type NrPropertySubCategoryMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NrPropertySubCategoryMasterWhereInput
    orderBy?: NrPropertySubCategoryMasterOrderByWithAggregationInput | NrPropertySubCategoryMasterOrderByWithAggregationInput[]
    by: NrPropertySubCategoryMasterScalarFieldEnum[] | NrPropertySubCategoryMasterScalarFieldEnum
    having?: NrPropertySubCategoryMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NrPropertySubCategoryMasterCountAggregateInputType | true
    _avg?: NrPropertySubCategoryMasterAvgAggregateInputType
    _sum?: NrPropertySubCategoryMasterSumAggregateInputType
    _min?: NrPropertySubCategoryMasterMinAggregateInputType
    _max?: NrPropertySubCategoryMasterMaxAggregateInputType
  }

  export type NrPropertySubCategoryMasterGroupByOutputType = {
    subCategoryId: string
    subCategoryNumber: number
    subCategoryName: string
    isActive: boolean
    description: string | null
    createdAt: Date
    propertyCategoryId: string
    _count: NrPropertySubCategoryMasterCountAggregateOutputType | null
    _avg: NrPropertySubCategoryMasterAvgAggregateOutputType | null
    _sum: NrPropertySubCategoryMasterSumAggregateOutputType | null
    _min: NrPropertySubCategoryMasterMinAggregateOutputType | null
    _max: NrPropertySubCategoryMasterMaxAggregateOutputType | null
  }

  type GetNrPropertySubCategoryMasterGroupByPayload<T extends NrPropertySubCategoryMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NrPropertySubCategoryMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NrPropertySubCategoryMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NrPropertySubCategoryMasterGroupByOutputType[P]>
            : GetScalarType<T[P], NrPropertySubCategoryMasterGroupByOutputType[P]>
        }
      >
    >


  export type NrPropertySubCategoryMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subCategoryId?: boolean
    subCategoryNumber?: boolean
    subCategoryName?: boolean
    isActive?: boolean
    description?: boolean
    createdAt?: boolean
    propertyCategoryId?: boolean
    propertyCategory?: boolean | NrPropertyCategoryMasterDefaultArgs<ExtArgs>
    nonResidentialPropertyAssessments?: boolean | NrPropertySubCategoryMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs>
    _count?: boolean | NrPropertySubCategoryMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nrPropertySubCategoryMaster"]>

  export type NrPropertySubCategoryMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subCategoryId?: boolean
    subCategoryNumber?: boolean
    subCategoryName?: boolean
    isActive?: boolean
    description?: boolean
    createdAt?: boolean
    propertyCategoryId?: boolean
    propertyCategory?: boolean | NrPropertyCategoryMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nrPropertySubCategoryMaster"]>

  export type NrPropertySubCategoryMasterSelectScalar = {
    subCategoryId?: boolean
    subCategoryNumber?: boolean
    subCategoryName?: boolean
    isActive?: boolean
    description?: boolean
    createdAt?: boolean
    propertyCategoryId?: boolean
  }

  export type NrPropertySubCategoryMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyCategory?: boolean | NrPropertyCategoryMasterDefaultArgs<ExtArgs>
    nonResidentialPropertyAssessments?: boolean | NrPropertySubCategoryMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs>
    _count?: boolean | NrPropertySubCategoryMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NrPropertySubCategoryMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyCategory?: boolean | NrPropertyCategoryMasterDefaultArgs<ExtArgs>
  }

  export type $NrPropertySubCategoryMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NrPropertySubCategoryMaster"
    objects: {
      propertyCategory: Prisma.$NrPropertyCategoryMasterPayload<ExtArgs>
      nonResidentialPropertyAssessments: Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      subCategoryId: string
      subCategoryNumber: number
      subCategoryName: string
      isActive: boolean
      description: string | null
      createdAt: Date
      propertyCategoryId: string
    }, ExtArgs["result"]["nrPropertySubCategoryMaster"]>
    composites: {}
  }

  type NrPropertySubCategoryMasterGetPayload<S extends boolean | null | undefined | NrPropertySubCategoryMasterDefaultArgs> = $Result.GetResult<Prisma.$NrPropertySubCategoryMasterPayload, S>

  type NrPropertySubCategoryMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NrPropertySubCategoryMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NrPropertySubCategoryMasterCountAggregateInputType | true
    }

  export interface NrPropertySubCategoryMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NrPropertySubCategoryMaster'], meta: { name: 'NrPropertySubCategoryMaster' } }
    /**
     * Find zero or one NrPropertySubCategoryMaster that matches the filter.
     * @param {NrPropertySubCategoryMasterFindUniqueArgs} args - Arguments to find a NrPropertySubCategoryMaster
     * @example
     * // Get one NrPropertySubCategoryMaster
     * const nrPropertySubCategoryMaster = await prisma.nrPropertySubCategoryMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NrPropertySubCategoryMasterFindUniqueArgs>(args: SelectSubset<T, NrPropertySubCategoryMasterFindUniqueArgs<ExtArgs>>): Prisma__NrPropertySubCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertySubCategoryMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NrPropertySubCategoryMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NrPropertySubCategoryMasterFindUniqueOrThrowArgs} args - Arguments to find a NrPropertySubCategoryMaster
     * @example
     * // Get one NrPropertySubCategoryMaster
     * const nrPropertySubCategoryMaster = await prisma.nrPropertySubCategoryMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NrPropertySubCategoryMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, NrPropertySubCategoryMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NrPropertySubCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertySubCategoryMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NrPropertySubCategoryMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NrPropertySubCategoryMasterFindFirstArgs} args - Arguments to find a NrPropertySubCategoryMaster
     * @example
     * // Get one NrPropertySubCategoryMaster
     * const nrPropertySubCategoryMaster = await prisma.nrPropertySubCategoryMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NrPropertySubCategoryMasterFindFirstArgs>(args?: SelectSubset<T, NrPropertySubCategoryMasterFindFirstArgs<ExtArgs>>): Prisma__NrPropertySubCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertySubCategoryMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NrPropertySubCategoryMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NrPropertySubCategoryMasterFindFirstOrThrowArgs} args - Arguments to find a NrPropertySubCategoryMaster
     * @example
     * // Get one NrPropertySubCategoryMaster
     * const nrPropertySubCategoryMaster = await prisma.nrPropertySubCategoryMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NrPropertySubCategoryMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, NrPropertySubCategoryMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__NrPropertySubCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertySubCategoryMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NrPropertySubCategoryMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NrPropertySubCategoryMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NrPropertySubCategoryMasters
     * const nrPropertySubCategoryMasters = await prisma.nrPropertySubCategoryMaster.findMany()
     * 
     * // Get first 10 NrPropertySubCategoryMasters
     * const nrPropertySubCategoryMasters = await prisma.nrPropertySubCategoryMaster.findMany({ take: 10 })
     * 
     * // Only select the `subCategoryId`
     * const nrPropertySubCategoryMasterWithSubCategoryIdOnly = await prisma.nrPropertySubCategoryMaster.findMany({ select: { subCategoryId: true } })
     * 
     */
    findMany<T extends NrPropertySubCategoryMasterFindManyArgs>(args?: SelectSubset<T, NrPropertySubCategoryMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NrPropertySubCategoryMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NrPropertySubCategoryMaster.
     * @param {NrPropertySubCategoryMasterCreateArgs} args - Arguments to create a NrPropertySubCategoryMaster.
     * @example
     * // Create one NrPropertySubCategoryMaster
     * const NrPropertySubCategoryMaster = await prisma.nrPropertySubCategoryMaster.create({
     *   data: {
     *     // ... data to create a NrPropertySubCategoryMaster
     *   }
     * })
     * 
     */
    create<T extends NrPropertySubCategoryMasterCreateArgs>(args: SelectSubset<T, NrPropertySubCategoryMasterCreateArgs<ExtArgs>>): Prisma__NrPropertySubCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertySubCategoryMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NrPropertySubCategoryMasters.
     * @param {NrPropertySubCategoryMasterCreateManyArgs} args - Arguments to create many NrPropertySubCategoryMasters.
     * @example
     * // Create many NrPropertySubCategoryMasters
     * const nrPropertySubCategoryMaster = await prisma.nrPropertySubCategoryMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NrPropertySubCategoryMasterCreateManyArgs>(args?: SelectSubset<T, NrPropertySubCategoryMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NrPropertySubCategoryMasters and returns the data saved in the database.
     * @param {NrPropertySubCategoryMasterCreateManyAndReturnArgs} args - Arguments to create many NrPropertySubCategoryMasters.
     * @example
     * // Create many NrPropertySubCategoryMasters
     * const nrPropertySubCategoryMaster = await prisma.nrPropertySubCategoryMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NrPropertySubCategoryMasters and only return the `subCategoryId`
     * const nrPropertySubCategoryMasterWithSubCategoryIdOnly = await prisma.nrPropertySubCategoryMaster.createManyAndReturn({ 
     *   select: { subCategoryId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NrPropertySubCategoryMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, NrPropertySubCategoryMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NrPropertySubCategoryMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NrPropertySubCategoryMaster.
     * @param {NrPropertySubCategoryMasterDeleteArgs} args - Arguments to delete one NrPropertySubCategoryMaster.
     * @example
     * // Delete one NrPropertySubCategoryMaster
     * const NrPropertySubCategoryMaster = await prisma.nrPropertySubCategoryMaster.delete({
     *   where: {
     *     // ... filter to delete one NrPropertySubCategoryMaster
     *   }
     * })
     * 
     */
    delete<T extends NrPropertySubCategoryMasterDeleteArgs>(args: SelectSubset<T, NrPropertySubCategoryMasterDeleteArgs<ExtArgs>>): Prisma__NrPropertySubCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertySubCategoryMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NrPropertySubCategoryMaster.
     * @param {NrPropertySubCategoryMasterUpdateArgs} args - Arguments to update one NrPropertySubCategoryMaster.
     * @example
     * // Update one NrPropertySubCategoryMaster
     * const nrPropertySubCategoryMaster = await prisma.nrPropertySubCategoryMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NrPropertySubCategoryMasterUpdateArgs>(args: SelectSubset<T, NrPropertySubCategoryMasterUpdateArgs<ExtArgs>>): Prisma__NrPropertySubCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertySubCategoryMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NrPropertySubCategoryMasters.
     * @param {NrPropertySubCategoryMasterDeleteManyArgs} args - Arguments to filter NrPropertySubCategoryMasters to delete.
     * @example
     * // Delete a few NrPropertySubCategoryMasters
     * const { count } = await prisma.nrPropertySubCategoryMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NrPropertySubCategoryMasterDeleteManyArgs>(args?: SelectSubset<T, NrPropertySubCategoryMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NrPropertySubCategoryMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NrPropertySubCategoryMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NrPropertySubCategoryMasters
     * const nrPropertySubCategoryMaster = await prisma.nrPropertySubCategoryMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NrPropertySubCategoryMasterUpdateManyArgs>(args: SelectSubset<T, NrPropertySubCategoryMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NrPropertySubCategoryMaster.
     * @param {NrPropertySubCategoryMasterUpsertArgs} args - Arguments to update or create a NrPropertySubCategoryMaster.
     * @example
     * // Update or create a NrPropertySubCategoryMaster
     * const nrPropertySubCategoryMaster = await prisma.nrPropertySubCategoryMaster.upsert({
     *   create: {
     *     // ... data to create a NrPropertySubCategoryMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NrPropertySubCategoryMaster we want to update
     *   }
     * })
     */
    upsert<T extends NrPropertySubCategoryMasterUpsertArgs>(args: SelectSubset<T, NrPropertySubCategoryMasterUpsertArgs<ExtArgs>>): Prisma__NrPropertySubCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertySubCategoryMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NrPropertySubCategoryMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NrPropertySubCategoryMasterCountArgs} args - Arguments to filter NrPropertySubCategoryMasters to count.
     * @example
     * // Count the number of NrPropertySubCategoryMasters
     * const count = await prisma.nrPropertySubCategoryMaster.count({
     *   where: {
     *     // ... the filter for the NrPropertySubCategoryMasters we want to count
     *   }
     * })
    **/
    count<T extends NrPropertySubCategoryMasterCountArgs>(
      args?: Subset<T, NrPropertySubCategoryMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NrPropertySubCategoryMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NrPropertySubCategoryMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NrPropertySubCategoryMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NrPropertySubCategoryMasterAggregateArgs>(args: Subset<T, NrPropertySubCategoryMasterAggregateArgs>): Prisma.PrismaPromise<GetNrPropertySubCategoryMasterAggregateType<T>>

    /**
     * Group by NrPropertySubCategoryMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NrPropertySubCategoryMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NrPropertySubCategoryMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NrPropertySubCategoryMasterGroupByArgs['orderBy'] }
        : { orderBy?: NrPropertySubCategoryMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NrPropertySubCategoryMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNrPropertySubCategoryMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NrPropertySubCategoryMaster model
   */
  readonly fields: NrPropertySubCategoryMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NrPropertySubCategoryMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NrPropertySubCategoryMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    propertyCategory<T extends NrPropertyCategoryMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NrPropertyCategoryMasterDefaultArgs<ExtArgs>>): Prisma__NrPropertyCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertyCategoryMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    nonResidentialPropertyAssessments<T extends NrPropertySubCategoryMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs> = {}>(args?: Subset<T, NrPropertySubCategoryMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NrPropertySubCategoryMaster model
   */ 
  interface NrPropertySubCategoryMasterFieldRefs {
    readonly subCategoryId: FieldRef<"NrPropertySubCategoryMaster", 'String'>
    readonly subCategoryNumber: FieldRef<"NrPropertySubCategoryMaster", 'Int'>
    readonly subCategoryName: FieldRef<"NrPropertySubCategoryMaster", 'String'>
    readonly isActive: FieldRef<"NrPropertySubCategoryMaster", 'Boolean'>
    readonly description: FieldRef<"NrPropertySubCategoryMaster", 'String'>
    readonly createdAt: FieldRef<"NrPropertySubCategoryMaster", 'DateTime'>
    readonly propertyCategoryId: FieldRef<"NrPropertySubCategoryMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NrPropertySubCategoryMaster findUnique
   */
  export type NrPropertySubCategoryMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertySubCategoryMaster
     */
    select?: NrPropertySubCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertySubCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter, which NrPropertySubCategoryMaster to fetch.
     */
    where: NrPropertySubCategoryMasterWhereUniqueInput
  }

  /**
   * NrPropertySubCategoryMaster findUniqueOrThrow
   */
  export type NrPropertySubCategoryMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertySubCategoryMaster
     */
    select?: NrPropertySubCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertySubCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter, which NrPropertySubCategoryMaster to fetch.
     */
    where: NrPropertySubCategoryMasterWhereUniqueInput
  }

  /**
   * NrPropertySubCategoryMaster findFirst
   */
  export type NrPropertySubCategoryMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertySubCategoryMaster
     */
    select?: NrPropertySubCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertySubCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter, which NrPropertySubCategoryMaster to fetch.
     */
    where?: NrPropertySubCategoryMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NrPropertySubCategoryMasters to fetch.
     */
    orderBy?: NrPropertySubCategoryMasterOrderByWithRelationInput | NrPropertySubCategoryMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NrPropertySubCategoryMasters.
     */
    cursor?: NrPropertySubCategoryMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NrPropertySubCategoryMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NrPropertySubCategoryMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NrPropertySubCategoryMasters.
     */
    distinct?: NrPropertySubCategoryMasterScalarFieldEnum | NrPropertySubCategoryMasterScalarFieldEnum[]
  }

  /**
   * NrPropertySubCategoryMaster findFirstOrThrow
   */
  export type NrPropertySubCategoryMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertySubCategoryMaster
     */
    select?: NrPropertySubCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertySubCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter, which NrPropertySubCategoryMaster to fetch.
     */
    where?: NrPropertySubCategoryMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NrPropertySubCategoryMasters to fetch.
     */
    orderBy?: NrPropertySubCategoryMasterOrderByWithRelationInput | NrPropertySubCategoryMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NrPropertySubCategoryMasters.
     */
    cursor?: NrPropertySubCategoryMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NrPropertySubCategoryMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NrPropertySubCategoryMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NrPropertySubCategoryMasters.
     */
    distinct?: NrPropertySubCategoryMasterScalarFieldEnum | NrPropertySubCategoryMasterScalarFieldEnum[]
  }

  /**
   * NrPropertySubCategoryMaster findMany
   */
  export type NrPropertySubCategoryMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertySubCategoryMaster
     */
    select?: NrPropertySubCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertySubCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter, which NrPropertySubCategoryMasters to fetch.
     */
    where?: NrPropertySubCategoryMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NrPropertySubCategoryMasters to fetch.
     */
    orderBy?: NrPropertySubCategoryMasterOrderByWithRelationInput | NrPropertySubCategoryMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NrPropertySubCategoryMasters.
     */
    cursor?: NrPropertySubCategoryMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NrPropertySubCategoryMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NrPropertySubCategoryMasters.
     */
    skip?: number
    distinct?: NrPropertySubCategoryMasterScalarFieldEnum | NrPropertySubCategoryMasterScalarFieldEnum[]
  }

  /**
   * NrPropertySubCategoryMaster create
   */
  export type NrPropertySubCategoryMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertySubCategoryMaster
     */
    select?: NrPropertySubCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertySubCategoryMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a NrPropertySubCategoryMaster.
     */
    data: XOR<NrPropertySubCategoryMasterCreateInput, NrPropertySubCategoryMasterUncheckedCreateInput>
  }

  /**
   * NrPropertySubCategoryMaster createMany
   */
  export type NrPropertySubCategoryMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NrPropertySubCategoryMasters.
     */
    data: NrPropertySubCategoryMasterCreateManyInput | NrPropertySubCategoryMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NrPropertySubCategoryMaster createManyAndReturn
   */
  export type NrPropertySubCategoryMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertySubCategoryMaster
     */
    select?: NrPropertySubCategoryMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NrPropertySubCategoryMasters.
     */
    data: NrPropertySubCategoryMasterCreateManyInput | NrPropertySubCategoryMasterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertySubCategoryMasterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NrPropertySubCategoryMaster update
   */
  export type NrPropertySubCategoryMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertySubCategoryMaster
     */
    select?: NrPropertySubCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertySubCategoryMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a NrPropertySubCategoryMaster.
     */
    data: XOR<NrPropertySubCategoryMasterUpdateInput, NrPropertySubCategoryMasterUncheckedUpdateInput>
    /**
     * Choose, which NrPropertySubCategoryMaster to update.
     */
    where: NrPropertySubCategoryMasterWhereUniqueInput
  }

  /**
   * NrPropertySubCategoryMaster updateMany
   */
  export type NrPropertySubCategoryMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NrPropertySubCategoryMasters.
     */
    data: XOR<NrPropertySubCategoryMasterUpdateManyMutationInput, NrPropertySubCategoryMasterUncheckedUpdateManyInput>
    /**
     * Filter which NrPropertySubCategoryMasters to update
     */
    where?: NrPropertySubCategoryMasterWhereInput
  }

  /**
   * NrPropertySubCategoryMaster upsert
   */
  export type NrPropertySubCategoryMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertySubCategoryMaster
     */
    select?: NrPropertySubCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertySubCategoryMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the NrPropertySubCategoryMaster to update in case it exists.
     */
    where: NrPropertySubCategoryMasterWhereUniqueInput
    /**
     * In case the NrPropertySubCategoryMaster found by the `where` argument doesn't exist, create a new NrPropertySubCategoryMaster with this data.
     */
    create: XOR<NrPropertySubCategoryMasterCreateInput, NrPropertySubCategoryMasterUncheckedCreateInput>
    /**
     * In case the NrPropertySubCategoryMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NrPropertySubCategoryMasterUpdateInput, NrPropertySubCategoryMasterUncheckedUpdateInput>
  }

  /**
   * NrPropertySubCategoryMaster delete
   */
  export type NrPropertySubCategoryMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertySubCategoryMaster
     */
    select?: NrPropertySubCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertySubCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter which NrPropertySubCategoryMaster to delete.
     */
    where: NrPropertySubCategoryMasterWhereUniqueInput
  }

  /**
   * NrPropertySubCategoryMaster deleteMany
   */
  export type NrPropertySubCategoryMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NrPropertySubCategoryMasters to delete
     */
    where?: NrPropertySubCategoryMasterWhereInput
  }

  /**
   * NrPropertySubCategoryMaster.nonResidentialPropertyAssessments
   */
  export type NrPropertySubCategoryMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonResidentialPropertyAssessment
     */
    select?: NonResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonResidentialPropertyAssessmentInclude<ExtArgs> | null
    where?: NonResidentialPropertyAssessmentWhereInput
    orderBy?: NonResidentialPropertyAssessmentOrderByWithRelationInput | NonResidentialPropertyAssessmentOrderByWithRelationInput[]
    cursor?: NonResidentialPropertyAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NonResidentialPropertyAssessmentScalarFieldEnum | NonResidentialPropertyAssessmentScalarFieldEnum[]
  }

  /**
   * NrPropertySubCategoryMaster without action
   */
  export type NrPropertySubCategoryMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NrPropertySubCategoryMaster
     */
    select?: NrPropertySubCategoryMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NrPropertySubCategoryMasterInclude<ExtArgs> | null
  }


  /**
   * Model ConstructionNatureMaster
   */

  export type AggregateConstructionNatureMaster = {
    _count: ConstructionNatureMasterCountAggregateOutputType | null
    _min: ConstructionNatureMasterMinAggregateOutputType | null
    _max: ConstructionNatureMasterMaxAggregateOutputType | null
  }

  export type ConstructionNatureMasterMinAggregateOutputType = {
    constructionNatureId: string | null
    constructionNatureName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type ConstructionNatureMasterMaxAggregateOutputType = {
    constructionNatureId: string | null
    constructionNatureName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type ConstructionNatureMasterCountAggregateOutputType = {
    constructionNatureId: number
    constructionNatureName: number
    isActive: number
    description: number
    _all: number
  }


  export type ConstructionNatureMasterMinAggregateInputType = {
    constructionNatureId?: true
    constructionNatureName?: true
    isActive?: true
    description?: true
  }

  export type ConstructionNatureMasterMaxAggregateInputType = {
    constructionNatureId?: true
    constructionNatureName?: true
    isActive?: true
    description?: true
  }

  export type ConstructionNatureMasterCountAggregateInputType = {
    constructionNatureId?: true
    constructionNatureName?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type ConstructionNatureMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConstructionNatureMaster to aggregate.
     */
    where?: ConstructionNatureMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionNatureMasters to fetch.
     */
    orderBy?: ConstructionNatureMasterOrderByWithRelationInput | ConstructionNatureMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConstructionNatureMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionNatureMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionNatureMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConstructionNatureMasters
    **/
    _count?: true | ConstructionNatureMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConstructionNatureMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConstructionNatureMasterMaxAggregateInputType
  }

  export type GetConstructionNatureMasterAggregateType<T extends ConstructionNatureMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateConstructionNatureMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConstructionNatureMaster[P]>
      : GetScalarType<T[P], AggregateConstructionNatureMaster[P]>
  }




  export type ConstructionNatureMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConstructionNatureMasterWhereInput
    orderBy?: ConstructionNatureMasterOrderByWithAggregationInput | ConstructionNatureMasterOrderByWithAggregationInput[]
    by: ConstructionNatureMasterScalarFieldEnum[] | ConstructionNatureMasterScalarFieldEnum
    having?: ConstructionNatureMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConstructionNatureMasterCountAggregateInputType | true
    _min?: ConstructionNatureMasterMinAggregateInputType
    _max?: ConstructionNatureMasterMaxAggregateInputType
  }

  export type ConstructionNatureMasterGroupByOutputType = {
    constructionNatureId: string
    constructionNatureName: string
    isActive: boolean
    description: string | null
    _count: ConstructionNatureMasterCountAggregateOutputType | null
    _min: ConstructionNatureMasterMinAggregateOutputType | null
    _max: ConstructionNatureMasterMaxAggregateOutputType | null
  }

  type GetConstructionNatureMasterGroupByPayload<T extends ConstructionNatureMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConstructionNatureMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConstructionNatureMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConstructionNatureMasterGroupByOutputType[P]>
            : GetScalarType<T[P], ConstructionNatureMasterGroupByOutputType[P]>
        }
      >
    >


  export type ConstructionNatureMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    constructionNatureId?: boolean
    constructionNatureName?: boolean
    isActive?: boolean
    description?: boolean
    residentialPropertyAssessments?: boolean | ConstructionNatureMaster$residentialPropertyAssessmentsArgs<ExtArgs>
    nonResidentialPropertyAssessments?: boolean | ConstructionNatureMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs>
    _count?: boolean | ConstructionNatureMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["constructionNatureMaster"]>

  export type ConstructionNatureMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    constructionNatureId?: boolean
    constructionNatureName?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["constructionNatureMaster"]>

  export type ConstructionNatureMasterSelectScalar = {
    constructionNatureId?: boolean
    constructionNatureName?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type ConstructionNatureMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    residentialPropertyAssessments?: boolean | ConstructionNatureMaster$residentialPropertyAssessmentsArgs<ExtArgs>
    nonResidentialPropertyAssessments?: boolean | ConstructionNatureMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs>
    _count?: boolean | ConstructionNatureMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConstructionNatureMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ConstructionNatureMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConstructionNatureMaster"
    objects: {
      residentialPropertyAssessments: Prisma.$ResidentialPropertyAssessmentPayload<ExtArgs>[]
      nonResidentialPropertyAssessments: Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      constructionNatureId: string
      constructionNatureName: string
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["constructionNatureMaster"]>
    composites: {}
  }

  type ConstructionNatureMasterGetPayload<S extends boolean | null | undefined | ConstructionNatureMasterDefaultArgs> = $Result.GetResult<Prisma.$ConstructionNatureMasterPayload, S>

  type ConstructionNatureMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConstructionNatureMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConstructionNatureMasterCountAggregateInputType | true
    }

  export interface ConstructionNatureMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConstructionNatureMaster'], meta: { name: 'ConstructionNatureMaster' } }
    /**
     * Find zero or one ConstructionNatureMaster that matches the filter.
     * @param {ConstructionNatureMasterFindUniqueArgs} args - Arguments to find a ConstructionNatureMaster
     * @example
     * // Get one ConstructionNatureMaster
     * const constructionNatureMaster = await prisma.constructionNatureMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConstructionNatureMasterFindUniqueArgs>(args: SelectSubset<T, ConstructionNatureMasterFindUniqueArgs<ExtArgs>>): Prisma__ConstructionNatureMasterClient<$Result.GetResult<Prisma.$ConstructionNatureMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConstructionNatureMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConstructionNatureMasterFindUniqueOrThrowArgs} args - Arguments to find a ConstructionNatureMaster
     * @example
     * // Get one ConstructionNatureMaster
     * const constructionNatureMaster = await prisma.constructionNatureMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConstructionNatureMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, ConstructionNatureMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConstructionNatureMasterClient<$Result.GetResult<Prisma.$ConstructionNatureMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConstructionNatureMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionNatureMasterFindFirstArgs} args - Arguments to find a ConstructionNatureMaster
     * @example
     * // Get one ConstructionNatureMaster
     * const constructionNatureMaster = await prisma.constructionNatureMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConstructionNatureMasterFindFirstArgs>(args?: SelectSubset<T, ConstructionNatureMasterFindFirstArgs<ExtArgs>>): Prisma__ConstructionNatureMasterClient<$Result.GetResult<Prisma.$ConstructionNatureMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConstructionNatureMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionNatureMasterFindFirstOrThrowArgs} args - Arguments to find a ConstructionNatureMaster
     * @example
     * // Get one ConstructionNatureMaster
     * const constructionNatureMaster = await prisma.constructionNatureMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConstructionNatureMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, ConstructionNatureMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConstructionNatureMasterClient<$Result.GetResult<Prisma.$ConstructionNatureMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConstructionNatureMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionNatureMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConstructionNatureMasters
     * const constructionNatureMasters = await prisma.constructionNatureMaster.findMany()
     * 
     * // Get first 10 ConstructionNatureMasters
     * const constructionNatureMasters = await prisma.constructionNatureMaster.findMany({ take: 10 })
     * 
     * // Only select the `constructionNatureId`
     * const constructionNatureMasterWithConstructionNatureIdOnly = await prisma.constructionNatureMaster.findMany({ select: { constructionNatureId: true } })
     * 
     */
    findMany<T extends ConstructionNatureMasterFindManyArgs>(args?: SelectSubset<T, ConstructionNatureMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionNatureMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConstructionNatureMaster.
     * @param {ConstructionNatureMasterCreateArgs} args - Arguments to create a ConstructionNatureMaster.
     * @example
     * // Create one ConstructionNatureMaster
     * const ConstructionNatureMaster = await prisma.constructionNatureMaster.create({
     *   data: {
     *     // ... data to create a ConstructionNatureMaster
     *   }
     * })
     * 
     */
    create<T extends ConstructionNatureMasterCreateArgs>(args: SelectSubset<T, ConstructionNatureMasterCreateArgs<ExtArgs>>): Prisma__ConstructionNatureMasterClient<$Result.GetResult<Prisma.$ConstructionNatureMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConstructionNatureMasters.
     * @param {ConstructionNatureMasterCreateManyArgs} args - Arguments to create many ConstructionNatureMasters.
     * @example
     * // Create many ConstructionNatureMasters
     * const constructionNatureMaster = await prisma.constructionNatureMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConstructionNatureMasterCreateManyArgs>(args?: SelectSubset<T, ConstructionNatureMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConstructionNatureMasters and returns the data saved in the database.
     * @param {ConstructionNatureMasterCreateManyAndReturnArgs} args - Arguments to create many ConstructionNatureMasters.
     * @example
     * // Create many ConstructionNatureMasters
     * const constructionNatureMaster = await prisma.constructionNatureMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConstructionNatureMasters and only return the `constructionNatureId`
     * const constructionNatureMasterWithConstructionNatureIdOnly = await prisma.constructionNatureMaster.createManyAndReturn({ 
     *   select: { constructionNatureId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConstructionNatureMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, ConstructionNatureMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionNatureMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConstructionNatureMaster.
     * @param {ConstructionNatureMasterDeleteArgs} args - Arguments to delete one ConstructionNatureMaster.
     * @example
     * // Delete one ConstructionNatureMaster
     * const ConstructionNatureMaster = await prisma.constructionNatureMaster.delete({
     *   where: {
     *     // ... filter to delete one ConstructionNatureMaster
     *   }
     * })
     * 
     */
    delete<T extends ConstructionNatureMasterDeleteArgs>(args: SelectSubset<T, ConstructionNatureMasterDeleteArgs<ExtArgs>>): Prisma__ConstructionNatureMasterClient<$Result.GetResult<Prisma.$ConstructionNatureMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConstructionNatureMaster.
     * @param {ConstructionNatureMasterUpdateArgs} args - Arguments to update one ConstructionNatureMaster.
     * @example
     * // Update one ConstructionNatureMaster
     * const constructionNatureMaster = await prisma.constructionNatureMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConstructionNatureMasterUpdateArgs>(args: SelectSubset<T, ConstructionNatureMasterUpdateArgs<ExtArgs>>): Prisma__ConstructionNatureMasterClient<$Result.GetResult<Prisma.$ConstructionNatureMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConstructionNatureMasters.
     * @param {ConstructionNatureMasterDeleteManyArgs} args - Arguments to filter ConstructionNatureMasters to delete.
     * @example
     * // Delete a few ConstructionNatureMasters
     * const { count } = await prisma.constructionNatureMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConstructionNatureMasterDeleteManyArgs>(args?: SelectSubset<T, ConstructionNatureMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConstructionNatureMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionNatureMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConstructionNatureMasters
     * const constructionNatureMaster = await prisma.constructionNatureMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConstructionNatureMasterUpdateManyArgs>(args: SelectSubset<T, ConstructionNatureMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConstructionNatureMaster.
     * @param {ConstructionNatureMasterUpsertArgs} args - Arguments to update or create a ConstructionNatureMaster.
     * @example
     * // Update or create a ConstructionNatureMaster
     * const constructionNatureMaster = await prisma.constructionNatureMaster.upsert({
     *   create: {
     *     // ... data to create a ConstructionNatureMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConstructionNatureMaster we want to update
     *   }
     * })
     */
    upsert<T extends ConstructionNatureMasterUpsertArgs>(args: SelectSubset<T, ConstructionNatureMasterUpsertArgs<ExtArgs>>): Prisma__ConstructionNatureMasterClient<$Result.GetResult<Prisma.$ConstructionNatureMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConstructionNatureMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionNatureMasterCountArgs} args - Arguments to filter ConstructionNatureMasters to count.
     * @example
     * // Count the number of ConstructionNatureMasters
     * const count = await prisma.constructionNatureMaster.count({
     *   where: {
     *     // ... the filter for the ConstructionNatureMasters we want to count
     *   }
     * })
    **/
    count<T extends ConstructionNatureMasterCountArgs>(
      args?: Subset<T, ConstructionNatureMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConstructionNatureMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConstructionNatureMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionNatureMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConstructionNatureMasterAggregateArgs>(args: Subset<T, ConstructionNatureMasterAggregateArgs>): Prisma.PrismaPromise<GetConstructionNatureMasterAggregateType<T>>

    /**
     * Group by ConstructionNatureMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionNatureMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConstructionNatureMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConstructionNatureMasterGroupByArgs['orderBy'] }
        : { orderBy?: ConstructionNatureMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConstructionNatureMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConstructionNatureMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConstructionNatureMaster model
   */
  readonly fields: ConstructionNatureMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConstructionNatureMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConstructionNatureMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    residentialPropertyAssessments<T extends ConstructionNatureMaster$residentialPropertyAssessmentsArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionNatureMaster$residentialPropertyAssessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResidentialPropertyAssessmentPayload<ExtArgs>, T, "findMany"> | Null>
    nonResidentialPropertyAssessments<T extends ConstructionNatureMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionNatureMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConstructionNatureMaster model
   */ 
  interface ConstructionNatureMasterFieldRefs {
    readonly constructionNatureId: FieldRef<"ConstructionNatureMaster", 'String'>
    readonly constructionNatureName: FieldRef<"ConstructionNatureMaster", 'String'>
    readonly isActive: FieldRef<"ConstructionNatureMaster", 'Boolean'>
    readonly description: FieldRef<"ConstructionNatureMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConstructionNatureMaster findUnique
   */
  export type ConstructionNatureMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionNatureMaster
     */
    select?: ConstructionNatureMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionNatureMasterInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionNatureMaster to fetch.
     */
    where: ConstructionNatureMasterWhereUniqueInput
  }

  /**
   * ConstructionNatureMaster findUniqueOrThrow
   */
  export type ConstructionNatureMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionNatureMaster
     */
    select?: ConstructionNatureMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionNatureMasterInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionNatureMaster to fetch.
     */
    where: ConstructionNatureMasterWhereUniqueInput
  }

  /**
   * ConstructionNatureMaster findFirst
   */
  export type ConstructionNatureMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionNatureMaster
     */
    select?: ConstructionNatureMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionNatureMasterInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionNatureMaster to fetch.
     */
    where?: ConstructionNatureMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionNatureMasters to fetch.
     */
    orderBy?: ConstructionNatureMasterOrderByWithRelationInput | ConstructionNatureMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConstructionNatureMasters.
     */
    cursor?: ConstructionNatureMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionNatureMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionNatureMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConstructionNatureMasters.
     */
    distinct?: ConstructionNatureMasterScalarFieldEnum | ConstructionNatureMasterScalarFieldEnum[]
  }

  /**
   * ConstructionNatureMaster findFirstOrThrow
   */
  export type ConstructionNatureMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionNatureMaster
     */
    select?: ConstructionNatureMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionNatureMasterInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionNatureMaster to fetch.
     */
    where?: ConstructionNatureMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionNatureMasters to fetch.
     */
    orderBy?: ConstructionNatureMasterOrderByWithRelationInput | ConstructionNatureMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConstructionNatureMasters.
     */
    cursor?: ConstructionNatureMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionNatureMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionNatureMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConstructionNatureMasters.
     */
    distinct?: ConstructionNatureMasterScalarFieldEnum | ConstructionNatureMasterScalarFieldEnum[]
  }

  /**
   * ConstructionNatureMaster findMany
   */
  export type ConstructionNatureMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionNatureMaster
     */
    select?: ConstructionNatureMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionNatureMasterInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionNatureMasters to fetch.
     */
    where?: ConstructionNatureMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionNatureMasters to fetch.
     */
    orderBy?: ConstructionNatureMasterOrderByWithRelationInput | ConstructionNatureMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConstructionNatureMasters.
     */
    cursor?: ConstructionNatureMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionNatureMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionNatureMasters.
     */
    skip?: number
    distinct?: ConstructionNatureMasterScalarFieldEnum | ConstructionNatureMasterScalarFieldEnum[]
  }

  /**
   * ConstructionNatureMaster create
   */
  export type ConstructionNatureMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionNatureMaster
     */
    select?: ConstructionNatureMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionNatureMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a ConstructionNatureMaster.
     */
    data: XOR<ConstructionNatureMasterCreateInput, ConstructionNatureMasterUncheckedCreateInput>
  }

  /**
   * ConstructionNatureMaster createMany
   */
  export type ConstructionNatureMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConstructionNatureMasters.
     */
    data: ConstructionNatureMasterCreateManyInput | ConstructionNatureMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConstructionNatureMaster createManyAndReturn
   */
  export type ConstructionNatureMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionNatureMaster
     */
    select?: ConstructionNatureMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConstructionNatureMasters.
     */
    data: ConstructionNatureMasterCreateManyInput | ConstructionNatureMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConstructionNatureMaster update
   */
  export type ConstructionNatureMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionNatureMaster
     */
    select?: ConstructionNatureMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionNatureMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a ConstructionNatureMaster.
     */
    data: XOR<ConstructionNatureMasterUpdateInput, ConstructionNatureMasterUncheckedUpdateInput>
    /**
     * Choose, which ConstructionNatureMaster to update.
     */
    where: ConstructionNatureMasterWhereUniqueInput
  }

  /**
   * ConstructionNatureMaster updateMany
   */
  export type ConstructionNatureMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConstructionNatureMasters.
     */
    data: XOR<ConstructionNatureMasterUpdateManyMutationInput, ConstructionNatureMasterUncheckedUpdateManyInput>
    /**
     * Filter which ConstructionNatureMasters to update
     */
    where?: ConstructionNatureMasterWhereInput
  }

  /**
   * ConstructionNatureMaster upsert
   */
  export type ConstructionNatureMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionNatureMaster
     */
    select?: ConstructionNatureMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionNatureMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the ConstructionNatureMaster to update in case it exists.
     */
    where: ConstructionNatureMasterWhereUniqueInput
    /**
     * In case the ConstructionNatureMaster found by the `where` argument doesn't exist, create a new ConstructionNatureMaster with this data.
     */
    create: XOR<ConstructionNatureMasterCreateInput, ConstructionNatureMasterUncheckedCreateInput>
    /**
     * In case the ConstructionNatureMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConstructionNatureMasterUpdateInput, ConstructionNatureMasterUncheckedUpdateInput>
  }

  /**
   * ConstructionNatureMaster delete
   */
  export type ConstructionNatureMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionNatureMaster
     */
    select?: ConstructionNatureMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionNatureMasterInclude<ExtArgs> | null
    /**
     * Filter which ConstructionNatureMaster to delete.
     */
    where: ConstructionNatureMasterWhereUniqueInput
  }

  /**
   * ConstructionNatureMaster deleteMany
   */
  export type ConstructionNatureMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConstructionNatureMasters to delete
     */
    where?: ConstructionNatureMasterWhereInput
  }

  /**
   * ConstructionNatureMaster.residentialPropertyAssessments
   */
  export type ConstructionNatureMaster$residentialPropertyAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidentialPropertyAssessment
     */
    select?: ResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentialPropertyAssessmentInclude<ExtArgs> | null
    where?: ResidentialPropertyAssessmentWhereInput
    orderBy?: ResidentialPropertyAssessmentOrderByWithRelationInput | ResidentialPropertyAssessmentOrderByWithRelationInput[]
    cursor?: ResidentialPropertyAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResidentialPropertyAssessmentScalarFieldEnum | ResidentialPropertyAssessmentScalarFieldEnum[]
  }

  /**
   * ConstructionNatureMaster.nonResidentialPropertyAssessments
   */
  export type ConstructionNatureMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonResidentialPropertyAssessment
     */
    select?: NonResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonResidentialPropertyAssessmentInclude<ExtArgs> | null
    where?: NonResidentialPropertyAssessmentWhereInput
    orderBy?: NonResidentialPropertyAssessmentOrderByWithRelationInput | NonResidentialPropertyAssessmentOrderByWithRelationInput[]
    cursor?: NonResidentialPropertyAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NonResidentialPropertyAssessmentScalarFieldEnum | NonResidentialPropertyAssessmentScalarFieldEnum[]
  }

  /**
   * ConstructionNatureMaster without action
   */
  export type ConstructionNatureMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionNatureMaster
     */
    select?: ConstructionNatureMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionNatureMasterInclude<ExtArgs> | null
  }


  /**
   * Model SurveyTypeMaster
   */

  export type AggregateSurveyTypeMaster = {
    _count: SurveyTypeMasterCountAggregateOutputType | null
    _min: SurveyTypeMasterMinAggregateOutputType | null
    _max: SurveyTypeMasterMaxAggregateOutputType | null
  }

  export type SurveyTypeMasterMinAggregateOutputType = {
    surveyTypeId: string | null
    surveyTypeName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type SurveyTypeMasterMaxAggregateOutputType = {
    surveyTypeId: string | null
    surveyTypeName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type SurveyTypeMasterCountAggregateOutputType = {
    surveyTypeId: number
    surveyTypeName: number
    isActive: number
    description: number
    _all: number
  }


  export type SurveyTypeMasterMinAggregateInputType = {
    surveyTypeId?: true
    surveyTypeName?: true
    isActive?: true
    description?: true
  }

  export type SurveyTypeMasterMaxAggregateInputType = {
    surveyTypeId?: true
    surveyTypeName?: true
    isActive?: true
    description?: true
  }

  export type SurveyTypeMasterCountAggregateInputType = {
    surveyTypeId?: true
    surveyTypeName?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type SurveyTypeMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyTypeMaster to aggregate.
     */
    where?: SurveyTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyTypeMasters to fetch.
     */
    orderBy?: SurveyTypeMasterOrderByWithRelationInput | SurveyTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyTypeMasters
    **/
    _count?: true | SurveyTypeMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyTypeMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyTypeMasterMaxAggregateInputType
  }

  export type GetSurveyTypeMasterAggregateType<T extends SurveyTypeMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyTypeMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyTypeMaster[P]>
      : GetScalarType<T[P], AggregateSurveyTypeMaster[P]>
  }




  export type SurveyTypeMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyTypeMasterWhereInput
    orderBy?: SurveyTypeMasterOrderByWithAggregationInput | SurveyTypeMasterOrderByWithAggregationInput[]
    by: SurveyTypeMasterScalarFieldEnum[] | SurveyTypeMasterScalarFieldEnum
    having?: SurveyTypeMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyTypeMasterCountAggregateInputType | true
    _min?: SurveyTypeMasterMinAggregateInputType
    _max?: SurveyTypeMasterMaxAggregateInputType
  }

  export type SurveyTypeMasterGroupByOutputType = {
    surveyTypeId: string
    surveyTypeName: string
    isActive: boolean
    description: string | null
    _count: SurveyTypeMasterCountAggregateOutputType | null
    _min: SurveyTypeMasterMinAggregateOutputType | null
    _max: SurveyTypeMasterMaxAggregateOutputType | null
  }

  type GetSurveyTypeMasterGroupByPayload<T extends SurveyTypeMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyTypeMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyTypeMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyTypeMasterGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyTypeMasterGroupByOutputType[P]>
        }
      >
    >


  export type SurveyTypeMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surveyTypeId?: boolean
    surveyTypeName?: boolean
    isActive?: boolean
    description?: boolean
    surveyDetails?: boolean | SurveyTypeMaster$surveyDetailsArgs<ExtArgs>
    _count?: boolean | SurveyTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyTypeMaster"]>

  export type SurveyTypeMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surveyTypeId?: boolean
    surveyTypeName?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["surveyTypeMaster"]>

  export type SurveyTypeMasterSelectScalar = {
    surveyTypeId?: boolean
    surveyTypeName?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type SurveyTypeMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyDetails?: boolean | SurveyTypeMaster$surveyDetailsArgs<ExtArgs>
    _count?: boolean | SurveyTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SurveyTypeMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SurveyTypeMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurveyTypeMaster"
    objects: {
      surveyDetails: Prisma.$SurveyDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      surveyTypeId: string
      surveyTypeName: string
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["surveyTypeMaster"]>
    composites: {}
  }

  type SurveyTypeMasterGetPayload<S extends boolean | null | undefined | SurveyTypeMasterDefaultArgs> = $Result.GetResult<Prisma.$SurveyTypeMasterPayload, S>

  type SurveyTypeMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SurveyTypeMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SurveyTypeMasterCountAggregateInputType | true
    }

  export interface SurveyTypeMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurveyTypeMaster'], meta: { name: 'SurveyTypeMaster' } }
    /**
     * Find zero or one SurveyTypeMaster that matches the filter.
     * @param {SurveyTypeMasterFindUniqueArgs} args - Arguments to find a SurveyTypeMaster
     * @example
     * // Get one SurveyTypeMaster
     * const surveyTypeMaster = await prisma.surveyTypeMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyTypeMasterFindUniqueArgs>(args: SelectSubset<T, SurveyTypeMasterFindUniqueArgs<ExtArgs>>): Prisma__SurveyTypeMasterClient<$Result.GetResult<Prisma.$SurveyTypeMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SurveyTypeMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SurveyTypeMasterFindUniqueOrThrowArgs} args - Arguments to find a SurveyTypeMaster
     * @example
     * // Get one SurveyTypeMaster
     * const surveyTypeMaster = await prisma.surveyTypeMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyTypeMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyTypeMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyTypeMasterClient<$Result.GetResult<Prisma.$SurveyTypeMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SurveyTypeMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyTypeMasterFindFirstArgs} args - Arguments to find a SurveyTypeMaster
     * @example
     * // Get one SurveyTypeMaster
     * const surveyTypeMaster = await prisma.surveyTypeMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyTypeMasterFindFirstArgs>(args?: SelectSubset<T, SurveyTypeMasterFindFirstArgs<ExtArgs>>): Prisma__SurveyTypeMasterClient<$Result.GetResult<Prisma.$SurveyTypeMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SurveyTypeMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyTypeMasterFindFirstOrThrowArgs} args - Arguments to find a SurveyTypeMaster
     * @example
     * // Get one SurveyTypeMaster
     * const surveyTypeMaster = await prisma.surveyTypeMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyTypeMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyTypeMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyTypeMasterClient<$Result.GetResult<Prisma.$SurveyTypeMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SurveyTypeMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyTypeMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyTypeMasters
     * const surveyTypeMasters = await prisma.surveyTypeMaster.findMany()
     * 
     * // Get first 10 SurveyTypeMasters
     * const surveyTypeMasters = await prisma.surveyTypeMaster.findMany({ take: 10 })
     * 
     * // Only select the `surveyTypeId`
     * const surveyTypeMasterWithSurveyTypeIdOnly = await prisma.surveyTypeMaster.findMany({ select: { surveyTypeId: true } })
     * 
     */
    findMany<T extends SurveyTypeMasterFindManyArgs>(args?: SelectSubset<T, SurveyTypeMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyTypeMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SurveyTypeMaster.
     * @param {SurveyTypeMasterCreateArgs} args - Arguments to create a SurveyTypeMaster.
     * @example
     * // Create one SurveyTypeMaster
     * const SurveyTypeMaster = await prisma.surveyTypeMaster.create({
     *   data: {
     *     // ... data to create a SurveyTypeMaster
     *   }
     * })
     * 
     */
    create<T extends SurveyTypeMasterCreateArgs>(args: SelectSubset<T, SurveyTypeMasterCreateArgs<ExtArgs>>): Prisma__SurveyTypeMasterClient<$Result.GetResult<Prisma.$SurveyTypeMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SurveyTypeMasters.
     * @param {SurveyTypeMasterCreateManyArgs} args - Arguments to create many SurveyTypeMasters.
     * @example
     * // Create many SurveyTypeMasters
     * const surveyTypeMaster = await prisma.surveyTypeMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyTypeMasterCreateManyArgs>(args?: SelectSubset<T, SurveyTypeMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SurveyTypeMasters and returns the data saved in the database.
     * @param {SurveyTypeMasterCreateManyAndReturnArgs} args - Arguments to create many SurveyTypeMasters.
     * @example
     * // Create many SurveyTypeMasters
     * const surveyTypeMaster = await prisma.surveyTypeMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SurveyTypeMasters and only return the `surveyTypeId`
     * const surveyTypeMasterWithSurveyTypeIdOnly = await prisma.surveyTypeMaster.createManyAndReturn({ 
     *   select: { surveyTypeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurveyTypeMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, SurveyTypeMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyTypeMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SurveyTypeMaster.
     * @param {SurveyTypeMasterDeleteArgs} args - Arguments to delete one SurveyTypeMaster.
     * @example
     * // Delete one SurveyTypeMaster
     * const SurveyTypeMaster = await prisma.surveyTypeMaster.delete({
     *   where: {
     *     // ... filter to delete one SurveyTypeMaster
     *   }
     * })
     * 
     */
    delete<T extends SurveyTypeMasterDeleteArgs>(args: SelectSubset<T, SurveyTypeMasterDeleteArgs<ExtArgs>>): Prisma__SurveyTypeMasterClient<$Result.GetResult<Prisma.$SurveyTypeMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SurveyTypeMaster.
     * @param {SurveyTypeMasterUpdateArgs} args - Arguments to update one SurveyTypeMaster.
     * @example
     * // Update one SurveyTypeMaster
     * const surveyTypeMaster = await prisma.surveyTypeMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyTypeMasterUpdateArgs>(args: SelectSubset<T, SurveyTypeMasterUpdateArgs<ExtArgs>>): Prisma__SurveyTypeMasterClient<$Result.GetResult<Prisma.$SurveyTypeMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SurveyTypeMasters.
     * @param {SurveyTypeMasterDeleteManyArgs} args - Arguments to filter SurveyTypeMasters to delete.
     * @example
     * // Delete a few SurveyTypeMasters
     * const { count } = await prisma.surveyTypeMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyTypeMasterDeleteManyArgs>(args?: SelectSubset<T, SurveyTypeMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyTypeMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyTypeMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyTypeMasters
     * const surveyTypeMaster = await prisma.surveyTypeMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyTypeMasterUpdateManyArgs>(args: SelectSubset<T, SurveyTypeMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SurveyTypeMaster.
     * @param {SurveyTypeMasterUpsertArgs} args - Arguments to update or create a SurveyTypeMaster.
     * @example
     * // Update or create a SurveyTypeMaster
     * const surveyTypeMaster = await prisma.surveyTypeMaster.upsert({
     *   create: {
     *     // ... data to create a SurveyTypeMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyTypeMaster we want to update
     *   }
     * })
     */
    upsert<T extends SurveyTypeMasterUpsertArgs>(args: SelectSubset<T, SurveyTypeMasterUpsertArgs<ExtArgs>>): Prisma__SurveyTypeMasterClient<$Result.GetResult<Prisma.$SurveyTypeMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SurveyTypeMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyTypeMasterCountArgs} args - Arguments to filter SurveyTypeMasters to count.
     * @example
     * // Count the number of SurveyTypeMasters
     * const count = await prisma.surveyTypeMaster.count({
     *   where: {
     *     // ... the filter for the SurveyTypeMasters we want to count
     *   }
     * })
    **/
    count<T extends SurveyTypeMasterCountArgs>(
      args?: Subset<T, SurveyTypeMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyTypeMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyTypeMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyTypeMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyTypeMasterAggregateArgs>(args: Subset<T, SurveyTypeMasterAggregateArgs>): Prisma.PrismaPromise<GetSurveyTypeMasterAggregateType<T>>

    /**
     * Group by SurveyTypeMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyTypeMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyTypeMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyTypeMasterGroupByArgs['orderBy'] }
        : { orderBy?: SurveyTypeMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyTypeMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyTypeMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurveyTypeMaster model
   */
  readonly fields: SurveyTypeMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyTypeMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyTypeMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    surveyDetails<T extends SurveyTypeMaster$surveyDetailsArgs<ExtArgs> = {}>(args?: Subset<T, SurveyTypeMaster$surveyDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurveyTypeMaster model
   */ 
  interface SurveyTypeMasterFieldRefs {
    readonly surveyTypeId: FieldRef<"SurveyTypeMaster", 'String'>
    readonly surveyTypeName: FieldRef<"SurveyTypeMaster", 'String'>
    readonly isActive: FieldRef<"SurveyTypeMaster", 'Boolean'>
    readonly description: FieldRef<"SurveyTypeMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SurveyTypeMaster findUnique
   */
  export type SurveyTypeMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyTypeMaster
     */
    select?: SurveyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which SurveyTypeMaster to fetch.
     */
    where: SurveyTypeMasterWhereUniqueInput
  }

  /**
   * SurveyTypeMaster findUniqueOrThrow
   */
  export type SurveyTypeMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyTypeMaster
     */
    select?: SurveyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which SurveyTypeMaster to fetch.
     */
    where: SurveyTypeMasterWhereUniqueInput
  }

  /**
   * SurveyTypeMaster findFirst
   */
  export type SurveyTypeMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyTypeMaster
     */
    select?: SurveyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which SurveyTypeMaster to fetch.
     */
    where?: SurveyTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyTypeMasters to fetch.
     */
    orderBy?: SurveyTypeMasterOrderByWithRelationInput | SurveyTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyTypeMasters.
     */
    cursor?: SurveyTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyTypeMasters.
     */
    distinct?: SurveyTypeMasterScalarFieldEnum | SurveyTypeMasterScalarFieldEnum[]
  }

  /**
   * SurveyTypeMaster findFirstOrThrow
   */
  export type SurveyTypeMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyTypeMaster
     */
    select?: SurveyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which SurveyTypeMaster to fetch.
     */
    where?: SurveyTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyTypeMasters to fetch.
     */
    orderBy?: SurveyTypeMasterOrderByWithRelationInput | SurveyTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyTypeMasters.
     */
    cursor?: SurveyTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyTypeMasters.
     */
    distinct?: SurveyTypeMasterScalarFieldEnum | SurveyTypeMasterScalarFieldEnum[]
  }

  /**
   * SurveyTypeMaster findMany
   */
  export type SurveyTypeMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyTypeMaster
     */
    select?: SurveyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which SurveyTypeMasters to fetch.
     */
    where?: SurveyTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyTypeMasters to fetch.
     */
    orderBy?: SurveyTypeMasterOrderByWithRelationInput | SurveyTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyTypeMasters.
     */
    cursor?: SurveyTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyTypeMasters.
     */
    skip?: number
    distinct?: SurveyTypeMasterScalarFieldEnum | SurveyTypeMasterScalarFieldEnum[]
  }

  /**
   * SurveyTypeMaster create
   */
  export type SurveyTypeMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyTypeMaster
     */
    select?: SurveyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyTypeMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a SurveyTypeMaster.
     */
    data: XOR<SurveyTypeMasterCreateInput, SurveyTypeMasterUncheckedCreateInput>
  }

  /**
   * SurveyTypeMaster createMany
   */
  export type SurveyTypeMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurveyTypeMasters.
     */
    data: SurveyTypeMasterCreateManyInput | SurveyTypeMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurveyTypeMaster createManyAndReturn
   */
  export type SurveyTypeMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyTypeMaster
     */
    select?: SurveyTypeMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SurveyTypeMasters.
     */
    data: SurveyTypeMasterCreateManyInput | SurveyTypeMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurveyTypeMaster update
   */
  export type SurveyTypeMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyTypeMaster
     */
    select?: SurveyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyTypeMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a SurveyTypeMaster.
     */
    data: XOR<SurveyTypeMasterUpdateInput, SurveyTypeMasterUncheckedUpdateInput>
    /**
     * Choose, which SurveyTypeMaster to update.
     */
    where: SurveyTypeMasterWhereUniqueInput
  }

  /**
   * SurveyTypeMaster updateMany
   */
  export type SurveyTypeMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurveyTypeMasters.
     */
    data: XOR<SurveyTypeMasterUpdateManyMutationInput, SurveyTypeMasterUncheckedUpdateManyInput>
    /**
     * Filter which SurveyTypeMasters to update
     */
    where?: SurveyTypeMasterWhereInput
  }

  /**
   * SurveyTypeMaster upsert
   */
  export type SurveyTypeMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyTypeMaster
     */
    select?: SurveyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyTypeMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the SurveyTypeMaster to update in case it exists.
     */
    where: SurveyTypeMasterWhereUniqueInput
    /**
     * In case the SurveyTypeMaster found by the `where` argument doesn't exist, create a new SurveyTypeMaster with this data.
     */
    create: XOR<SurveyTypeMasterCreateInput, SurveyTypeMasterUncheckedCreateInput>
    /**
     * In case the SurveyTypeMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyTypeMasterUpdateInput, SurveyTypeMasterUncheckedUpdateInput>
  }

  /**
   * SurveyTypeMaster delete
   */
  export type SurveyTypeMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyTypeMaster
     */
    select?: SurveyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter which SurveyTypeMaster to delete.
     */
    where: SurveyTypeMasterWhereUniqueInput
  }

  /**
   * SurveyTypeMaster deleteMany
   */
  export type SurveyTypeMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyTypeMasters to delete
     */
    where?: SurveyTypeMasterWhereInput
  }

  /**
   * SurveyTypeMaster.surveyDetails
   */
  export type SurveyTypeMaster$surveyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyDetails
     */
    select?: SurveyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyDetailsInclude<ExtArgs> | null
    where?: SurveyDetailsWhereInput
    orderBy?: SurveyDetailsOrderByWithRelationInput | SurveyDetailsOrderByWithRelationInput[]
    cursor?: SurveyDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyDetailsScalarFieldEnum | SurveyDetailsScalarFieldEnum[]
  }

  /**
   * SurveyTypeMaster without action
   */
  export type SurveyTypeMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyTypeMaster
     */
    select?: SurveyTypeMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyTypeMasterInclude<ExtArgs> | null
  }


  /**
   * Model OccupancyStatusMaster
   */

  export type AggregateOccupancyStatusMaster = {
    _count: OccupancyStatusMasterCountAggregateOutputType | null
    _min: OccupancyStatusMasterMinAggregateOutputType | null
    _max: OccupancyStatusMasterMaxAggregateOutputType | null
  }

  export type OccupancyStatusMasterMinAggregateOutputType = {
    occupancyStatusId: string | null
    occupancyStatusName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type OccupancyStatusMasterMaxAggregateOutputType = {
    occupancyStatusId: string | null
    occupancyStatusName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type OccupancyStatusMasterCountAggregateOutputType = {
    occupancyStatusId: number
    occupancyStatusName: number
    isActive: number
    description: number
    _all: number
  }


  export type OccupancyStatusMasterMinAggregateInputType = {
    occupancyStatusId?: true
    occupancyStatusName?: true
    isActive?: true
    description?: true
  }

  export type OccupancyStatusMasterMaxAggregateInputType = {
    occupancyStatusId?: true
    occupancyStatusName?: true
    isActive?: true
    description?: true
  }

  export type OccupancyStatusMasterCountAggregateInputType = {
    occupancyStatusId?: true
    occupancyStatusName?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type OccupancyStatusMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OccupancyStatusMaster to aggregate.
     */
    where?: OccupancyStatusMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OccupancyStatusMasters to fetch.
     */
    orderBy?: OccupancyStatusMasterOrderByWithRelationInput | OccupancyStatusMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OccupancyStatusMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OccupancyStatusMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OccupancyStatusMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OccupancyStatusMasters
    **/
    _count?: true | OccupancyStatusMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OccupancyStatusMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OccupancyStatusMasterMaxAggregateInputType
  }

  export type GetOccupancyStatusMasterAggregateType<T extends OccupancyStatusMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateOccupancyStatusMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOccupancyStatusMaster[P]>
      : GetScalarType<T[P], AggregateOccupancyStatusMaster[P]>
  }




  export type OccupancyStatusMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OccupancyStatusMasterWhereInput
    orderBy?: OccupancyStatusMasterOrderByWithAggregationInput | OccupancyStatusMasterOrderByWithAggregationInput[]
    by: OccupancyStatusMasterScalarFieldEnum[] | OccupancyStatusMasterScalarFieldEnum
    having?: OccupancyStatusMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OccupancyStatusMasterCountAggregateInputType | true
    _min?: OccupancyStatusMasterMinAggregateInputType
    _max?: OccupancyStatusMasterMaxAggregateInputType
  }

  export type OccupancyStatusMasterGroupByOutputType = {
    occupancyStatusId: string
    occupancyStatusName: string
    isActive: boolean
    description: string | null
    _count: OccupancyStatusMasterCountAggregateOutputType | null
    _min: OccupancyStatusMasterMinAggregateOutputType | null
    _max: OccupancyStatusMasterMaxAggregateOutputType | null
  }

  type GetOccupancyStatusMasterGroupByPayload<T extends OccupancyStatusMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OccupancyStatusMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OccupancyStatusMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OccupancyStatusMasterGroupByOutputType[P]>
            : GetScalarType<T[P], OccupancyStatusMasterGroupByOutputType[P]>
        }
      >
    >


  export type OccupancyStatusMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    occupancyStatusId?: boolean
    occupancyStatusName?: boolean
    isActive?: boolean
    description?: boolean
    residentialPropertyAssessments?: boolean | OccupancyStatusMaster$residentialPropertyAssessmentsArgs<ExtArgs>
    nonResidentialPropertyAssessments?: boolean | OccupancyStatusMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs>
    _count?: boolean | OccupancyStatusMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["occupancyStatusMaster"]>

  export type OccupancyStatusMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    occupancyStatusId?: boolean
    occupancyStatusName?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["occupancyStatusMaster"]>

  export type OccupancyStatusMasterSelectScalar = {
    occupancyStatusId?: boolean
    occupancyStatusName?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type OccupancyStatusMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    residentialPropertyAssessments?: boolean | OccupancyStatusMaster$residentialPropertyAssessmentsArgs<ExtArgs>
    nonResidentialPropertyAssessments?: boolean | OccupancyStatusMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs>
    _count?: boolean | OccupancyStatusMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OccupancyStatusMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OccupancyStatusMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OccupancyStatusMaster"
    objects: {
      residentialPropertyAssessments: Prisma.$ResidentialPropertyAssessmentPayload<ExtArgs>[]
      nonResidentialPropertyAssessments: Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      occupancyStatusId: string
      occupancyStatusName: string
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["occupancyStatusMaster"]>
    composites: {}
  }

  type OccupancyStatusMasterGetPayload<S extends boolean | null | undefined | OccupancyStatusMasterDefaultArgs> = $Result.GetResult<Prisma.$OccupancyStatusMasterPayload, S>

  type OccupancyStatusMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OccupancyStatusMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OccupancyStatusMasterCountAggregateInputType | true
    }

  export interface OccupancyStatusMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OccupancyStatusMaster'], meta: { name: 'OccupancyStatusMaster' } }
    /**
     * Find zero or one OccupancyStatusMaster that matches the filter.
     * @param {OccupancyStatusMasterFindUniqueArgs} args - Arguments to find a OccupancyStatusMaster
     * @example
     * // Get one OccupancyStatusMaster
     * const occupancyStatusMaster = await prisma.occupancyStatusMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OccupancyStatusMasterFindUniqueArgs>(args: SelectSubset<T, OccupancyStatusMasterFindUniqueArgs<ExtArgs>>): Prisma__OccupancyStatusMasterClient<$Result.GetResult<Prisma.$OccupancyStatusMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OccupancyStatusMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OccupancyStatusMasterFindUniqueOrThrowArgs} args - Arguments to find a OccupancyStatusMaster
     * @example
     * // Get one OccupancyStatusMaster
     * const occupancyStatusMaster = await prisma.occupancyStatusMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OccupancyStatusMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, OccupancyStatusMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OccupancyStatusMasterClient<$Result.GetResult<Prisma.$OccupancyStatusMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OccupancyStatusMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupancyStatusMasterFindFirstArgs} args - Arguments to find a OccupancyStatusMaster
     * @example
     * // Get one OccupancyStatusMaster
     * const occupancyStatusMaster = await prisma.occupancyStatusMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OccupancyStatusMasterFindFirstArgs>(args?: SelectSubset<T, OccupancyStatusMasterFindFirstArgs<ExtArgs>>): Prisma__OccupancyStatusMasterClient<$Result.GetResult<Prisma.$OccupancyStatusMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OccupancyStatusMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupancyStatusMasterFindFirstOrThrowArgs} args - Arguments to find a OccupancyStatusMaster
     * @example
     * // Get one OccupancyStatusMaster
     * const occupancyStatusMaster = await prisma.occupancyStatusMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OccupancyStatusMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, OccupancyStatusMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__OccupancyStatusMasterClient<$Result.GetResult<Prisma.$OccupancyStatusMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OccupancyStatusMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupancyStatusMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OccupancyStatusMasters
     * const occupancyStatusMasters = await prisma.occupancyStatusMaster.findMany()
     * 
     * // Get first 10 OccupancyStatusMasters
     * const occupancyStatusMasters = await prisma.occupancyStatusMaster.findMany({ take: 10 })
     * 
     * // Only select the `occupancyStatusId`
     * const occupancyStatusMasterWithOccupancyStatusIdOnly = await prisma.occupancyStatusMaster.findMany({ select: { occupancyStatusId: true } })
     * 
     */
    findMany<T extends OccupancyStatusMasterFindManyArgs>(args?: SelectSubset<T, OccupancyStatusMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OccupancyStatusMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OccupancyStatusMaster.
     * @param {OccupancyStatusMasterCreateArgs} args - Arguments to create a OccupancyStatusMaster.
     * @example
     * // Create one OccupancyStatusMaster
     * const OccupancyStatusMaster = await prisma.occupancyStatusMaster.create({
     *   data: {
     *     // ... data to create a OccupancyStatusMaster
     *   }
     * })
     * 
     */
    create<T extends OccupancyStatusMasterCreateArgs>(args: SelectSubset<T, OccupancyStatusMasterCreateArgs<ExtArgs>>): Prisma__OccupancyStatusMasterClient<$Result.GetResult<Prisma.$OccupancyStatusMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OccupancyStatusMasters.
     * @param {OccupancyStatusMasterCreateManyArgs} args - Arguments to create many OccupancyStatusMasters.
     * @example
     * // Create many OccupancyStatusMasters
     * const occupancyStatusMaster = await prisma.occupancyStatusMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OccupancyStatusMasterCreateManyArgs>(args?: SelectSubset<T, OccupancyStatusMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OccupancyStatusMasters and returns the data saved in the database.
     * @param {OccupancyStatusMasterCreateManyAndReturnArgs} args - Arguments to create many OccupancyStatusMasters.
     * @example
     * // Create many OccupancyStatusMasters
     * const occupancyStatusMaster = await prisma.occupancyStatusMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OccupancyStatusMasters and only return the `occupancyStatusId`
     * const occupancyStatusMasterWithOccupancyStatusIdOnly = await prisma.occupancyStatusMaster.createManyAndReturn({ 
     *   select: { occupancyStatusId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OccupancyStatusMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, OccupancyStatusMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OccupancyStatusMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OccupancyStatusMaster.
     * @param {OccupancyStatusMasterDeleteArgs} args - Arguments to delete one OccupancyStatusMaster.
     * @example
     * // Delete one OccupancyStatusMaster
     * const OccupancyStatusMaster = await prisma.occupancyStatusMaster.delete({
     *   where: {
     *     // ... filter to delete one OccupancyStatusMaster
     *   }
     * })
     * 
     */
    delete<T extends OccupancyStatusMasterDeleteArgs>(args: SelectSubset<T, OccupancyStatusMasterDeleteArgs<ExtArgs>>): Prisma__OccupancyStatusMasterClient<$Result.GetResult<Prisma.$OccupancyStatusMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OccupancyStatusMaster.
     * @param {OccupancyStatusMasterUpdateArgs} args - Arguments to update one OccupancyStatusMaster.
     * @example
     * // Update one OccupancyStatusMaster
     * const occupancyStatusMaster = await prisma.occupancyStatusMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OccupancyStatusMasterUpdateArgs>(args: SelectSubset<T, OccupancyStatusMasterUpdateArgs<ExtArgs>>): Prisma__OccupancyStatusMasterClient<$Result.GetResult<Prisma.$OccupancyStatusMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OccupancyStatusMasters.
     * @param {OccupancyStatusMasterDeleteManyArgs} args - Arguments to filter OccupancyStatusMasters to delete.
     * @example
     * // Delete a few OccupancyStatusMasters
     * const { count } = await prisma.occupancyStatusMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OccupancyStatusMasterDeleteManyArgs>(args?: SelectSubset<T, OccupancyStatusMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OccupancyStatusMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupancyStatusMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OccupancyStatusMasters
     * const occupancyStatusMaster = await prisma.occupancyStatusMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OccupancyStatusMasterUpdateManyArgs>(args: SelectSubset<T, OccupancyStatusMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OccupancyStatusMaster.
     * @param {OccupancyStatusMasterUpsertArgs} args - Arguments to update or create a OccupancyStatusMaster.
     * @example
     * // Update or create a OccupancyStatusMaster
     * const occupancyStatusMaster = await prisma.occupancyStatusMaster.upsert({
     *   create: {
     *     // ... data to create a OccupancyStatusMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OccupancyStatusMaster we want to update
     *   }
     * })
     */
    upsert<T extends OccupancyStatusMasterUpsertArgs>(args: SelectSubset<T, OccupancyStatusMasterUpsertArgs<ExtArgs>>): Prisma__OccupancyStatusMasterClient<$Result.GetResult<Prisma.$OccupancyStatusMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OccupancyStatusMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupancyStatusMasterCountArgs} args - Arguments to filter OccupancyStatusMasters to count.
     * @example
     * // Count the number of OccupancyStatusMasters
     * const count = await prisma.occupancyStatusMaster.count({
     *   where: {
     *     // ... the filter for the OccupancyStatusMasters we want to count
     *   }
     * })
    **/
    count<T extends OccupancyStatusMasterCountArgs>(
      args?: Subset<T, OccupancyStatusMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OccupancyStatusMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OccupancyStatusMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupancyStatusMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OccupancyStatusMasterAggregateArgs>(args: Subset<T, OccupancyStatusMasterAggregateArgs>): Prisma.PrismaPromise<GetOccupancyStatusMasterAggregateType<T>>

    /**
     * Group by OccupancyStatusMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupancyStatusMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OccupancyStatusMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OccupancyStatusMasterGroupByArgs['orderBy'] }
        : { orderBy?: OccupancyStatusMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OccupancyStatusMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOccupancyStatusMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OccupancyStatusMaster model
   */
  readonly fields: OccupancyStatusMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OccupancyStatusMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OccupancyStatusMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    residentialPropertyAssessments<T extends OccupancyStatusMaster$residentialPropertyAssessmentsArgs<ExtArgs> = {}>(args?: Subset<T, OccupancyStatusMaster$residentialPropertyAssessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResidentialPropertyAssessmentPayload<ExtArgs>, T, "findMany"> | Null>
    nonResidentialPropertyAssessments<T extends OccupancyStatusMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs> = {}>(args?: Subset<T, OccupancyStatusMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OccupancyStatusMaster model
   */ 
  interface OccupancyStatusMasterFieldRefs {
    readonly occupancyStatusId: FieldRef<"OccupancyStatusMaster", 'String'>
    readonly occupancyStatusName: FieldRef<"OccupancyStatusMaster", 'String'>
    readonly isActive: FieldRef<"OccupancyStatusMaster", 'Boolean'>
    readonly description: FieldRef<"OccupancyStatusMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OccupancyStatusMaster findUnique
   */
  export type OccupancyStatusMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupancyStatusMaster
     */
    select?: OccupancyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupancyStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which OccupancyStatusMaster to fetch.
     */
    where: OccupancyStatusMasterWhereUniqueInput
  }

  /**
   * OccupancyStatusMaster findUniqueOrThrow
   */
  export type OccupancyStatusMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupancyStatusMaster
     */
    select?: OccupancyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupancyStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which OccupancyStatusMaster to fetch.
     */
    where: OccupancyStatusMasterWhereUniqueInput
  }

  /**
   * OccupancyStatusMaster findFirst
   */
  export type OccupancyStatusMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupancyStatusMaster
     */
    select?: OccupancyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupancyStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which OccupancyStatusMaster to fetch.
     */
    where?: OccupancyStatusMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OccupancyStatusMasters to fetch.
     */
    orderBy?: OccupancyStatusMasterOrderByWithRelationInput | OccupancyStatusMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OccupancyStatusMasters.
     */
    cursor?: OccupancyStatusMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OccupancyStatusMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OccupancyStatusMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OccupancyStatusMasters.
     */
    distinct?: OccupancyStatusMasterScalarFieldEnum | OccupancyStatusMasterScalarFieldEnum[]
  }

  /**
   * OccupancyStatusMaster findFirstOrThrow
   */
  export type OccupancyStatusMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupancyStatusMaster
     */
    select?: OccupancyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupancyStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which OccupancyStatusMaster to fetch.
     */
    where?: OccupancyStatusMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OccupancyStatusMasters to fetch.
     */
    orderBy?: OccupancyStatusMasterOrderByWithRelationInput | OccupancyStatusMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OccupancyStatusMasters.
     */
    cursor?: OccupancyStatusMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OccupancyStatusMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OccupancyStatusMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OccupancyStatusMasters.
     */
    distinct?: OccupancyStatusMasterScalarFieldEnum | OccupancyStatusMasterScalarFieldEnum[]
  }

  /**
   * OccupancyStatusMaster findMany
   */
  export type OccupancyStatusMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupancyStatusMaster
     */
    select?: OccupancyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupancyStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which OccupancyStatusMasters to fetch.
     */
    where?: OccupancyStatusMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OccupancyStatusMasters to fetch.
     */
    orderBy?: OccupancyStatusMasterOrderByWithRelationInput | OccupancyStatusMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OccupancyStatusMasters.
     */
    cursor?: OccupancyStatusMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OccupancyStatusMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OccupancyStatusMasters.
     */
    skip?: number
    distinct?: OccupancyStatusMasterScalarFieldEnum | OccupancyStatusMasterScalarFieldEnum[]
  }

  /**
   * OccupancyStatusMaster create
   */
  export type OccupancyStatusMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupancyStatusMaster
     */
    select?: OccupancyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupancyStatusMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a OccupancyStatusMaster.
     */
    data: XOR<OccupancyStatusMasterCreateInput, OccupancyStatusMasterUncheckedCreateInput>
  }

  /**
   * OccupancyStatusMaster createMany
   */
  export type OccupancyStatusMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OccupancyStatusMasters.
     */
    data: OccupancyStatusMasterCreateManyInput | OccupancyStatusMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OccupancyStatusMaster createManyAndReturn
   */
  export type OccupancyStatusMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupancyStatusMaster
     */
    select?: OccupancyStatusMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OccupancyStatusMasters.
     */
    data: OccupancyStatusMasterCreateManyInput | OccupancyStatusMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OccupancyStatusMaster update
   */
  export type OccupancyStatusMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupancyStatusMaster
     */
    select?: OccupancyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupancyStatusMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a OccupancyStatusMaster.
     */
    data: XOR<OccupancyStatusMasterUpdateInput, OccupancyStatusMasterUncheckedUpdateInput>
    /**
     * Choose, which OccupancyStatusMaster to update.
     */
    where: OccupancyStatusMasterWhereUniqueInput
  }

  /**
   * OccupancyStatusMaster updateMany
   */
  export type OccupancyStatusMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OccupancyStatusMasters.
     */
    data: XOR<OccupancyStatusMasterUpdateManyMutationInput, OccupancyStatusMasterUncheckedUpdateManyInput>
    /**
     * Filter which OccupancyStatusMasters to update
     */
    where?: OccupancyStatusMasterWhereInput
  }

  /**
   * OccupancyStatusMaster upsert
   */
  export type OccupancyStatusMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupancyStatusMaster
     */
    select?: OccupancyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupancyStatusMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the OccupancyStatusMaster to update in case it exists.
     */
    where: OccupancyStatusMasterWhereUniqueInput
    /**
     * In case the OccupancyStatusMaster found by the `where` argument doesn't exist, create a new OccupancyStatusMaster with this data.
     */
    create: XOR<OccupancyStatusMasterCreateInput, OccupancyStatusMasterUncheckedCreateInput>
    /**
     * In case the OccupancyStatusMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OccupancyStatusMasterUpdateInput, OccupancyStatusMasterUncheckedUpdateInput>
  }

  /**
   * OccupancyStatusMaster delete
   */
  export type OccupancyStatusMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupancyStatusMaster
     */
    select?: OccupancyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupancyStatusMasterInclude<ExtArgs> | null
    /**
     * Filter which OccupancyStatusMaster to delete.
     */
    where: OccupancyStatusMasterWhereUniqueInput
  }

  /**
   * OccupancyStatusMaster deleteMany
   */
  export type OccupancyStatusMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OccupancyStatusMasters to delete
     */
    where?: OccupancyStatusMasterWhereInput
  }

  /**
   * OccupancyStatusMaster.residentialPropertyAssessments
   */
  export type OccupancyStatusMaster$residentialPropertyAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidentialPropertyAssessment
     */
    select?: ResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentialPropertyAssessmentInclude<ExtArgs> | null
    where?: ResidentialPropertyAssessmentWhereInput
    orderBy?: ResidentialPropertyAssessmentOrderByWithRelationInput | ResidentialPropertyAssessmentOrderByWithRelationInput[]
    cursor?: ResidentialPropertyAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResidentialPropertyAssessmentScalarFieldEnum | ResidentialPropertyAssessmentScalarFieldEnum[]
  }

  /**
   * OccupancyStatusMaster.nonResidentialPropertyAssessments
   */
  export type OccupancyStatusMaster$nonResidentialPropertyAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonResidentialPropertyAssessment
     */
    select?: NonResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonResidentialPropertyAssessmentInclude<ExtArgs> | null
    where?: NonResidentialPropertyAssessmentWhereInput
    orderBy?: NonResidentialPropertyAssessmentOrderByWithRelationInput | NonResidentialPropertyAssessmentOrderByWithRelationInput[]
    cursor?: NonResidentialPropertyAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NonResidentialPropertyAssessmentScalarFieldEnum | NonResidentialPropertyAssessmentScalarFieldEnum[]
  }

  /**
   * OccupancyStatusMaster without action
   */
  export type OccupancyStatusMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupancyStatusMaster
     */
    select?: OccupancyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupancyStatusMasterInclude<ExtArgs> | null
  }


  /**
   * Model SurveyStatusMaster
   */

  export type AggregateSurveyStatusMaster = {
    _count: SurveyStatusMasterCountAggregateOutputType | null
    _min: SurveyStatusMasterMinAggregateOutputType | null
    _max: SurveyStatusMasterMaxAggregateOutputType | null
  }

  export type SurveyStatusMasterMinAggregateOutputType = {
    statusId: string | null
    statusName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type SurveyStatusMasterMaxAggregateOutputType = {
    statusId: string | null
    statusName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type SurveyStatusMasterCountAggregateOutputType = {
    statusId: number
    statusName: number
    isActive: number
    description: number
    _all: number
  }


  export type SurveyStatusMasterMinAggregateInputType = {
    statusId?: true
    statusName?: true
    isActive?: true
    description?: true
  }

  export type SurveyStatusMasterMaxAggregateInputType = {
    statusId?: true
    statusName?: true
    isActive?: true
    description?: true
  }

  export type SurveyStatusMasterCountAggregateInputType = {
    statusId?: true
    statusName?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type SurveyStatusMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyStatusMaster to aggregate.
     */
    where?: SurveyStatusMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyStatusMasters to fetch.
     */
    orderBy?: SurveyStatusMasterOrderByWithRelationInput | SurveyStatusMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyStatusMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyStatusMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyStatusMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyStatusMasters
    **/
    _count?: true | SurveyStatusMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyStatusMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyStatusMasterMaxAggregateInputType
  }

  export type GetSurveyStatusMasterAggregateType<T extends SurveyStatusMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyStatusMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyStatusMaster[P]>
      : GetScalarType<T[P], AggregateSurveyStatusMaster[P]>
  }




  export type SurveyStatusMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyStatusMasterWhereInput
    orderBy?: SurveyStatusMasterOrderByWithAggregationInput | SurveyStatusMasterOrderByWithAggregationInput[]
    by: SurveyStatusMasterScalarFieldEnum[] | SurveyStatusMasterScalarFieldEnum
    having?: SurveyStatusMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyStatusMasterCountAggregateInputType | true
    _min?: SurveyStatusMasterMinAggregateInputType
    _max?: SurveyStatusMasterMaxAggregateInputType
  }

  export type SurveyStatusMasterGroupByOutputType = {
    statusId: string
    statusName: string
    isActive: boolean
    description: string | null
    _count: SurveyStatusMasterCountAggregateOutputType | null
    _min: SurveyStatusMasterMinAggregateOutputType | null
    _max: SurveyStatusMasterMaxAggregateOutputType | null
  }

  type GetSurveyStatusMasterGroupByPayload<T extends SurveyStatusMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyStatusMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyStatusMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyStatusMasterGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyStatusMasterGroupByOutputType[P]>
        }
      >
    >


  export type SurveyStatusMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statusId?: boolean
    statusName?: boolean
    isActive?: boolean
    description?: boolean
    surveyStatusMaps?: boolean | SurveyStatusMaster$surveyStatusMapsArgs<ExtArgs>
    surveyStatusMapsReverted?: boolean | SurveyStatusMaster$surveyStatusMapsRevertedArgs<ExtArgs>
    _count?: boolean | SurveyStatusMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyStatusMaster"]>

  export type SurveyStatusMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statusId?: boolean
    statusName?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["surveyStatusMaster"]>

  export type SurveyStatusMasterSelectScalar = {
    statusId?: boolean
    statusName?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type SurveyStatusMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyStatusMaps?: boolean | SurveyStatusMaster$surveyStatusMapsArgs<ExtArgs>
    surveyStatusMapsReverted?: boolean | SurveyStatusMaster$surveyStatusMapsRevertedArgs<ExtArgs>
    _count?: boolean | SurveyStatusMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SurveyStatusMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SurveyStatusMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurveyStatusMaster"
    objects: {
      surveyStatusMaps: Prisma.$SurveyStatusMappingPayload<ExtArgs>[]
      surveyStatusMapsReverted: Prisma.$SurveyStatusMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      statusId: string
      statusName: string
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["surveyStatusMaster"]>
    composites: {}
  }

  type SurveyStatusMasterGetPayload<S extends boolean | null | undefined | SurveyStatusMasterDefaultArgs> = $Result.GetResult<Prisma.$SurveyStatusMasterPayload, S>

  type SurveyStatusMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SurveyStatusMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SurveyStatusMasterCountAggregateInputType | true
    }

  export interface SurveyStatusMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurveyStatusMaster'], meta: { name: 'SurveyStatusMaster' } }
    /**
     * Find zero or one SurveyStatusMaster that matches the filter.
     * @param {SurveyStatusMasterFindUniqueArgs} args - Arguments to find a SurveyStatusMaster
     * @example
     * // Get one SurveyStatusMaster
     * const surveyStatusMaster = await prisma.surveyStatusMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyStatusMasterFindUniqueArgs>(args: SelectSubset<T, SurveyStatusMasterFindUniqueArgs<ExtArgs>>): Prisma__SurveyStatusMasterClient<$Result.GetResult<Prisma.$SurveyStatusMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SurveyStatusMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SurveyStatusMasterFindUniqueOrThrowArgs} args - Arguments to find a SurveyStatusMaster
     * @example
     * // Get one SurveyStatusMaster
     * const surveyStatusMaster = await prisma.surveyStatusMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyStatusMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyStatusMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyStatusMasterClient<$Result.GetResult<Prisma.$SurveyStatusMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SurveyStatusMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyStatusMasterFindFirstArgs} args - Arguments to find a SurveyStatusMaster
     * @example
     * // Get one SurveyStatusMaster
     * const surveyStatusMaster = await prisma.surveyStatusMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyStatusMasterFindFirstArgs>(args?: SelectSubset<T, SurveyStatusMasterFindFirstArgs<ExtArgs>>): Prisma__SurveyStatusMasterClient<$Result.GetResult<Prisma.$SurveyStatusMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SurveyStatusMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyStatusMasterFindFirstOrThrowArgs} args - Arguments to find a SurveyStatusMaster
     * @example
     * // Get one SurveyStatusMaster
     * const surveyStatusMaster = await prisma.surveyStatusMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyStatusMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyStatusMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyStatusMasterClient<$Result.GetResult<Prisma.$SurveyStatusMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SurveyStatusMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyStatusMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyStatusMasters
     * const surveyStatusMasters = await prisma.surveyStatusMaster.findMany()
     * 
     * // Get first 10 SurveyStatusMasters
     * const surveyStatusMasters = await prisma.surveyStatusMaster.findMany({ take: 10 })
     * 
     * // Only select the `statusId`
     * const surveyStatusMasterWithStatusIdOnly = await prisma.surveyStatusMaster.findMany({ select: { statusId: true } })
     * 
     */
    findMany<T extends SurveyStatusMasterFindManyArgs>(args?: SelectSubset<T, SurveyStatusMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyStatusMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SurveyStatusMaster.
     * @param {SurveyStatusMasterCreateArgs} args - Arguments to create a SurveyStatusMaster.
     * @example
     * // Create one SurveyStatusMaster
     * const SurveyStatusMaster = await prisma.surveyStatusMaster.create({
     *   data: {
     *     // ... data to create a SurveyStatusMaster
     *   }
     * })
     * 
     */
    create<T extends SurveyStatusMasterCreateArgs>(args: SelectSubset<T, SurveyStatusMasterCreateArgs<ExtArgs>>): Prisma__SurveyStatusMasterClient<$Result.GetResult<Prisma.$SurveyStatusMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SurveyStatusMasters.
     * @param {SurveyStatusMasterCreateManyArgs} args - Arguments to create many SurveyStatusMasters.
     * @example
     * // Create many SurveyStatusMasters
     * const surveyStatusMaster = await prisma.surveyStatusMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyStatusMasterCreateManyArgs>(args?: SelectSubset<T, SurveyStatusMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SurveyStatusMasters and returns the data saved in the database.
     * @param {SurveyStatusMasterCreateManyAndReturnArgs} args - Arguments to create many SurveyStatusMasters.
     * @example
     * // Create many SurveyStatusMasters
     * const surveyStatusMaster = await prisma.surveyStatusMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SurveyStatusMasters and only return the `statusId`
     * const surveyStatusMasterWithStatusIdOnly = await prisma.surveyStatusMaster.createManyAndReturn({ 
     *   select: { statusId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurveyStatusMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, SurveyStatusMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyStatusMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SurveyStatusMaster.
     * @param {SurveyStatusMasterDeleteArgs} args - Arguments to delete one SurveyStatusMaster.
     * @example
     * // Delete one SurveyStatusMaster
     * const SurveyStatusMaster = await prisma.surveyStatusMaster.delete({
     *   where: {
     *     // ... filter to delete one SurveyStatusMaster
     *   }
     * })
     * 
     */
    delete<T extends SurveyStatusMasterDeleteArgs>(args: SelectSubset<T, SurveyStatusMasterDeleteArgs<ExtArgs>>): Prisma__SurveyStatusMasterClient<$Result.GetResult<Prisma.$SurveyStatusMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SurveyStatusMaster.
     * @param {SurveyStatusMasterUpdateArgs} args - Arguments to update one SurveyStatusMaster.
     * @example
     * // Update one SurveyStatusMaster
     * const surveyStatusMaster = await prisma.surveyStatusMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyStatusMasterUpdateArgs>(args: SelectSubset<T, SurveyStatusMasterUpdateArgs<ExtArgs>>): Prisma__SurveyStatusMasterClient<$Result.GetResult<Prisma.$SurveyStatusMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SurveyStatusMasters.
     * @param {SurveyStatusMasterDeleteManyArgs} args - Arguments to filter SurveyStatusMasters to delete.
     * @example
     * // Delete a few SurveyStatusMasters
     * const { count } = await prisma.surveyStatusMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyStatusMasterDeleteManyArgs>(args?: SelectSubset<T, SurveyStatusMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyStatusMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyStatusMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyStatusMasters
     * const surveyStatusMaster = await prisma.surveyStatusMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyStatusMasterUpdateManyArgs>(args: SelectSubset<T, SurveyStatusMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SurveyStatusMaster.
     * @param {SurveyStatusMasterUpsertArgs} args - Arguments to update or create a SurveyStatusMaster.
     * @example
     * // Update or create a SurveyStatusMaster
     * const surveyStatusMaster = await prisma.surveyStatusMaster.upsert({
     *   create: {
     *     // ... data to create a SurveyStatusMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyStatusMaster we want to update
     *   }
     * })
     */
    upsert<T extends SurveyStatusMasterUpsertArgs>(args: SelectSubset<T, SurveyStatusMasterUpsertArgs<ExtArgs>>): Prisma__SurveyStatusMasterClient<$Result.GetResult<Prisma.$SurveyStatusMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SurveyStatusMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyStatusMasterCountArgs} args - Arguments to filter SurveyStatusMasters to count.
     * @example
     * // Count the number of SurveyStatusMasters
     * const count = await prisma.surveyStatusMaster.count({
     *   where: {
     *     // ... the filter for the SurveyStatusMasters we want to count
     *   }
     * })
    **/
    count<T extends SurveyStatusMasterCountArgs>(
      args?: Subset<T, SurveyStatusMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyStatusMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyStatusMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyStatusMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyStatusMasterAggregateArgs>(args: Subset<T, SurveyStatusMasterAggregateArgs>): Prisma.PrismaPromise<GetSurveyStatusMasterAggregateType<T>>

    /**
     * Group by SurveyStatusMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyStatusMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyStatusMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyStatusMasterGroupByArgs['orderBy'] }
        : { orderBy?: SurveyStatusMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyStatusMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyStatusMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurveyStatusMaster model
   */
  readonly fields: SurveyStatusMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyStatusMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyStatusMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    surveyStatusMaps<T extends SurveyStatusMaster$surveyStatusMapsArgs<ExtArgs> = {}>(args?: Subset<T, SurveyStatusMaster$surveyStatusMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyStatusMappingPayload<ExtArgs>, T, "findMany"> | Null>
    surveyStatusMapsReverted<T extends SurveyStatusMaster$surveyStatusMapsRevertedArgs<ExtArgs> = {}>(args?: Subset<T, SurveyStatusMaster$surveyStatusMapsRevertedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyStatusMappingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurveyStatusMaster model
   */ 
  interface SurveyStatusMasterFieldRefs {
    readonly statusId: FieldRef<"SurveyStatusMaster", 'String'>
    readonly statusName: FieldRef<"SurveyStatusMaster", 'String'>
    readonly isActive: FieldRef<"SurveyStatusMaster", 'Boolean'>
    readonly description: FieldRef<"SurveyStatusMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SurveyStatusMaster findUnique
   */
  export type SurveyStatusMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMaster
     */
    select?: SurveyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which SurveyStatusMaster to fetch.
     */
    where: SurveyStatusMasterWhereUniqueInput
  }

  /**
   * SurveyStatusMaster findUniqueOrThrow
   */
  export type SurveyStatusMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMaster
     */
    select?: SurveyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which SurveyStatusMaster to fetch.
     */
    where: SurveyStatusMasterWhereUniqueInput
  }

  /**
   * SurveyStatusMaster findFirst
   */
  export type SurveyStatusMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMaster
     */
    select?: SurveyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which SurveyStatusMaster to fetch.
     */
    where?: SurveyStatusMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyStatusMasters to fetch.
     */
    orderBy?: SurveyStatusMasterOrderByWithRelationInput | SurveyStatusMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyStatusMasters.
     */
    cursor?: SurveyStatusMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyStatusMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyStatusMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyStatusMasters.
     */
    distinct?: SurveyStatusMasterScalarFieldEnum | SurveyStatusMasterScalarFieldEnum[]
  }

  /**
   * SurveyStatusMaster findFirstOrThrow
   */
  export type SurveyStatusMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMaster
     */
    select?: SurveyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which SurveyStatusMaster to fetch.
     */
    where?: SurveyStatusMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyStatusMasters to fetch.
     */
    orderBy?: SurveyStatusMasterOrderByWithRelationInput | SurveyStatusMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyStatusMasters.
     */
    cursor?: SurveyStatusMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyStatusMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyStatusMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyStatusMasters.
     */
    distinct?: SurveyStatusMasterScalarFieldEnum | SurveyStatusMasterScalarFieldEnum[]
  }

  /**
   * SurveyStatusMaster findMany
   */
  export type SurveyStatusMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMaster
     */
    select?: SurveyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which SurveyStatusMasters to fetch.
     */
    where?: SurveyStatusMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyStatusMasters to fetch.
     */
    orderBy?: SurveyStatusMasterOrderByWithRelationInput | SurveyStatusMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyStatusMasters.
     */
    cursor?: SurveyStatusMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyStatusMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyStatusMasters.
     */
    skip?: number
    distinct?: SurveyStatusMasterScalarFieldEnum | SurveyStatusMasterScalarFieldEnum[]
  }

  /**
   * SurveyStatusMaster create
   */
  export type SurveyStatusMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMaster
     */
    select?: SurveyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a SurveyStatusMaster.
     */
    data: XOR<SurveyStatusMasterCreateInput, SurveyStatusMasterUncheckedCreateInput>
  }

  /**
   * SurveyStatusMaster createMany
   */
  export type SurveyStatusMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurveyStatusMasters.
     */
    data: SurveyStatusMasterCreateManyInput | SurveyStatusMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurveyStatusMaster createManyAndReturn
   */
  export type SurveyStatusMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMaster
     */
    select?: SurveyStatusMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SurveyStatusMasters.
     */
    data: SurveyStatusMasterCreateManyInput | SurveyStatusMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurveyStatusMaster update
   */
  export type SurveyStatusMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMaster
     */
    select?: SurveyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a SurveyStatusMaster.
     */
    data: XOR<SurveyStatusMasterUpdateInput, SurveyStatusMasterUncheckedUpdateInput>
    /**
     * Choose, which SurveyStatusMaster to update.
     */
    where: SurveyStatusMasterWhereUniqueInput
  }

  /**
   * SurveyStatusMaster updateMany
   */
  export type SurveyStatusMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurveyStatusMasters.
     */
    data: XOR<SurveyStatusMasterUpdateManyMutationInput, SurveyStatusMasterUncheckedUpdateManyInput>
    /**
     * Filter which SurveyStatusMasters to update
     */
    where?: SurveyStatusMasterWhereInput
  }

  /**
   * SurveyStatusMaster upsert
   */
  export type SurveyStatusMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMaster
     */
    select?: SurveyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the SurveyStatusMaster to update in case it exists.
     */
    where: SurveyStatusMasterWhereUniqueInput
    /**
     * In case the SurveyStatusMaster found by the `where` argument doesn't exist, create a new SurveyStatusMaster with this data.
     */
    create: XOR<SurveyStatusMasterCreateInput, SurveyStatusMasterUncheckedCreateInput>
    /**
     * In case the SurveyStatusMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyStatusMasterUpdateInput, SurveyStatusMasterUncheckedUpdateInput>
  }

  /**
   * SurveyStatusMaster delete
   */
  export type SurveyStatusMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMaster
     */
    select?: SurveyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMasterInclude<ExtArgs> | null
    /**
     * Filter which SurveyStatusMaster to delete.
     */
    where: SurveyStatusMasterWhereUniqueInput
  }

  /**
   * SurveyStatusMaster deleteMany
   */
  export type SurveyStatusMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyStatusMasters to delete
     */
    where?: SurveyStatusMasterWhereInput
  }

  /**
   * SurveyStatusMaster.surveyStatusMaps
   */
  export type SurveyStatusMaster$surveyStatusMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMapping
     */
    select?: SurveyStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMappingInclude<ExtArgs> | null
    where?: SurveyStatusMappingWhereInput
    orderBy?: SurveyStatusMappingOrderByWithRelationInput | SurveyStatusMappingOrderByWithRelationInput[]
    cursor?: SurveyStatusMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyStatusMappingScalarFieldEnum | SurveyStatusMappingScalarFieldEnum[]
  }

  /**
   * SurveyStatusMaster.surveyStatusMapsReverted
   */
  export type SurveyStatusMaster$surveyStatusMapsRevertedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMapping
     */
    select?: SurveyStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMappingInclude<ExtArgs> | null
    where?: SurveyStatusMappingWhereInput
    orderBy?: SurveyStatusMappingOrderByWithRelationInput | SurveyStatusMappingOrderByWithRelationInput[]
    cursor?: SurveyStatusMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyStatusMappingScalarFieldEnum | SurveyStatusMappingScalarFieldEnum[]
  }

  /**
   * SurveyStatusMaster without action
   */
  export type SurveyStatusMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMaster
     */
    select?: SurveyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMasterInclude<ExtArgs> | null
  }


  /**
   * Model WardStatusMaster
   */

  export type AggregateWardStatusMaster = {
    _count: WardStatusMasterCountAggregateOutputType | null
    _min: WardStatusMasterMinAggregateOutputType | null
    _max: WardStatusMasterMaxAggregateOutputType | null
  }

  export type WardStatusMasterMinAggregateOutputType = {
    statusId: string | null
    statusName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type WardStatusMasterMaxAggregateOutputType = {
    statusId: string | null
    statusName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type WardStatusMasterCountAggregateOutputType = {
    statusId: number
    statusName: number
    isActive: number
    description: number
    _all: number
  }


  export type WardStatusMasterMinAggregateInputType = {
    statusId?: true
    statusName?: true
    isActive?: true
    description?: true
  }

  export type WardStatusMasterMaxAggregateInputType = {
    statusId?: true
    statusName?: true
    isActive?: true
    description?: true
  }

  export type WardStatusMasterCountAggregateInputType = {
    statusId?: true
    statusName?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type WardStatusMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WardStatusMaster to aggregate.
     */
    where?: WardStatusMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardStatusMasters to fetch.
     */
    orderBy?: WardStatusMasterOrderByWithRelationInput | WardStatusMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WardStatusMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardStatusMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardStatusMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WardStatusMasters
    **/
    _count?: true | WardStatusMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WardStatusMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WardStatusMasterMaxAggregateInputType
  }

  export type GetWardStatusMasterAggregateType<T extends WardStatusMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateWardStatusMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWardStatusMaster[P]>
      : GetScalarType<T[P], AggregateWardStatusMaster[P]>
  }




  export type WardStatusMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardStatusMasterWhereInput
    orderBy?: WardStatusMasterOrderByWithAggregationInput | WardStatusMasterOrderByWithAggregationInput[]
    by: WardStatusMasterScalarFieldEnum[] | WardStatusMasterScalarFieldEnum
    having?: WardStatusMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WardStatusMasterCountAggregateInputType | true
    _min?: WardStatusMasterMinAggregateInputType
    _max?: WardStatusMasterMaxAggregateInputType
  }

  export type WardStatusMasterGroupByOutputType = {
    statusId: string
    statusName: string
    isActive: boolean
    description: string | null
    _count: WardStatusMasterCountAggregateOutputType | null
    _min: WardStatusMasterMinAggregateOutputType | null
    _max: WardStatusMasterMaxAggregateOutputType | null
  }

  type GetWardStatusMasterGroupByPayload<T extends WardStatusMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WardStatusMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WardStatusMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WardStatusMasterGroupByOutputType[P]>
            : GetScalarType<T[P], WardStatusMasterGroupByOutputType[P]>
        }
      >
    >


  export type WardStatusMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statusId?: boolean
    statusName?: boolean
    isActive?: boolean
    description?: boolean
    wardStatusMaps?: boolean | WardStatusMaster$wardStatusMapsArgs<ExtArgs>
    _count?: boolean | WardStatusMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wardStatusMaster"]>

  export type WardStatusMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statusId?: boolean
    statusName?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["wardStatusMaster"]>

  export type WardStatusMasterSelectScalar = {
    statusId?: boolean
    statusName?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type WardStatusMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wardStatusMaps?: boolean | WardStatusMaster$wardStatusMapsArgs<ExtArgs>
    _count?: boolean | WardStatusMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WardStatusMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WardStatusMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WardStatusMaster"
    objects: {
      wardStatusMaps: Prisma.$WardStatusMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      statusId: string
      statusName: string
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["wardStatusMaster"]>
    composites: {}
  }

  type WardStatusMasterGetPayload<S extends boolean | null | undefined | WardStatusMasterDefaultArgs> = $Result.GetResult<Prisma.$WardStatusMasterPayload, S>

  type WardStatusMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WardStatusMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WardStatusMasterCountAggregateInputType | true
    }

  export interface WardStatusMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WardStatusMaster'], meta: { name: 'WardStatusMaster' } }
    /**
     * Find zero or one WardStatusMaster that matches the filter.
     * @param {WardStatusMasterFindUniqueArgs} args - Arguments to find a WardStatusMaster
     * @example
     * // Get one WardStatusMaster
     * const wardStatusMaster = await prisma.wardStatusMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WardStatusMasterFindUniqueArgs>(args: SelectSubset<T, WardStatusMasterFindUniqueArgs<ExtArgs>>): Prisma__WardStatusMasterClient<$Result.GetResult<Prisma.$WardStatusMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WardStatusMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WardStatusMasterFindUniqueOrThrowArgs} args - Arguments to find a WardStatusMaster
     * @example
     * // Get one WardStatusMaster
     * const wardStatusMaster = await prisma.wardStatusMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WardStatusMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, WardStatusMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WardStatusMasterClient<$Result.GetResult<Prisma.$WardStatusMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WardStatusMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardStatusMasterFindFirstArgs} args - Arguments to find a WardStatusMaster
     * @example
     * // Get one WardStatusMaster
     * const wardStatusMaster = await prisma.wardStatusMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WardStatusMasterFindFirstArgs>(args?: SelectSubset<T, WardStatusMasterFindFirstArgs<ExtArgs>>): Prisma__WardStatusMasterClient<$Result.GetResult<Prisma.$WardStatusMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WardStatusMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardStatusMasterFindFirstOrThrowArgs} args - Arguments to find a WardStatusMaster
     * @example
     * // Get one WardStatusMaster
     * const wardStatusMaster = await prisma.wardStatusMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WardStatusMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, WardStatusMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__WardStatusMasterClient<$Result.GetResult<Prisma.$WardStatusMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WardStatusMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardStatusMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WardStatusMasters
     * const wardStatusMasters = await prisma.wardStatusMaster.findMany()
     * 
     * // Get first 10 WardStatusMasters
     * const wardStatusMasters = await prisma.wardStatusMaster.findMany({ take: 10 })
     * 
     * // Only select the `statusId`
     * const wardStatusMasterWithStatusIdOnly = await prisma.wardStatusMaster.findMany({ select: { statusId: true } })
     * 
     */
    findMany<T extends WardStatusMasterFindManyArgs>(args?: SelectSubset<T, WardStatusMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardStatusMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WardStatusMaster.
     * @param {WardStatusMasterCreateArgs} args - Arguments to create a WardStatusMaster.
     * @example
     * // Create one WardStatusMaster
     * const WardStatusMaster = await prisma.wardStatusMaster.create({
     *   data: {
     *     // ... data to create a WardStatusMaster
     *   }
     * })
     * 
     */
    create<T extends WardStatusMasterCreateArgs>(args: SelectSubset<T, WardStatusMasterCreateArgs<ExtArgs>>): Prisma__WardStatusMasterClient<$Result.GetResult<Prisma.$WardStatusMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WardStatusMasters.
     * @param {WardStatusMasterCreateManyArgs} args - Arguments to create many WardStatusMasters.
     * @example
     * // Create many WardStatusMasters
     * const wardStatusMaster = await prisma.wardStatusMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WardStatusMasterCreateManyArgs>(args?: SelectSubset<T, WardStatusMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WardStatusMasters and returns the data saved in the database.
     * @param {WardStatusMasterCreateManyAndReturnArgs} args - Arguments to create many WardStatusMasters.
     * @example
     * // Create many WardStatusMasters
     * const wardStatusMaster = await prisma.wardStatusMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WardStatusMasters and only return the `statusId`
     * const wardStatusMasterWithStatusIdOnly = await prisma.wardStatusMaster.createManyAndReturn({ 
     *   select: { statusId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WardStatusMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, WardStatusMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardStatusMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WardStatusMaster.
     * @param {WardStatusMasterDeleteArgs} args - Arguments to delete one WardStatusMaster.
     * @example
     * // Delete one WardStatusMaster
     * const WardStatusMaster = await prisma.wardStatusMaster.delete({
     *   where: {
     *     // ... filter to delete one WardStatusMaster
     *   }
     * })
     * 
     */
    delete<T extends WardStatusMasterDeleteArgs>(args: SelectSubset<T, WardStatusMasterDeleteArgs<ExtArgs>>): Prisma__WardStatusMasterClient<$Result.GetResult<Prisma.$WardStatusMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WardStatusMaster.
     * @param {WardStatusMasterUpdateArgs} args - Arguments to update one WardStatusMaster.
     * @example
     * // Update one WardStatusMaster
     * const wardStatusMaster = await prisma.wardStatusMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WardStatusMasterUpdateArgs>(args: SelectSubset<T, WardStatusMasterUpdateArgs<ExtArgs>>): Prisma__WardStatusMasterClient<$Result.GetResult<Prisma.$WardStatusMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WardStatusMasters.
     * @param {WardStatusMasterDeleteManyArgs} args - Arguments to filter WardStatusMasters to delete.
     * @example
     * // Delete a few WardStatusMasters
     * const { count } = await prisma.wardStatusMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WardStatusMasterDeleteManyArgs>(args?: SelectSubset<T, WardStatusMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WardStatusMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardStatusMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WardStatusMasters
     * const wardStatusMaster = await prisma.wardStatusMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WardStatusMasterUpdateManyArgs>(args: SelectSubset<T, WardStatusMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WardStatusMaster.
     * @param {WardStatusMasterUpsertArgs} args - Arguments to update or create a WardStatusMaster.
     * @example
     * // Update or create a WardStatusMaster
     * const wardStatusMaster = await prisma.wardStatusMaster.upsert({
     *   create: {
     *     // ... data to create a WardStatusMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WardStatusMaster we want to update
     *   }
     * })
     */
    upsert<T extends WardStatusMasterUpsertArgs>(args: SelectSubset<T, WardStatusMasterUpsertArgs<ExtArgs>>): Prisma__WardStatusMasterClient<$Result.GetResult<Prisma.$WardStatusMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WardStatusMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardStatusMasterCountArgs} args - Arguments to filter WardStatusMasters to count.
     * @example
     * // Count the number of WardStatusMasters
     * const count = await prisma.wardStatusMaster.count({
     *   where: {
     *     // ... the filter for the WardStatusMasters we want to count
     *   }
     * })
    **/
    count<T extends WardStatusMasterCountArgs>(
      args?: Subset<T, WardStatusMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WardStatusMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WardStatusMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardStatusMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WardStatusMasterAggregateArgs>(args: Subset<T, WardStatusMasterAggregateArgs>): Prisma.PrismaPromise<GetWardStatusMasterAggregateType<T>>

    /**
     * Group by WardStatusMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardStatusMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WardStatusMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WardStatusMasterGroupByArgs['orderBy'] }
        : { orderBy?: WardStatusMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WardStatusMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWardStatusMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WardStatusMaster model
   */
  readonly fields: WardStatusMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WardStatusMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WardStatusMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wardStatusMaps<T extends WardStatusMaster$wardStatusMapsArgs<ExtArgs> = {}>(args?: Subset<T, WardStatusMaster$wardStatusMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardStatusMappingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WardStatusMaster model
   */ 
  interface WardStatusMasterFieldRefs {
    readonly statusId: FieldRef<"WardStatusMaster", 'String'>
    readonly statusName: FieldRef<"WardStatusMaster", 'String'>
    readonly isActive: FieldRef<"WardStatusMaster", 'Boolean'>
    readonly description: FieldRef<"WardStatusMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WardStatusMaster findUnique
   */
  export type WardStatusMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMaster
     */
    select?: WardStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which WardStatusMaster to fetch.
     */
    where: WardStatusMasterWhereUniqueInput
  }

  /**
   * WardStatusMaster findUniqueOrThrow
   */
  export type WardStatusMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMaster
     */
    select?: WardStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which WardStatusMaster to fetch.
     */
    where: WardStatusMasterWhereUniqueInput
  }

  /**
   * WardStatusMaster findFirst
   */
  export type WardStatusMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMaster
     */
    select?: WardStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which WardStatusMaster to fetch.
     */
    where?: WardStatusMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardStatusMasters to fetch.
     */
    orderBy?: WardStatusMasterOrderByWithRelationInput | WardStatusMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WardStatusMasters.
     */
    cursor?: WardStatusMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardStatusMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardStatusMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WardStatusMasters.
     */
    distinct?: WardStatusMasterScalarFieldEnum | WardStatusMasterScalarFieldEnum[]
  }

  /**
   * WardStatusMaster findFirstOrThrow
   */
  export type WardStatusMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMaster
     */
    select?: WardStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which WardStatusMaster to fetch.
     */
    where?: WardStatusMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardStatusMasters to fetch.
     */
    orderBy?: WardStatusMasterOrderByWithRelationInput | WardStatusMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WardStatusMasters.
     */
    cursor?: WardStatusMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardStatusMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardStatusMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WardStatusMasters.
     */
    distinct?: WardStatusMasterScalarFieldEnum | WardStatusMasterScalarFieldEnum[]
  }

  /**
   * WardStatusMaster findMany
   */
  export type WardStatusMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMaster
     */
    select?: WardStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMasterInclude<ExtArgs> | null
    /**
     * Filter, which WardStatusMasters to fetch.
     */
    where?: WardStatusMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardStatusMasters to fetch.
     */
    orderBy?: WardStatusMasterOrderByWithRelationInput | WardStatusMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WardStatusMasters.
     */
    cursor?: WardStatusMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardStatusMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardStatusMasters.
     */
    skip?: number
    distinct?: WardStatusMasterScalarFieldEnum | WardStatusMasterScalarFieldEnum[]
  }

  /**
   * WardStatusMaster create
   */
  export type WardStatusMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMaster
     */
    select?: WardStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a WardStatusMaster.
     */
    data: XOR<WardStatusMasterCreateInput, WardStatusMasterUncheckedCreateInput>
  }

  /**
   * WardStatusMaster createMany
   */
  export type WardStatusMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WardStatusMasters.
     */
    data: WardStatusMasterCreateManyInput | WardStatusMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WardStatusMaster createManyAndReturn
   */
  export type WardStatusMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMaster
     */
    select?: WardStatusMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WardStatusMasters.
     */
    data: WardStatusMasterCreateManyInput | WardStatusMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WardStatusMaster update
   */
  export type WardStatusMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMaster
     */
    select?: WardStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a WardStatusMaster.
     */
    data: XOR<WardStatusMasterUpdateInput, WardStatusMasterUncheckedUpdateInput>
    /**
     * Choose, which WardStatusMaster to update.
     */
    where: WardStatusMasterWhereUniqueInput
  }

  /**
   * WardStatusMaster updateMany
   */
  export type WardStatusMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WardStatusMasters.
     */
    data: XOR<WardStatusMasterUpdateManyMutationInput, WardStatusMasterUncheckedUpdateManyInput>
    /**
     * Filter which WardStatusMasters to update
     */
    where?: WardStatusMasterWhereInput
  }

  /**
   * WardStatusMaster upsert
   */
  export type WardStatusMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMaster
     */
    select?: WardStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the WardStatusMaster to update in case it exists.
     */
    where: WardStatusMasterWhereUniqueInput
    /**
     * In case the WardStatusMaster found by the `where` argument doesn't exist, create a new WardStatusMaster with this data.
     */
    create: XOR<WardStatusMasterCreateInput, WardStatusMasterUncheckedCreateInput>
    /**
     * In case the WardStatusMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WardStatusMasterUpdateInput, WardStatusMasterUncheckedUpdateInput>
  }

  /**
   * WardStatusMaster delete
   */
  export type WardStatusMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMaster
     */
    select?: WardStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMasterInclude<ExtArgs> | null
    /**
     * Filter which WardStatusMaster to delete.
     */
    where: WardStatusMasterWhereUniqueInput
  }

  /**
   * WardStatusMaster deleteMany
   */
  export type WardStatusMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WardStatusMasters to delete
     */
    where?: WardStatusMasterWhereInput
  }

  /**
   * WardStatusMaster.wardStatusMaps
   */
  export type WardStatusMaster$wardStatusMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMapping
     */
    select?: WardStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMappingInclude<ExtArgs> | null
    where?: WardStatusMappingWhereInput
    orderBy?: WardStatusMappingOrderByWithRelationInput | WardStatusMappingOrderByWithRelationInput[]
    cursor?: WardStatusMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WardStatusMappingScalarFieldEnum | WardStatusMappingScalarFieldEnum[]
  }

  /**
   * WardStatusMaster without action
   */
  export type WardStatusMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMaster
     */
    select?: WardStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMasterInclude<ExtArgs> | null
  }


  /**
   * Model UsersMaster
   */

  export type AggregateUsersMaster = {
    _count: UsersMasterCountAggregateOutputType | null
    _min: UsersMasterMinAggregateOutputType | null
    _max: UsersMasterMaxAggregateOutputType | null
  }

  export type UsersMasterMinAggregateOutputType = {
    userId: string | null
    username: string | null
    password: string | null
    mobileNumber: string | null
    isCreatedAt: Date | null
    isActive: boolean | null
    description: string | null
  }

  export type UsersMasterMaxAggregateOutputType = {
    userId: string | null
    username: string | null
    password: string | null
    mobileNumber: string | null
    isCreatedAt: Date | null
    isActive: boolean | null
    description: string | null
  }

  export type UsersMasterCountAggregateOutputType = {
    userId: number
    username: number
    password: number
    mobileNumber: number
    isCreatedAt: number
    isActive: number
    description: number
    _all: number
  }


  export type UsersMasterMinAggregateInputType = {
    userId?: true
    username?: true
    password?: true
    mobileNumber?: true
    isCreatedAt?: true
    isActive?: true
    description?: true
  }

  export type UsersMasterMaxAggregateInputType = {
    userId?: true
    username?: true
    password?: true
    mobileNumber?: true
    isCreatedAt?: true
    isActive?: true
    description?: true
  }

  export type UsersMasterCountAggregateInputType = {
    userId?: true
    username?: true
    password?: true
    mobileNumber?: true
    isCreatedAt?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type UsersMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersMaster to aggregate.
     */
    where?: UsersMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersMasters to fetch.
     */
    orderBy?: UsersMasterOrderByWithRelationInput | UsersMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsersMasters
    **/
    _count?: true | UsersMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMasterMaxAggregateInputType
  }

  export type GetUsersMasterAggregateType<T extends UsersMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateUsersMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsersMaster[P]>
      : GetScalarType<T[P], AggregateUsersMaster[P]>
  }




  export type UsersMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersMasterWhereInput
    orderBy?: UsersMasterOrderByWithAggregationInput | UsersMasterOrderByWithAggregationInput[]
    by: UsersMasterScalarFieldEnum[] | UsersMasterScalarFieldEnum
    having?: UsersMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersMasterCountAggregateInputType | true
    _min?: UsersMasterMinAggregateInputType
    _max?: UsersMasterMaxAggregateInputType
  }

  export type UsersMasterGroupByOutputType = {
    userId: string
    username: string
    password: string
    mobileNumber: string | null
    isCreatedAt: Date
    isActive: boolean
    description: string | null
    _count: UsersMasterCountAggregateOutputType | null
    _min: UsersMasterMinAggregateOutputType | null
    _max: UsersMasterMaxAggregateOutputType | null
  }

  type GetUsersMasterGroupByPayload<T extends UsersMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersMasterGroupByOutputType[P]>
            : GetScalarType<T[P], UsersMasterGroupByOutputType[P]>
        }
      >
    >


  export type UsersMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    username?: boolean
    password?: boolean
    mobileNumber?: boolean
    isCreatedAt?: boolean
    isActive?: boolean
    description?: boolean
    surveyorAssignments?: boolean | UsersMaster$surveyorAssignmentsArgs<ExtArgs>
    surveyorAssignmentsAssignedBy?: boolean | UsersMaster$surveyorAssignmentsAssignedByArgs<ExtArgs>
    wardStatusMaps?: boolean | UsersMaster$wardStatusMapsArgs<ExtArgs>
    surveyStatusMaps?: boolean | UsersMaster$surveyStatusMapsArgs<ExtArgs>
    userRoleMaps?: boolean | UsersMaster$userRoleMapsArgs<ExtArgs>
    sessions?: boolean | UsersMaster$sessionsArgs<ExtArgs>
    surveyors?: boolean | UsersMaster$surveyorsArgs<ExtArgs>
    supervisors?: boolean | UsersMaster$supervisorsArgs<ExtArgs>
    admins?: boolean | UsersMaster$adminsArgs<ExtArgs>
    _count?: boolean | UsersMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usersMaster"]>

  export type UsersMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    username?: boolean
    password?: boolean
    mobileNumber?: boolean
    isCreatedAt?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["usersMaster"]>

  export type UsersMasterSelectScalar = {
    userId?: boolean
    username?: boolean
    password?: boolean
    mobileNumber?: boolean
    isCreatedAt?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type UsersMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyorAssignments?: boolean | UsersMaster$surveyorAssignmentsArgs<ExtArgs>
    surveyorAssignmentsAssignedBy?: boolean | UsersMaster$surveyorAssignmentsAssignedByArgs<ExtArgs>
    wardStatusMaps?: boolean | UsersMaster$wardStatusMapsArgs<ExtArgs>
    surveyStatusMaps?: boolean | UsersMaster$surveyStatusMapsArgs<ExtArgs>
    userRoleMaps?: boolean | UsersMaster$userRoleMapsArgs<ExtArgs>
    sessions?: boolean | UsersMaster$sessionsArgs<ExtArgs>
    surveyors?: boolean | UsersMaster$surveyorsArgs<ExtArgs>
    supervisors?: boolean | UsersMaster$supervisorsArgs<ExtArgs>
    admins?: boolean | UsersMaster$adminsArgs<ExtArgs>
    _count?: boolean | UsersMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsersMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsersMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsersMaster"
    objects: {
      surveyorAssignments: Prisma.$SurveyorAssignmentPayload<ExtArgs>[]
      surveyorAssignmentsAssignedBy: Prisma.$SurveyorAssignmentPayload<ExtArgs>[]
      wardStatusMaps: Prisma.$WardStatusMappingPayload<ExtArgs>[]
      surveyStatusMaps: Prisma.$SurveyStatusMappingPayload<ExtArgs>[]
      userRoleMaps: Prisma.$UserRoleMappingPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      surveyors: Prisma.$SurveyorsPayload<ExtArgs>[]
      supervisors: Prisma.$SupervisorsPayload<ExtArgs>[]
      admins: Prisma.$AdminsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      username: string
      password: string
      mobileNumber: string | null
      isCreatedAt: Date
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["usersMaster"]>
    composites: {}
  }

  type UsersMasterGetPayload<S extends boolean | null | undefined | UsersMasterDefaultArgs> = $Result.GetResult<Prisma.$UsersMasterPayload, S>

  type UsersMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsersMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersMasterCountAggregateInputType | true
    }

  export interface UsersMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsersMaster'], meta: { name: 'UsersMaster' } }
    /**
     * Find zero or one UsersMaster that matches the filter.
     * @param {UsersMasterFindUniqueArgs} args - Arguments to find a UsersMaster
     * @example
     * // Get one UsersMaster
     * const usersMaster = await prisma.usersMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersMasterFindUniqueArgs>(args: SelectSubset<T, UsersMasterFindUniqueArgs<ExtArgs>>): Prisma__UsersMasterClient<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsersMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsersMasterFindUniqueOrThrowArgs} args - Arguments to find a UsersMaster
     * @example
     * // Get one UsersMaster
     * const usersMaster = await prisma.usersMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersMasterClient<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsersMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersMasterFindFirstArgs} args - Arguments to find a UsersMaster
     * @example
     * // Get one UsersMaster
     * const usersMaster = await prisma.usersMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersMasterFindFirstArgs>(args?: SelectSubset<T, UsersMasterFindFirstArgs<ExtArgs>>): Prisma__UsersMasterClient<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsersMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersMasterFindFirstOrThrowArgs} args - Arguments to find a UsersMaster
     * @example
     * // Get one UsersMaster
     * const usersMaster = await prisma.usersMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersMasterClient<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsersMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsersMasters
     * const usersMasters = await prisma.usersMaster.findMany()
     * 
     * // Get first 10 UsersMasters
     * const usersMasters = await prisma.usersMaster.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const usersMasterWithUserIdOnly = await prisma.usersMaster.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UsersMasterFindManyArgs>(args?: SelectSubset<T, UsersMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsersMaster.
     * @param {UsersMasterCreateArgs} args - Arguments to create a UsersMaster.
     * @example
     * // Create one UsersMaster
     * const UsersMaster = await prisma.usersMaster.create({
     *   data: {
     *     // ... data to create a UsersMaster
     *   }
     * })
     * 
     */
    create<T extends UsersMasterCreateArgs>(args: SelectSubset<T, UsersMasterCreateArgs<ExtArgs>>): Prisma__UsersMasterClient<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsersMasters.
     * @param {UsersMasterCreateManyArgs} args - Arguments to create many UsersMasters.
     * @example
     * // Create many UsersMasters
     * const usersMaster = await prisma.usersMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersMasterCreateManyArgs>(args?: SelectSubset<T, UsersMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsersMasters and returns the data saved in the database.
     * @param {UsersMasterCreateManyAndReturnArgs} args - Arguments to create many UsersMasters.
     * @example
     * // Create many UsersMasters
     * const usersMaster = await prisma.usersMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsersMasters and only return the `userId`
     * const usersMasterWithUserIdOnly = await prisma.usersMaster.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsersMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, UsersMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UsersMaster.
     * @param {UsersMasterDeleteArgs} args - Arguments to delete one UsersMaster.
     * @example
     * // Delete one UsersMaster
     * const UsersMaster = await prisma.usersMaster.delete({
     *   where: {
     *     // ... filter to delete one UsersMaster
     *   }
     * })
     * 
     */
    delete<T extends UsersMasterDeleteArgs>(args: SelectSubset<T, UsersMasterDeleteArgs<ExtArgs>>): Prisma__UsersMasterClient<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsersMaster.
     * @param {UsersMasterUpdateArgs} args - Arguments to update one UsersMaster.
     * @example
     * // Update one UsersMaster
     * const usersMaster = await prisma.usersMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersMasterUpdateArgs>(args: SelectSubset<T, UsersMasterUpdateArgs<ExtArgs>>): Prisma__UsersMasterClient<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsersMasters.
     * @param {UsersMasterDeleteManyArgs} args - Arguments to filter UsersMasters to delete.
     * @example
     * // Delete a few UsersMasters
     * const { count } = await prisma.usersMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersMasterDeleteManyArgs>(args?: SelectSubset<T, UsersMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsersMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsersMasters
     * const usersMaster = await prisma.usersMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersMasterUpdateManyArgs>(args: SelectSubset<T, UsersMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsersMaster.
     * @param {UsersMasterUpsertArgs} args - Arguments to update or create a UsersMaster.
     * @example
     * // Update or create a UsersMaster
     * const usersMaster = await prisma.usersMaster.upsert({
     *   create: {
     *     // ... data to create a UsersMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsersMaster we want to update
     *   }
     * })
     */
    upsert<T extends UsersMasterUpsertArgs>(args: SelectSubset<T, UsersMasterUpsertArgs<ExtArgs>>): Prisma__UsersMasterClient<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsersMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersMasterCountArgs} args - Arguments to filter UsersMasters to count.
     * @example
     * // Count the number of UsersMasters
     * const count = await prisma.usersMaster.count({
     *   where: {
     *     // ... the filter for the UsersMasters we want to count
     *   }
     * })
    **/
    count<T extends UsersMasterCountArgs>(
      args?: Subset<T, UsersMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsersMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersMasterAggregateArgs>(args: Subset<T, UsersMasterAggregateArgs>): Prisma.PrismaPromise<GetUsersMasterAggregateType<T>>

    /**
     * Group by UsersMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersMasterGroupByArgs['orderBy'] }
        : { orderBy?: UsersMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsersMaster model
   */
  readonly fields: UsersMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsersMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    surveyorAssignments<T extends UsersMaster$surveyorAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, UsersMaster$surveyorAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyorAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    surveyorAssignmentsAssignedBy<T extends UsersMaster$surveyorAssignmentsAssignedByArgs<ExtArgs> = {}>(args?: Subset<T, UsersMaster$surveyorAssignmentsAssignedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyorAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    wardStatusMaps<T extends UsersMaster$wardStatusMapsArgs<ExtArgs> = {}>(args?: Subset<T, UsersMaster$wardStatusMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardStatusMappingPayload<ExtArgs>, T, "findMany"> | Null>
    surveyStatusMaps<T extends UsersMaster$surveyStatusMapsArgs<ExtArgs> = {}>(args?: Subset<T, UsersMaster$surveyStatusMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyStatusMappingPayload<ExtArgs>, T, "findMany"> | Null>
    userRoleMaps<T extends UsersMaster$userRoleMapsArgs<ExtArgs> = {}>(args?: Subset<T, UsersMaster$userRoleMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends UsersMaster$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, UsersMaster$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    surveyors<T extends UsersMaster$surveyorsArgs<ExtArgs> = {}>(args?: Subset<T, UsersMaster$surveyorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyorsPayload<ExtArgs>, T, "findMany"> | Null>
    supervisors<T extends UsersMaster$supervisorsArgs<ExtArgs> = {}>(args?: Subset<T, UsersMaster$supervisorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupervisorsPayload<ExtArgs>, T, "findMany"> | Null>
    admins<T extends UsersMaster$adminsArgs<ExtArgs> = {}>(args?: Subset<T, UsersMaster$adminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsersMaster model
   */ 
  interface UsersMasterFieldRefs {
    readonly userId: FieldRef<"UsersMaster", 'String'>
    readonly username: FieldRef<"UsersMaster", 'String'>
    readonly password: FieldRef<"UsersMaster", 'String'>
    readonly mobileNumber: FieldRef<"UsersMaster", 'String'>
    readonly isCreatedAt: FieldRef<"UsersMaster", 'DateTime'>
    readonly isActive: FieldRef<"UsersMaster", 'Boolean'>
    readonly description: FieldRef<"UsersMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UsersMaster findUnique
   */
  export type UsersMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersMaster
     */
    select?: UsersMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersMasterInclude<ExtArgs> | null
    /**
     * Filter, which UsersMaster to fetch.
     */
    where: UsersMasterWhereUniqueInput
  }

  /**
   * UsersMaster findUniqueOrThrow
   */
  export type UsersMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersMaster
     */
    select?: UsersMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersMasterInclude<ExtArgs> | null
    /**
     * Filter, which UsersMaster to fetch.
     */
    where: UsersMasterWhereUniqueInput
  }

  /**
   * UsersMaster findFirst
   */
  export type UsersMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersMaster
     */
    select?: UsersMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersMasterInclude<ExtArgs> | null
    /**
     * Filter, which UsersMaster to fetch.
     */
    where?: UsersMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersMasters to fetch.
     */
    orderBy?: UsersMasterOrderByWithRelationInput | UsersMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersMasters.
     */
    cursor?: UsersMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersMasters.
     */
    distinct?: UsersMasterScalarFieldEnum | UsersMasterScalarFieldEnum[]
  }

  /**
   * UsersMaster findFirstOrThrow
   */
  export type UsersMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersMaster
     */
    select?: UsersMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersMasterInclude<ExtArgs> | null
    /**
     * Filter, which UsersMaster to fetch.
     */
    where?: UsersMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersMasters to fetch.
     */
    orderBy?: UsersMasterOrderByWithRelationInput | UsersMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersMasters.
     */
    cursor?: UsersMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersMasters.
     */
    distinct?: UsersMasterScalarFieldEnum | UsersMasterScalarFieldEnum[]
  }

  /**
   * UsersMaster findMany
   */
  export type UsersMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersMaster
     */
    select?: UsersMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersMasterInclude<ExtArgs> | null
    /**
     * Filter, which UsersMasters to fetch.
     */
    where?: UsersMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersMasters to fetch.
     */
    orderBy?: UsersMasterOrderByWithRelationInput | UsersMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsersMasters.
     */
    cursor?: UsersMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersMasters.
     */
    skip?: number
    distinct?: UsersMasterScalarFieldEnum | UsersMasterScalarFieldEnum[]
  }

  /**
   * UsersMaster create
   */
  export type UsersMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersMaster
     */
    select?: UsersMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a UsersMaster.
     */
    data: XOR<UsersMasterCreateInput, UsersMasterUncheckedCreateInput>
  }

  /**
   * UsersMaster createMany
   */
  export type UsersMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsersMasters.
     */
    data: UsersMasterCreateManyInput | UsersMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsersMaster createManyAndReturn
   */
  export type UsersMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersMaster
     */
    select?: UsersMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UsersMasters.
     */
    data: UsersMasterCreateManyInput | UsersMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsersMaster update
   */
  export type UsersMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersMaster
     */
    select?: UsersMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a UsersMaster.
     */
    data: XOR<UsersMasterUpdateInput, UsersMasterUncheckedUpdateInput>
    /**
     * Choose, which UsersMaster to update.
     */
    where: UsersMasterWhereUniqueInput
  }

  /**
   * UsersMaster updateMany
   */
  export type UsersMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsersMasters.
     */
    data: XOR<UsersMasterUpdateManyMutationInput, UsersMasterUncheckedUpdateManyInput>
    /**
     * Filter which UsersMasters to update
     */
    where?: UsersMasterWhereInput
  }

  /**
   * UsersMaster upsert
   */
  export type UsersMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersMaster
     */
    select?: UsersMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the UsersMaster to update in case it exists.
     */
    where: UsersMasterWhereUniqueInput
    /**
     * In case the UsersMaster found by the `where` argument doesn't exist, create a new UsersMaster with this data.
     */
    create: XOR<UsersMasterCreateInput, UsersMasterUncheckedCreateInput>
    /**
     * In case the UsersMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersMasterUpdateInput, UsersMasterUncheckedUpdateInput>
  }

  /**
   * UsersMaster delete
   */
  export type UsersMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersMaster
     */
    select?: UsersMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersMasterInclude<ExtArgs> | null
    /**
     * Filter which UsersMaster to delete.
     */
    where: UsersMasterWhereUniqueInput
  }

  /**
   * UsersMaster deleteMany
   */
  export type UsersMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersMasters to delete
     */
    where?: UsersMasterWhereInput
  }

  /**
   * UsersMaster.surveyorAssignments
   */
  export type UsersMaster$surveyorAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyorAssignment
     */
    select?: SurveyorAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorAssignmentInclude<ExtArgs> | null
    where?: SurveyorAssignmentWhereInput
    orderBy?: SurveyorAssignmentOrderByWithRelationInput | SurveyorAssignmentOrderByWithRelationInput[]
    cursor?: SurveyorAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyorAssignmentScalarFieldEnum | SurveyorAssignmentScalarFieldEnum[]
  }

  /**
   * UsersMaster.surveyorAssignmentsAssignedBy
   */
  export type UsersMaster$surveyorAssignmentsAssignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyorAssignment
     */
    select?: SurveyorAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorAssignmentInclude<ExtArgs> | null
    where?: SurveyorAssignmentWhereInput
    orderBy?: SurveyorAssignmentOrderByWithRelationInput | SurveyorAssignmentOrderByWithRelationInput[]
    cursor?: SurveyorAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyorAssignmentScalarFieldEnum | SurveyorAssignmentScalarFieldEnum[]
  }

  /**
   * UsersMaster.wardStatusMaps
   */
  export type UsersMaster$wardStatusMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMapping
     */
    select?: WardStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMappingInclude<ExtArgs> | null
    where?: WardStatusMappingWhereInput
    orderBy?: WardStatusMappingOrderByWithRelationInput | WardStatusMappingOrderByWithRelationInput[]
    cursor?: WardStatusMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WardStatusMappingScalarFieldEnum | WardStatusMappingScalarFieldEnum[]
  }

  /**
   * UsersMaster.surveyStatusMaps
   */
  export type UsersMaster$surveyStatusMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMapping
     */
    select?: SurveyStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMappingInclude<ExtArgs> | null
    where?: SurveyStatusMappingWhereInput
    orderBy?: SurveyStatusMappingOrderByWithRelationInput | SurveyStatusMappingOrderByWithRelationInput[]
    cursor?: SurveyStatusMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyStatusMappingScalarFieldEnum | SurveyStatusMappingScalarFieldEnum[]
  }

  /**
   * UsersMaster.userRoleMaps
   */
  export type UsersMaster$userRoleMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    where?: UserRoleMappingWhereInput
    orderBy?: UserRoleMappingOrderByWithRelationInput | UserRoleMappingOrderByWithRelationInput[]
    cursor?: UserRoleMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleMappingScalarFieldEnum | UserRoleMappingScalarFieldEnum[]
  }

  /**
   * UsersMaster.sessions
   */
  export type UsersMaster$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * UsersMaster.surveyors
   */
  export type UsersMaster$surveyorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surveyors
     */
    select?: SurveyorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorsInclude<ExtArgs> | null
    where?: SurveyorsWhereInput
    orderBy?: SurveyorsOrderByWithRelationInput | SurveyorsOrderByWithRelationInput[]
    cursor?: SurveyorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyorsScalarFieldEnum | SurveyorsScalarFieldEnum[]
  }

  /**
   * UsersMaster.supervisors
   */
  export type UsersMaster$supervisorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supervisors
     */
    select?: SupervisorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupervisorsInclude<ExtArgs> | null
    where?: SupervisorsWhereInput
    orderBy?: SupervisorsOrderByWithRelationInput | SupervisorsOrderByWithRelationInput[]
    cursor?: SupervisorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupervisorsScalarFieldEnum | SupervisorsScalarFieldEnum[]
  }

  /**
   * UsersMaster.admins
   */
  export type UsersMaster$adminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    where?: AdminsWhereInput
    orderBy?: AdminsOrderByWithRelationInput | AdminsOrderByWithRelationInput[]
    cursor?: AdminsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[]
  }

  /**
   * UsersMaster without action
   */
  export type UsersMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersMaster
     */
    select?: UsersMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersMasterInclude<ExtArgs> | null
  }


  /**
   * Model RolePermissionMaster
   */

  export type AggregateRolePermissionMaster = {
    _count: RolePermissionMasterCountAggregateOutputType | null
    _min: RolePermissionMasterMinAggregateOutputType | null
    _max: RolePermissionMasterMaxAggregateOutputType | null
  }

  export type RolePermissionMasterMinAggregateOutputType = {
    roleId: string | null
    roleName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type RolePermissionMasterMaxAggregateOutputType = {
    roleId: string | null
    roleName: string | null
    isActive: boolean | null
    description: string | null
  }

  export type RolePermissionMasterCountAggregateOutputType = {
    roleId: number
    roleName: number
    isActive: number
    description: number
    _all: number
  }


  export type RolePermissionMasterMinAggregateInputType = {
    roleId?: true
    roleName?: true
    isActive?: true
    description?: true
  }

  export type RolePermissionMasterMaxAggregateInputType = {
    roleId?: true
    roleName?: true
    isActive?: true
    description?: true
  }

  export type RolePermissionMasterCountAggregateInputType = {
    roleId?: true
    roleName?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type RolePermissionMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissionMaster to aggregate.
     */
    where?: RolePermissionMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissionMasters to fetch.
     */
    orderBy?: RolePermissionMasterOrderByWithRelationInput | RolePermissionMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissionMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissionMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissionMasters
    **/
    _count?: true | RolePermissionMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMasterMaxAggregateInputType
  }

  export type GetRolePermissionMasterAggregateType<T extends RolePermissionMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermissionMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermissionMaster[P]>
      : GetScalarType<T[P], AggregateRolePermissionMaster[P]>
  }




  export type RolePermissionMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionMasterWhereInput
    orderBy?: RolePermissionMasterOrderByWithAggregationInput | RolePermissionMasterOrderByWithAggregationInput[]
    by: RolePermissionMasterScalarFieldEnum[] | RolePermissionMasterScalarFieldEnum
    having?: RolePermissionMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionMasterCountAggregateInputType | true
    _min?: RolePermissionMasterMinAggregateInputType
    _max?: RolePermissionMasterMaxAggregateInputType
  }

  export type RolePermissionMasterGroupByOutputType = {
    roleId: string
    roleName: string
    isActive: boolean
    description: string | null
    _count: RolePermissionMasterCountAggregateOutputType | null
    _min: RolePermissionMasterMinAggregateOutputType | null
    _max: RolePermissionMasterMaxAggregateOutputType | null
  }

  type GetRolePermissionMasterGroupByPayload<T extends RolePermissionMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionMasterGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionMasterGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    roleName?: boolean
    isActive?: boolean
    description?: boolean
    userRoleMaps?: boolean | RolePermissionMaster$userRoleMapsArgs<ExtArgs>
    _count?: boolean | RolePermissionMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermissionMaster"]>

  export type RolePermissionMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    roleName?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["rolePermissionMaster"]>

  export type RolePermissionMasterSelectScalar = {
    roleId?: boolean
    roleName?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type RolePermissionMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoleMaps?: boolean | RolePermissionMaster$userRoleMapsArgs<ExtArgs>
    _count?: boolean | RolePermissionMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RolePermissionMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePermissionMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermissionMaster"
    objects: {
      userRoleMaps: Prisma.$UserRoleMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      roleId: string
      roleName: string
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["rolePermissionMaster"]>
    composites: {}
  }

  type RolePermissionMasterGetPayload<S extends boolean | null | undefined | RolePermissionMasterDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionMasterPayload, S>

  type RolePermissionMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolePermissionMasterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolePermissionMasterCountAggregateInputType | true
    }

  export interface RolePermissionMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermissionMaster'], meta: { name: 'RolePermissionMaster' } }
    /**
     * Find zero or one RolePermissionMaster that matches the filter.
     * @param {RolePermissionMasterFindUniqueArgs} args - Arguments to find a RolePermissionMaster
     * @example
     * // Get one RolePermissionMaster
     * const rolePermissionMaster = await prisma.rolePermissionMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionMasterFindUniqueArgs>(args: SelectSubset<T, RolePermissionMasterFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionMasterClient<$Result.GetResult<Prisma.$RolePermissionMasterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolePermissionMaster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolePermissionMasterFindUniqueOrThrowArgs} args - Arguments to find a RolePermissionMaster
     * @example
     * // Get one RolePermissionMaster
     * const rolePermissionMaster = await prisma.rolePermissionMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionMasterClient<$Result.GetResult<Prisma.$RolePermissionMasterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolePermissionMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionMasterFindFirstArgs} args - Arguments to find a RolePermissionMaster
     * @example
     * // Get one RolePermissionMaster
     * const rolePermissionMaster = await prisma.rolePermissionMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionMasterFindFirstArgs>(args?: SelectSubset<T, RolePermissionMasterFindFirstArgs<ExtArgs>>): Prisma__RolePermissionMasterClient<$Result.GetResult<Prisma.$RolePermissionMasterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolePermissionMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionMasterFindFirstOrThrowArgs} args - Arguments to find a RolePermissionMaster
     * @example
     * // Get one RolePermissionMaster
     * const rolePermissionMaster = await prisma.rolePermissionMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionMasterClient<$Result.GetResult<Prisma.$RolePermissionMasterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolePermissionMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissionMasters
     * const rolePermissionMasters = await prisma.rolePermissionMaster.findMany()
     * 
     * // Get first 10 RolePermissionMasters
     * const rolePermissionMasters = await prisma.rolePermissionMaster.findMany({ take: 10 })
     * 
     * // Only select the `roleId`
     * const rolePermissionMasterWithRoleIdOnly = await prisma.rolePermissionMaster.findMany({ select: { roleId: true } })
     * 
     */
    findMany<T extends RolePermissionMasterFindManyArgs>(args?: SelectSubset<T, RolePermissionMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionMasterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolePermissionMaster.
     * @param {RolePermissionMasterCreateArgs} args - Arguments to create a RolePermissionMaster.
     * @example
     * // Create one RolePermissionMaster
     * const RolePermissionMaster = await prisma.rolePermissionMaster.create({
     *   data: {
     *     // ... data to create a RolePermissionMaster
     *   }
     * })
     * 
     */
    create<T extends RolePermissionMasterCreateArgs>(args: SelectSubset<T, RolePermissionMasterCreateArgs<ExtArgs>>): Prisma__RolePermissionMasterClient<$Result.GetResult<Prisma.$RolePermissionMasterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolePermissionMasters.
     * @param {RolePermissionMasterCreateManyArgs} args - Arguments to create many RolePermissionMasters.
     * @example
     * // Create many RolePermissionMasters
     * const rolePermissionMaster = await prisma.rolePermissionMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionMasterCreateManyArgs>(args?: SelectSubset<T, RolePermissionMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissionMasters and returns the data saved in the database.
     * @param {RolePermissionMasterCreateManyAndReturnArgs} args - Arguments to create many RolePermissionMasters.
     * @example
     * // Create many RolePermissionMasters
     * const rolePermissionMaster = await prisma.rolePermissionMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissionMasters and only return the `roleId`
     * const rolePermissionMasterWithRoleIdOnly = await prisma.rolePermissionMaster.createManyAndReturn({ 
     *   select: { roleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionMasterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RolePermissionMaster.
     * @param {RolePermissionMasterDeleteArgs} args - Arguments to delete one RolePermissionMaster.
     * @example
     * // Delete one RolePermissionMaster
     * const RolePermissionMaster = await prisma.rolePermissionMaster.delete({
     *   where: {
     *     // ... filter to delete one RolePermissionMaster
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionMasterDeleteArgs>(args: SelectSubset<T, RolePermissionMasterDeleteArgs<ExtArgs>>): Prisma__RolePermissionMasterClient<$Result.GetResult<Prisma.$RolePermissionMasterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolePermissionMaster.
     * @param {RolePermissionMasterUpdateArgs} args - Arguments to update one RolePermissionMaster.
     * @example
     * // Update one RolePermissionMaster
     * const rolePermissionMaster = await prisma.rolePermissionMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionMasterUpdateArgs>(args: SelectSubset<T, RolePermissionMasterUpdateArgs<ExtArgs>>): Prisma__RolePermissionMasterClient<$Result.GetResult<Prisma.$RolePermissionMasterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolePermissionMasters.
     * @param {RolePermissionMasterDeleteManyArgs} args - Arguments to filter RolePermissionMasters to delete.
     * @example
     * // Delete a few RolePermissionMasters
     * const { count } = await prisma.rolePermissionMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionMasterDeleteManyArgs>(args?: SelectSubset<T, RolePermissionMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissionMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissionMasters
     * const rolePermissionMaster = await prisma.rolePermissionMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionMasterUpdateManyArgs>(args: SelectSubset<T, RolePermissionMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermissionMaster.
     * @param {RolePermissionMasterUpsertArgs} args - Arguments to update or create a RolePermissionMaster.
     * @example
     * // Update or create a RolePermissionMaster
     * const rolePermissionMaster = await prisma.rolePermissionMaster.upsert({
     *   create: {
     *     // ... data to create a RolePermissionMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermissionMaster we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionMasterUpsertArgs>(args: SelectSubset<T, RolePermissionMasterUpsertArgs<ExtArgs>>): Prisma__RolePermissionMasterClient<$Result.GetResult<Prisma.$RolePermissionMasterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolePermissionMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionMasterCountArgs} args - Arguments to filter RolePermissionMasters to count.
     * @example
     * // Count the number of RolePermissionMasters
     * const count = await prisma.rolePermissionMaster.count({
     *   where: {
     *     // ... the filter for the RolePermissionMasters we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionMasterCountArgs>(
      args?: Subset<T, RolePermissionMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermissionMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionMasterAggregateArgs>(args: Subset<T, RolePermissionMasterAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionMasterAggregateType<T>>

    /**
     * Group by RolePermissionMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionMasterGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermissionMaster model
   */
  readonly fields: RolePermissionMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermissionMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRoleMaps<T extends RolePermissionMaster$userRoleMapsArgs<ExtArgs> = {}>(args?: Subset<T, RolePermissionMaster$userRoleMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermissionMaster model
   */ 
  interface RolePermissionMasterFieldRefs {
    readonly roleId: FieldRef<"RolePermissionMaster", 'String'>
    readonly roleName: FieldRef<"RolePermissionMaster", 'String'>
    readonly isActive: FieldRef<"RolePermissionMaster", 'Boolean'>
    readonly description: FieldRef<"RolePermissionMaster", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RolePermissionMaster findUnique
   */
  export type RolePermissionMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissionMaster
     */
    select?: RolePermissionMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionMasterInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissionMaster to fetch.
     */
    where: RolePermissionMasterWhereUniqueInput
  }

  /**
   * RolePermissionMaster findUniqueOrThrow
   */
  export type RolePermissionMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissionMaster
     */
    select?: RolePermissionMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionMasterInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissionMaster to fetch.
     */
    where: RolePermissionMasterWhereUniqueInput
  }

  /**
   * RolePermissionMaster findFirst
   */
  export type RolePermissionMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissionMaster
     */
    select?: RolePermissionMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionMasterInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissionMaster to fetch.
     */
    where?: RolePermissionMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissionMasters to fetch.
     */
    orderBy?: RolePermissionMasterOrderByWithRelationInput | RolePermissionMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissionMasters.
     */
    cursor?: RolePermissionMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissionMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissionMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissionMasters.
     */
    distinct?: RolePermissionMasterScalarFieldEnum | RolePermissionMasterScalarFieldEnum[]
  }

  /**
   * RolePermissionMaster findFirstOrThrow
   */
  export type RolePermissionMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissionMaster
     */
    select?: RolePermissionMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionMasterInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissionMaster to fetch.
     */
    where?: RolePermissionMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissionMasters to fetch.
     */
    orderBy?: RolePermissionMasterOrderByWithRelationInput | RolePermissionMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissionMasters.
     */
    cursor?: RolePermissionMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissionMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissionMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissionMasters.
     */
    distinct?: RolePermissionMasterScalarFieldEnum | RolePermissionMasterScalarFieldEnum[]
  }

  /**
   * RolePermissionMaster findMany
   */
  export type RolePermissionMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissionMaster
     */
    select?: RolePermissionMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionMasterInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissionMasters to fetch.
     */
    where?: RolePermissionMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissionMasters to fetch.
     */
    orderBy?: RolePermissionMasterOrderByWithRelationInput | RolePermissionMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissionMasters.
     */
    cursor?: RolePermissionMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissionMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissionMasters.
     */
    skip?: number
    distinct?: RolePermissionMasterScalarFieldEnum | RolePermissionMasterScalarFieldEnum[]
  }

  /**
   * RolePermissionMaster create
   */
  export type RolePermissionMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissionMaster
     */
    select?: RolePermissionMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermissionMaster.
     */
    data: XOR<RolePermissionMasterCreateInput, RolePermissionMasterUncheckedCreateInput>
  }

  /**
   * RolePermissionMaster createMany
   */
  export type RolePermissionMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissionMasters.
     */
    data: RolePermissionMasterCreateManyInput | RolePermissionMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermissionMaster createManyAndReturn
   */
  export type RolePermissionMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissionMaster
     */
    select?: RolePermissionMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RolePermissionMasters.
     */
    data: RolePermissionMasterCreateManyInput | RolePermissionMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermissionMaster update
   */
  export type RolePermissionMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissionMaster
     */
    select?: RolePermissionMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermissionMaster.
     */
    data: XOR<RolePermissionMasterUpdateInput, RolePermissionMasterUncheckedUpdateInput>
    /**
     * Choose, which RolePermissionMaster to update.
     */
    where: RolePermissionMasterWhereUniqueInput
  }

  /**
   * RolePermissionMaster updateMany
   */
  export type RolePermissionMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissionMasters.
     */
    data: XOR<RolePermissionMasterUpdateManyMutationInput, RolePermissionMasterUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissionMasters to update
     */
    where?: RolePermissionMasterWhereInput
  }

  /**
   * RolePermissionMaster upsert
   */
  export type RolePermissionMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissionMaster
     */
    select?: RolePermissionMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermissionMaster to update in case it exists.
     */
    where: RolePermissionMasterWhereUniqueInput
    /**
     * In case the RolePermissionMaster found by the `where` argument doesn't exist, create a new RolePermissionMaster with this data.
     */
    create: XOR<RolePermissionMasterCreateInput, RolePermissionMasterUncheckedCreateInput>
    /**
     * In case the RolePermissionMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionMasterUpdateInput, RolePermissionMasterUncheckedUpdateInput>
  }

  /**
   * RolePermissionMaster delete
   */
  export type RolePermissionMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissionMaster
     */
    select?: RolePermissionMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionMasterInclude<ExtArgs> | null
    /**
     * Filter which RolePermissionMaster to delete.
     */
    where: RolePermissionMasterWhereUniqueInput
  }

  /**
   * RolePermissionMaster deleteMany
   */
  export type RolePermissionMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissionMasters to delete
     */
    where?: RolePermissionMasterWhereInput
  }

  /**
   * RolePermissionMaster.userRoleMaps
   */
  export type RolePermissionMaster$userRoleMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    where?: UserRoleMappingWhereInput
    orderBy?: UserRoleMappingOrderByWithRelationInput | UserRoleMappingOrderByWithRelationInput[]
    cursor?: UserRoleMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleMappingScalarFieldEnum | UserRoleMappingScalarFieldEnum[]
  }

  /**
   * RolePermissionMaster without action
   */
  export type RolePermissionMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissionMaster
     */
    select?: RolePermissionMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionMasterInclude<ExtArgs> | null
  }


  /**
   * Model UlbZoneMapping
   */

  export type AggregateUlbZoneMapping = {
    _count: UlbZoneMappingCountAggregateOutputType | null
    _min: UlbZoneMappingMinAggregateOutputType | null
    _max: UlbZoneMappingMaxAggregateOutputType | null
  }

  export type UlbZoneMappingMinAggregateOutputType = {
    ulbZoneMapId: string | null
    ulbId: string | null
    zoneId: string | null
    isActive: boolean | null
  }

  export type UlbZoneMappingMaxAggregateOutputType = {
    ulbZoneMapId: string | null
    ulbId: string | null
    zoneId: string | null
    isActive: boolean | null
  }

  export type UlbZoneMappingCountAggregateOutputType = {
    ulbZoneMapId: number
    ulbId: number
    zoneId: number
    isActive: number
    _all: number
  }


  export type UlbZoneMappingMinAggregateInputType = {
    ulbZoneMapId?: true
    ulbId?: true
    zoneId?: true
    isActive?: true
  }

  export type UlbZoneMappingMaxAggregateInputType = {
    ulbZoneMapId?: true
    ulbId?: true
    zoneId?: true
    isActive?: true
  }

  export type UlbZoneMappingCountAggregateInputType = {
    ulbZoneMapId?: true
    ulbId?: true
    zoneId?: true
    isActive?: true
    _all?: true
  }

  export type UlbZoneMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UlbZoneMapping to aggregate.
     */
    where?: UlbZoneMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UlbZoneMappings to fetch.
     */
    orderBy?: UlbZoneMappingOrderByWithRelationInput | UlbZoneMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UlbZoneMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UlbZoneMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UlbZoneMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UlbZoneMappings
    **/
    _count?: true | UlbZoneMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UlbZoneMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UlbZoneMappingMaxAggregateInputType
  }

  export type GetUlbZoneMappingAggregateType<T extends UlbZoneMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateUlbZoneMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUlbZoneMapping[P]>
      : GetScalarType<T[P], AggregateUlbZoneMapping[P]>
  }




  export type UlbZoneMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UlbZoneMappingWhereInput
    orderBy?: UlbZoneMappingOrderByWithAggregationInput | UlbZoneMappingOrderByWithAggregationInput[]
    by: UlbZoneMappingScalarFieldEnum[] | UlbZoneMappingScalarFieldEnum
    having?: UlbZoneMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UlbZoneMappingCountAggregateInputType | true
    _min?: UlbZoneMappingMinAggregateInputType
    _max?: UlbZoneMappingMaxAggregateInputType
  }

  export type UlbZoneMappingGroupByOutputType = {
    ulbZoneMapId: string
    ulbId: string
    zoneId: string
    isActive: boolean
    _count: UlbZoneMappingCountAggregateOutputType | null
    _min: UlbZoneMappingMinAggregateOutputType | null
    _max: UlbZoneMappingMaxAggregateOutputType | null
  }

  type GetUlbZoneMappingGroupByPayload<T extends UlbZoneMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UlbZoneMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UlbZoneMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UlbZoneMappingGroupByOutputType[P]>
            : GetScalarType<T[P], UlbZoneMappingGroupByOutputType[P]>
        }
      >
    >


  export type UlbZoneMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ulbZoneMapId?: boolean
    ulbId?: boolean
    zoneId?: boolean
    isActive?: boolean
    ulb?: boolean | UlbMasterDefaultArgs<ExtArgs>
    zone?: boolean | ZoneMasterDefaultArgs<ExtArgs>
    surveyors?: boolean | UlbZoneMapping$surveyorsArgs<ExtArgs>
    _count?: boolean | UlbZoneMappingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ulbZoneMapping"]>

  export type UlbZoneMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ulbZoneMapId?: boolean
    ulbId?: boolean
    zoneId?: boolean
    isActive?: boolean
    ulb?: boolean | UlbMasterDefaultArgs<ExtArgs>
    zone?: boolean | ZoneMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ulbZoneMapping"]>

  export type UlbZoneMappingSelectScalar = {
    ulbZoneMapId?: boolean
    ulbId?: boolean
    zoneId?: boolean
    isActive?: boolean
  }

  export type UlbZoneMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ulb?: boolean | UlbMasterDefaultArgs<ExtArgs>
    zone?: boolean | ZoneMasterDefaultArgs<ExtArgs>
    surveyors?: boolean | UlbZoneMapping$surveyorsArgs<ExtArgs>
    _count?: boolean | UlbZoneMappingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UlbZoneMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ulb?: boolean | UlbMasterDefaultArgs<ExtArgs>
    zone?: boolean | ZoneMasterDefaultArgs<ExtArgs>
  }

  export type $UlbZoneMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UlbZoneMapping"
    objects: {
      ulb: Prisma.$UlbMasterPayload<ExtArgs>
      zone: Prisma.$ZoneMasterPayload<ExtArgs>
      surveyors: Prisma.$SurveyorsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ulbZoneMapId: string
      ulbId: string
      zoneId: string
      isActive: boolean
    }, ExtArgs["result"]["ulbZoneMapping"]>
    composites: {}
  }

  type UlbZoneMappingGetPayload<S extends boolean | null | undefined | UlbZoneMappingDefaultArgs> = $Result.GetResult<Prisma.$UlbZoneMappingPayload, S>

  type UlbZoneMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UlbZoneMappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UlbZoneMappingCountAggregateInputType | true
    }

  export interface UlbZoneMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UlbZoneMapping'], meta: { name: 'UlbZoneMapping' } }
    /**
     * Find zero or one UlbZoneMapping that matches the filter.
     * @param {UlbZoneMappingFindUniqueArgs} args - Arguments to find a UlbZoneMapping
     * @example
     * // Get one UlbZoneMapping
     * const ulbZoneMapping = await prisma.ulbZoneMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UlbZoneMappingFindUniqueArgs>(args: SelectSubset<T, UlbZoneMappingFindUniqueArgs<ExtArgs>>): Prisma__UlbZoneMappingClient<$Result.GetResult<Prisma.$UlbZoneMappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UlbZoneMapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UlbZoneMappingFindUniqueOrThrowArgs} args - Arguments to find a UlbZoneMapping
     * @example
     * // Get one UlbZoneMapping
     * const ulbZoneMapping = await prisma.ulbZoneMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UlbZoneMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, UlbZoneMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UlbZoneMappingClient<$Result.GetResult<Prisma.$UlbZoneMappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UlbZoneMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UlbZoneMappingFindFirstArgs} args - Arguments to find a UlbZoneMapping
     * @example
     * // Get one UlbZoneMapping
     * const ulbZoneMapping = await prisma.ulbZoneMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UlbZoneMappingFindFirstArgs>(args?: SelectSubset<T, UlbZoneMappingFindFirstArgs<ExtArgs>>): Prisma__UlbZoneMappingClient<$Result.GetResult<Prisma.$UlbZoneMappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UlbZoneMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UlbZoneMappingFindFirstOrThrowArgs} args - Arguments to find a UlbZoneMapping
     * @example
     * // Get one UlbZoneMapping
     * const ulbZoneMapping = await prisma.ulbZoneMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UlbZoneMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, UlbZoneMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UlbZoneMappingClient<$Result.GetResult<Prisma.$UlbZoneMappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UlbZoneMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UlbZoneMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UlbZoneMappings
     * const ulbZoneMappings = await prisma.ulbZoneMapping.findMany()
     * 
     * // Get first 10 UlbZoneMappings
     * const ulbZoneMappings = await prisma.ulbZoneMapping.findMany({ take: 10 })
     * 
     * // Only select the `ulbZoneMapId`
     * const ulbZoneMappingWithUlbZoneMapIdOnly = await prisma.ulbZoneMapping.findMany({ select: { ulbZoneMapId: true } })
     * 
     */
    findMany<T extends UlbZoneMappingFindManyArgs>(args?: SelectSubset<T, UlbZoneMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UlbZoneMappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UlbZoneMapping.
     * @param {UlbZoneMappingCreateArgs} args - Arguments to create a UlbZoneMapping.
     * @example
     * // Create one UlbZoneMapping
     * const UlbZoneMapping = await prisma.ulbZoneMapping.create({
     *   data: {
     *     // ... data to create a UlbZoneMapping
     *   }
     * })
     * 
     */
    create<T extends UlbZoneMappingCreateArgs>(args: SelectSubset<T, UlbZoneMappingCreateArgs<ExtArgs>>): Prisma__UlbZoneMappingClient<$Result.GetResult<Prisma.$UlbZoneMappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UlbZoneMappings.
     * @param {UlbZoneMappingCreateManyArgs} args - Arguments to create many UlbZoneMappings.
     * @example
     * // Create many UlbZoneMappings
     * const ulbZoneMapping = await prisma.ulbZoneMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UlbZoneMappingCreateManyArgs>(args?: SelectSubset<T, UlbZoneMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UlbZoneMappings and returns the data saved in the database.
     * @param {UlbZoneMappingCreateManyAndReturnArgs} args - Arguments to create many UlbZoneMappings.
     * @example
     * // Create many UlbZoneMappings
     * const ulbZoneMapping = await prisma.ulbZoneMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UlbZoneMappings and only return the `ulbZoneMapId`
     * const ulbZoneMappingWithUlbZoneMapIdOnly = await prisma.ulbZoneMapping.createManyAndReturn({ 
     *   select: { ulbZoneMapId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UlbZoneMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, UlbZoneMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UlbZoneMappingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UlbZoneMapping.
     * @param {UlbZoneMappingDeleteArgs} args - Arguments to delete one UlbZoneMapping.
     * @example
     * // Delete one UlbZoneMapping
     * const UlbZoneMapping = await prisma.ulbZoneMapping.delete({
     *   where: {
     *     // ... filter to delete one UlbZoneMapping
     *   }
     * })
     * 
     */
    delete<T extends UlbZoneMappingDeleteArgs>(args: SelectSubset<T, UlbZoneMappingDeleteArgs<ExtArgs>>): Prisma__UlbZoneMappingClient<$Result.GetResult<Prisma.$UlbZoneMappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UlbZoneMapping.
     * @param {UlbZoneMappingUpdateArgs} args - Arguments to update one UlbZoneMapping.
     * @example
     * // Update one UlbZoneMapping
     * const ulbZoneMapping = await prisma.ulbZoneMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UlbZoneMappingUpdateArgs>(args: SelectSubset<T, UlbZoneMappingUpdateArgs<ExtArgs>>): Prisma__UlbZoneMappingClient<$Result.GetResult<Prisma.$UlbZoneMappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UlbZoneMappings.
     * @param {UlbZoneMappingDeleteManyArgs} args - Arguments to filter UlbZoneMappings to delete.
     * @example
     * // Delete a few UlbZoneMappings
     * const { count } = await prisma.ulbZoneMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UlbZoneMappingDeleteManyArgs>(args?: SelectSubset<T, UlbZoneMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UlbZoneMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UlbZoneMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UlbZoneMappings
     * const ulbZoneMapping = await prisma.ulbZoneMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UlbZoneMappingUpdateManyArgs>(args: SelectSubset<T, UlbZoneMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UlbZoneMapping.
     * @param {UlbZoneMappingUpsertArgs} args - Arguments to update or create a UlbZoneMapping.
     * @example
     * // Update or create a UlbZoneMapping
     * const ulbZoneMapping = await prisma.ulbZoneMapping.upsert({
     *   create: {
     *     // ... data to create a UlbZoneMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UlbZoneMapping we want to update
     *   }
     * })
     */
    upsert<T extends UlbZoneMappingUpsertArgs>(args: SelectSubset<T, UlbZoneMappingUpsertArgs<ExtArgs>>): Prisma__UlbZoneMappingClient<$Result.GetResult<Prisma.$UlbZoneMappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UlbZoneMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UlbZoneMappingCountArgs} args - Arguments to filter UlbZoneMappings to count.
     * @example
     * // Count the number of UlbZoneMappings
     * const count = await prisma.ulbZoneMapping.count({
     *   where: {
     *     // ... the filter for the UlbZoneMappings we want to count
     *   }
     * })
    **/
    count<T extends UlbZoneMappingCountArgs>(
      args?: Subset<T, UlbZoneMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UlbZoneMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UlbZoneMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UlbZoneMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UlbZoneMappingAggregateArgs>(args: Subset<T, UlbZoneMappingAggregateArgs>): Prisma.PrismaPromise<GetUlbZoneMappingAggregateType<T>>

    /**
     * Group by UlbZoneMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UlbZoneMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UlbZoneMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UlbZoneMappingGroupByArgs['orderBy'] }
        : { orderBy?: UlbZoneMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UlbZoneMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUlbZoneMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UlbZoneMapping model
   */
  readonly fields: UlbZoneMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UlbZoneMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UlbZoneMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ulb<T extends UlbMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UlbMasterDefaultArgs<ExtArgs>>): Prisma__UlbMasterClient<$Result.GetResult<Prisma.$UlbMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    zone<T extends ZoneMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneMasterDefaultArgs<ExtArgs>>): Prisma__ZoneMasterClient<$Result.GetResult<Prisma.$ZoneMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    surveyors<T extends UlbZoneMapping$surveyorsArgs<ExtArgs> = {}>(args?: Subset<T, UlbZoneMapping$surveyorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyorsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UlbZoneMapping model
   */ 
  interface UlbZoneMappingFieldRefs {
    readonly ulbZoneMapId: FieldRef<"UlbZoneMapping", 'String'>
    readonly ulbId: FieldRef<"UlbZoneMapping", 'String'>
    readonly zoneId: FieldRef<"UlbZoneMapping", 'String'>
    readonly isActive: FieldRef<"UlbZoneMapping", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UlbZoneMapping findUnique
   */
  export type UlbZoneMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbZoneMapping
     */
    select?: UlbZoneMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbZoneMappingInclude<ExtArgs> | null
    /**
     * Filter, which UlbZoneMapping to fetch.
     */
    where: UlbZoneMappingWhereUniqueInput
  }

  /**
   * UlbZoneMapping findUniqueOrThrow
   */
  export type UlbZoneMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbZoneMapping
     */
    select?: UlbZoneMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbZoneMappingInclude<ExtArgs> | null
    /**
     * Filter, which UlbZoneMapping to fetch.
     */
    where: UlbZoneMappingWhereUniqueInput
  }

  /**
   * UlbZoneMapping findFirst
   */
  export type UlbZoneMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbZoneMapping
     */
    select?: UlbZoneMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbZoneMappingInclude<ExtArgs> | null
    /**
     * Filter, which UlbZoneMapping to fetch.
     */
    where?: UlbZoneMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UlbZoneMappings to fetch.
     */
    orderBy?: UlbZoneMappingOrderByWithRelationInput | UlbZoneMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UlbZoneMappings.
     */
    cursor?: UlbZoneMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UlbZoneMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UlbZoneMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UlbZoneMappings.
     */
    distinct?: UlbZoneMappingScalarFieldEnum | UlbZoneMappingScalarFieldEnum[]
  }

  /**
   * UlbZoneMapping findFirstOrThrow
   */
  export type UlbZoneMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbZoneMapping
     */
    select?: UlbZoneMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbZoneMappingInclude<ExtArgs> | null
    /**
     * Filter, which UlbZoneMapping to fetch.
     */
    where?: UlbZoneMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UlbZoneMappings to fetch.
     */
    orderBy?: UlbZoneMappingOrderByWithRelationInput | UlbZoneMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UlbZoneMappings.
     */
    cursor?: UlbZoneMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UlbZoneMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UlbZoneMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UlbZoneMappings.
     */
    distinct?: UlbZoneMappingScalarFieldEnum | UlbZoneMappingScalarFieldEnum[]
  }

  /**
   * UlbZoneMapping findMany
   */
  export type UlbZoneMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbZoneMapping
     */
    select?: UlbZoneMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbZoneMappingInclude<ExtArgs> | null
    /**
     * Filter, which UlbZoneMappings to fetch.
     */
    where?: UlbZoneMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UlbZoneMappings to fetch.
     */
    orderBy?: UlbZoneMappingOrderByWithRelationInput | UlbZoneMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UlbZoneMappings.
     */
    cursor?: UlbZoneMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UlbZoneMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UlbZoneMappings.
     */
    skip?: number
    distinct?: UlbZoneMappingScalarFieldEnum | UlbZoneMappingScalarFieldEnum[]
  }

  /**
   * UlbZoneMapping create
   */
  export type UlbZoneMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbZoneMapping
     */
    select?: UlbZoneMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbZoneMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a UlbZoneMapping.
     */
    data: XOR<UlbZoneMappingCreateInput, UlbZoneMappingUncheckedCreateInput>
  }

  /**
   * UlbZoneMapping createMany
   */
  export type UlbZoneMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UlbZoneMappings.
     */
    data: UlbZoneMappingCreateManyInput | UlbZoneMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UlbZoneMapping createManyAndReturn
   */
  export type UlbZoneMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbZoneMapping
     */
    select?: UlbZoneMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UlbZoneMappings.
     */
    data: UlbZoneMappingCreateManyInput | UlbZoneMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbZoneMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UlbZoneMapping update
   */
  export type UlbZoneMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbZoneMapping
     */
    select?: UlbZoneMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbZoneMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a UlbZoneMapping.
     */
    data: XOR<UlbZoneMappingUpdateInput, UlbZoneMappingUncheckedUpdateInput>
    /**
     * Choose, which UlbZoneMapping to update.
     */
    where: UlbZoneMappingWhereUniqueInput
  }

  /**
   * UlbZoneMapping updateMany
   */
  export type UlbZoneMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UlbZoneMappings.
     */
    data: XOR<UlbZoneMappingUpdateManyMutationInput, UlbZoneMappingUncheckedUpdateManyInput>
    /**
     * Filter which UlbZoneMappings to update
     */
    where?: UlbZoneMappingWhereInput
  }

  /**
   * UlbZoneMapping upsert
   */
  export type UlbZoneMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbZoneMapping
     */
    select?: UlbZoneMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbZoneMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the UlbZoneMapping to update in case it exists.
     */
    where: UlbZoneMappingWhereUniqueInput
    /**
     * In case the UlbZoneMapping found by the `where` argument doesn't exist, create a new UlbZoneMapping with this data.
     */
    create: XOR<UlbZoneMappingCreateInput, UlbZoneMappingUncheckedCreateInput>
    /**
     * In case the UlbZoneMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UlbZoneMappingUpdateInput, UlbZoneMappingUncheckedUpdateInput>
  }

  /**
   * UlbZoneMapping delete
   */
  export type UlbZoneMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbZoneMapping
     */
    select?: UlbZoneMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbZoneMappingInclude<ExtArgs> | null
    /**
     * Filter which UlbZoneMapping to delete.
     */
    where: UlbZoneMappingWhereUniqueInput
  }

  /**
   * UlbZoneMapping deleteMany
   */
  export type UlbZoneMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UlbZoneMappings to delete
     */
    where?: UlbZoneMappingWhereInput
  }

  /**
   * UlbZoneMapping.surveyors
   */
  export type UlbZoneMapping$surveyorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surveyors
     */
    select?: SurveyorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorsInclude<ExtArgs> | null
    where?: SurveyorsWhereInput
    orderBy?: SurveyorsOrderByWithRelationInput | SurveyorsOrderByWithRelationInput[]
    cursor?: SurveyorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyorsScalarFieldEnum | SurveyorsScalarFieldEnum[]
  }

  /**
   * UlbZoneMapping without action
   */
  export type UlbZoneMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UlbZoneMapping
     */
    select?: UlbZoneMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UlbZoneMappingInclude<ExtArgs> | null
  }


  /**
   * Model ZoneWardMapping
   */

  export type AggregateZoneWardMapping = {
    _count: ZoneWardMappingCountAggregateOutputType | null
    _min: ZoneWardMappingMinAggregateOutputType | null
    _max: ZoneWardMappingMaxAggregateOutputType | null
  }

  export type ZoneWardMappingMinAggregateOutputType = {
    zoneWardMapId: string | null
    zoneId: string | null
    wardId: string | null
    isActive: boolean | null
  }

  export type ZoneWardMappingMaxAggregateOutputType = {
    zoneWardMapId: string | null
    zoneId: string | null
    wardId: string | null
    isActive: boolean | null
  }

  export type ZoneWardMappingCountAggregateOutputType = {
    zoneWardMapId: number
    zoneId: number
    wardId: number
    isActive: number
    _all: number
  }


  export type ZoneWardMappingMinAggregateInputType = {
    zoneWardMapId?: true
    zoneId?: true
    wardId?: true
    isActive?: true
  }

  export type ZoneWardMappingMaxAggregateInputType = {
    zoneWardMapId?: true
    zoneId?: true
    wardId?: true
    isActive?: true
  }

  export type ZoneWardMappingCountAggregateInputType = {
    zoneWardMapId?: true
    zoneId?: true
    wardId?: true
    isActive?: true
    _all?: true
  }

  export type ZoneWardMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZoneWardMapping to aggregate.
     */
    where?: ZoneWardMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoneWardMappings to fetch.
     */
    orderBy?: ZoneWardMappingOrderByWithRelationInput | ZoneWardMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoneWardMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoneWardMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoneWardMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ZoneWardMappings
    **/
    _count?: true | ZoneWardMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneWardMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneWardMappingMaxAggregateInputType
  }

  export type GetZoneWardMappingAggregateType<T extends ZoneWardMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateZoneWardMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZoneWardMapping[P]>
      : GetScalarType<T[P], AggregateZoneWardMapping[P]>
  }




  export type ZoneWardMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWardMappingWhereInput
    orderBy?: ZoneWardMappingOrderByWithAggregationInput | ZoneWardMappingOrderByWithAggregationInput[]
    by: ZoneWardMappingScalarFieldEnum[] | ZoneWardMappingScalarFieldEnum
    having?: ZoneWardMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneWardMappingCountAggregateInputType | true
    _min?: ZoneWardMappingMinAggregateInputType
    _max?: ZoneWardMappingMaxAggregateInputType
  }

  export type ZoneWardMappingGroupByOutputType = {
    zoneWardMapId: string
    zoneId: string
    wardId: string
    isActive: boolean
    _count: ZoneWardMappingCountAggregateOutputType | null
    _min: ZoneWardMappingMinAggregateOutputType | null
    _max: ZoneWardMappingMaxAggregateOutputType | null
  }

  type GetZoneWardMappingGroupByPayload<T extends ZoneWardMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneWardMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneWardMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneWardMappingGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneWardMappingGroupByOutputType[P]>
        }
      >
    >


  export type ZoneWardMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    zoneWardMapId?: boolean
    zoneId?: boolean
    wardId?: boolean
    isActive?: boolean
    zone?: boolean | ZoneMasterDefaultArgs<ExtArgs>
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    surveyors?: boolean | ZoneWardMapping$surveyorsArgs<ExtArgs>
    _count?: boolean | ZoneWardMappingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zoneWardMapping"]>

  export type ZoneWardMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    zoneWardMapId?: boolean
    zoneId?: boolean
    wardId?: boolean
    isActive?: boolean
    zone?: boolean | ZoneMasterDefaultArgs<ExtArgs>
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zoneWardMapping"]>

  export type ZoneWardMappingSelectScalar = {
    zoneWardMapId?: boolean
    zoneId?: boolean
    wardId?: boolean
    isActive?: boolean
  }

  export type ZoneWardMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneMasterDefaultArgs<ExtArgs>
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    surveyors?: boolean | ZoneWardMapping$surveyorsArgs<ExtArgs>
    _count?: boolean | ZoneWardMappingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ZoneWardMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneMasterDefaultArgs<ExtArgs>
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
  }

  export type $ZoneWardMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ZoneWardMapping"
    objects: {
      zone: Prisma.$ZoneMasterPayload<ExtArgs>
      ward: Prisma.$WardMasterPayload<ExtArgs>
      surveyors: Prisma.$SurveyorsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      zoneWardMapId: string
      zoneId: string
      wardId: string
      isActive: boolean
    }, ExtArgs["result"]["zoneWardMapping"]>
    composites: {}
  }

  type ZoneWardMappingGetPayload<S extends boolean | null | undefined | ZoneWardMappingDefaultArgs> = $Result.GetResult<Prisma.$ZoneWardMappingPayload, S>

  type ZoneWardMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ZoneWardMappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ZoneWardMappingCountAggregateInputType | true
    }

  export interface ZoneWardMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ZoneWardMapping'], meta: { name: 'ZoneWardMapping' } }
    /**
     * Find zero or one ZoneWardMapping that matches the filter.
     * @param {ZoneWardMappingFindUniqueArgs} args - Arguments to find a ZoneWardMapping
     * @example
     * // Get one ZoneWardMapping
     * const zoneWardMapping = await prisma.zoneWardMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZoneWardMappingFindUniqueArgs>(args: SelectSubset<T, ZoneWardMappingFindUniqueArgs<ExtArgs>>): Prisma__ZoneWardMappingClient<$Result.GetResult<Prisma.$ZoneWardMappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ZoneWardMapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ZoneWardMappingFindUniqueOrThrowArgs} args - Arguments to find a ZoneWardMapping
     * @example
     * // Get one ZoneWardMapping
     * const zoneWardMapping = await prisma.zoneWardMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZoneWardMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, ZoneWardMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZoneWardMappingClient<$Result.GetResult<Prisma.$ZoneWardMappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ZoneWardMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneWardMappingFindFirstArgs} args - Arguments to find a ZoneWardMapping
     * @example
     * // Get one ZoneWardMapping
     * const zoneWardMapping = await prisma.zoneWardMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZoneWardMappingFindFirstArgs>(args?: SelectSubset<T, ZoneWardMappingFindFirstArgs<ExtArgs>>): Prisma__ZoneWardMappingClient<$Result.GetResult<Prisma.$ZoneWardMappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ZoneWardMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneWardMappingFindFirstOrThrowArgs} args - Arguments to find a ZoneWardMapping
     * @example
     * // Get one ZoneWardMapping
     * const zoneWardMapping = await prisma.zoneWardMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZoneWardMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, ZoneWardMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZoneWardMappingClient<$Result.GetResult<Prisma.$ZoneWardMappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ZoneWardMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneWardMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ZoneWardMappings
     * const zoneWardMappings = await prisma.zoneWardMapping.findMany()
     * 
     * // Get first 10 ZoneWardMappings
     * const zoneWardMappings = await prisma.zoneWardMapping.findMany({ take: 10 })
     * 
     * // Only select the `zoneWardMapId`
     * const zoneWardMappingWithZoneWardMapIdOnly = await prisma.zoneWardMapping.findMany({ select: { zoneWardMapId: true } })
     * 
     */
    findMany<T extends ZoneWardMappingFindManyArgs>(args?: SelectSubset<T, ZoneWardMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoneWardMappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ZoneWardMapping.
     * @param {ZoneWardMappingCreateArgs} args - Arguments to create a ZoneWardMapping.
     * @example
     * // Create one ZoneWardMapping
     * const ZoneWardMapping = await prisma.zoneWardMapping.create({
     *   data: {
     *     // ... data to create a ZoneWardMapping
     *   }
     * })
     * 
     */
    create<T extends ZoneWardMappingCreateArgs>(args: SelectSubset<T, ZoneWardMappingCreateArgs<ExtArgs>>): Prisma__ZoneWardMappingClient<$Result.GetResult<Prisma.$ZoneWardMappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ZoneWardMappings.
     * @param {ZoneWardMappingCreateManyArgs} args - Arguments to create many ZoneWardMappings.
     * @example
     * // Create many ZoneWardMappings
     * const zoneWardMapping = await prisma.zoneWardMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZoneWardMappingCreateManyArgs>(args?: SelectSubset<T, ZoneWardMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ZoneWardMappings and returns the data saved in the database.
     * @param {ZoneWardMappingCreateManyAndReturnArgs} args - Arguments to create many ZoneWardMappings.
     * @example
     * // Create many ZoneWardMappings
     * const zoneWardMapping = await prisma.zoneWardMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ZoneWardMappings and only return the `zoneWardMapId`
     * const zoneWardMappingWithZoneWardMapIdOnly = await prisma.zoneWardMapping.createManyAndReturn({ 
     *   select: { zoneWardMapId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZoneWardMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, ZoneWardMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoneWardMappingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ZoneWardMapping.
     * @param {ZoneWardMappingDeleteArgs} args - Arguments to delete one ZoneWardMapping.
     * @example
     * // Delete one ZoneWardMapping
     * const ZoneWardMapping = await prisma.zoneWardMapping.delete({
     *   where: {
     *     // ... filter to delete one ZoneWardMapping
     *   }
     * })
     * 
     */
    delete<T extends ZoneWardMappingDeleteArgs>(args: SelectSubset<T, ZoneWardMappingDeleteArgs<ExtArgs>>): Prisma__ZoneWardMappingClient<$Result.GetResult<Prisma.$ZoneWardMappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ZoneWardMapping.
     * @param {ZoneWardMappingUpdateArgs} args - Arguments to update one ZoneWardMapping.
     * @example
     * // Update one ZoneWardMapping
     * const zoneWardMapping = await prisma.zoneWardMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZoneWardMappingUpdateArgs>(args: SelectSubset<T, ZoneWardMappingUpdateArgs<ExtArgs>>): Prisma__ZoneWardMappingClient<$Result.GetResult<Prisma.$ZoneWardMappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ZoneWardMappings.
     * @param {ZoneWardMappingDeleteManyArgs} args - Arguments to filter ZoneWardMappings to delete.
     * @example
     * // Delete a few ZoneWardMappings
     * const { count } = await prisma.zoneWardMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZoneWardMappingDeleteManyArgs>(args?: SelectSubset<T, ZoneWardMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZoneWardMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneWardMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ZoneWardMappings
     * const zoneWardMapping = await prisma.zoneWardMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZoneWardMappingUpdateManyArgs>(args: SelectSubset<T, ZoneWardMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ZoneWardMapping.
     * @param {ZoneWardMappingUpsertArgs} args - Arguments to update or create a ZoneWardMapping.
     * @example
     * // Update or create a ZoneWardMapping
     * const zoneWardMapping = await prisma.zoneWardMapping.upsert({
     *   create: {
     *     // ... data to create a ZoneWardMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ZoneWardMapping we want to update
     *   }
     * })
     */
    upsert<T extends ZoneWardMappingUpsertArgs>(args: SelectSubset<T, ZoneWardMappingUpsertArgs<ExtArgs>>): Prisma__ZoneWardMappingClient<$Result.GetResult<Prisma.$ZoneWardMappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ZoneWardMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneWardMappingCountArgs} args - Arguments to filter ZoneWardMappings to count.
     * @example
     * // Count the number of ZoneWardMappings
     * const count = await prisma.zoneWardMapping.count({
     *   where: {
     *     // ... the filter for the ZoneWardMappings we want to count
     *   }
     * })
    **/
    count<T extends ZoneWardMappingCountArgs>(
      args?: Subset<T, ZoneWardMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneWardMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ZoneWardMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneWardMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneWardMappingAggregateArgs>(args: Subset<T, ZoneWardMappingAggregateArgs>): Prisma.PrismaPromise<GetZoneWardMappingAggregateType<T>>

    /**
     * Group by ZoneWardMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneWardMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoneWardMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoneWardMappingGroupByArgs['orderBy'] }
        : { orderBy?: ZoneWardMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoneWardMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneWardMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ZoneWardMapping model
   */
  readonly fields: ZoneWardMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ZoneWardMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoneWardMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zone<T extends ZoneMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneMasterDefaultArgs<ExtArgs>>): Prisma__ZoneMasterClient<$Result.GetResult<Prisma.$ZoneMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ward<T extends WardMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WardMasterDefaultArgs<ExtArgs>>): Prisma__WardMasterClient<$Result.GetResult<Prisma.$WardMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    surveyors<T extends ZoneWardMapping$surveyorsArgs<ExtArgs> = {}>(args?: Subset<T, ZoneWardMapping$surveyorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyorsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ZoneWardMapping model
   */ 
  interface ZoneWardMappingFieldRefs {
    readonly zoneWardMapId: FieldRef<"ZoneWardMapping", 'String'>
    readonly zoneId: FieldRef<"ZoneWardMapping", 'String'>
    readonly wardId: FieldRef<"ZoneWardMapping", 'String'>
    readonly isActive: FieldRef<"ZoneWardMapping", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ZoneWardMapping findUnique
   */
  export type ZoneWardMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneWardMapping
     */
    select?: ZoneWardMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneWardMappingInclude<ExtArgs> | null
    /**
     * Filter, which ZoneWardMapping to fetch.
     */
    where: ZoneWardMappingWhereUniqueInput
  }

  /**
   * ZoneWardMapping findUniqueOrThrow
   */
  export type ZoneWardMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneWardMapping
     */
    select?: ZoneWardMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneWardMappingInclude<ExtArgs> | null
    /**
     * Filter, which ZoneWardMapping to fetch.
     */
    where: ZoneWardMappingWhereUniqueInput
  }

  /**
   * ZoneWardMapping findFirst
   */
  export type ZoneWardMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneWardMapping
     */
    select?: ZoneWardMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneWardMappingInclude<ExtArgs> | null
    /**
     * Filter, which ZoneWardMapping to fetch.
     */
    where?: ZoneWardMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoneWardMappings to fetch.
     */
    orderBy?: ZoneWardMappingOrderByWithRelationInput | ZoneWardMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZoneWardMappings.
     */
    cursor?: ZoneWardMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoneWardMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoneWardMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZoneWardMappings.
     */
    distinct?: ZoneWardMappingScalarFieldEnum | ZoneWardMappingScalarFieldEnum[]
  }

  /**
   * ZoneWardMapping findFirstOrThrow
   */
  export type ZoneWardMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneWardMapping
     */
    select?: ZoneWardMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneWardMappingInclude<ExtArgs> | null
    /**
     * Filter, which ZoneWardMapping to fetch.
     */
    where?: ZoneWardMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoneWardMappings to fetch.
     */
    orderBy?: ZoneWardMappingOrderByWithRelationInput | ZoneWardMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZoneWardMappings.
     */
    cursor?: ZoneWardMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoneWardMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoneWardMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZoneWardMappings.
     */
    distinct?: ZoneWardMappingScalarFieldEnum | ZoneWardMappingScalarFieldEnum[]
  }

  /**
   * ZoneWardMapping findMany
   */
  export type ZoneWardMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneWardMapping
     */
    select?: ZoneWardMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneWardMappingInclude<ExtArgs> | null
    /**
     * Filter, which ZoneWardMappings to fetch.
     */
    where?: ZoneWardMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoneWardMappings to fetch.
     */
    orderBy?: ZoneWardMappingOrderByWithRelationInput | ZoneWardMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ZoneWardMappings.
     */
    cursor?: ZoneWardMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoneWardMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoneWardMappings.
     */
    skip?: number
    distinct?: ZoneWardMappingScalarFieldEnum | ZoneWardMappingScalarFieldEnum[]
  }

  /**
   * ZoneWardMapping create
   */
  export type ZoneWardMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneWardMapping
     */
    select?: ZoneWardMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneWardMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a ZoneWardMapping.
     */
    data: XOR<ZoneWardMappingCreateInput, ZoneWardMappingUncheckedCreateInput>
  }

  /**
   * ZoneWardMapping createMany
   */
  export type ZoneWardMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ZoneWardMappings.
     */
    data: ZoneWardMappingCreateManyInput | ZoneWardMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ZoneWardMapping createManyAndReturn
   */
  export type ZoneWardMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneWardMapping
     */
    select?: ZoneWardMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ZoneWardMappings.
     */
    data: ZoneWardMappingCreateManyInput | ZoneWardMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneWardMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZoneWardMapping update
   */
  export type ZoneWardMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneWardMapping
     */
    select?: ZoneWardMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneWardMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a ZoneWardMapping.
     */
    data: XOR<ZoneWardMappingUpdateInput, ZoneWardMappingUncheckedUpdateInput>
    /**
     * Choose, which ZoneWardMapping to update.
     */
    where: ZoneWardMappingWhereUniqueInput
  }

  /**
   * ZoneWardMapping updateMany
   */
  export type ZoneWardMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ZoneWardMappings.
     */
    data: XOR<ZoneWardMappingUpdateManyMutationInput, ZoneWardMappingUncheckedUpdateManyInput>
    /**
     * Filter which ZoneWardMappings to update
     */
    where?: ZoneWardMappingWhereInput
  }

  /**
   * ZoneWardMapping upsert
   */
  export type ZoneWardMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneWardMapping
     */
    select?: ZoneWardMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneWardMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the ZoneWardMapping to update in case it exists.
     */
    where: ZoneWardMappingWhereUniqueInput
    /**
     * In case the ZoneWardMapping found by the `where` argument doesn't exist, create a new ZoneWardMapping with this data.
     */
    create: XOR<ZoneWardMappingCreateInput, ZoneWardMappingUncheckedCreateInput>
    /**
     * In case the ZoneWardMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoneWardMappingUpdateInput, ZoneWardMappingUncheckedUpdateInput>
  }

  /**
   * ZoneWardMapping delete
   */
  export type ZoneWardMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneWardMapping
     */
    select?: ZoneWardMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneWardMappingInclude<ExtArgs> | null
    /**
     * Filter which ZoneWardMapping to delete.
     */
    where: ZoneWardMappingWhereUniqueInput
  }

  /**
   * ZoneWardMapping deleteMany
   */
  export type ZoneWardMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZoneWardMappings to delete
     */
    where?: ZoneWardMappingWhereInput
  }

  /**
   * ZoneWardMapping.surveyors
   */
  export type ZoneWardMapping$surveyorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surveyors
     */
    select?: SurveyorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorsInclude<ExtArgs> | null
    where?: SurveyorsWhereInput
    orderBy?: SurveyorsOrderByWithRelationInput | SurveyorsOrderByWithRelationInput[]
    cursor?: SurveyorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyorsScalarFieldEnum | SurveyorsScalarFieldEnum[]
  }

  /**
   * ZoneWardMapping without action
   */
  export type ZoneWardMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneWardMapping
     */
    select?: ZoneWardMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneWardMappingInclude<ExtArgs> | null
  }


  /**
   * Model WardMohallaMapping
   */

  export type AggregateWardMohallaMapping = {
    _count: WardMohallaMappingCountAggregateOutputType | null
    _min: WardMohallaMappingMinAggregateOutputType | null
    _max: WardMohallaMappingMaxAggregateOutputType | null
  }

  export type WardMohallaMappingMinAggregateOutputType = {
    wardMohallaMapId: string | null
    wardId: string | null
    mohallaId: string | null
    isActive: boolean | null
  }

  export type WardMohallaMappingMaxAggregateOutputType = {
    wardMohallaMapId: string | null
    wardId: string | null
    mohallaId: string | null
    isActive: boolean | null
  }

  export type WardMohallaMappingCountAggregateOutputType = {
    wardMohallaMapId: number
    wardId: number
    mohallaId: number
    isActive: number
    _all: number
  }


  export type WardMohallaMappingMinAggregateInputType = {
    wardMohallaMapId?: true
    wardId?: true
    mohallaId?: true
    isActive?: true
  }

  export type WardMohallaMappingMaxAggregateInputType = {
    wardMohallaMapId?: true
    wardId?: true
    mohallaId?: true
    isActive?: true
  }

  export type WardMohallaMappingCountAggregateInputType = {
    wardMohallaMapId?: true
    wardId?: true
    mohallaId?: true
    isActive?: true
    _all?: true
  }

  export type WardMohallaMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WardMohallaMapping to aggregate.
     */
    where?: WardMohallaMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardMohallaMappings to fetch.
     */
    orderBy?: WardMohallaMappingOrderByWithRelationInput | WardMohallaMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WardMohallaMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardMohallaMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardMohallaMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WardMohallaMappings
    **/
    _count?: true | WardMohallaMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WardMohallaMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WardMohallaMappingMaxAggregateInputType
  }

  export type GetWardMohallaMappingAggregateType<T extends WardMohallaMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateWardMohallaMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWardMohallaMapping[P]>
      : GetScalarType<T[P], AggregateWardMohallaMapping[P]>
  }




  export type WardMohallaMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardMohallaMappingWhereInput
    orderBy?: WardMohallaMappingOrderByWithAggregationInput | WardMohallaMappingOrderByWithAggregationInput[]
    by: WardMohallaMappingScalarFieldEnum[] | WardMohallaMappingScalarFieldEnum
    having?: WardMohallaMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WardMohallaMappingCountAggregateInputType | true
    _min?: WardMohallaMappingMinAggregateInputType
    _max?: WardMohallaMappingMaxAggregateInputType
  }

  export type WardMohallaMappingGroupByOutputType = {
    wardMohallaMapId: string
    wardId: string
    mohallaId: string
    isActive: boolean
    _count: WardMohallaMappingCountAggregateOutputType | null
    _min: WardMohallaMappingMinAggregateOutputType | null
    _max: WardMohallaMappingMaxAggregateOutputType | null
  }

  type GetWardMohallaMappingGroupByPayload<T extends WardMohallaMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WardMohallaMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WardMohallaMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WardMohallaMappingGroupByOutputType[P]>
            : GetScalarType<T[P], WardMohallaMappingGroupByOutputType[P]>
        }
      >
    >


  export type WardMohallaMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    wardMohallaMapId?: boolean
    wardId?: boolean
    mohallaId?: boolean
    isActive?: boolean
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    mohalla?: boolean | MohallaMasterDefaultArgs<ExtArgs>
    surveyorAssignments?: boolean | WardMohallaMapping$surveyorAssignmentsArgs<ExtArgs>
    surveyors?: boolean | WardMohallaMapping$surveyorsArgs<ExtArgs>
    _count?: boolean | WardMohallaMappingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wardMohallaMapping"]>

  export type WardMohallaMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    wardMohallaMapId?: boolean
    wardId?: boolean
    mohallaId?: boolean
    isActive?: boolean
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    mohalla?: boolean | MohallaMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wardMohallaMapping"]>

  export type WardMohallaMappingSelectScalar = {
    wardMohallaMapId?: boolean
    wardId?: boolean
    mohallaId?: boolean
    isActive?: boolean
  }

  export type WardMohallaMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    mohalla?: boolean | MohallaMasterDefaultArgs<ExtArgs>
    surveyorAssignments?: boolean | WardMohallaMapping$surveyorAssignmentsArgs<ExtArgs>
    surveyors?: boolean | WardMohallaMapping$surveyorsArgs<ExtArgs>
    _count?: boolean | WardMohallaMappingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WardMohallaMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    mohalla?: boolean | MohallaMasterDefaultArgs<ExtArgs>
  }

  export type $WardMohallaMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WardMohallaMapping"
    objects: {
      ward: Prisma.$WardMasterPayload<ExtArgs>
      mohalla: Prisma.$MohallaMasterPayload<ExtArgs>
      surveyorAssignments: Prisma.$SurveyorAssignmentPayload<ExtArgs>[]
      surveyors: Prisma.$SurveyorsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      wardMohallaMapId: string
      wardId: string
      mohallaId: string
      isActive: boolean
    }, ExtArgs["result"]["wardMohallaMapping"]>
    composites: {}
  }

  type WardMohallaMappingGetPayload<S extends boolean | null | undefined | WardMohallaMappingDefaultArgs> = $Result.GetResult<Prisma.$WardMohallaMappingPayload, S>

  type WardMohallaMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WardMohallaMappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WardMohallaMappingCountAggregateInputType | true
    }

  export interface WardMohallaMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WardMohallaMapping'], meta: { name: 'WardMohallaMapping' } }
    /**
     * Find zero or one WardMohallaMapping that matches the filter.
     * @param {WardMohallaMappingFindUniqueArgs} args - Arguments to find a WardMohallaMapping
     * @example
     * // Get one WardMohallaMapping
     * const wardMohallaMapping = await prisma.wardMohallaMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WardMohallaMappingFindUniqueArgs>(args: SelectSubset<T, WardMohallaMappingFindUniqueArgs<ExtArgs>>): Prisma__WardMohallaMappingClient<$Result.GetResult<Prisma.$WardMohallaMappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WardMohallaMapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WardMohallaMappingFindUniqueOrThrowArgs} args - Arguments to find a WardMohallaMapping
     * @example
     * // Get one WardMohallaMapping
     * const wardMohallaMapping = await prisma.wardMohallaMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WardMohallaMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, WardMohallaMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WardMohallaMappingClient<$Result.GetResult<Prisma.$WardMohallaMappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WardMohallaMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardMohallaMappingFindFirstArgs} args - Arguments to find a WardMohallaMapping
     * @example
     * // Get one WardMohallaMapping
     * const wardMohallaMapping = await prisma.wardMohallaMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WardMohallaMappingFindFirstArgs>(args?: SelectSubset<T, WardMohallaMappingFindFirstArgs<ExtArgs>>): Prisma__WardMohallaMappingClient<$Result.GetResult<Prisma.$WardMohallaMappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WardMohallaMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardMohallaMappingFindFirstOrThrowArgs} args - Arguments to find a WardMohallaMapping
     * @example
     * // Get one WardMohallaMapping
     * const wardMohallaMapping = await prisma.wardMohallaMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WardMohallaMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, WardMohallaMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__WardMohallaMappingClient<$Result.GetResult<Prisma.$WardMohallaMappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WardMohallaMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardMohallaMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WardMohallaMappings
     * const wardMohallaMappings = await prisma.wardMohallaMapping.findMany()
     * 
     * // Get first 10 WardMohallaMappings
     * const wardMohallaMappings = await prisma.wardMohallaMapping.findMany({ take: 10 })
     * 
     * // Only select the `wardMohallaMapId`
     * const wardMohallaMappingWithWardMohallaMapIdOnly = await prisma.wardMohallaMapping.findMany({ select: { wardMohallaMapId: true } })
     * 
     */
    findMany<T extends WardMohallaMappingFindManyArgs>(args?: SelectSubset<T, WardMohallaMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardMohallaMappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WardMohallaMapping.
     * @param {WardMohallaMappingCreateArgs} args - Arguments to create a WardMohallaMapping.
     * @example
     * // Create one WardMohallaMapping
     * const WardMohallaMapping = await prisma.wardMohallaMapping.create({
     *   data: {
     *     // ... data to create a WardMohallaMapping
     *   }
     * })
     * 
     */
    create<T extends WardMohallaMappingCreateArgs>(args: SelectSubset<T, WardMohallaMappingCreateArgs<ExtArgs>>): Prisma__WardMohallaMappingClient<$Result.GetResult<Prisma.$WardMohallaMappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WardMohallaMappings.
     * @param {WardMohallaMappingCreateManyArgs} args - Arguments to create many WardMohallaMappings.
     * @example
     * // Create many WardMohallaMappings
     * const wardMohallaMapping = await prisma.wardMohallaMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WardMohallaMappingCreateManyArgs>(args?: SelectSubset<T, WardMohallaMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WardMohallaMappings and returns the data saved in the database.
     * @param {WardMohallaMappingCreateManyAndReturnArgs} args - Arguments to create many WardMohallaMappings.
     * @example
     * // Create many WardMohallaMappings
     * const wardMohallaMapping = await prisma.wardMohallaMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WardMohallaMappings and only return the `wardMohallaMapId`
     * const wardMohallaMappingWithWardMohallaMapIdOnly = await prisma.wardMohallaMapping.createManyAndReturn({ 
     *   select: { wardMohallaMapId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WardMohallaMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, WardMohallaMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardMohallaMappingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WardMohallaMapping.
     * @param {WardMohallaMappingDeleteArgs} args - Arguments to delete one WardMohallaMapping.
     * @example
     * // Delete one WardMohallaMapping
     * const WardMohallaMapping = await prisma.wardMohallaMapping.delete({
     *   where: {
     *     // ... filter to delete one WardMohallaMapping
     *   }
     * })
     * 
     */
    delete<T extends WardMohallaMappingDeleteArgs>(args: SelectSubset<T, WardMohallaMappingDeleteArgs<ExtArgs>>): Prisma__WardMohallaMappingClient<$Result.GetResult<Prisma.$WardMohallaMappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WardMohallaMapping.
     * @param {WardMohallaMappingUpdateArgs} args - Arguments to update one WardMohallaMapping.
     * @example
     * // Update one WardMohallaMapping
     * const wardMohallaMapping = await prisma.wardMohallaMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WardMohallaMappingUpdateArgs>(args: SelectSubset<T, WardMohallaMappingUpdateArgs<ExtArgs>>): Prisma__WardMohallaMappingClient<$Result.GetResult<Prisma.$WardMohallaMappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WardMohallaMappings.
     * @param {WardMohallaMappingDeleteManyArgs} args - Arguments to filter WardMohallaMappings to delete.
     * @example
     * // Delete a few WardMohallaMappings
     * const { count } = await prisma.wardMohallaMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WardMohallaMappingDeleteManyArgs>(args?: SelectSubset<T, WardMohallaMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WardMohallaMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardMohallaMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WardMohallaMappings
     * const wardMohallaMapping = await prisma.wardMohallaMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WardMohallaMappingUpdateManyArgs>(args: SelectSubset<T, WardMohallaMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WardMohallaMapping.
     * @param {WardMohallaMappingUpsertArgs} args - Arguments to update or create a WardMohallaMapping.
     * @example
     * // Update or create a WardMohallaMapping
     * const wardMohallaMapping = await prisma.wardMohallaMapping.upsert({
     *   create: {
     *     // ... data to create a WardMohallaMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WardMohallaMapping we want to update
     *   }
     * })
     */
    upsert<T extends WardMohallaMappingUpsertArgs>(args: SelectSubset<T, WardMohallaMappingUpsertArgs<ExtArgs>>): Prisma__WardMohallaMappingClient<$Result.GetResult<Prisma.$WardMohallaMappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WardMohallaMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardMohallaMappingCountArgs} args - Arguments to filter WardMohallaMappings to count.
     * @example
     * // Count the number of WardMohallaMappings
     * const count = await prisma.wardMohallaMapping.count({
     *   where: {
     *     // ... the filter for the WardMohallaMappings we want to count
     *   }
     * })
    **/
    count<T extends WardMohallaMappingCountArgs>(
      args?: Subset<T, WardMohallaMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WardMohallaMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WardMohallaMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardMohallaMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WardMohallaMappingAggregateArgs>(args: Subset<T, WardMohallaMappingAggregateArgs>): Prisma.PrismaPromise<GetWardMohallaMappingAggregateType<T>>

    /**
     * Group by WardMohallaMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardMohallaMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WardMohallaMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WardMohallaMappingGroupByArgs['orderBy'] }
        : { orderBy?: WardMohallaMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WardMohallaMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWardMohallaMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WardMohallaMapping model
   */
  readonly fields: WardMohallaMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WardMohallaMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WardMohallaMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ward<T extends WardMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WardMasterDefaultArgs<ExtArgs>>): Prisma__WardMasterClient<$Result.GetResult<Prisma.$WardMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mohalla<T extends MohallaMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MohallaMasterDefaultArgs<ExtArgs>>): Prisma__MohallaMasterClient<$Result.GetResult<Prisma.$MohallaMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    surveyorAssignments<T extends WardMohallaMapping$surveyorAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, WardMohallaMapping$surveyorAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyorAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    surveyors<T extends WardMohallaMapping$surveyorsArgs<ExtArgs> = {}>(args?: Subset<T, WardMohallaMapping$surveyorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyorsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WardMohallaMapping model
   */ 
  interface WardMohallaMappingFieldRefs {
    readonly wardMohallaMapId: FieldRef<"WardMohallaMapping", 'String'>
    readonly wardId: FieldRef<"WardMohallaMapping", 'String'>
    readonly mohallaId: FieldRef<"WardMohallaMapping", 'String'>
    readonly isActive: FieldRef<"WardMohallaMapping", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * WardMohallaMapping findUnique
   */
  export type WardMohallaMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMohallaMapping
     */
    select?: WardMohallaMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMohallaMappingInclude<ExtArgs> | null
    /**
     * Filter, which WardMohallaMapping to fetch.
     */
    where: WardMohallaMappingWhereUniqueInput
  }

  /**
   * WardMohallaMapping findUniqueOrThrow
   */
  export type WardMohallaMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMohallaMapping
     */
    select?: WardMohallaMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMohallaMappingInclude<ExtArgs> | null
    /**
     * Filter, which WardMohallaMapping to fetch.
     */
    where: WardMohallaMappingWhereUniqueInput
  }

  /**
   * WardMohallaMapping findFirst
   */
  export type WardMohallaMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMohallaMapping
     */
    select?: WardMohallaMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMohallaMappingInclude<ExtArgs> | null
    /**
     * Filter, which WardMohallaMapping to fetch.
     */
    where?: WardMohallaMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardMohallaMappings to fetch.
     */
    orderBy?: WardMohallaMappingOrderByWithRelationInput | WardMohallaMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WardMohallaMappings.
     */
    cursor?: WardMohallaMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardMohallaMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardMohallaMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WardMohallaMappings.
     */
    distinct?: WardMohallaMappingScalarFieldEnum | WardMohallaMappingScalarFieldEnum[]
  }

  /**
   * WardMohallaMapping findFirstOrThrow
   */
  export type WardMohallaMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMohallaMapping
     */
    select?: WardMohallaMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMohallaMappingInclude<ExtArgs> | null
    /**
     * Filter, which WardMohallaMapping to fetch.
     */
    where?: WardMohallaMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardMohallaMappings to fetch.
     */
    orderBy?: WardMohallaMappingOrderByWithRelationInput | WardMohallaMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WardMohallaMappings.
     */
    cursor?: WardMohallaMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardMohallaMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardMohallaMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WardMohallaMappings.
     */
    distinct?: WardMohallaMappingScalarFieldEnum | WardMohallaMappingScalarFieldEnum[]
  }

  /**
   * WardMohallaMapping findMany
   */
  export type WardMohallaMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMohallaMapping
     */
    select?: WardMohallaMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMohallaMappingInclude<ExtArgs> | null
    /**
     * Filter, which WardMohallaMappings to fetch.
     */
    where?: WardMohallaMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardMohallaMappings to fetch.
     */
    orderBy?: WardMohallaMappingOrderByWithRelationInput | WardMohallaMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WardMohallaMappings.
     */
    cursor?: WardMohallaMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardMohallaMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardMohallaMappings.
     */
    skip?: number
    distinct?: WardMohallaMappingScalarFieldEnum | WardMohallaMappingScalarFieldEnum[]
  }

  /**
   * WardMohallaMapping create
   */
  export type WardMohallaMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMohallaMapping
     */
    select?: WardMohallaMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMohallaMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a WardMohallaMapping.
     */
    data: XOR<WardMohallaMappingCreateInput, WardMohallaMappingUncheckedCreateInput>
  }

  /**
   * WardMohallaMapping createMany
   */
  export type WardMohallaMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WardMohallaMappings.
     */
    data: WardMohallaMappingCreateManyInput | WardMohallaMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WardMohallaMapping createManyAndReturn
   */
  export type WardMohallaMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMohallaMapping
     */
    select?: WardMohallaMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WardMohallaMappings.
     */
    data: WardMohallaMappingCreateManyInput | WardMohallaMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMohallaMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WardMohallaMapping update
   */
  export type WardMohallaMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMohallaMapping
     */
    select?: WardMohallaMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMohallaMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a WardMohallaMapping.
     */
    data: XOR<WardMohallaMappingUpdateInput, WardMohallaMappingUncheckedUpdateInput>
    /**
     * Choose, which WardMohallaMapping to update.
     */
    where: WardMohallaMappingWhereUniqueInput
  }

  /**
   * WardMohallaMapping updateMany
   */
  export type WardMohallaMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WardMohallaMappings.
     */
    data: XOR<WardMohallaMappingUpdateManyMutationInput, WardMohallaMappingUncheckedUpdateManyInput>
    /**
     * Filter which WardMohallaMappings to update
     */
    where?: WardMohallaMappingWhereInput
  }

  /**
   * WardMohallaMapping upsert
   */
  export type WardMohallaMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMohallaMapping
     */
    select?: WardMohallaMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMohallaMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the WardMohallaMapping to update in case it exists.
     */
    where: WardMohallaMappingWhereUniqueInput
    /**
     * In case the WardMohallaMapping found by the `where` argument doesn't exist, create a new WardMohallaMapping with this data.
     */
    create: XOR<WardMohallaMappingCreateInput, WardMohallaMappingUncheckedCreateInput>
    /**
     * In case the WardMohallaMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WardMohallaMappingUpdateInput, WardMohallaMappingUncheckedUpdateInput>
  }

  /**
   * WardMohallaMapping delete
   */
  export type WardMohallaMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMohallaMapping
     */
    select?: WardMohallaMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMohallaMappingInclude<ExtArgs> | null
    /**
     * Filter which WardMohallaMapping to delete.
     */
    where: WardMohallaMappingWhereUniqueInput
  }

  /**
   * WardMohallaMapping deleteMany
   */
  export type WardMohallaMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WardMohallaMappings to delete
     */
    where?: WardMohallaMappingWhereInput
  }

  /**
   * WardMohallaMapping.surveyorAssignments
   */
  export type WardMohallaMapping$surveyorAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyorAssignment
     */
    select?: SurveyorAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorAssignmentInclude<ExtArgs> | null
    where?: SurveyorAssignmentWhereInput
    orderBy?: SurveyorAssignmentOrderByWithRelationInput | SurveyorAssignmentOrderByWithRelationInput[]
    cursor?: SurveyorAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyorAssignmentScalarFieldEnum | SurveyorAssignmentScalarFieldEnum[]
  }

  /**
   * WardMohallaMapping.surveyors
   */
  export type WardMohallaMapping$surveyorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surveyors
     */
    select?: SurveyorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorsInclude<ExtArgs> | null
    where?: SurveyorsWhereInput
    orderBy?: SurveyorsOrderByWithRelationInput | SurveyorsOrderByWithRelationInput[]
    cursor?: SurveyorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyorsScalarFieldEnum | SurveyorsScalarFieldEnum[]
  }

  /**
   * WardMohallaMapping without action
   */
  export type WardMohallaMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardMohallaMapping
     */
    select?: WardMohallaMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardMohallaMappingInclude<ExtArgs> | null
  }


  /**
   * Model SurveyorAssignment
   */

  export type AggregateSurveyorAssignment = {
    _count: SurveyorAssignmentCountAggregateOutputType | null
    _min: SurveyorAssignmentMinAggregateOutputType | null
    _max: SurveyorAssignmentMaxAggregateOutputType | null
  }

  export type SurveyorAssignmentMinAggregateOutputType = {
    assignmentId: string | null
    userId: string | null
    assignmentType: string | null
    wardId: string | null
    mohallaId: string | null
    wardMohallaMapId: string | null
    assignedById: string | null
    isActive: boolean | null
  }

  export type SurveyorAssignmentMaxAggregateOutputType = {
    assignmentId: string | null
    userId: string | null
    assignmentType: string | null
    wardId: string | null
    mohallaId: string | null
    wardMohallaMapId: string | null
    assignedById: string | null
    isActive: boolean | null
  }

  export type SurveyorAssignmentCountAggregateOutputType = {
    assignmentId: number
    userId: number
    assignmentType: number
    wardId: number
    mohallaId: number
    wardMohallaMapId: number
    assignedById: number
    isActive: number
    _all: number
  }


  export type SurveyorAssignmentMinAggregateInputType = {
    assignmentId?: true
    userId?: true
    assignmentType?: true
    wardId?: true
    mohallaId?: true
    wardMohallaMapId?: true
    assignedById?: true
    isActive?: true
  }

  export type SurveyorAssignmentMaxAggregateInputType = {
    assignmentId?: true
    userId?: true
    assignmentType?: true
    wardId?: true
    mohallaId?: true
    wardMohallaMapId?: true
    assignedById?: true
    isActive?: true
  }

  export type SurveyorAssignmentCountAggregateInputType = {
    assignmentId?: true
    userId?: true
    assignmentType?: true
    wardId?: true
    mohallaId?: true
    wardMohallaMapId?: true
    assignedById?: true
    isActive?: true
    _all?: true
  }

  export type SurveyorAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyorAssignment to aggregate.
     */
    where?: SurveyorAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyorAssignments to fetch.
     */
    orderBy?: SurveyorAssignmentOrderByWithRelationInput | SurveyorAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyorAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyorAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyorAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyorAssignments
    **/
    _count?: true | SurveyorAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyorAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyorAssignmentMaxAggregateInputType
  }

  export type GetSurveyorAssignmentAggregateType<T extends SurveyorAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyorAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyorAssignment[P]>
      : GetScalarType<T[P], AggregateSurveyorAssignment[P]>
  }




  export type SurveyorAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyorAssignmentWhereInput
    orderBy?: SurveyorAssignmentOrderByWithAggregationInput | SurveyorAssignmentOrderByWithAggregationInput[]
    by: SurveyorAssignmentScalarFieldEnum[] | SurveyorAssignmentScalarFieldEnum
    having?: SurveyorAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyorAssignmentCountAggregateInputType | true
    _min?: SurveyorAssignmentMinAggregateInputType
    _max?: SurveyorAssignmentMaxAggregateInputType
  }

  export type SurveyorAssignmentGroupByOutputType = {
    assignmentId: string
    userId: string
    assignmentType: string
    wardId: string
    mohallaId: string
    wardMohallaMapId: string
    assignedById: string
    isActive: boolean
    _count: SurveyorAssignmentCountAggregateOutputType | null
    _min: SurveyorAssignmentMinAggregateOutputType | null
    _max: SurveyorAssignmentMaxAggregateOutputType | null
  }

  type GetSurveyorAssignmentGroupByPayload<T extends SurveyorAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyorAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyorAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyorAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyorAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type SurveyorAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignmentId?: boolean
    userId?: boolean
    assignmentType?: boolean
    wardId?: boolean
    mohallaId?: boolean
    wardMohallaMapId?: boolean
    assignedById?: boolean
    isActive?: boolean
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    mohalla?: boolean | MohallaMasterDefaultArgs<ExtArgs>
    wardMohallaMap?: boolean | WardMohallaMappingDefaultArgs<ExtArgs>
    assignedBy?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyorAssignment"]>

  export type SurveyorAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignmentId?: boolean
    userId?: boolean
    assignmentType?: boolean
    wardId?: boolean
    mohallaId?: boolean
    wardMohallaMapId?: boolean
    assignedById?: boolean
    isActive?: boolean
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    mohalla?: boolean | MohallaMasterDefaultArgs<ExtArgs>
    wardMohallaMap?: boolean | WardMohallaMappingDefaultArgs<ExtArgs>
    assignedBy?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyorAssignment"]>

  export type SurveyorAssignmentSelectScalar = {
    assignmentId?: boolean
    userId?: boolean
    assignmentType?: boolean
    wardId?: boolean
    mohallaId?: boolean
    wardMohallaMapId?: boolean
    assignedById?: boolean
    isActive?: boolean
  }

  export type SurveyorAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    mohalla?: boolean | MohallaMasterDefaultArgs<ExtArgs>
    wardMohallaMap?: boolean | WardMohallaMappingDefaultArgs<ExtArgs>
    assignedBy?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }
  export type SurveyorAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    mohalla?: boolean | MohallaMasterDefaultArgs<ExtArgs>
    wardMohallaMap?: boolean | WardMohallaMappingDefaultArgs<ExtArgs>
    assignedBy?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }

  export type $SurveyorAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurveyorAssignment"
    objects: {
      user: Prisma.$UsersMasterPayload<ExtArgs>
      ward: Prisma.$WardMasterPayload<ExtArgs>
      mohalla: Prisma.$MohallaMasterPayload<ExtArgs>
      wardMohallaMap: Prisma.$WardMohallaMappingPayload<ExtArgs>
      assignedBy: Prisma.$UsersMasterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      assignmentId: string
      userId: string
      assignmentType: string
      wardId: string
      mohallaId: string
      wardMohallaMapId: string
      assignedById: string
      isActive: boolean
    }, ExtArgs["result"]["surveyorAssignment"]>
    composites: {}
  }

  type SurveyorAssignmentGetPayload<S extends boolean | null | undefined | SurveyorAssignmentDefaultArgs> = $Result.GetResult<Prisma.$SurveyorAssignmentPayload, S>

  type SurveyorAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SurveyorAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SurveyorAssignmentCountAggregateInputType | true
    }

  export interface SurveyorAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurveyorAssignment'], meta: { name: 'SurveyorAssignment' } }
    /**
     * Find zero or one SurveyorAssignment that matches the filter.
     * @param {SurveyorAssignmentFindUniqueArgs} args - Arguments to find a SurveyorAssignment
     * @example
     * // Get one SurveyorAssignment
     * const surveyorAssignment = await prisma.surveyorAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyorAssignmentFindUniqueArgs>(args: SelectSubset<T, SurveyorAssignmentFindUniqueArgs<ExtArgs>>): Prisma__SurveyorAssignmentClient<$Result.GetResult<Prisma.$SurveyorAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SurveyorAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SurveyorAssignmentFindUniqueOrThrowArgs} args - Arguments to find a SurveyorAssignment
     * @example
     * // Get one SurveyorAssignment
     * const surveyorAssignment = await prisma.surveyorAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyorAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyorAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyorAssignmentClient<$Result.GetResult<Prisma.$SurveyorAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SurveyorAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyorAssignmentFindFirstArgs} args - Arguments to find a SurveyorAssignment
     * @example
     * // Get one SurveyorAssignment
     * const surveyorAssignment = await prisma.surveyorAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyorAssignmentFindFirstArgs>(args?: SelectSubset<T, SurveyorAssignmentFindFirstArgs<ExtArgs>>): Prisma__SurveyorAssignmentClient<$Result.GetResult<Prisma.$SurveyorAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SurveyorAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyorAssignmentFindFirstOrThrowArgs} args - Arguments to find a SurveyorAssignment
     * @example
     * // Get one SurveyorAssignment
     * const surveyorAssignment = await prisma.surveyorAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyorAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyorAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyorAssignmentClient<$Result.GetResult<Prisma.$SurveyorAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SurveyorAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyorAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyorAssignments
     * const surveyorAssignments = await prisma.surveyorAssignment.findMany()
     * 
     * // Get first 10 SurveyorAssignments
     * const surveyorAssignments = await prisma.surveyorAssignment.findMany({ take: 10 })
     * 
     * // Only select the `assignmentId`
     * const surveyorAssignmentWithAssignmentIdOnly = await prisma.surveyorAssignment.findMany({ select: { assignmentId: true } })
     * 
     */
    findMany<T extends SurveyorAssignmentFindManyArgs>(args?: SelectSubset<T, SurveyorAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyorAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SurveyorAssignment.
     * @param {SurveyorAssignmentCreateArgs} args - Arguments to create a SurveyorAssignment.
     * @example
     * // Create one SurveyorAssignment
     * const SurveyorAssignment = await prisma.surveyorAssignment.create({
     *   data: {
     *     // ... data to create a SurveyorAssignment
     *   }
     * })
     * 
     */
    create<T extends SurveyorAssignmentCreateArgs>(args: SelectSubset<T, SurveyorAssignmentCreateArgs<ExtArgs>>): Prisma__SurveyorAssignmentClient<$Result.GetResult<Prisma.$SurveyorAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SurveyorAssignments.
     * @param {SurveyorAssignmentCreateManyArgs} args - Arguments to create many SurveyorAssignments.
     * @example
     * // Create many SurveyorAssignments
     * const surveyorAssignment = await prisma.surveyorAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyorAssignmentCreateManyArgs>(args?: SelectSubset<T, SurveyorAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SurveyorAssignments and returns the data saved in the database.
     * @param {SurveyorAssignmentCreateManyAndReturnArgs} args - Arguments to create many SurveyorAssignments.
     * @example
     * // Create many SurveyorAssignments
     * const surveyorAssignment = await prisma.surveyorAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SurveyorAssignments and only return the `assignmentId`
     * const surveyorAssignmentWithAssignmentIdOnly = await prisma.surveyorAssignment.createManyAndReturn({ 
     *   select: { assignmentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurveyorAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, SurveyorAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyorAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SurveyorAssignment.
     * @param {SurveyorAssignmentDeleteArgs} args - Arguments to delete one SurveyorAssignment.
     * @example
     * // Delete one SurveyorAssignment
     * const SurveyorAssignment = await prisma.surveyorAssignment.delete({
     *   where: {
     *     // ... filter to delete one SurveyorAssignment
     *   }
     * })
     * 
     */
    delete<T extends SurveyorAssignmentDeleteArgs>(args: SelectSubset<T, SurveyorAssignmentDeleteArgs<ExtArgs>>): Prisma__SurveyorAssignmentClient<$Result.GetResult<Prisma.$SurveyorAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SurveyorAssignment.
     * @param {SurveyorAssignmentUpdateArgs} args - Arguments to update one SurveyorAssignment.
     * @example
     * // Update one SurveyorAssignment
     * const surveyorAssignment = await prisma.surveyorAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyorAssignmentUpdateArgs>(args: SelectSubset<T, SurveyorAssignmentUpdateArgs<ExtArgs>>): Prisma__SurveyorAssignmentClient<$Result.GetResult<Prisma.$SurveyorAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SurveyorAssignments.
     * @param {SurveyorAssignmentDeleteManyArgs} args - Arguments to filter SurveyorAssignments to delete.
     * @example
     * // Delete a few SurveyorAssignments
     * const { count } = await prisma.surveyorAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyorAssignmentDeleteManyArgs>(args?: SelectSubset<T, SurveyorAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyorAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyorAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyorAssignments
     * const surveyorAssignment = await prisma.surveyorAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyorAssignmentUpdateManyArgs>(args: SelectSubset<T, SurveyorAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SurveyorAssignment.
     * @param {SurveyorAssignmentUpsertArgs} args - Arguments to update or create a SurveyorAssignment.
     * @example
     * // Update or create a SurveyorAssignment
     * const surveyorAssignment = await prisma.surveyorAssignment.upsert({
     *   create: {
     *     // ... data to create a SurveyorAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyorAssignment we want to update
     *   }
     * })
     */
    upsert<T extends SurveyorAssignmentUpsertArgs>(args: SelectSubset<T, SurveyorAssignmentUpsertArgs<ExtArgs>>): Prisma__SurveyorAssignmentClient<$Result.GetResult<Prisma.$SurveyorAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SurveyorAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyorAssignmentCountArgs} args - Arguments to filter SurveyorAssignments to count.
     * @example
     * // Count the number of SurveyorAssignments
     * const count = await prisma.surveyorAssignment.count({
     *   where: {
     *     // ... the filter for the SurveyorAssignments we want to count
     *   }
     * })
    **/
    count<T extends SurveyorAssignmentCountArgs>(
      args?: Subset<T, SurveyorAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyorAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyorAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyorAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyorAssignmentAggregateArgs>(args: Subset<T, SurveyorAssignmentAggregateArgs>): Prisma.PrismaPromise<GetSurveyorAssignmentAggregateType<T>>

    /**
     * Group by SurveyorAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyorAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyorAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyorAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: SurveyorAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyorAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyorAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurveyorAssignment model
   */
  readonly fields: SurveyorAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyorAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyorAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersMasterDefaultArgs<ExtArgs>>): Prisma__UsersMasterClient<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ward<T extends WardMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WardMasterDefaultArgs<ExtArgs>>): Prisma__WardMasterClient<$Result.GetResult<Prisma.$WardMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mohalla<T extends MohallaMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MohallaMasterDefaultArgs<ExtArgs>>): Prisma__MohallaMasterClient<$Result.GetResult<Prisma.$MohallaMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    wardMohallaMap<T extends WardMohallaMappingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WardMohallaMappingDefaultArgs<ExtArgs>>): Prisma__WardMohallaMappingClient<$Result.GetResult<Prisma.$WardMohallaMappingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignedBy<T extends UsersMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersMasterDefaultArgs<ExtArgs>>): Prisma__UsersMasterClient<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurveyorAssignment model
   */ 
  interface SurveyorAssignmentFieldRefs {
    readonly assignmentId: FieldRef<"SurveyorAssignment", 'String'>
    readonly userId: FieldRef<"SurveyorAssignment", 'String'>
    readonly assignmentType: FieldRef<"SurveyorAssignment", 'String'>
    readonly wardId: FieldRef<"SurveyorAssignment", 'String'>
    readonly mohallaId: FieldRef<"SurveyorAssignment", 'String'>
    readonly wardMohallaMapId: FieldRef<"SurveyorAssignment", 'String'>
    readonly assignedById: FieldRef<"SurveyorAssignment", 'String'>
    readonly isActive: FieldRef<"SurveyorAssignment", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SurveyorAssignment findUnique
   */
  export type SurveyorAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyorAssignment
     */
    select?: SurveyorAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which SurveyorAssignment to fetch.
     */
    where: SurveyorAssignmentWhereUniqueInput
  }

  /**
   * SurveyorAssignment findUniqueOrThrow
   */
  export type SurveyorAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyorAssignment
     */
    select?: SurveyorAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which SurveyorAssignment to fetch.
     */
    where: SurveyorAssignmentWhereUniqueInput
  }

  /**
   * SurveyorAssignment findFirst
   */
  export type SurveyorAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyorAssignment
     */
    select?: SurveyorAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which SurveyorAssignment to fetch.
     */
    where?: SurveyorAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyorAssignments to fetch.
     */
    orderBy?: SurveyorAssignmentOrderByWithRelationInput | SurveyorAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyorAssignments.
     */
    cursor?: SurveyorAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyorAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyorAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyorAssignments.
     */
    distinct?: SurveyorAssignmentScalarFieldEnum | SurveyorAssignmentScalarFieldEnum[]
  }

  /**
   * SurveyorAssignment findFirstOrThrow
   */
  export type SurveyorAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyorAssignment
     */
    select?: SurveyorAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which SurveyorAssignment to fetch.
     */
    where?: SurveyorAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyorAssignments to fetch.
     */
    orderBy?: SurveyorAssignmentOrderByWithRelationInput | SurveyorAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyorAssignments.
     */
    cursor?: SurveyorAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyorAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyorAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyorAssignments.
     */
    distinct?: SurveyorAssignmentScalarFieldEnum | SurveyorAssignmentScalarFieldEnum[]
  }

  /**
   * SurveyorAssignment findMany
   */
  export type SurveyorAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyorAssignment
     */
    select?: SurveyorAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which SurveyorAssignments to fetch.
     */
    where?: SurveyorAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyorAssignments to fetch.
     */
    orderBy?: SurveyorAssignmentOrderByWithRelationInput | SurveyorAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyorAssignments.
     */
    cursor?: SurveyorAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyorAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyorAssignments.
     */
    skip?: number
    distinct?: SurveyorAssignmentScalarFieldEnum | SurveyorAssignmentScalarFieldEnum[]
  }

  /**
   * SurveyorAssignment create
   */
  export type SurveyorAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyorAssignment
     */
    select?: SurveyorAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a SurveyorAssignment.
     */
    data: XOR<SurveyorAssignmentCreateInput, SurveyorAssignmentUncheckedCreateInput>
  }

  /**
   * SurveyorAssignment createMany
   */
  export type SurveyorAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurveyorAssignments.
     */
    data: SurveyorAssignmentCreateManyInput | SurveyorAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurveyorAssignment createManyAndReturn
   */
  export type SurveyorAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyorAssignment
     */
    select?: SurveyorAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SurveyorAssignments.
     */
    data: SurveyorAssignmentCreateManyInput | SurveyorAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurveyorAssignment update
   */
  export type SurveyorAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyorAssignment
     */
    select?: SurveyorAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a SurveyorAssignment.
     */
    data: XOR<SurveyorAssignmentUpdateInput, SurveyorAssignmentUncheckedUpdateInput>
    /**
     * Choose, which SurveyorAssignment to update.
     */
    where: SurveyorAssignmentWhereUniqueInput
  }

  /**
   * SurveyorAssignment updateMany
   */
  export type SurveyorAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurveyorAssignments.
     */
    data: XOR<SurveyorAssignmentUpdateManyMutationInput, SurveyorAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which SurveyorAssignments to update
     */
    where?: SurveyorAssignmentWhereInput
  }

  /**
   * SurveyorAssignment upsert
   */
  export type SurveyorAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyorAssignment
     */
    select?: SurveyorAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the SurveyorAssignment to update in case it exists.
     */
    where: SurveyorAssignmentWhereUniqueInput
    /**
     * In case the SurveyorAssignment found by the `where` argument doesn't exist, create a new SurveyorAssignment with this data.
     */
    create: XOR<SurveyorAssignmentCreateInput, SurveyorAssignmentUncheckedCreateInput>
    /**
     * In case the SurveyorAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyorAssignmentUpdateInput, SurveyorAssignmentUncheckedUpdateInput>
  }

  /**
   * SurveyorAssignment delete
   */
  export type SurveyorAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyorAssignment
     */
    select?: SurveyorAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorAssignmentInclude<ExtArgs> | null
    /**
     * Filter which SurveyorAssignment to delete.
     */
    where: SurveyorAssignmentWhereUniqueInput
  }

  /**
   * SurveyorAssignment deleteMany
   */
  export type SurveyorAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyorAssignments to delete
     */
    where?: SurveyorAssignmentWhereInput
  }

  /**
   * SurveyorAssignment without action
   */
  export type SurveyorAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyorAssignment
     */
    select?: SurveyorAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model WardStatusMapping
   */

  export type AggregateWardStatusMapping = {
    _count: WardStatusMappingCountAggregateOutputType | null
    _min: WardStatusMappingMinAggregateOutputType | null
    _max: WardStatusMappingMaxAggregateOutputType | null
  }

  export type WardStatusMappingMinAggregateOutputType = {
    wardStatusId: string | null
    wardId: string | null
    statusId: string | null
    changedById: string | null
    isActive: boolean | null
  }

  export type WardStatusMappingMaxAggregateOutputType = {
    wardStatusId: string | null
    wardId: string | null
    statusId: string | null
    changedById: string | null
    isActive: boolean | null
  }

  export type WardStatusMappingCountAggregateOutputType = {
    wardStatusId: number
    wardId: number
    statusId: number
    changedById: number
    isActive: number
    _all: number
  }


  export type WardStatusMappingMinAggregateInputType = {
    wardStatusId?: true
    wardId?: true
    statusId?: true
    changedById?: true
    isActive?: true
  }

  export type WardStatusMappingMaxAggregateInputType = {
    wardStatusId?: true
    wardId?: true
    statusId?: true
    changedById?: true
    isActive?: true
  }

  export type WardStatusMappingCountAggregateInputType = {
    wardStatusId?: true
    wardId?: true
    statusId?: true
    changedById?: true
    isActive?: true
    _all?: true
  }

  export type WardStatusMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WardStatusMapping to aggregate.
     */
    where?: WardStatusMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardStatusMappings to fetch.
     */
    orderBy?: WardStatusMappingOrderByWithRelationInput | WardStatusMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WardStatusMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardStatusMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardStatusMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WardStatusMappings
    **/
    _count?: true | WardStatusMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WardStatusMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WardStatusMappingMaxAggregateInputType
  }

  export type GetWardStatusMappingAggregateType<T extends WardStatusMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateWardStatusMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWardStatusMapping[P]>
      : GetScalarType<T[P], AggregateWardStatusMapping[P]>
  }




  export type WardStatusMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardStatusMappingWhereInput
    orderBy?: WardStatusMappingOrderByWithAggregationInput | WardStatusMappingOrderByWithAggregationInput[]
    by: WardStatusMappingScalarFieldEnum[] | WardStatusMappingScalarFieldEnum
    having?: WardStatusMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WardStatusMappingCountAggregateInputType | true
    _min?: WardStatusMappingMinAggregateInputType
    _max?: WardStatusMappingMaxAggregateInputType
  }

  export type WardStatusMappingGroupByOutputType = {
    wardStatusId: string
    wardId: string
    statusId: string
    changedById: string
    isActive: boolean
    _count: WardStatusMappingCountAggregateOutputType | null
    _min: WardStatusMappingMinAggregateOutputType | null
    _max: WardStatusMappingMaxAggregateOutputType | null
  }

  type GetWardStatusMappingGroupByPayload<T extends WardStatusMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WardStatusMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WardStatusMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WardStatusMappingGroupByOutputType[P]>
            : GetScalarType<T[P], WardStatusMappingGroupByOutputType[P]>
        }
      >
    >


  export type WardStatusMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    wardStatusId?: boolean
    wardId?: boolean
    statusId?: boolean
    changedById?: boolean
    isActive?: boolean
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    status?: boolean | WardStatusMasterDefaultArgs<ExtArgs>
    changedBy?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wardStatusMapping"]>

  export type WardStatusMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    wardStatusId?: boolean
    wardId?: boolean
    statusId?: boolean
    changedById?: boolean
    isActive?: boolean
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    status?: boolean | WardStatusMasterDefaultArgs<ExtArgs>
    changedBy?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wardStatusMapping"]>

  export type WardStatusMappingSelectScalar = {
    wardStatusId?: boolean
    wardId?: boolean
    statusId?: boolean
    changedById?: boolean
    isActive?: boolean
  }

  export type WardStatusMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    status?: boolean | WardStatusMasterDefaultArgs<ExtArgs>
    changedBy?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }
  export type WardStatusMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    status?: boolean | WardStatusMasterDefaultArgs<ExtArgs>
    changedBy?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }

  export type $WardStatusMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WardStatusMapping"
    objects: {
      ward: Prisma.$WardMasterPayload<ExtArgs>
      status: Prisma.$WardStatusMasterPayload<ExtArgs>
      changedBy: Prisma.$UsersMasterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      wardStatusId: string
      wardId: string
      statusId: string
      changedById: string
      isActive: boolean
    }, ExtArgs["result"]["wardStatusMapping"]>
    composites: {}
  }

  type WardStatusMappingGetPayload<S extends boolean | null | undefined | WardStatusMappingDefaultArgs> = $Result.GetResult<Prisma.$WardStatusMappingPayload, S>

  type WardStatusMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WardStatusMappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WardStatusMappingCountAggregateInputType | true
    }

  export interface WardStatusMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WardStatusMapping'], meta: { name: 'WardStatusMapping' } }
    /**
     * Find zero or one WardStatusMapping that matches the filter.
     * @param {WardStatusMappingFindUniqueArgs} args - Arguments to find a WardStatusMapping
     * @example
     * // Get one WardStatusMapping
     * const wardStatusMapping = await prisma.wardStatusMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WardStatusMappingFindUniqueArgs>(args: SelectSubset<T, WardStatusMappingFindUniqueArgs<ExtArgs>>): Prisma__WardStatusMappingClient<$Result.GetResult<Prisma.$WardStatusMappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WardStatusMapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WardStatusMappingFindUniqueOrThrowArgs} args - Arguments to find a WardStatusMapping
     * @example
     * // Get one WardStatusMapping
     * const wardStatusMapping = await prisma.wardStatusMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WardStatusMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, WardStatusMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WardStatusMappingClient<$Result.GetResult<Prisma.$WardStatusMappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WardStatusMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardStatusMappingFindFirstArgs} args - Arguments to find a WardStatusMapping
     * @example
     * // Get one WardStatusMapping
     * const wardStatusMapping = await prisma.wardStatusMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WardStatusMappingFindFirstArgs>(args?: SelectSubset<T, WardStatusMappingFindFirstArgs<ExtArgs>>): Prisma__WardStatusMappingClient<$Result.GetResult<Prisma.$WardStatusMappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WardStatusMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardStatusMappingFindFirstOrThrowArgs} args - Arguments to find a WardStatusMapping
     * @example
     * // Get one WardStatusMapping
     * const wardStatusMapping = await prisma.wardStatusMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WardStatusMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, WardStatusMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__WardStatusMappingClient<$Result.GetResult<Prisma.$WardStatusMappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WardStatusMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardStatusMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WardStatusMappings
     * const wardStatusMappings = await prisma.wardStatusMapping.findMany()
     * 
     * // Get first 10 WardStatusMappings
     * const wardStatusMappings = await prisma.wardStatusMapping.findMany({ take: 10 })
     * 
     * // Only select the `wardStatusId`
     * const wardStatusMappingWithWardStatusIdOnly = await prisma.wardStatusMapping.findMany({ select: { wardStatusId: true } })
     * 
     */
    findMany<T extends WardStatusMappingFindManyArgs>(args?: SelectSubset<T, WardStatusMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardStatusMappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WardStatusMapping.
     * @param {WardStatusMappingCreateArgs} args - Arguments to create a WardStatusMapping.
     * @example
     * // Create one WardStatusMapping
     * const WardStatusMapping = await prisma.wardStatusMapping.create({
     *   data: {
     *     // ... data to create a WardStatusMapping
     *   }
     * })
     * 
     */
    create<T extends WardStatusMappingCreateArgs>(args: SelectSubset<T, WardStatusMappingCreateArgs<ExtArgs>>): Prisma__WardStatusMappingClient<$Result.GetResult<Prisma.$WardStatusMappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WardStatusMappings.
     * @param {WardStatusMappingCreateManyArgs} args - Arguments to create many WardStatusMappings.
     * @example
     * // Create many WardStatusMappings
     * const wardStatusMapping = await prisma.wardStatusMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WardStatusMappingCreateManyArgs>(args?: SelectSubset<T, WardStatusMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WardStatusMappings and returns the data saved in the database.
     * @param {WardStatusMappingCreateManyAndReturnArgs} args - Arguments to create many WardStatusMappings.
     * @example
     * // Create many WardStatusMappings
     * const wardStatusMapping = await prisma.wardStatusMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WardStatusMappings and only return the `wardStatusId`
     * const wardStatusMappingWithWardStatusIdOnly = await prisma.wardStatusMapping.createManyAndReturn({ 
     *   select: { wardStatusId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WardStatusMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, WardStatusMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardStatusMappingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WardStatusMapping.
     * @param {WardStatusMappingDeleteArgs} args - Arguments to delete one WardStatusMapping.
     * @example
     * // Delete one WardStatusMapping
     * const WardStatusMapping = await prisma.wardStatusMapping.delete({
     *   where: {
     *     // ... filter to delete one WardStatusMapping
     *   }
     * })
     * 
     */
    delete<T extends WardStatusMappingDeleteArgs>(args: SelectSubset<T, WardStatusMappingDeleteArgs<ExtArgs>>): Prisma__WardStatusMappingClient<$Result.GetResult<Prisma.$WardStatusMappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WardStatusMapping.
     * @param {WardStatusMappingUpdateArgs} args - Arguments to update one WardStatusMapping.
     * @example
     * // Update one WardStatusMapping
     * const wardStatusMapping = await prisma.wardStatusMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WardStatusMappingUpdateArgs>(args: SelectSubset<T, WardStatusMappingUpdateArgs<ExtArgs>>): Prisma__WardStatusMappingClient<$Result.GetResult<Prisma.$WardStatusMappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WardStatusMappings.
     * @param {WardStatusMappingDeleteManyArgs} args - Arguments to filter WardStatusMappings to delete.
     * @example
     * // Delete a few WardStatusMappings
     * const { count } = await prisma.wardStatusMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WardStatusMappingDeleteManyArgs>(args?: SelectSubset<T, WardStatusMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WardStatusMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardStatusMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WardStatusMappings
     * const wardStatusMapping = await prisma.wardStatusMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WardStatusMappingUpdateManyArgs>(args: SelectSubset<T, WardStatusMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WardStatusMapping.
     * @param {WardStatusMappingUpsertArgs} args - Arguments to update or create a WardStatusMapping.
     * @example
     * // Update or create a WardStatusMapping
     * const wardStatusMapping = await prisma.wardStatusMapping.upsert({
     *   create: {
     *     // ... data to create a WardStatusMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WardStatusMapping we want to update
     *   }
     * })
     */
    upsert<T extends WardStatusMappingUpsertArgs>(args: SelectSubset<T, WardStatusMappingUpsertArgs<ExtArgs>>): Prisma__WardStatusMappingClient<$Result.GetResult<Prisma.$WardStatusMappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WardStatusMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardStatusMappingCountArgs} args - Arguments to filter WardStatusMappings to count.
     * @example
     * // Count the number of WardStatusMappings
     * const count = await prisma.wardStatusMapping.count({
     *   where: {
     *     // ... the filter for the WardStatusMappings we want to count
     *   }
     * })
    **/
    count<T extends WardStatusMappingCountArgs>(
      args?: Subset<T, WardStatusMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WardStatusMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WardStatusMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardStatusMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WardStatusMappingAggregateArgs>(args: Subset<T, WardStatusMappingAggregateArgs>): Prisma.PrismaPromise<GetWardStatusMappingAggregateType<T>>

    /**
     * Group by WardStatusMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardStatusMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WardStatusMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WardStatusMappingGroupByArgs['orderBy'] }
        : { orderBy?: WardStatusMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WardStatusMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWardStatusMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WardStatusMapping model
   */
  readonly fields: WardStatusMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WardStatusMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WardStatusMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ward<T extends WardMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WardMasterDefaultArgs<ExtArgs>>): Prisma__WardMasterClient<$Result.GetResult<Prisma.$WardMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    status<T extends WardStatusMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WardStatusMasterDefaultArgs<ExtArgs>>): Prisma__WardStatusMasterClient<$Result.GetResult<Prisma.$WardStatusMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    changedBy<T extends UsersMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersMasterDefaultArgs<ExtArgs>>): Prisma__UsersMasterClient<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WardStatusMapping model
   */ 
  interface WardStatusMappingFieldRefs {
    readonly wardStatusId: FieldRef<"WardStatusMapping", 'String'>
    readonly wardId: FieldRef<"WardStatusMapping", 'String'>
    readonly statusId: FieldRef<"WardStatusMapping", 'String'>
    readonly changedById: FieldRef<"WardStatusMapping", 'String'>
    readonly isActive: FieldRef<"WardStatusMapping", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * WardStatusMapping findUnique
   */
  export type WardStatusMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMapping
     */
    select?: WardStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMappingInclude<ExtArgs> | null
    /**
     * Filter, which WardStatusMapping to fetch.
     */
    where: WardStatusMappingWhereUniqueInput
  }

  /**
   * WardStatusMapping findUniqueOrThrow
   */
  export type WardStatusMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMapping
     */
    select?: WardStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMappingInclude<ExtArgs> | null
    /**
     * Filter, which WardStatusMapping to fetch.
     */
    where: WardStatusMappingWhereUniqueInput
  }

  /**
   * WardStatusMapping findFirst
   */
  export type WardStatusMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMapping
     */
    select?: WardStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMappingInclude<ExtArgs> | null
    /**
     * Filter, which WardStatusMapping to fetch.
     */
    where?: WardStatusMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardStatusMappings to fetch.
     */
    orderBy?: WardStatusMappingOrderByWithRelationInput | WardStatusMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WardStatusMappings.
     */
    cursor?: WardStatusMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardStatusMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardStatusMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WardStatusMappings.
     */
    distinct?: WardStatusMappingScalarFieldEnum | WardStatusMappingScalarFieldEnum[]
  }

  /**
   * WardStatusMapping findFirstOrThrow
   */
  export type WardStatusMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMapping
     */
    select?: WardStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMappingInclude<ExtArgs> | null
    /**
     * Filter, which WardStatusMapping to fetch.
     */
    where?: WardStatusMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardStatusMappings to fetch.
     */
    orderBy?: WardStatusMappingOrderByWithRelationInput | WardStatusMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WardStatusMappings.
     */
    cursor?: WardStatusMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardStatusMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardStatusMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WardStatusMappings.
     */
    distinct?: WardStatusMappingScalarFieldEnum | WardStatusMappingScalarFieldEnum[]
  }

  /**
   * WardStatusMapping findMany
   */
  export type WardStatusMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMapping
     */
    select?: WardStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMappingInclude<ExtArgs> | null
    /**
     * Filter, which WardStatusMappings to fetch.
     */
    where?: WardStatusMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WardStatusMappings to fetch.
     */
    orderBy?: WardStatusMappingOrderByWithRelationInput | WardStatusMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WardStatusMappings.
     */
    cursor?: WardStatusMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WardStatusMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WardStatusMappings.
     */
    skip?: number
    distinct?: WardStatusMappingScalarFieldEnum | WardStatusMappingScalarFieldEnum[]
  }

  /**
   * WardStatusMapping create
   */
  export type WardStatusMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMapping
     */
    select?: WardStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a WardStatusMapping.
     */
    data: XOR<WardStatusMappingCreateInput, WardStatusMappingUncheckedCreateInput>
  }

  /**
   * WardStatusMapping createMany
   */
  export type WardStatusMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WardStatusMappings.
     */
    data: WardStatusMappingCreateManyInput | WardStatusMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WardStatusMapping createManyAndReturn
   */
  export type WardStatusMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMapping
     */
    select?: WardStatusMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WardStatusMappings.
     */
    data: WardStatusMappingCreateManyInput | WardStatusMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WardStatusMapping update
   */
  export type WardStatusMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMapping
     */
    select?: WardStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a WardStatusMapping.
     */
    data: XOR<WardStatusMappingUpdateInput, WardStatusMappingUncheckedUpdateInput>
    /**
     * Choose, which WardStatusMapping to update.
     */
    where: WardStatusMappingWhereUniqueInput
  }

  /**
   * WardStatusMapping updateMany
   */
  export type WardStatusMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WardStatusMappings.
     */
    data: XOR<WardStatusMappingUpdateManyMutationInput, WardStatusMappingUncheckedUpdateManyInput>
    /**
     * Filter which WardStatusMappings to update
     */
    where?: WardStatusMappingWhereInput
  }

  /**
   * WardStatusMapping upsert
   */
  export type WardStatusMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMapping
     */
    select?: WardStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the WardStatusMapping to update in case it exists.
     */
    where: WardStatusMappingWhereUniqueInput
    /**
     * In case the WardStatusMapping found by the `where` argument doesn't exist, create a new WardStatusMapping with this data.
     */
    create: XOR<WardStatusMappingCreateInput, WardStatusMappingUncheckedCreateInput>
    /**
     * In case the WardStatusMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WardStatusMappingUpdateInput, WardStatusMappingUncheckedUpdateInput>
  }

  /**
   * WardStatusMapping delete
   */
  export type WardStatusMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMapping
     */
    select?: WardStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMappingInclude<ExtArgs> | null
    /**
     * Filter which WardStatusMapping to delete.
     */
    where: WardStatusMappingWhereUniqueInput
  }

  /**
   * WardStatusMapping deleteMany
   */
  export type WardStatusMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WardStatusMappings to delete
     */
    where?: WardStatusMappingWhereInput
  }

  /**
   * WardStatusMapping without action
   */
  export type WardStatusMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardStatusMapping
     */
    select?: WardStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardStatusMappingInclude<ExtArgs> | null
  }


  /**
   * Model SurveyStatusMapping
   */

  export type AggregateSurveyStatusMapping = {
    _count: SurveyStatusMappingCountAggregateOutputType | null
    _min: SurveyStatusMappingMinAggregateOutputType | null
    _max: SurveyStatusMappingMaxAggregateOutputType | null
  }

  export type SurveyStatusMappingMinAggregateOutputType = {
    statusMappingId: string | null
    surveyUniqueCode: string | null
    statusId: string | null
    revertedFromId: string | null
    changedById: string | null
    isActive: boolean | null
  }

  export type SurveyStatusMappingMaxAggregateOutputType = {
    statusMappingId: string | null
    surveyUniqueCode: string | null
    statusId: string | null
    revertedFromId: string | null
    changedById: string | null
    isActive: boolean | null
  }

  export type SurveyStatusMappingCountAggregateOutputType = {
    statusMappingId: number
    surveyUniqueCode: number
    statusId: number
    revertedFromId: number
    changedById: number
    isActive: number
    _all: number
  }


  export type SurveyStatusMappingMinAggregateInputType = {
    statusMappingId?: true
    surveyUniqueCode?: true
    statusId?: true
    revertedFromId?: true
    changedById?: true
    isActive?: true
  }

  export type SurveyStatusMappingMaxAggregateInputType = {
    statusMappingId?: true
    surveyUniqueCode?: true
    statusId?: true
    revertedFromId?: true
    changedById?: true
    isActive?: true
  }

  export type SurveyStatusMappingCountAggregateInputType = {
    statusMappingId?: true
    surveyUniqueCode?: true
    statusId?: true
    revertedFromId?: true
    changedById?: true
    isActive?: true
    _all?: true
  }

  export type SurveyStatusMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyStatusMapping to aggregate.
     */
    where?: SurveyStatusMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyStatusMappings to fetch.
     */
    orderBy?: SurveyStatusMappingOrderByWithRelationInput | SurveyStatusMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyStatusMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyStatusMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyStatusMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyStatusMappings
    **/
    _count?: true | SurveyStatusMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyStatusMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyStatusMappingMaxAggregateInputType
  }

  export type GetSurveyStatusMappingAggregateType<T extends SurveyStatusMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyStatusMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyStatusMapping[P]>
      : GetScalarType<T[P], AggregateSurveyStatusMapping[P]>
  }




  export type SurveyStatusMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyStatusMappingWhereInput
    orderBy?: SurveyStatusMappingOrderByWithAggregationInput | SurveyStatusMappingOrderByWithAggregationInput[]
    by: SurveyStatusMappingScalarFieldEnum[] | SurveyStatusMappingScalarFieldEnum
    having?: SurveyStatusMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyStatusMappingCountAggregateInputType | true
    _min?: SurveyStatusMappingMinAggregateInputType
    _max?: SurveyStatusMappingMaxAggregateInputType
  }

  export type SurveyStatusMappingGroupByOutputType = {
    statusMappingId: string
    surveyUniqueCode: string
    statusId: string
    revertedFromId: string | null
    changedById: string
    isActive: boolean
    _count: SurveyStatusMappingCountAggregateOutputType | null
    _min: SurveyStatusMappingMinAggregateOutputType | null
    _max: SurveyStatusMappingMaxAggregateOutputType | null
  }

  type GetSurveyStatusMappingGroupByPayload<T extends SurveyStatusMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyStatusMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyStatusMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyStatusMappingGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyStatusMappingGroupByOutputType[P]>
        }
      >
    >


  export type SurveyStatusMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statusMappingId?: boolean
    surveyUniqueCode?: boolean
    statusId?: boolean
    revertedFromId?: boolean
    changedById?: boolean
    isActive?: boolean
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    status?: boolean | SurveyStatusMasterDefaultArgs<ExtArgs>
    revertedFrom?: boolean | SurveyStatusMapping$revertedFromArgs<ExtArgs>
    changedBy?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyStatusMapping"]>

  export type SurveyStatusMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statusMappingId?: boolean
    surveyUniqueCode?: boolean
    statusId?: boolean
    revertedFromId?: boolean
    changedById?: boolean
    isActive?: boolean
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    status?: boolean | SurveyStatusMasterDefaultArgs<ExtArgs>
    revertedFrom?: boolean | SurveyStatusMapping$revertedFromArgs<ExtArgs>
    changedBy?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyStatusMapping"]>

  export type SurveyStatusMappingSelectScalar = {
    statusMappingId?: boolean
    surveyUniqueCode?: boolean
    statusId?: boolean
    revertedFromId?: boolean
    changedById?: boolean
    isActive?: boolean
  }

  export type SurveyStatusMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    status?: boolean | SurveyStatusMasterDefaultArgs<ExtArgs>
    revertedFrom?: boolean | SurveyStatusMapping$revertedFromArgs<ExtArgs>
    changedBy?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }
  export type SurveyStatusMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    status?: boolean | SurveyStatusMasterDefaultArgs<ExtArgs>
    revertedFrom?: boolean | SurveyStatusMapping$revertedFromArgs<ExtArgs>
    changedBy?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }

  export type $SurveyStatusMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurveyStatusMapping"
    objects: {
      survey: Prisma.$SurveyDetailsPayload<ExtArgs>
      status: Prisma.$SurveyStatusMasterPayload<ExtArgs>
      revertedFrom: Prisma.$SurveyStatusMasterPayload<ExtArgs> | null
      changedBy: Prisma.$UsersMasterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      statusMappingId: string
      surveyUniqueCode: string
      statusId: string
      revertedFromId: string | null
      changedById: string
      isActive: boolean
    }, ExtArgs["result"]["surveyStatusMapping"]>
    composites: {}
  }

  type SurveyStatusMappingGetPayload<S extends boolean | null | undefined | SurveyStatusMappingDefaultArgs> = $Result.GetResult<Prisma.$SurveyStatusMappingPayload, S>

  type SurveyStatusMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SurveyStatusMappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SurveyStatusMappingCountAggregateInputType | true
    }

  export interface SurveyStatusMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurveyStatusMapping'], meta: { name: 'SurveyStatusMapping' } }
    /**
     * Find zero or one SurveyStatusMapping that matches the filter.
     * @param {SurveyStatusMappingFindUniqueArgs} args - Arguments to find a SurveyStatusMapping
     * @example
     * // Get one SurveyStatusMapping
     * const surveyStatusMapping = await prisma.surveyStatusMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyStatusMappingFindUniqueArgs>(args: SelectSubset<T, SurveyStatusMappingFindUniqueArgs<ExtArgs>>): Prisma__SurveyStatusMappingClient<$Result.GetResult<Prisma.$SurveyStatusMappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SurveyStatusMapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SurveyStatusMappingFindUniqueOrThrowArgs} args - Arguments to find a SurveyStatusMapping
     * @example
     * // Get one SurveyStatusMapping
     * const surveyStatusMapping = await prisma.surveyStatusMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyStatusMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyStatusMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyStatusMappingClient<$Result.GetResult<Prisma.$SurveyStatusMappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SurveyStatusMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyStatusMappingFindFirstArgs} args - Arguments to find a SurveyStatusMapping
     * @example
     * // Get one SurveyStatusMapping
     * const surveyStatusMapping = await prisma.surveyStatusMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyStatusMappingFindFirstArgs>(args?: SelectSubset<T, SurveyStatusMappingFindFirstArgs<ExtArgs>>): Prisma__SurveyStatusMappingClient<$Result.GetResult<Prisma.$SurveyStatusMappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SurveyStatusMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyStatusMappingFindFirstOrThrowArgs} args - Arguments to find a SurveyStatusMapping
     * @example
     * // Get one SurveyStatusMapping
     * const surveyStatusMapping = await prisma.surveyStatusMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyStatusMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyStatusMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyStatusMappingClient<$Result.GetResult<Prisma.$SurveyStatusMappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SurveyStatusMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyStatusMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyStatusMappings
     * const surveyStatusMappings = await prisma.surveyStatusMapping.findMany()
     * 
     * // Get first 10 SurveyStatusMappings
     * const surveyStatusMappings = await prisma.surveyStatusMapping.findMany({ take: 10 })
     * 
     * // Only select the `statusMappingId`
     * const surveyStatusMappingWithStatusMappingIdOnly = await prisma.surveyStatusMapping.findMany({ select: { statusMappingId: true } })
     * 
     */
    findMany<T extends SurveyStatusMappingFindManyArgs>(args?: SelectSubset<T, SurveyStatusMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyStatusMappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SurveyStatusMapping.
     * @param {SurveyStatusMappingCreateArgs} args - Arguments to create a SurveyStatusMapping.
     * @example
     * // Create one SurveyStatusMapping
     * const SurveyStatusMapping = await prisma.surveyStatusMapping.create({
     *   data: {
     *     // ... data to create a SurveyStatusMapping
     *   }
     * })
     * 
     */
    create<T extends SurveyStatusMappingCreateArgs>(args: SelectSubset<T, SurveyStatusMappingCreateArgs<ExtArgs>>): Prisma__SurveyStatusMappingClient<$Result.GetResult<Prisma.$SurveyStatusMappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SurveyStatusMappings.
     * @param {SurveyStatusMappingCreateManyArgs} args - Arguments to create many SurveyStatusMappings.
     * @example
     * // Create many SurveyStatusMappings
     * const surveyStatusMapping = await prisma.surveyStatusMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyStatusMappingCreateManyArgs>(args?: SelectSubset<T, SurveyStatusMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SurveyStatusMappings and returns the data saved in the database.
     * @param {SurveyStatusMappingCreateManyAndReturnArgs} args - Arguments to create many SurveyStatusMappings.
     * @example
     * // Create many SurveyStatusMappings
     * const surveyStatusMapping = await prisma.surveyStatusMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SurveyStatusMappings and only return the `statusMappingId`
     * const surveyStatusMappingWithStatusMappingIdOnly = await prisma.surveyStatusMapping.createManyAndReturn({ 
     *   select: { statusMappingId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurveyStatusMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, SurveyStatusMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyStatusMappingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SurveyStatusMapping.
     * @param {SurveyStatusMappingDeleteArgs} args - Arguments to delete one SurveyStatusMapping.
     * @example
     * // Delete one SurveyStatusMapping
     * const SurveyStatusMapping = await prisma.surveyStatusMapping.delete({
     *   where: {
     *     // ... filter to delete one SurveyStatusMapping
     *   }
     * })
     * 
     */
    delete<T extends SurveyStatusMappingDeleteArgs>(args: SelectSubset<T, SurveyStatusMappingDeleteArgs<ExtArgs>>): Prisma__SurveyStatusMappingClient<$Result.GetResult<Prisma.$SurveyStatusMappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SurveyStatusMapping.
     * @param {SurveyStatusMappingUpdateArgs} args - Arguments to update one SurveyStatusMapping.
     * @example
     * // Update one SurveyStatusMapping
     * const surveyStatusMapping = await prisma.surveyStatusMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyStatusMappingUpdateArgs>(args: SelectSubset<T, SurveyStatusMappingUpdateArgs<ExtArgs>>): Prisma__SurveyStatusMappingClient<$Result.GetResult<Prisma.$SurveyStatusMappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SurveyStatusMappings.
     * @param {SurveyStatusMappingDeleteManyArgs} args - Arguments to filter SurveyStatusMappings to delete.
     * @example
     * // Delete a few SurveyStatusMappings
     * const { count } = await prisma.surveyStatusMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyStatusMappingDeleteManyArgs>(args?: SelectSubset<T, SurveyStatusMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyStatusMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyStatusMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyStatusMappings
     * const surveyStatusMapping = await prisma.surveyStatusMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyStatusMappingUpdateManyArgs>(args: SelectSubset<T, SurveyStatusMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SurveyStatusMapping.
     * @param {SurveyStatusMappingUpsertArgs} args - Arguments to update or create a SurveyStatusMapping.
     * @example
     * // Update or create a SurveyStatusMapping
     * const surveyStatusMapping = await prisma.surveyStatusMapping.upsert({
     *   create: {
     *     // ... data to create a SurveyStatusMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyStatusMapping we want to update
     *   }
     * })
     */
    upsert<T extends SurveyStatusMappingUpsertArgs>(args: SelectSubset<T, SurveyStatusMappingUpsertArgs<ExtArgs>>): Prisma__SurveyStatusMappingClient<$Result.GetResult<Prisma.$SurveyStatusMappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SurveyStatusMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyStatusMappingCountArgs} args - Arguments to filter SurveyStatusMappings to count.
     * @example
     * // Count the number of SurveyStatusMappings
     * const count = await prisma.surveyStatusMapping.count({
     *   where: {
     *     // ... the filter for the SurveyStatusMappings we want to count
     *   }
     * })
    **/
    count<T extends SurveyStatusMappingCountArgs>(
      args?: Subset<T, SurveyStatusMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyStatusMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyStatusMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyStatusMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyStatusMappingAggregateArgs>(args: Subset<T, SurveyStatusMappingAggregateArgs>): Prisma.PrismaPromise<GetSurveyStatusMappingAggregateType<T>>

    /**
     * Group by SurveyStatusMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyStatusMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyStatusMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyStatusMappingGroupByArgs['orderBy'] }
        : { orderBy?: SurveyStatusMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyStatusMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyStatusMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurveyStatusMapping model
   */
  readonly fields: SurveyStatusMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyStatusMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyStatusMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDetailsDefaultArgs<ExtArgs>>): Prisma__SurveyDetailsClient<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    status<T extends SurveyStatusMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyStatusMasterDefaultArgs<ExtArgs>>): Prisma__SurveyStatusMasterClient<$Result.GetResult<Prisma.$SurveyStatusMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    revertedFrom<T extends SurveyStatusMapping$revertedFromArgs<ExtArgs> = {}>(args?: Subset<T, SurveyStatusMapping$revertedFromArgs<ExtArgs>>): Prisma__SurveyStatusMasterClient<$Result.GetResult<Prisma.$SurveyStatusMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    changedBy<T extends UsersMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersMasterDefaultArgs<ExtArgs>>): Prisma__UsersMasterClient<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurveyStatusMapping model
   */ 
  interface SurveyStatusMappingFieldRefs {
    readonly statusMappingId: FieldRef<"SurveyStatusMapping", 'String'>
    readonly surveyUniqueCode: FieldRef<"SurveyStatusMapping", 'String'>
    readonly statusId: FieldRef<"SurveyStatusMapping", 'String'>
    readonly revertedFromId: FieldRef<"SurveyStatusMapping", 'String'>
    readonly changedById: FieldRef<"SurveyStatusMapping", 'String'>
    readonly isActive: FieldRef<"SurveyStatusMapping", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SurveyStatusMapping findUnique
   */
  export type SurveyStatusMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMapping
     */
    select?: SurveyStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMappingInclude<ExtArgs> | null
    /**
     * Filter, which SurveyStatusMapping to fetch.
     */
    where: SurveyStatusMappingWhereUniqueInput
  }

  /**
   * SurveyStatusMapping findUniqueOrThrow
   */
  export type SurveyStatusMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMapping
     */
    select?: SurveyStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMappingInclude<ExtArgs> | null
    /**
     * Filter, which SurveyStatusMapping to fetch.
     */
    where: SurveyStatusMappingWhereUniqueInput
  }

  /**
   * SurveyStatusMapping findFirst
   */
  export type SurveyStatusMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMapping
     */
    select?: SurveyStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMappingInclude<ExtArgs> | null
    /**
     * Filter, which SurveyStatusMapping to fetch.
     */
    where?: SurveyStatusMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyStatusMappings to fetch.
     */
    orderBy?: SurveyStatusMappingOrderByWithRelationInput | SurveyStatusMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyStatusMappings.
     */
    cursor?: SurveyStatusMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyStatusMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyStatusMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyStatusMappings.
     */
    distinct?: SurveyStatusMappingScalarFieldEnum | SurveyStatusMappingScalarFieldEnum[]
  }

  /**
   * SurveyStatusMapping findFirstOrThrow
   */
  export type SurveyStatusMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMapping
     */
    select?: SurveyStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMappingInclude<ExtArgs> | null
    /**
     * Filter, which SurveyStatusMapping to fetch.
     */
    where?: SurveyStatusMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyStatusMappings to fetch.
     */
    orderBy?: SurveyStatusMappingOrderByWithRelationInput | SurveyStatusMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyStatusMappings.
     */
    cursor?: SurveyStatusMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyStatusMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyStatusMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyStatusMappings.
     */
    distinct?: SurveyStatusMappingScalarFieldEnum | SurveyStatusMappingScalarFieldEnum[]
  }

  /**
   * SurveyStatusMapping findMany
   */
  export type SurveyStatusMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMapping
     */
    select?: SurveyStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMappingInclude<ExtArgs> | null
    /**
     * Filter, which SurveyStatusMappings to fetch.
     */
    where?: SurveyStatusMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyStatusMappings to fetch.
     */
    orderBy?: SurveyStatusMappingOrderByWithRelationInput | SurveyStatusMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyStatusMappings.
     */
    cursor?: SurveyStatusMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyStatusMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyStatusMappings.
     */
    skip?: number
    distinct?: SurveyStatusMappingScalarFieldEnum | SurveyStatusMappingScalarFieldEnum[]
  }

  /**
   * SurveyStatusMapping create
   */
  export type SurveyStatusMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMapping
     */
    select?: SurveyStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a SurveyStatusMapping.
     */
    data: XOR<SurveyStatusMappingCreateInput, SurveyStatusMappingUncheckedCreateInput>
  }

  /**
   * SurveyStatusMapping createMany
   */
  export type SurveyStatusMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurveyStatusMappings.
     */
    data: SurveyStatusMappingCreateManyInput | SurveyStatusMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurveyStatusMapping createManyAndReturn
   */
  export type SurveyStatusMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMapping
     */
    select?: SurveyStatusMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SurveyStatusMappings.
     */
    data: SurveyStatusMappingCreateManyInput | SurveyStatusMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurveyStatusMapping update
   */
  export type SurveyStatusMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMapping
     */
    select?: SurveyStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a SurveyStatusMapping.
     */
    data: XOR<SurveyStatusMappingUpdateInput, SurveyStatusMappingUncheckedUpdateInput>
    /**
     * Choose, which SurveyStatusMapping to update.
     */
    where: SurveyStatusMappingWhereUniqueInput
  }

  /**
   * SurveyStatusMapping updateMany
   */
  export type SurveyStatusMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurveyStatusMappings.
     */
    data: XOR<SurveyStatusMappingUpdateManyMutationInput, SurveyStatusMappingUncheckedUpdateManyInput>
    /**
     * Filter which SurveyStatusMappings to update
     */
    where?: SurveyStatusMappingWhereInput
  }

  /**
   * SurveyStatusMapping upsert
   */
  export type SurveyStatusMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMapping
     */
    select?: SurveyStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the SurveyStatusMapping to update in case it exists.
     */
    where: SurveyStatusMappingWhereUniqueInput
    /**
     * In case the SurveyStatusMapping found by the `where` argument doesn't exist, create a new SurveyStatusMapping with this data.
     */
    create: XOR<SurveyStatusMappingCreateInput, SurveyStatusMappingUncheckedCreateInput>
    /**
     * In case the SurveyStatusMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyStatusMappingUpdateInput, SurveyStatusMappingUncheckedUpdateInput>
  }

  /**
   * SurveyStatusMapping delete
   */
  export type SurveyStatusMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMapping
     */
    select?: SurveyStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMappingInclude<ExtArgs> | null
    /**
     * Filter which SurveyStatusMapping to delete.
     */
    where: SurveyStatusMappingWhereUniqueInput
  }

  /**
   * SurveyStatusMapping deleteMany
   */
  export type SurveyStatusMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyStatusMappings to delete
     */
    where?: SurveyStatusMappingWhereInput
  }

  /**
   * SurveyStatusMapping.revertedFrom
   */
  export type SurveyStatusMapping$revertedFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMaster
     */
    select?: SurveyStatusMasterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMasterInclude<ExtArgs> | null
    where?: SurveyStatusMasterWhereInput
  }

  /**
   * SurveyStatusMapping without action
   */
  export type SurveyStatusMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMapping
     */
    select?: SurveyStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMappingInclude<ExtArgs> | null
  }


  /**
   * Model UserRoleMapping
   */

  export type AggregateUserRoleMapping = {
    _count: UserRoleMappingCountAggregateOutputType | null
    _min: UserRoleMappingMinAggregateOutputType | null
    _max: UserRoleMappingMaxAggregateOutputType | null
  }

  export type UserRoleMappingMinAggregateOutputType = {
    userRoleMapId: string | null
    userId: string | null
    roleId: string | null
    isActive: boolean | null
  }

  export type UserRoleMappingMaxAggregateOutputType = {
    userRoleMapId: string | null
    userId: string | null
    roleId: string | null
    isActive: boolean | null
  }

  export type UserRoleMappingCountAggregateOutputType = {
    userRoleMapId: number
    userId: number
    roleId: number
    isActive: number
    _all: number
  }


  export type UserRoleMappingMinAggregateInputType = {
    userRoleMapId?: true
    userId?: true
    roleId?: true
    isActive?: true
  }

  export type UserRoleMappingMaxAggregateInputType = {
    userRoleMapId?: true
    userId?: true
    roleId?: true
    isActive?: true
  }

  export type UserRoleMappingCountAggregateInputType = {
    userRoleMapId?: true
    userId?: true
    roleId?: true
    isActive?: true
    _all?: true
  }

  export type UserRoleMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoleMapping to aggregate.
     */
    where?: UserRoleMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleMappings to fetch.
     */
    orderBy?: UserRoleMappingOrderByWithRelationInput | UserRoleMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoleMappings
    **/
    _count?: true | UserRoleMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMappingMaxAggregateInputType
  }

  export type GetUserRoleMappingAggregateType<T extends UserRoleMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRoleMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRoleMapping[P]>
      : GetScalarType<T[P], AggregateUserRoleMapping[P]>
  }




  export type UserRoleMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleMappingWhereInput
    orderBy?: UserRoleMappingOrderByWithAggregationInput | UserRoleMappingOrderByWithAggregationInput[]
    by: UserRoleMappingScalarFieldEnum[] | UserRoleMappingScalarFieldEnum
    having?: UserRoleMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleMappingCountAggregateInputType | true
    _min?: UserRoleMappingMinAggregateInputType
    _max?: UserRoleMappingMaxAggregateInputType
  }

  export type UserRoleMappingGroupByOutputType = {
    userRoleMapId: string
    userId: string
    roleId: string
    isActive: boolean
    _count: UserRoleMappingCountAggregateOutputType | null
    _min: UserRoleMappingMinAggregateOutputType | null
    _max: UserRoleMappingMaxAggregateOutputType | null
  }

  type GetUserRoleMappingGroupByPayload<T extends UserRoleMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleMappingGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleMappingGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userRoleMapId?: boolean
    userId?: boolean
    roleId?: boolean
    isActive?: boolean
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
    role?: boolean | RolePermissionMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRoleMapping"]>

  export type UserRoleMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userRoleMapId?: boolean
    userId?: boolean
    roleId?: boolean
    isActive?: boolean
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
    role?: boolean | RolePermissionMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRoleMapping"]>

  export type UserRoleMappingSelectScalar = {
    userRoleMapId?: boolean
    userId?: boolean
    roleId?: boolean
    isActive?: boolean
  }

  export type UserRoleMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
    role?: boolean | RolePermissionMasterDefaultArgs<ExtArgs>
  }
  export type UserRoleMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
    role?: boolean | RolePermissionMasterDefaultArgs<ExtArgs>
  }

  export type $UserRoleMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRoleMapping"
    objects: {
      user: Prisma.$UsersMasterPayload<ExtArgs>
      role: Prisma.$RolePermissionMasterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userRoleMapId: string
      userId: string
      roleId: string
      isActive: boolean
    }, ExtArgs["result"]["userRoleMapping"]>
    composites: {}
  }

  type UserRoleMappingGetPayload<S extends boolean | null | undefined | UserRoleMappingDefaultArgs> = $Result.GetResult<Prisma.$UserRoleMappingPayload, S>

  type UserRoleMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleMappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleMappingCountAggregateInputType | true
    }

  export interface UserRoleMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRoleMapping'], meta: { name: 'UserRoleMapping' } }
    /**
     * Find zero or one UserRoleMapping that matches the filter.
     * @param {UserRoleMappingFindUniqueArgs} args - Arguments to find a UserRoleMapping
     * @example
     * // Get one UserRoleMapping
     * const userRoleMapping = await prisma.userRoleMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleMappingFindUniqueArgs>(args: SelectSubset<T, UserRoleMappingFindUniqueArgs<ExtArgs>>): Prisma__UserRoleMappingClient<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserRoleMapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserRoleMappingFindUniqueOrThrowArgs} args - Arguments to find a UserRoleMapping
     * @example
     * // Get one UserRoleMapping
     * const userRoleMapping = await prisma.userRoleMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleMappingClient<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserRoleMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleMappingFindFirstArgs} args - Arguments to find a UserRoleMapping
     * @example
     * // Get one UserRoleMapping
     * const userRoleMapping = await prisma.userRoleMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleMappingFindFirstArgs>(args?: SelectSubset<T, UserRoleMappingFindFirstArgs<ExtArgs>>): Prisma__UserRoleMappingClient<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserRoleMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleMappingFindFirstOrThrowArgs} args - Arguments to find a UserRoleMapping
     * @example
     * // Get one UserRoleMapping
     * const userRoleMapping = await prisma.userRoleMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleMappingClient<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserRoleMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoleMappings
     * const userRoleMappings = await prisma.userRoleMapping.findMany()
     * 
     * // Get first 10 UserRoleMappings
     * const userRoleMappings = await prisma.userRoleMapping.findMany({ take: 10 })
     * 
     * // Only select the `userRoleMapId`
     * const userRoleMappingWithUserRoleMapIdOnly = await prisma.userRoleMapping.findMany({ select: { userRoleMapId: true } })
     * 
     */
    findMany<T extends UserRoleMappingFindManyArgs>(args?: SelectSubset<T, UserRoleMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserRoleMapping.
     * @param {UserRoleMappingCreateArgs} args - Arguments to create a UserRoleMapping.
     * @example
     * // Create one UserRoleMapping
     * const UserRoleMapping = await prisma.userRoleMapping.create({
     *   data: {
     *     // ... data to create a UserRoleMapping
     *   }
     * })
     * 
     */
    create<T extends UserRoleMappingCreateArgs>(args: SelectSubset<T, UserRoleMappingCreateArgs<ExtArgs>>): Prisma__UserRoleMappingClient<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserRoleMappings.
     * @param {UserRoleMappingCreateManyArgs} args - Arguments to create many UserRoleMappings.
     * @example
     * // Create many UserRoleMappings
     * const userRoleMapping = await prisma.userRoleMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleMappingCreateManyArgs>(args?: SelectSubset<T, UserRoleMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoleMappings and returns the data saved in the database.
     * @param {UserRoleMappingCreateManyAndReturnArgs} args - Arguments to create many UserRoleMappings.
     * @example
     * // Create many UserRoleMappings
     * const userRoleMapping = await prisma.userRoleMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoleMappings and only return the `userRoleMapId`
     * const userRoleMappingWithUserRoleMapIdOnly = await prisma.userRoleMapping.createManyAndReturn({ 
     *   select: { userRoleMapId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserRoleMapping.
     * @param {UserRoleMappingDeleteArgs} args - Arguments to delete one UserRoleMapping.
     * @example
     * // Delete one UserRoleMapping
     * const UserRoleMapping = await prisma.userRoleMapping.delete({
     *   where: {
     *     // ... filter to delete one UserRoleMapping
     *   }
     * })
     * 
     */
    delete<T extends UserRoleMappingDeleteArgs>(args: SelectSubset<T, UserRoleMappingDeleteArgs<ExtArgs>>): Prisma__UserRoleMappingClient<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserRoleMapping.
     * @param {UserRoleMappingUpdateArgs} args - Arguments to update one UserRoleMapping.
     * @example
     * // Update one UserRoleMapping
     * const userRoleMapping = await prisma.userRoleMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleMappingUpdateArgs>(args: SelectSubset<T, UserRoleMappingUpdateArgs<ExtArgs>>): Prisma__UserRoleMappingClient<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserRoleMappings.
     * @param {UserRoleMappingDeleteManyArgs} args - Arguments to filter UserRoleMappings to delete.
     * @example
     * // Delete a few UserRoleMappings
     * const { count } = await prisma.userRoleMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleMappingDeleteManyArgs>(args?: SelectSubset<T, UserRoleMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoleMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoleMappings
     * const userRoleMapping = await prisma.userRoleMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleMappingUpdateManyArgs>(args: SelectSubset<T, UserRoleMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRoleMapping.
     * @param {UserRoleMappingUpsertArgs} args - Arguments to update or create a UserRoleMapping.
     * @example
     * // Update or create a UserRoleMapping
     * const userRoleMapping = await prisma.userRoleMapping.upsert({
     *   create: {
     *     // ... data to create a UserRoleMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRoleMapping we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleMappingUpsertArgs>(args: SelectSubset<T, UserRoleMappingUpsertArgs<ExtArgs>>): Prisma__UserRoleMappingClient<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserRoleMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleMappingCountArgs} args - Arguments to filter UserRoleMappings to count.
     * @example
     * // Count the number of UserRoleMappings
     * const count = await prisma.userRoleMapping.count({
     *   where: {
     *     // ... the filter for the UserRoleMappings we want to count
     *   }
     * })
    **/
    count<T extends UserRoleMappingCountArgs>(
      args?: Subset<T, UserRoleMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRoleMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleMappingAggregateArgs>(args: Subset<T, UserRoleMappingAggregateArgs>): Prisma.PrismaPromise<GetUserRoleMappingAggregateType<T>>

    /**
     * Group by UserRoleMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleMappingGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRoleMapping model
   */
  readonly fields: UserRoleMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRoleMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersMasterDefaultArgs<ExtArgs>>): Prisma__UsersMasterClient<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends RolePermissionMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolePermissionMasterDefaultArgs<ExtArgs>>): Prisma__RolePermissionMasterClient<$Result.GetResult<Prisma.$RolePermissionMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRoleMapping model
   */ 
  interface UserRoleMappingFieldRefs {
    readonly userRoleMapId: FieldRef<"UserRoleMapping", 'String'>
    readonly userId: FieldRef<"UserRoleMapping", 'String'>
    readonly roleId: FieldRef<"UserRoleMapping", 'String'>
    readonly isActive: FieldRef<"UserRoleMapping", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UserRoleMapping findUnique
   */
  export type UserRoleMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleMapping to fetch.
     */
    where: UserRoleMappingWhereUniqueInput
  }

  /**
   * UserRoleMapping findUniqueOrThrow
   */
  export type UserRoleMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleMapping to fetch.
     */
    where: UserRoleMappingWhereUniqueInput
  }

  /**
   * UserRoleMapping findFirst
   */
  export type UserRoleMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleMapping to fetch.
     */
    where?: UserRoleMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleMappings to fetch.
     */
    orderBy?: UserRoleMappingOrderByWithRelationInput | UserRoleMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoleMappings.
     */
    cursor?: UserRoleMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoleMappings.
     */
    distinct?: UserRoleMappingScalarFieldEnum | UserRoleMappingScalarFieldEnum[]
  }

  /**
   * UserRoleMapping findFirstOrThrow
   */
  export type UserRoleMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleMapping to fetch.
     */
    where?: UserRoleMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleMappings to fetch.
     */
    orderBy?: UserRoleMappingOrderByWithRelationInput | UserRoleMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoleMappings.
     */
    cursor?: UserRoleMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoleMappings.
     */
    distinct?: UserRoleMappingScalarFieldEnum | UserRoleMappingScalarFieldEnum[]
  }

  /**
   * UserRoleMapping findMany
   */
  export type UserRoleMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleMappings to fetch.
     */
    where?: UserRoleMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleMappings to fetch.
     */
    orderBy?: UserRoleMappingOrderByWithRelationInput | UserRoleMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoleMappings.
     */
    cursor?: UserRoleMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleMappings.
     */
    skip?: number
    distinct?: UserRoleMappingScalarFieldEnum | UserRoleMappingScalarFieldEnum[]
  }

  /**
   * UserRoleMapping create
   */
  export type UserRoleMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRoleMapping.
     */
    data: XOR<UserRoleMappingCreateInput, UserRoleMappingUncheckedCreateInput>
  }

  /**
   * UserRoleMapping createMany
   */
  export type UserRoleMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoleMappings.
     */
    data: UserRoleMappingCreateManyInput | UserRoleMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRoleMapping createManyAndReturn
   */
  export type UserRoleMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserRoleMappings.
     */
    data: UserRoleMappingCreateManyInput | UserRoleMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRoleMapping update
   */
  export type UserRoleMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRoleMapping.
     */
    data: XOR<UserRoleMappingUpdateInput, UserRoleMappingUncheckedUpdateInput>
    /**
     * Choose, which UserRoleMapping to update.
     */
    where: UserRoleMappingWhereUniqueInput
  }

  /**
   * UserRoleMapping updateMany
   */
  export type UserRoleMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoleMappings.
     */
    data: XOR<UserRoleMappingUpdateManyMutationInput, UserRoleMappingUncheckedUpdateManyInput>
    /**
     * Filter which UserRoleMappings to update
     */
    where?: UserRoleMappingWhereInput
  }

  /**
   * UserRoleMapping upsert
   */
  export type UserRoleMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRoleMapping to update in case it exists.
     */
    where: UserRoleMappingWhereUniqueInput
    /**
     * In case the UserRoleMapping found by the `where` argument doesn't exist, create a new UserRoleMapping with this data.
     */
    create: XOR<UserRoleMappingCreateInput, UserRoleMappingUncheckedCreateInput>
    /**
     * In case the UserRoleMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleMappingUpdateInput, UserRoleMappingUncheckedUpdateInput>
  }

  /**
   * UserRoleMapping delete
   */
  export type UserRoleMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * Filter which UserRoleMapping to delete.
     */
    where: UserRoleMappingWhereUniqueInput
  }

  /**
   * UserRoleMapping deleteMany
   */
  export type UserRoleMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoleMappings to delete
     */
    where?: UserRoleMappingWhereInput
  }

  /**
   * UserRoleMapping without action
   */
  export type UserRoleMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    sessionId: string | null
    userId: string | null
    loginTime: Date | null
    logoutTime: Date | null
    isActive: boolean | null
  }

  export type SessionMaxAggregateOutputType = {
    sessionId: string | null
    userId: string | null
    loginTime: Date | null
    logoutTime: Date | null
    isActive: boolean | null
  }

  export type SessionCountAggregateOutputType = {
    sessionId: number
    userId: number
    loginTime: number
    logoutTime: number
    isActive: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    sessionId?: true
    userId?: true
    loginTime?: true
    logoutTime?: true
    isActive?: true
  }

  export type SessionMaxAggregateInputType = {
    sessionId?: true
    userId?: true
    loginTime?: true
    logoutTime?: true
    isActive?: true
  }

  export type SessionCountAggregateInputType = {
    sessionId?: true
    userId?: true
    loginTime?: true
    logoutTime?: true
    isActive?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    sessionId: string
    userId: string
    loginTime: Date
    logoutTime: Date
    isActive: boolean
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    userId?: boolean
    loginTime?: boolean
    logoutTime?: boolean
    isActive?: boolean
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    userId?: boolean
    loginTime?: boolean
    logoutTime?: boolean
    isActive?: boolean
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    sessionId?: boolean
    userId?: boolean
    loginTime?: boolean
    logoutTime?: boolean
    isActive?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UsersMasterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sessionId: string
      userId: string
      loginTime: Date
      logoutTime: Date
      isActive: boolean
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `sessionId`
     * const sessionWithSessionIdOnly = await prisma.session.findMany({ select: { sessionId: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `sessionId`
     * const sessionWithSessionIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { sessionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersMasterDefaultArgs<ExtArgs>>): Prisma__UsersMasterClient<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly sessionId: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly loginTime: FieldRef<"Session", 'DateTime'>
    readonly logoutTime: FieldRef<"Session", 'DateTime'>
    readonly isActive: FieldRef<"Session", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Surveyors
   */

  export type AggregateSurveyors = {
    _count: SurveyorsCountAggregateOutputType | null
    _min: SurveyorsMinAggregateOutputType | null
    _max: SurveyorsMaxAggregateOutputType | null
  }

  export type SurveyorsMinAggregateOutputType = {
    userId: string | null
    surveyorName: string | null
    username: string | null
    password: string | null
    wardNumber: string | null
    wardMohallaMapId: string | null
    zoneWardMapId: string | null
    ulbZoneMapId: string | null
  }

  export type SurveyorsMaxAggregateOutputType = {
    userId: string | null
    surveyorName: string | null
    username: string | null
    password: string | null
    wardNumber: string | null
    wardMohallaMapId: string | null
    zoneWardMapId: string | null
    ulbZoneMapId: string | null
  }

  export type SurveyorsCountAggregateOutputType = {
    userId: number
    surveyorName: number
    username: number
    password: number
    wardNumber: number
    wardMohallaMapId: number
    zoneWardMapId: number
    ulbZoneMapId: number
    _all: number
  }


  export type SurveyorsMinAggregateInputType = {
    userId?: true
    surveyorName?: true
    username?: true
    password?: true
    wardNumber?: true
    wardMohallaMapId?: true
    zoneWardMapId?: true
    ulbZoneMapId?: true
  }

  export type SurveyorsMaxAggregateInputType = {
    userId?: true
    surveyorName?: true
    username?: true
    password?: true
    wardNumber?: true
    wardMohallaMapId?: true
    zoneWardMapId?: true
    ulbZoneMapId?: true
  }

  export type SurveyorsCountAggregateInputType = {
    userId?: true
    surveyorName?: true
    username?: true
    password?: true
    wardNumber?: true
    wardMohallaMapId?: true
    zoneWardMapId?: true
    ulbZoneMapId?: true
    _all?: true
  }

  export type SurveyorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Surveyors to aggregate.
     */
    where?: SurveyorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveyors to fetch.
     */
    orderBy?: SurveyorsOrderByWithRelationInput | SurveyorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveyors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveyors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Surveyors
    **/
    _count?: true | SurveyorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyorsMaxAggregateInputType
  }

  export type GetSurveyorsAggregateType<T extends SurveyorsAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyors[P]>
      : GetScalarType<T[P], AggregateSurveyors[P]>
  }




  export type SurveyorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyorsWhereInput
    orderBy?: SurveyorsOrderByWithAggregationInput | SurveyorsOrderByWithAggregationInput[]
    by: SurveyorsScalarFieldEnum[] | SurveyorsScalarFieldEnum
    having?: SurveyorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyorsCountAggregateInputType | true
    _min?: SurveyorsMinAggregateInputType
    _max?: SurveyorsMaxAggregateInputType
  }

  export type SurveyorsGroupByOutputType = {
    userId: string
    surveyorName: string
    username: string
    password: string
    wardNumber: string
    wardMohallaMapId: string
    zoneWardMapId: string
    ulbZoneMapId: string
    _count: SurveyorsCountAggregateOutputType | null
    _min: SurveyorsMinAggregateOutputType | null
    _max: SurveyorsMaxAggregateOutputType | null
  }

  type GetSurveyorsGroupByPayload<T extends SurveyorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyorsGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyorsGroupByOutputType[P]>
        }
      >
    >


  export type SurveyorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    surveyorName?: boolean
    username?: boolean
    password?: boolean
    wardNumber?: boolean
    wardMohallaMapId?: boolean
    zoneWardMapId?: boolean
    ulbZoneMapId?: boolean
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
    wardMohallaMap?: boolean | WardMohallaMappingDefaultArgs<ExtArgs>
    zoneWardMap?: boolean | ZoneWardMappingDefaultArgs<ExtArgs>
    ulbZoneMap?: boolean | UlbZoneMappingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyors"]>

  export type SurveyorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    surveyorName?: boolean
    username?: boolean
    password?: boolean
    wardNumber?: boolean
    wardMohallaMapId?: boolean
    zoneWardMapId?: boolean
    ulbZoneMapId?: boolean
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
    wardMohallaMap?: boolean | WardMohallaMappingDefaultArgs<ExtArgs>
    zoneWardMap?: boolean | ZoneWardMappingDefaultArgs<ExtArgs>
    ulbZoneMap?: boolean | UlbZoneMappingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyors"]>

  export type SurveyorsSelectScalar = {
    userId?: boolean
    surveyorName?: boolean
    username?: boolean
    password?: boolean
    wardNumber?: boolean
    wardMohallaMapId?: boolean
    zoneWardMapId?: boolean
    ulbZoneMapId?: boolean
  }

  export type SurveyorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
    wardMohallaMap?: boolean | WardMohallaMappingDefaultArgs<ExtArgs>
    zoneWardMap?: boolean | ZoneWardMappingDefaultArgs<ExtArgs>
    ulbZoneMap?: boolean | UlbZoneMappingDefaultArgs<ExtArgs>
  }
  export type SurveyorsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
    wardMohallaMap?: boolean | WardMohallaMappingDefaultArgs<ExtArgs>
    zoneWardMap?: boolean | ZoneWardMappingDefaultArgs<ExtArgs>
    ulbZoneMap?: boolean | UlbZoneMappingDefaultArgs<ExtArgs>
  }

  export type $SurveyorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Surveyors"
    objects: {
      user: Prisma.$UsersMasterPayload<ExtArgs>
      wardMohallaMap: Prisma.$WardMohallaMappingPayload<ExtArgs>
      zoneWardMap: Prisma.$ZoneWardMappingPayload<ExtArgs>
      ulbZoneMap: Prisma.$UlbZoneMappingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      surveyorName: string
      username: string
      password: string
      wardNumber: string
      wardMohallaMapId: string
      zoneWardMapId: string
      ulbZoneMapId: string
    }, ExtArgs["result"]["surveyors"]>
    composites: {}
  }

  type SurveyorsGetPayload<S extends boolean | null | undefined | SurveyorsDefaultArgs> = $Result.GetResult<Prisma.$SurveyorsPayload, S>

  type SurveyorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SurveyorsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SurveyorsCountAggregateInputType | true
    }

  export interface SurveyorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Surveyors'], meta: { name: 'Surveyors' } }
    /**
     * Find zero or one Surveyors that matches the filter.
     * @param {SurveyorsFindUniqueArgs} args - Arguments to find a Surveyors
     * @example
     * // Get one Surveyors
     * const surveyors = await prisma.surveyors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyorsFindUniqueArgs>(args: SelectSubset<T, SurveyorsFindUniqueArgs<ExtArgs>>): Prisma__SurveyorsClient<$Result.GetResult<Prisma.$SurveyorsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Surveyors that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SurveyorsFindUniqueOrThrowArgs} args - Arguments to find a Surveyors
     * @example
     * // Get one Surveyors
     * const surveyors = await prisma.surveyors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyorsFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyorsClient<$Result.GetResult<Prisma.$SurveyorsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Surveyors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyorsFindFirstArgs} args - Arguments to find a Surveyors
     * @example
     * // Get one Surveyors
     * const surveyors = await prisma.surveyors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyorsFindFirstArgs>(args?: SelectSubset<T, SurveyorsFindFirstArgs<ExtArgs>>): Prisma__SurveyorsClient<$Result.GetResult<Prisma.$SurveyorsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Surveyors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyorsFindFirstOrThrowArgs} args - Arguments to find a Surveyors
     * @example
     * // Get one Surveyors
     * const surveyors = await prisma.surveyors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyorsFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyorsClient<$Result.GetResult<Prisma.$SurveyorsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Surveyors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Surveyors
     * const surveyors = await prisma.surveyors.findMany()
     * 
     * // Get first 10 Surveyors
     * const surveyors = await prisma.surveyors.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const surveyorsWithUserIdOnly = await prisma.surveyors.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends SurveyorsFindManyArgs>(args?: SelectSubset<T, SurveyorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyorsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Surveyors.
     * @param {SurveyorsCreateArgs} args - Arguments to create a Surveyors.
     * @example
     * // Create one Surveyors
     * const Surveyors = await prisma.surveyors.create({
     *   data: {
     *     // ... data to create a Surveyors
     *   }
     * })
     * 
     */
    create<T extends SurveyorsCreateArgs>(args: SelectSubset<T, SurveyorsCreateArgs<ExtArgs>>): Prisma__SurveyorsClient<$Result.GetResult<Prisma.$SurveyorsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Surveyors.
     * @param {SurveyorsCreateManyArgs} args - Arguments to create many Surveyors.
     * @example
     * // Create many Surveyors
     * const surveyors = await prisma.surveyors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyorsCreateManyArgs>(args?: SelectSubset<T, SurveyorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Surveyors and returns the data saved in the database.
     * @param {SurveyorsCreateManyAndReturnArgs} args - Arguments to create many Surveyors.
     * @example
     * // Create many Surveyors
     * const surveyors = await prisma.surveyors.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Surveyors and only return the `userId`
     * const surveyorsWithUserIdOnly = await prisma.surveyors.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurveyorsCreateManyAndReturnArgs>(args?: SelectSubset<T, SurveyorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyorsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Surveyors.
     * @param {SurveyorsDeleteArgs} args - Arguments to delete one Surveyors.
     * @example
     * // Delete one Surveyors
     * const Surveyors = await prisma.surveyors.delete({
     *   where: {
     *     // ... filter to delete one Surveyors
     *   }
     * })
     * 
     */
    delete<T extends SurveyorsDeleteArgs>(args: SelectSubset<T, SurveyorsDeleteArgs<ExtArgs>>): Prisma__SurveyorsClient<$Result.GetResult<Prisma.$SurveyorsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Surveyors.
     * @param {SurveyorsUpdateArgs} args - Arguments to update one Surveyors.
     * @example
     * // Update one Surveyors
     * const surveyors = await prisma.surveyors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyorsUpdateArgs>(args: SelectSubset<T, SurveyorsUpdateArgs<ExtArgs>>): Prisma__SurveyorsClient<$Result.GetResult<Prisma.$SurveyorsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Surveyors.
     * @param {SurveyorsDeleteManyArgs} args - Arguments to filter Surveyors to delete.
     * @example
     * // Delete a few Surveyors
     * const { count } = await prisma.surveyors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyorsDeleteManyArgs>(args?: SelectSubset<T, SurveyorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Surveyors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Surveyors
     * const surveyors = await prisma.surveyors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyorsUpdateManyArgs>(args: SelectSubset<T, SurveyorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Surveyors.
     * @param {SurveyorsUpsertArgs} args - Arguments to update or create a Surveyors.
     * @example
     * // Update or create a Surveyors
     * const surveyors = await prisma.surveyors.upsert({
     *   create: {
     *     // ... data to create a Surveyors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Surveyors we want to update
     *   }
     * })
     */
    upsert<T extends SurveyorsUpsertArgs>(args: SelectSubset<T, SurveyorsUpsertArgs<ExtArgs>>): Prisma__SurveyorsClient<$Result.GetResult<Prisma.$SurveyorsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Surveyors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyorsCountArgs} args - Arguments to filter Surveyors to count.
     * @example
     * // Count the number of Surveyors
     * const count = await prisma.surveyors.count({
     *   where: {
     *     // ... the filter for the Surveyors we want to count
     *   }
     * })
    **/
    count<T extends SurveyorsCountArgs>(
      args?: Subset<T, SurveyorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Surveyors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyorsAggregateArgs>(args: Subset<T, SurveyorsAggregateArgs>): Prisma.PrismaPromise<GetSurveyorsAggregateType<T>>

    /**
     * Group by Surveyors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyorsGroupByArgs['orderBy'] }
        : { orderBy?: SurveyorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Surveyors model
   */
  readonly fields: SurveyorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Surveyors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersMasterDefaultArgs<ExtArgs>>): Prisma__UsersMasterClient<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    wardMohallaMap<T extends WardMohallaMappingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WardMohallaMappingDefaultArgs<ExtArgs>>): Prisma__WardMohallaMappingClient<$Result.GetResult<Prisma.$WardMohallaMappingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    zoneWardMap<T extends ZoneWardMappingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneWardMappingDefaultArgs<ExtArgs>>): Prisma__ZoneWardMappingClient<$Result.GetResult<Prisma.$ZoneWardMappingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ulbZoneMap<T extends UlbZoneMappingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UlbZoneMappingDefaultArgs<ExtArgs>>): Prisma__UlbZoneMappingClient<$Result.GetResult<Prisma.$UlbZoneMappingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Surveyors model
   */ 
  interface SurveyorsFieldRefs {
    readonly userId: FieldRef<"Surveyors", 'String'>
    readonly surveyorName: FieldRef<"Surveyors", 'String'>
    readonly username: FieldRef<"Surveyors", 'String'>
    readonly password: FieldRef<"Surveyors", 'String'>
    readonly wardNumber: FieldRef<"Surveyors", 'String'>
    readonly wardMohallaMapId: FieldRef<"Surveyors", 'String'>
    readonly zoneWardMapId: FieldRef<"Surveyors", 'String'>
    readonly ulbZoneMapId: FieldRef<"Surveyors", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Surveyors findUnique
   */
  export type SurveyorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surveyors
     */
    select?: SurveyorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorsInclude<ExtArgs> | null
    /**
     * Filter, which Surveyors to fetch.
     */
    where: SurveyorsWhereUniqueInput
  }

  /**
   * Surveyors findUniqueOrThrow
   */
  export type SurveyorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surveyors
     */
    select?: SurveyorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorsInclude<ExtArgs> | null
    /**
     * Filter, which Surveyors to fetch.
     */
    where: SurveyorsWhereUniqueInput
  }

  /**
   * Surveyors findFirst
   */
  export type SurveyorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surveyors
     */
    select?: SurveyorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorsInclude<ExtArgs> | null
    /**
     * Filter, which Surveyors to fetch.
     */
    where?: SurveyorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveyors to fetch.
     */
    orderBy?: SurveyorsOrderByWithRelationInput | SurveyorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Surveyors.
     */
    cursor?: SurveyorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveyors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveyors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Surveyors.
     */
    distinct?: SurveyorsScalarFieldEnum | SurveyorsScalarFieldEnum[]
  }

  /**
   * Surveyors findFirstOrThrow
   */
  export type SurveyorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surveyors
     */
    select?: SurveyorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorsInclude<ExtArgs> | null
    /**
     * Filter, which Surveyors to fetch.
     */
    where?: SurveyorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveyors to fetch.
     */
    orderBy?: SurveyorsOrderByWithRelationInput | SurveyorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Surveyors.
     */
    cursor?: SurveyorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveyors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveyors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Surveyors.
     */
    distinct?: SurveyorsScalarFieldEnum | SurveyorsScalarFieldEnum[]
  }

  /**
   * Surveyors findMany
   */
  export type SurveyorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surveyors
     */
    select?: SurveyorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorsInclude<ExtArgs> | null
    /**
     * Filter, which Surveyors to fetch.
     */
    where?: SurveyorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveyors to fetch.
     */
    orderBy?: SurveyorsOrderByWithRelationInput | SurveyorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Surveyors.
     */
    cursor?: SurveyorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveyors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveyors.
     */
    skip?: number
    distinct?: SurveyorsScalarFieldEnum | SurveyorsScalarFieldEnum[]
  }

  /**
   * Surveyors create
   */
  export type SurveyorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surveyors
     */
    select?: SurveyorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorsInclude<ExtArgs> | null
    /**
     * The data needed to create a Surveyors.
     */
    data: XOR<SurveyorsCreateInput, SurveyorsUncheckedCreateInput>
  }

  /**
   * Surveyors createMany
   */
  export type SurveyorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Surveyors.
     */
    data: SurveyorsCreateManyInput | SurveyorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Surveyors createManyAndReturn
   */
  export type SurveyorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surveyors
     */
    select?: SurveyorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Surveyors.
     */
    data: SurveyorsCreateManyInput | SurveyorsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Surveyors update
   */
  export type SurveyorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surveyors
     */
    select?: SurveyorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorsInclude<ExtArgs> | null
    /**
     * The data needed to update a Surveyors.
     */
    data: XOR<SurveyorsUpdateInput, SurveyorsUncheckedUpdateInput>
    /**
     * Choose, which Surveyors to update.
     */
    where: SurveyorsWhereUniqueInput
  }

  /**
   * Surveyors updateMany
   */
  export type SurveyorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Surveyors.
     */
    data: XOR<SurveyorsUpdateManyMutationInput, SurveyorsUncheckedUpdateManyInput>
    /**
     * Filter which Surveyors to update
     */
    where?: SurveyorsWhereInput
  }

  /**
   * Surveyors upsert
   */
  export type SurveyorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surveyors
     */
    select?: SurveyorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorsInclude<ExtArgs> | null
    /**
     * The filter to search for the Surveyors to update in case it exists.
     */
    where: SurveyorsWhereUniqueInput
    /**
     * In case the Surveyors found by the `where` argument doesn't exist, create a new Surveyors with this data.
     */
    create: XOR<SurveyorsCreateInput, SurveyorsUncheckedCreateInput>
    /**
     * In case the Surveyors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyorsUpdateInput, SurveyorsUncheckedUpdateInput>
  }

  /**
   * Surveyors delete
   */
  export type SurveyorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surveyors
     */
    select?: SurveyorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorsInclude<ExtArgs> | null
    /**
     * Filter which Surveyors to delete.
     */
    where: SurveyorsWhereUniqueInput
  }

  /**
   * Surveyors deleteMany
   */
  export type SurveyorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Surveyors to delete
     */
    where?: SurveyorsWhereInput
  }

  /**
   * Surveyors without action
   */
  export type SurveyorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surveyors
     */
    select?: SurveyorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyorsInclude<ExtArgs> | null
  }


  /**
   * Model Supervisors
   */

  export type AggregateSupervisors = {
    _count: SupervisorsCountAggregateOutputType | null
    _min: SupervisorsMinAggregateOutputType | null
    _max: SupervisorsMaxAggregateOutputType | null
  }

  export type SupervisorsMinAggregateOutputType = {
    userId: string | null
    supervisorName: string | null
    username: string | null
    password: string | null
    wardId: string | null
  }

  export type SupervisorsMaxAggregateOutputType = {
    userId: string | null
    supervisorName: string | null
    username: string | null
    password: string | null
    wardId: string | null
  }

  export type SupervisorsCountAggregateOutputType = {
    userId: number
    supervisorName: number
    username: number
    password: number
    wardId: number
    _all: number
  }


  export type SupervisorsMinAggregateInputType = {
    userId?: true
    supervisorName?: true
    username?: true
    password?: true
    wardId?: true
  }

  export type SupervisorsMaxAggregateInputType = {
    userId?: true
    supervisorName?: true
    username?: true
    password?: true
    wardId?: true
  }

  export type SupervisorsCountAggregateInputType = {
    userId?: true
    supervisorName?: true
    username?: true
    password?: true
    wardId?: true
    _all?: true
  }

  export type SupervisorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supervisors to aggregate.
     */
    where?: SupervisorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Supervisors to fetch.
     */
    orderBy?: SupervisorsOrderByWithRelationInput | SupervisorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupervisorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Supervisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Supervisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Supervisors
    **/
    _count?: true | SupervisorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupervisorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupervisorsMaxAggregateInputType
  }

  export type GetSupervisorsAggregateType<T extends SupervisorsAggregateArgs> = {
        [P in keyof T & keyof AggregateSupervisors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupervisors[P]>
      : GetScalarType<T[P], AggregateSupervisors[P]>
  }




  export type SupervisorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupervisorsWhereInput
    orderBy?: SupervisorsOrderByWithAggregationInput | SupervisorsOrderByWithAggregationInput[]
    by: SupervisorsScalarFieldEnum[] | SupervisorsScalarFieldEnum
    having?: SupervisorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupervisorsCountAggregateInputType | true
    _min?: SupervisorsMinAggregateInputType
    _max?: SupervisorsMaxAggregateInputType
  }

  export type SupervisorsGroupByOutputType = {
    userId: string
    supervisorName: string
    username: string
    password: string
    wardId: string
    _count: SupervisorsCountAggregateOutputType | null
    _min: SupervisorsMinAggregateOutputType | null
    _max: SupervisorsMaxAggregateOutputType | null
  }

  type GetSupervisorsGroupByPayload<T extends SupervisorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupervisorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupervisorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupervisorsGroupByOutputType[P]>
            : GetScalarType<T[P], SupervisorsGroupByOutputType[P]>
        }
      >
    >


  export type SupervisorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    supervisorName?: boolean
    username?: boolean
    password?: boolean
    wardId?: boolean
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supervisors"]>

  export type SupervisorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    supervisorName?: boolean
    username?: boolean
    password?: boolean
    wardId?: boolean
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supervisors"]>

  export type SupervisorsSelectScalar = {
    userId?: boolean
    supervisorName?: boolean
    username?: boolean
    password?: boolean
    wardId?: boolean
  }

  export type SupervisorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
  }
  export type SupervisorsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
  }

  export type $SupervisorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supervisors"
    objects: {
      user: Prisma.$UsersMasterPayload<ExtArgs>
      ward: Prisma.$WardMasterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      supervisorName: string
      username: string
      password: string
      wardId: string
    }, ExtArgs["result"]["supervisors"]>
    composites: {}
  }

  type SupervisorsGetPayload<S extends boolean | null | undefined | SupervisorsDefaultArgs> = $Result.GetResult<Prisma.$SupervisorsPayload, S>

  type SupervisorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupervisorsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupervisorsCountAggregateInputType | true
    }

  export interface SupervisorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supervisors'], meta: { name: 'Supervisors' } }
    /**
     * Find zero or one Supervisors that matches the filter.
     * @param {SupervisorsFindUniqueArgs} args - Arguments to find a Supervisors
     * @example
     * // Get one Supervisors
     * const supervisors = await prisma.supervisors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupervisorsFindUniqueArgs>(args: SelectSubset<T, SupervisorsFindUniqueArgs<ExtArgs>>): Prisma__SupervisorsClient<$Result.GetResult<Prisma.$SupervisorsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Supervisors that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupervisorsFindUniqueOrThrowArgs} args - Arguments to find a Supervisors
     * @example
     * // Get one Supervisors
     * const supervisors = await prisma.supervisors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupervisorsFindUniqueOrThrowArgs>(args: SelectSubset<T, SupervisorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupervisorsClient<$Result.GetResult<Prisma.$SupervisorsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Supervisors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupervisorsFindFirstArgs} args - Arguments to find a Supervisors
     * @example
     * // Get one Supervisors
     * const supervisors = await prisma.supervisors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupervisorsFindFirstArgs>(args?: SelectSubset<T, SupervisorsFindFirstArgs<ExtArgs>>): Prisma__SupervisorsClient<$Result.GetResult<Prisma.$SupervisorsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Supervisors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupervisorsFindFirstOrThrowArgs} args - Arguments to find a Supervisors
     * @example
     * // Get one Supervisors
     * const supervisors = await prisma.supervisors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupervisorsFindFirstOrThrowArgs>(args?: SelectSubset<T, SupervisorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupervisorsClient<$Result.GetResult<Prisma.$SupervisorsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Supervisors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupervisorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Supervisors
     * const supervisors = await prisma.supervisors.findMany()
     * 
     * // Get first 10 Supervisors
     * const supervisors = await prisma.supervisors.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const supervisorsWithUserIdOnly = await prisma.supervisors.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends SupervisorsFindManyArgs>(args?: SelectSubset<T, SupervisorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupervisorsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Supervisors.
     * @param {SupervisorsCreateArgs} args - Arguments to create a Supervisors.
     * @example
     * // Create one Supervisors
     * const Supervisors = await prisma.supervisors.create({
     *   data: {
     *     // ... data to create a Supervisors
     *   }
     * })
     * 
     */
    create<T extends SupervisorsCreateArgs>(args: SelectSubset<T, SupervisorsCreateArgs<ExtArgs>>): Prisma__SupervisorsClient<$Result.GetResult<Prisma.$SupervisorsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Supervisors.
     * @param {SupervisorsCreateManyArgs} args - Arguments to create many Supervisors.
     * @example
     * // Create many Supervisors
     * const supervisors = await prisma.supervisors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupervisorsCreateManyArgs>(args?: SelectSubset<T, SupervisorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Supervisors and returns the data saved in the database.
     * @param {SupervisorsCreateManyAndReturnArgs} args - Arguments to create many Supervisors.
     * @example
     * // Create many Supervisors
     * const supervisors = await prisma.supervisors.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Supervisors and only return the `userId`
     * const supervisorsWithUserIdOnly = await prisma.supervisors.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupervisorsCreateManyAndReturnArgs>(args?: SelectSubset<T, SupervisorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupervisorsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Supervisors.
     * @param {SupervisorsDeleteArgs} args - Arguments to delete one Supervisors.
     * @example
     * // Delete one Supervisors
     * const Supervisors = await prisma.supervisors.delete({
     *   where: {
     *     // ... filter to delete one Supervisors
     *   }
     * })
     * 
     */
    delete<T extends SupervisorsDeleteArgs>(args: SelectSubset<T, SupervisorsDeleteArgs<ExtArgs>>): Prisma__SupervisorsClient<$Result.GetResult<Prisma.$SupervisorsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Supervisors.
     * @param {SupervisorsUpdateArgs} args - Arguments to update one Supervisors.
     * @example
     * // Update one Supervisors
     * const supervisors = await prisma.supervisors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupervisorsUpdateArgs>(args: SelectSubset<T, SupervisorsUpdateArgs<ExtArgs>>): Prisma__SupervisorsClient<$Result.GetResult<Prisma.$SupervisorsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Supervisors.
     * @param {SupervisorsDeleteManyArgs} args - Arguments to filter Supervisors to delete.
     * @example
     * // Delete a few Supervisors
     * const { count } = await prisma.supervisors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupervisorsDeleteManyArgs>(args?: SelectSubset<T, SupervisorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Supervisors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupervisorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Supervisors
     * const supervisors = await prisma.supervisors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupervisorsUpdateManyArgs>(args: SelectSubset<T, SupervisorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supervisors.
     * @param {SupervisorsUpsertArgs} args - Arguments to update or create a Supervisors.
     * @example
     * // Update or create a Supervisors
     * const supervisors = await prisma.supervisors.upsert({
     *   create: {
     *     // ... data to create a Supervisors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supervisors we want to update
     *   }
     * })
     */
    upsert<T extends SupervisorsUpsertArgs>(args: SelectSubset<T, SupervisorsUpsertArgs<ExtArgs>>): Prisma__SupervisorsClient<$Result.GetResult<Prisma.$SupervisorsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Supervisors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupervisorsCountArgs} args - Arguments to filter Supervisors to count.
     * @example
     * // Count the number of Supervisors
     * const count = await prisma.supervisors.count({
     *   where: {
     *     // ... the filter for the Supervisors we want to count
     *   }
     * })
    **/
    count<T extends SupervisorsCountArgs>(
      args?: Subset<T, SupervisorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupervisorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supervisors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupervisorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupervisorsAggregateArgs>(args: Subset<T, SupervisorsAggregateArgs>): Prisma.PrismaPromise<GetSupervisorsAggregateType<T>>

    /**
     * Group by Supervisors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupervisorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupervisorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupervisorsGroupByArgs['orderBy'] }
        : { orderBy?: SupervisorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupervisorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupervisorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supervisors model
   */
  readonly fields: SupervisorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supervisors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupervisorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersMasterDefaultArgs<ExtArgs>>): Prisma__UsersMasterClient<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ward<T extends WardMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WardMasterDefaultArgs<ExtArgs>>): Prisma__WardMasterClient<$Result.GetResult<Prisma.$WardMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supervisors model
   */ 
  interface SupervisorsFieldRefs {
    readonly userId: FieldRef<"Supervisors", 'String'>
    readonly supervisorName: FieldRef<"Supervisors", 'String'>
    readonly username: FieldRef<"Supervisors", 'String'>
    readonly password: FieldRef<"Supervisors", 'String'>
    readonly wardId: FieldRef<"Supervisors", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Supervisors findUnique
   */
  export type SupervisorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supervisors
     */
    select?: SupervisorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupervisorsInclude<ExtArgs> | null
    /**
     * Filter, which Supervisors to fetch.
     */
    where: SupervisorsWhereUniqueInput
  }

  /**
   * Supervisors findUniqueOrThrow
   */
  export type SupervisorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supervisors
     */
    select?: SupervisorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupervisorsInclude<ExtArgs> | null
    /**
     * Filter, which Supervisors to fetch.
     */
    where: SupervisorsWhereUniqueInput
  }

  /**
   * Supervisors findFirst
   */
  export type SupervisorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supervisors
     */
    select?: SupervisorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupervisorsInclude<ExtArgs> | null
    /**
     * Filter, which Supervisors to fetch.
     */
    where?: SupervisorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Supervisors to fetch.
     */
    orderBy?: SupervisorsOrderByWithRelationInput | SupervisorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Supervisors.
     */
    cursor?: SupervisorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Supervisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Supervisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Supervisors.
     */
    distinct?: SupervisorsScalarFieldEnum | SupervisorsScalarFieldEnum[]
  }

  /**
   * Supervisors findFirstOrThrow
   */
  export type SupervisorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supervisors
     */
    select?: SupervisorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupervisorsInclude<ExtArgs> | null
    /**
     * Filter, which Supervisors to fetch.
     */
    where?: SupervisorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Supervisors to fetch.
     */
    orderBy?: SupervisorsOrderByWithRelationInput | SupervisorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Supervisors.
     */
    cursor?: SupervisorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Supervisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Supervisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Supervisors.
     */
    distinct?: SupervisorsScalarFieldEnum | SupervisorsScalarFieldEnum[]
  }

  /**
   * Supervisors findMany
   */
  export type SupervisorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supervisors
     */
    select?: SupervisorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupervisorsInclude<ExtArgs> | null
    /**
     * Filter, which Supervisors to fetch.
     */
    where?: SupervisorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Supervisors to fetch.
     */
    orderBy?: SupervisorsOrderByWithRelationInput | SupervisorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Supervisors.
     */
    cursor?: SupervisorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Supervisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Supervisors.
     */
    skip?: number
    distinct?: SupervisorsScalarFieldEnum | SupervisorsScalarFieldEnum[]
  }

  /**
   * Supervisors create
   */
  export type SupervisorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supervisors
     */
    select?: SupervisorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupervisorsInclude<ExtArgs> | null
    /**
     * The data needed to create a Supervisors.
     */
    data: XOR<SupervisorsCreateInput, SupervisorsUncheckedCreateInput>
  }

  /**
   * Supervisors createMany
   */
  export type SupervisorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Supervisors.
     */
    data: SupervisorsCreateManyInput | SupervisorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supervisors createManyAndReturn
   */
  export type SupervisorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supervisors
     */
    select?: SupervisorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Supervisors.
     */
    data: SupervisorsCreateManyInput | SupervisorsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupervisorsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supervisors update
   */
  export type SupervisorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supervisors
     */
    select?: SupervisorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupervisorsInclude<ExtArgs> | null
    /**
     * The data needed to update a Supervisors.
     */
    data: XOR<SupervisorsUpdateInput, SupervisorsUncheckedUpdateInput>
    /**
     * Choose, which Supervisors to update.
     */
    where: SupervisorsWhereUniqueInput
  }

  /**
   * Supervisors updateMany
   */
  export type SupervisorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Supervisors.
     */
    data: XOR<SupervisorsUpdateManyMutationInput, SupervisorsUncheckedUpdateManyInput>
    /**
     * Filter which Supervisors to update
     */
    where?: SupervisorsWhereInput
  }

  /**
   * Supervisors upsert
   */
  export type SupervisorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supervisors
     */
    select?: SupervisorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupervisorsInclude<ExtArgs> | null
    /**
     * The filter to search for the Supervisors to update in case it exists.
     */
    where: SupervisorsWhereUniqueInput
    /**
     * In case the Supervisors found by the `where` argument doesn't exist, create a new Supervisors with this data.
     */
    create: XOR<SupervisorsCreateInput, SupervisorsUncheckedCreateInput>
    /**
     * In case the Supervisors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupervisorsUpdateInput, SupervisorsUncheckedUpdateInput>
  }

  /**
   * Supervisors delete
   */
  export type SupervisorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supervisors
     */
    select?: SupervisorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupervisorsInclude<ExtArgs> | null
    /**
     * Filter which Supervisors to delete.
     */
    where: SupervisorsWhereUniqueInput
  }

  /**
   * Supervisors deleteMany
   */
  export type SupervisorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supervisors to delete
     */
    where?: SupervisorsWhereInput
  }

  /**
   * Supervisors without action
   */
  export type SupervisorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supervisors
     */
    select?: SupervisorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupervisorsInclude<ExtArgs> | null
  }


  /**
   * Model Admins
   */

  export type AggregateAdmins = {
    _count: AdminsCountAggregateOutputType | null
    _min: AdminsMinAggregateOutputType | null
    _max: AdminsMaxAggregateOutputType | null
  }

  export type AdminsMinAggregateOutputType = {
    userId: string | null
    adminName: string | null
    username: string | null
    password: string | null
  }

  export type AdminsMaxAggregateOutputType = {
    userId: string | null
    adminName: string | null
    username: string | null
    password: string | null
  }

  export type AdminsCountAggregateOutputType = {
    userId: number
    adminName: number
    username: number
    password: number
    _all: number
  }


  export type AdminsMinAggregateInputType = {
    userId?: true
    adminName?: true
    username?: true
    password?: true
  }

  export type AdminsMaxAggregateInputType = {
    userId?: true
    adminName?: true
    username?: true
    password?: true
  }

  export type AdminsCountAggregateInputType = {
    userId?: true
    adminName?: true
    username?: true
    password?: true
    _all?: true
  }

  export type AdminsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to aggregate.
     */
    where?: AdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminsOrderByWithRelationInput | AdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminsMaxAggregateInputType
  }

  export type GetAdminsAggregateType<T extends AdminsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmins[P]>
      : GetScalarType<T[P], AggregateAdmins[P]>
  }




  export type AdminsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminsWhereInput
    orderBy?: AdminsOrderByWithAggregationInput | AdminsOrderByWithAggregationInput[]
    by: AdminsScalarFieldEnum[] | AdminsScalarFieldEnum
    having?: AdminsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminsCountAggregateInputType | true
    _min?: AdminsMinAggregateInputType
    _max?: AdminsMaxAggregateInputType
  }

  export type AdminsGroupByOutputType = {
    userId: string
    adminName: string
    username: string
    password: string
    _count: AdminsCountAggregateOutputType | null
    _min: AdminsMinAggregateOutputType | null
    _max: AdminsMaxAggregateOutputType | null
  }

  type GetAdminsGroupByPayload<T extends AdminsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminsGroupByOutputType[P]>
            : GetScalarType<T[P], AdminsGroupByOutputType[P]>
        }
      >
    >


  export type AdminsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    adminName?: boolean
    username?: boolean
    password?: boolean
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admins"]>

  export type AdminsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    adminName?: boolean
    username?: boolean
    password?: boolean
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admins"]>

  export type AdminsSelectScalar = {
    userId?: boolean
    adminName?: boolean
    username?: boolean
    password?: boolean
  }

  export type AdminsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }
  export type AdminsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersMasterDefaultArgs<ExtArgs>
  }

  export type $AdminsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admins"
    objects: {
      user: Prisma.$UsersMasterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      adminName: string
      username: string
      password: string
    }, ExtArgs["result"]["admins"]>
    composites: {}
  }

  type AdminsGetPayload<S extends boolean | null | undefined | AdminsDefaultArgs> = $Result.GetResult<Prisma.$AdminsPayload, S>

  type AdminsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminsCountAggregateInputType | true
    }

  export interface AdminsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admins'], meta: { name: 'Admins' } }
    /**
     * Find zero or one Admins that matches the filter.
     * @param {AdminsFindUniqueArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminsFindUniqueArgs>(args: SelectSubset<T, AdminsFindUniqueArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Admins that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminsFindUniqueOrThrowArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminsFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsFindFirstArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminsFindFirstArgs>(args?: SelectSubset<T, AdminsFindFirstArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Admins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsFindFirstOrThrowArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminsFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admins.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admins.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const adminsWithUserIdOnly = await prisma.admins.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends AdminsFindManyArgs>(args?: SelectSubset<T, AdminsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Admins.
     * @param {AdminsCreateArgs} args - Arguments to create a Admins.
     * @example
     * // Create one Admins
     * const Admins = await prisma.admins.create({
     *   data: {
     *     // ... data to create a Admins
     *   }
     * })
     * 
     */
    create<T extends AdminsCreateArgs>(args: SelectSubset<T, AdminsCreateArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Admins.
     * @param {AdminsCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admins = await prisma.admins.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminsCreateManyArgs>(args?: SelectSubset<T, AdminsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminsCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admins = await prisma.admins.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `userId`
     * const adminsWithUserIdOnly = await prisma.admins.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminsCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Admins.
     * @param {AdminsDeleteArgs} args - Arguments to delete one Admins.
     * @example
     * // Delete one Admins
     * const Admins = await prisma.admins.delete({
     *   where: {
     *     // ... filter to delete one Admins
     *   }
     * })
     * 
     */
    delete<T extends AdminsDeleteArgs>(args: SelectSubset<T, AdminsDeleteArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Admins.
     * @param {AdminsUpdateArgs} args - Arguments to update one Admins.
     * @example
     * // Update one Admins
     * const admins = await prisma.admins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminsUpdateArgs>(args: SelectSubset<T, AdminsUpdateArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminsDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminsDeleteManyArgs>(args?: SelectSubset<T, AdminsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admins = await prisma.admins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminsUpdateManyArgs>(args: SelectSubset<T, AdminsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admins.
     * @param {AdminsUpsertArgs} args - Arguments to update or create a Admins.
     * @example
     * // Update or create a Admins
     * const admins = await prisma.admins.upsert({
     *   create: {
     *     // ... data to create a Admins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admins we want to update
     *   }
     * })
     */
    upsert<T extends AdminsUpsertArgs>(args: SelectSubset<T, AdminsUpsertArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admins.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminsCountArgs>(
      args?: Subset<T, AdminsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminsAggregateArgs>(args: Subset<T, AdminsAggregateArgs>): Prisma.PrismaPromise<GetAdminsAggregateType<T>>

    /**
     * Group by Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminsGroupByArgs['orderBy'] }
        : { orderBy?: AdminsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admins model
   */
  readonly fields: AdminsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersMasterDefaultArgs<ExtArgs>>): Prisma__UsersMasterClient<$Result.GetResult<Prisma.$UsersMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admins model
   */ 
  interface AdminsFieldRefs {
    readonly userId: FieldRef<"Admins", 'String'>
    readonly adminName: FieldRef<"Admins", 'String'>
    readonly username: FieldRef<"Admins", 'String'>
    readonly password: FieldRef<"Admins", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Admins findUnique
   */
  export type AdminsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where: AdminsWhereUniqueInput
  }

  /**
   * Admins findUniqueOrThrow
   */
  export type AdminsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where: AdminsWhereUniqueInput
  }

  /**
   * Admins findFirst
   */
  export type AdminsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminsOrderByWithRelationInput | AdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[]
  }

  /**
   * Admins findFirstOrThrow
   */
  export type AdminsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminsOrderByWithRelationInput | AdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[]
  }

  /**
   * Admins findMany
   */
  export type AdminsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminsOrderByWithRelationInput | AdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[]
  }

  /**
   * Admins create
   */
  export type AdminsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * The data needed to create a Admins.
     */
    data: XOR<AdminsCreateInput, AdminsUncheckedCreateInput>
  }

  /**
   * Admins createMany
   */
  export type AdminsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminsCreateManyInput | AdminsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admins createManyAndReturn
   */
  export type AdminsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminsCreateManyInput | AdminsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admins update
   */
  export type AdminsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * The data needed to update a Admins.
     */
    data: XOR<AdminsUpdateInput, AdminsUncheckedUpdateInput>
    /**
     * Choose, which Admins to update.
     */
    where: AdminsWhereUniqueInput
  }

  /**
   * Admins updateMany
   */
  export type AdminsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminsUpdateManyMutationInput, AdminsUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminsWhereInput
  }

  /**
   * Admins upsert
   */
  export type AdminsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * The filter to search for the Admins to update in case it exists.
     */
    where: AdminsWhereUniqueInput
    /**
     * In case the Admins found by the `where` argument doesn't exist, create a new Admins with this data.
     */
    create: XOR<AdminsCreateInput, AdminsUncheckedCreateInput>
    /**
     * In case the Admins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminsUpdateInput, AdminsUncheckedUpdateInput>
  }

  /**
   * Admins delete
   */
  export type AdminsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter which Admins to delete.
     */
    where: AdminsWhereUniqueInput
  }

  /**
   * Admins deleteMany
   */
  export type AdminsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminsWhereInput
  }

  /**
   * Admins without action
   */
  export type AdminsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
  }


  /**
   * Model SurveyDetails
   */

  export type AggregateSurveyDetails = {
    _count: SurveyDetailsCountAggregateOutputType | null
    _avg: SurveyDetailsAvgAggregateOutputType | null
    _sum: SurveyDetailsSumAggregateOutputType | null
    _min: SurveyDetailsMinAggregateOutputType | null
    _max: SurveyDetailsMaxAggregateOutputType | null
  }

  export type SurveyDetailsAvgAggregateOutputType = {
    parcelId: number | null
    mapId: number | null
  }

  export type SurveyDetailsSumAggregateOutputType = {
    parcelId: number | null
    mapId: number | null
  }

  export type SurveyDetailsMinAggregateOutputType = {
    surveyUniqueCode: string | null
    ulbId: string | null
    zoneId: string | null
    wardId: string | null
    mohallaId: string | null
    surveyTypeId: string | null
    entryDate: Date | null
    parcelId: number | null
    mapId: number | null
    gisId: string | null
    subGisId: string | null
  }

  export type SurveyDetailsMaxAggregateOutputType = {
    surveyUniqueCode: string | null
    ulbId: string | null
    zoneId: string | null
    wardId: string | null
    mohallaId: string | null
    surveyTypeId: string | null
    entryDate: Date | null
    parcelId: number | null
    mapId: number | null
    gisId: string | null
    subGisId: string | null
  }

  export type SurveyDetailsCountAggregateOutputType = {
    surveyUniqueCode: number
    ulbId: number
    zoneId: number
    wardId: number
    mohallaId: number
    surveyTypeId: number
    entryDate: number
    parcelId: number
    mapId: number
    gisId: number
    subGisId: number
    _all: number
  }


  export type SurveyDetailsAvgAggregateInputType = {
    parcelId?: true
    mapId?: true
  }

  export type SurveyDetailsSumAggregateInputType = {
    parcelId?: true
    mapId?: true
  }

  export type SurveyDetailsMinAggregateInputType = {
    surveyUniqueCode?: true
    ulbId?: true
    zoneId?: true
    wardId?: true
    mohallaId?: true
    surveyTypeId?: true
    entryDate?: true
    parcelId?: true
    mapId?: true
    gisId?: true
    subGisId?: true
  }

  export type SurveyDetailsMaxAggregateInputType = {
    surveyUniqueCode?: true
    ulbId?: true
    zoneId?: true
    wardId?: true
    mohallaId?: true
    surveyTypeId?: true
    entryDate?: true
    parcelId?: true
    mapId?: true
    gisId?: true
    subGisId?: true
  }

  export type SurveyDetailsCountAggregateInputType = {
    surveyUniqueCode?: true
    ulbId?: true
    zoneId?: true
    wardId?: true
    mohallaId?: true
    surveyTypeId?: true
    entryDate?: true
    parcelId?: true
    mapId?: true
    gisId?: true
    subGisId?: true
    _all?: true
  }

  export type SurveyDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyDetails to aggregate.
     */
    where?: SurveyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyDetails to fetch.
     */
    orderBy?: SurveyDetailsOrderByWithRelationInput | SurveyDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyDetails
    **/
    _count?: true | SurveyDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SurveyDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SurveyDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyDetailsMaxAggregateInputType
  }

  export type GetSurveyDetailsAggregateType<T extends SurveyDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyDetails[P]>
      : GetScalarType<T[P], AggregateSurveyDetails[P]>
  }




  export type SurveyDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyDetailsWhereInput
    orderBy?: SurveyDetailsOrderByWithAggregationInput | SurveyDetailsOrderByWithAggregationInput[]
    by: SurveyDetailsScalarFieldEnum[] | SurveyDetailsScalarFieldEnum
    having?: SurveyDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyDetailsCountAggregateInputType | true
    _avg?: SurveyDetailsAvgAggregateInputType
    _sum?: SurveyDetailsSumAggregateInputType
    _min?: SurveyDetailsMinAggregateInputType
    _max?: SurveyDetailsMaxAggregateInputType
  }

  export type SurveyDetailsGroupByOutputType = {
    surveyUniqueCode: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    surveyTypeId: string
    entryDate: Date
    parcelId: number | null
    mapId: number
    gisId: string
    subGisId: string | null
    _count: SurveyDetailsCountAggregateOutputType | null
    _avg: SurveyDetailsAvgAggregateOutputType | null
    _sum: SurveyDetailsSumAggregateOutputType | null
    _min: SurveyDetailsMinAggregateOutputType | null
    _max: SurveyDetailsMaxAggregateOutputType | null
  }

  type GetSurveyDetailsGroupByPayload<T extends SurveyDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyDetailsGroupByOutputType[P]>
        }
      >
    >


  export type SurveyDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surveyUniqueCode?: boolean
    ulbId?: boolean
    zoneId?: boolean
    wardId?: boolean
    mohallaId?: boolean
    surveyTypeId?: boolean
    entryDate?: boolean
    parcelId?: boolean
    mapId?: boolean
    gisId?: boolean
    subGisId?: boolean
    ulb?: boolean | UlbMasterDefaultArgs<ExtArgs>
    zone?: boolean | ZoneMasterDefaultArgs<ExtArgs>
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    mohalla?: boolean | MohallaMasterDefaultArgs<ExtArgs>
    surveyType?: boolean | SurveyTypeMasterDefaultArgs<ExtArgs>
    propertyDetails?: boolean | SurveyDetails$propertyDetailsArgs<ExtArgs>
    ownerDetails?: boolean | SurveyDetails$ownerDetailsArgs<ExtArgs>
    locationDetails?: boolean | SurveyDetails$locationDetailsArgs<ExtArgs>
    otherDetails?: boolean | SurveyDetails$otherDetailsArgs<ExtArgs>
    residentialPropertyAssessments?: boolean | SurveyDetails$residentialPropertyAssessmentsArgs<ExtArgs>
    nonResidentialPropertyAssessments?: boolean | SurveyDetails$nonResidentialPropertyAssessmentsArgs<ExtArgs>
    propertyAttachments?: boolean | SurveyDetails$propertyAttachmentsArgs<ExtArgs>
    surveyStatusMaps?: boolean | SurveyDetails$surveyStatusMapsArgs<ExtArgs>
    _count?: boolean | SurveyDetailsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyDetails"]>

  export type SurveyDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surveyUniqueCode?: boolean
    ulbId?: boolean
    zoneId?: boolean
    wardId?: boolean
    mohallaId?: boolean
    surveyTypeId?: boolean
    entryDate?: boolean
    parcelId?: boolean
    mapId?: boolean
    gisId?: boolean
    subGisId?: boolean
    ulb?: boolean | UlbMasterDefaultArgs<ExtArgs>
    zone?: boolean | ZoneMasterDefaultArgs<ExtArgs>
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    mohalla?: boolean | MohallaMasterDefaultArgs<ExtArgs>
    surveyType?: boolean | SurveyTypeMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyDetails"]>

  export type SurveyDetailsSelectScalar = {
    surveyUniqueCode?: boolean
    ulbId?: boolean
    zoneId?: boolean
    wardId?: boolean
    mohallaId?: boolean
    surveyTypeId?: boolean
    entryDate?: boolean
    parcelId?: boolean
    mapId?: boolean
    gisId?: boolean
    subGisId?: boolean
  }

  export type SurveyDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ulb?: boolean | UlbMasterDefaultArgs<ExtArgs>
    zone?: boolean | ZoneMasterDefaultArgs<ExtArgs>
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    mohalla?: boolean | MohallaMasterDefaultArgs<ExtArgs>
    surveyType?: boolean | SurveyTypeMasterDefaultArgs<ExtArgs>
    propertyDetails?: boolean | SurveyDetails$propertyDetailsArgs<ExtArgs>
    ownerDetails?: boolean | SurveyDetails$ownerDetailsArgs<ExtArgs>
    locationDetails?: boolean | SurveyDetails$locationDetailsArgs<ExtArgs>
    otherDetails?: boolean | SurveyDetails$otherDetailsArgs<ExtArgs>
    residentialPropertyAssessments?: boolean | SurveyDetails$residentialPropertyAssessmentsArgs<ExtArgs>
    nonResidentialPropertyAssessments?: boolean | SurveyDetails$nonResidentialPropertyAssessmentsArgs<ExtArgs>
    propertyAttachments?: boolean | SurveyDetails$propertyAttachmentsArgs<ExtArgs>
    surveyStatusMaps?: boolean | SurveyDetails$surveyStatusMapsArgs<ExtArgs>
    _count?: boolean | SurveyDetailsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SurveyDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ulb?: boolean | UlbMasterDefaultArgs<ExtArgs>
    zone?: boolean | ZoneMasterDefaultArgs<ExtArgs>
    ward?: boolean | WardMasterDefaultArgs<ExtArgs>
    mohalla?: boolean | MohallaMasterDefaultArgs<ExtArgs>
    surveyType?: boolean | SurveyTypeMasterDefaultArgs<ExtArgs>
  }

  export type $SurveyDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurveyDetails"
    objects: {
      ulb: Prisma.$UlbMasterPayload<ExtArgs>
      zone: Prisma.$ZoneMasterPayload<ExtArgs>
      ward: Prisma.$WardMasterPayload<ExtArgs>
      mohalla: Prisma.$MohallaMasterPayload<ExtArgs>
      surveyType: Prisma.$SurveyTypeMasterPayload<ExtArgs>
      propertyDetails: Prisma.$PropertyDetailsPayload<ExtArgs>[]
      ownerDetails: Prisma.$OwnerDetailsPayload<ExtArgs>[]
      locationDetails: Prisma.$LocationDetailsPayload<ExtArgs>[]
      otherDetails: Prisma.$OtherDetailsPayload<ExtArgs>[]
      residentialPropertyAssessments: Prisma.$ResidentialPropertyAssessmentPayload<ExtArgs>[]
      nonResidentialPropertyAssessments: Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>[]
      propertyAttachments: Prisma.$PropertyAttachmentDetailsPayload<ExtArgs>[]
      surveyStatusMaps: Prisma.$SurveyStatusMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      surveyUniqueCode: string
      ulbId: string
      zoneId: string
      wardId: string
      mohallaId: string
      surveyTypeId: string
      entryDate: Date
      parcelId: number | null
      mapId: number
      gisId: string
      subGisId: string | null
    }, ExtArgs["result"]["surveyDetails"]>
    composites: {}
  }

  type SurveyDetailsGetPayload<S extends boolean | null | undefined | SurveyDetailsDefaultArgs> = $Result.GetResult<Prisma.$SurveyDetailsPayload, S>

  type SurveyDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SurveyDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SurveyDetailsCountAggregateInputType | true
    }

  export interface SurveyDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurveyDetails'], meta: { name: 'SurveyDetails' } }
    /**
     * Find zero or one SurveyDetails that matches the filter.
     * @param {SurveyDetailsFindUniqueArgs} args - Arguments to find a SurveyDetails
     * @example
     * // Get one SurveyDetails
     * const surveyDetails = await prisma.surveyDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyDetailsFindUniqueArgs>(args: SelectSubset<T, SurveyDetailsFindUniqueArgs<ExtArgs>>): Prisma__SurveyDetailsClient<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SurveyDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SurveyDetailsFindUniqueOrThrowArgs} args - Arguments to find a SurveyDetails
     * @example
     * // Get one SurveyDetails
     * const surveyDetails = await prisma.surveyDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyDetailsClient<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SurveyDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyDetailsFindFirstArgs} args - Arguments to find a SurveyDetails
     * @example
     * // Get one SurveyDetails
     * const surveyDetails = await prisma.surveyDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyDetailsFindFirstArgs>(args?: SelectSubset<T, SurveyDetailsFindFirstArgs<ExtArgs>>): Prisma__SurveyDetailsClient<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SurveyDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyDetailsFindFirstOrThrowArgs} args - Arguments to find a SurveyDetails
     * @example
     * // Get one SurveyDetails
     * const surveyDetails = await prisma.surveyDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyDetailsClient<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SurveyDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyDetails
     * const surveyDetails = await prisma.surveyDetails.findMany()
     * 
     * // Get first 10 SurveyDetails
     * const surveyDetails = await prisma.surveyDetails.findMany({ take: 10 })
     * 
     * // Only select the `surveyUniqueCode`
     * const surveyDetailsWithSurveyUniqueCodeOnly = await prisma.surveyDetails.findMany({ select: { surveyUniqueCode: true } })
     * 
     */
    findMany<T extends SurveyDetailsFindManyArgs>(args?: SelectSubset<T, SurveyDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SurveyDetails.
     * @param {SurveyDetailsCreateArgs} args - Arguments to create a SurveyDetails.
     * @example
     * // Create one SurveyDetails
     * const SurveyDetails = await prisma.surveyDetails.create({
     *   data: {
     *     // ... data to create a SurveyDetails
     *   }
     * })
     * 
     */
    create<T extends SurveyDetailsCreateArgs>(args: SelectSubset<T, SurveyDetailsCreateArgs<ExtArgs>>): Prisma__SurveyDetailsClient<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SurveyDetails.
     * @param {SurveyDetailsCreateManyArgs} args - Arguments to create many SurveyDetails.
     * @example
     * // Create many SurveyDetails
     * const surveyDetails = await prisma.surveyDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyDetailsCreateManyArgs>(args?: SelectSubset<T, SurveyDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SurveyDetails and returns the data saved in the database.
     * @param {SurveyDetailsCreateManyAndReturnArgs} args - Arguments to create many SurveyDetails.
     * @example
     * // Create many SurveyDetails
     * const surveyDetails = await prisma.surveyDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SurveyDetails and only return the `surveyUniqueCode`
     * const surveyDetailsWithSurveyUniqueCodeOnly = await prisma.surveyDetails.createManyAndReturn({ 
     *   select: { surveyUniqueCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurveyDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, SurveyDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SurveyDetails.
     * @param {SurveyDetailsDeleteArgs} args - Arguments to delete one SurveyDetails.
     * @example
     * // Delete one SurveyDetails
     * const SurveyDetails = await prisma.surveyDetails.delete({
     *   where: {
     *     // ... filter to delete one SurveyDetails
     *   }
     * })
     * 
     */
    delete<T extends SurveyDetailsDeleteArgs>(args: SelectSubset<T, SurveyDetailsDeleteArgs<ExtArgs>>): Prisma__SurveyDetailsClient<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SurveyDetails.
     * @param {SurveyDetailsUpdateArgs} args - Arguments to update one SurveyDetails.
     * @example
     * // Update one SurveyDetails
     * const surveyDetails = await prisma.surveyDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyDetailsUpdateArgs>(args: SelectSubset<T, SurveyDetailsUpdateArgs<ExtArgs>>): Prisma__SurveyDetailsClient<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SurveyDetails.
     * @param {SurveyDetailsDeleteManyArgs} args - Arguments to filter SurveyDetails to delete.
     * @example
     * // Delete a few SurveyDetails
     * const { count } = await prisma.surveyDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyDetailsDeleteManyArgs>(args?: SelectSubset<T, SurveyDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyDetails
     * const surveyDetails = await prisma.surveyDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyDetailsUpdateManyArgs>(args: SelectSubset<T, SurveyDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SurveyDetails.
     * @param {SurveyDetailsUpsertArgs} args - Arguments to update or create a SurveyDetails.
     * @example
     * // Update or create a SurveyDetails
     * const surveyDetails = await prisma.surveyDetails.upsert({
     *   create: {
     *     // ... data to create a SurveyDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyDetails we want to update
     *   }
     * })
     */
    upsert<T extends SurveyDetailsUpsertArgs>(args: SelectSubset<T, SurveyDetailsUpsertArgs<ExtArgs>>): Prisma__SurveyDetailsClient<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SurveyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyDetailsCountArgs} args - Arguments to filter SurveyDetails to count.
     * @example
     * // Count the number of SurveyDetails
     * const count = await prisma.surveyDetails.count({
     *   where: {
     *     // ... the filter for the SurveyDetails we want to count
     *   }
     * })
    **/
    count<T extends SurveyDetailsCountArgs>(
      args?: Subset<T, SurveyDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyDetailsAggregateArgs>(args: Subset<T, SurveyDetailsAggregateArgs>): Prisma.PrismaPromise<GetSurveyDetailsAggregateType<T>>

    /**
     * Group by SurveyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyDetailsGroupByArgs['orderBy'] }
        : { orderBy?: SurveyDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurveyDetails model
   */
  readonly fields: SurveyDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ulb<T extends UlbMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UlbMasterDefaultArgs<ExtArgs>>): Prisma__UlbMasterClient<$Result.GetResult<Prisma.$UlbMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    zone<T extends ZoneMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneMasterDefaultArgs<ExtArgs>>): Prisma__ZoneMasterClient<$Result.GetResult<Prisma.$ZoneMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ward<T extends WardMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WardMasterDefaultArgs<ExtArgs>>): Prisma__WardMasterClient<$Result.GetResult<Prisma.$WardMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mohalla<T extends MohallaMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MohallaMasterDefaultArgs<ExtArgs>>): Prisma__MohallaMasterClient<$Result.GetResult<Prisma.$MohallaMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    surveyType<T extends SurveyTypeMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyTypeMasterDefaultArgs<ExtArgs>>): Prisma__SurveyTypeMasterClient<$Result.GetResult<Prisma.$SurveyTypeMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    propertyDetails<T extends SurveyDetails$propertyDetailsArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDetails$propertyDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    ownerDetails<T extends SurveyDetails$ownerDetailsArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDetails$ownerDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    locationDetails<T extends SurveyDetails$locationDetailsArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDetails$locationDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    otherDetails<T extends SurveyDetails$otherDetailsArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDetails$otherDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    residentialPropertyAssessments<T extends SurveyDetails$residentialPropertyAssessmentsArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDetails$residentialPropertyAssessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResidentialPropertyAssessmentPayload<ExtArgs>, T, "findMany"> | Null>
    nonResidentialPropertyAssessments<T extends SurveyDetails$nonResidentialPropertyAssessmentsArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDetails$nonResidentialPropertyAssessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>, T, "findMany"> | Null>
    propertyAttachments<T extends SurveyDetails$propertyAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDetails$propertyAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAttachmentDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    surveyStatusMaps<T extends SurveyDetails$surveyStatusMapsArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDetails$surveyStatusMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyStatusMappingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurveyDetails model
   */ 
  interface SurveyDetailsFieldRefs {
    readonly surveyUniqueCode: FieldRef<"SurveyDetails", 'String'>
    readonly ulbId: FieldRef<"SurveyDetails", 'String'>
    readonly zoneId: FieldRef<"SurveyDetails", 'String'>
    readonly wardId: FieldRef<"SurveyDetails", 'String'>
    readonly mohallaId: FieldRef<"SurveyDetails", 'String'>
    readonly surveyTypeId: FieldRef<"SurveyDetails", 'String'>
    readonly entryDate: FieldRef<"SurveyDetails", 'DateTime'>
    readonly parcelId: FieldRef<"SurveyDetails", 'Int'>
    readonly mapId: FieldRef<"SurveyDetails", 'Int'>
    readonly gisId: FieldRef<"SurveyDetails", 'String'>
    readonly subGisId: FieldRef<"SurveyDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SurveyDetails findUnique
   */
  export type SurveyDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyDetails
     */
    select?: SurveyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SurveyDetails to fetch.
     */
    where: SurveyDetailsWhereUniqueInput
  }

  /**
   * SurveyDetails findUniqueOrThrow
   */
  export type SurveyDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyDetails
     */
    select?: SurveyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SurveyDetails to fetch.
     */
    where: SurveyDetailsWhereUniqueInput
  }

  /**
   * SurveyDetails findFirst
   */
  export type SurveyDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyDetails
     */
    select?: SurveyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SurveyDetails to fetch.
     */
    where?: SurveyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyDetails to fetch.
     */
    orderBy?: SurveyDetailsOrderByWithRelationInput | SurveyDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyDetails.
     */
    cursor?: SurveyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyDetails.
     */
    distinct?: SurveyDetailsScalarFieldEnum | SurveyDetailsScalarFieldEnum[]
  }

  /**
   * SurveyDetails findFirstOrThrow
   */
  export type SurveyDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyDetails
     */
    select?: SurveyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SurveyDetails to fetch.
     */
    where?: SurveyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyDetails to fetch.
     */
    orderBy?: SurveyDetailsOrderByWithRelationInput | SurveyDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyDetails.
     */
    cursor?: SurveyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyDetails.
     */
    distinct?: SurveyDetailsScalarFieldEnum | SurveyDetailsScalarFieldEnum[]
  }

  /**
   * SurveyDetails findMany
   */
  export type SurveyDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyDetails
     */
    select?: SurveyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SurveyDetails to fetch.
     */
    where?: SurveyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyDetails to fetch.
     */
    orderBy?: SurveyDetailsOrderByWithRelationInput | SurveyDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyDetails.
     */
    cursor?: SurveyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyDetails.
     */
    skip?: number
    distinct?: SurveyDetailsScalarFieldEnum | SurveyDetailsScalarFieldEnum[]
  }

  /**
   * SurveyDetails create
   */
  export type SurveyDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyDetails
     */
    select?: SurveyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a SurveyDetails.
     */
    data: XOR<SurveyDetailsCreateInput, SurveyDetailsUncheckedCreateInput>
  }

  /**
   * SurveyDetails createMany
   */
  export type SurveyDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurveyDetails.
     */
    data: SurveyDetailsCreateManyInput | SurveyDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurveyDetails createManyAndReturn
   */
  export type SurveyDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyDetails
     */
    select?: SurveyDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SurveyDetails.
     */
    data: SurveyDetailsCreateManyInput | SurveyDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurveyDetails update
   */
  export type SurveyDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyDetails
     */
    select?: SurveyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a SurveyDetails.
     */
    data: XOR<SurveyDetailsUpdateInput, SurveyDetailsUncheckedUpdateInput>
    /**
     * Choose, which SurveyDetails to update.
     */
    where: SurveyDetailsWhereUniqueInput
  }

  /**
   * SurveyDetails updateMany
   */
  export type SurveyDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurveyDetails.
     */
    data: XOR<SurveyDetailsUpdateManyMutationInput, SurveyDetailsUncheckedUpdateManyInput>
    /**
     * Filter which SurveyDetails to update
     */
    where?: SurveyDetailsWhereInput
  }

  /**
   * SurveyDetails upsert
   */
  export type SurveyDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyDetails
     */
    select?: SurveyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the SurveyDetails to update in case it exists.
     */
    where: SurveyDetailsWhereUniqueInput
    /**
     * In case the SurveyDetails found by the `where` argument doesn't exist, create a new SurveyDetails with this data.
     */
    create: XOR<SurveyDetailsCreateInput, SurveyDetailsUncheckedCreateInput>
    /**
     * In case the SurveyDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyDetailsUpdateInput, SurveyDetailsUncheckedUpdateInput>
  }

  /**
   * SurveyDetails delete
   */
  export type SurveyDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyDetails
     */
    select?: SurveyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyDetailsInclude<ExtArgs> | null
    /**
     * Filter which SurveyDetails to delete.
     */
    where: SurveyDetailsWhereUniqueInput
  }

  /**
   * SurveyDetails deleteMany
   */
  export type SurveyDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyDetails to delete
     */
    where?: SurveyDetailsWhereInput
  }

  /**
   * SurveyDetails.propertyDetails
   */
  export type SurveyDetails$propertyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    where?: PropertyDetailsWhereInput
    orderBy?: PropertyDetailsOrderByWithRelationInput | PropertyDetailsOrderByWithRelationInput[]
    cursor?: PropertyDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyDetailsScalarFieldEnum | PropertyDetailsScalarFieldEnum[]
  }

  /**
   * SurveyDetails.ownerDetails
   */
  export type SurveyDetails$ownerDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    where?: OwnerDetailsWhereInput
    orderBy?: OwnerDetailsOrderByWithRelationInput | OwnerDetailsOrderByWithRelationInput[]
    cursor?: OwnerDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnerDetailsScalarFieldEnum | OwnerDetailsScalarFieldEnum[]
  }

  /**
   * SurveyDetails.locationDetails
   */
  export type SurveyDetails$locationDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    where?: LocationDetailsWhereInput
    orderBy?: LocationDetailsOrderByWithRelationInput | LocationDetailsOrderByWithRelationInput[]
    cursor?: LocationDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationDetailsScalarFieldEnum | LocationDetailsScalarFieldEnum[]
  }

  /**
   * SurveyDetails.otherDetails
   */
  export type SurveyDetails$otherDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    where?: OtherDetailsWhereInput
    orderBy?: OtherDetailsOrderByWithRelationInput | OtherDetailsOrderByWithRelationInput[]
    cursor?: OtherDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtherDetailsScalarFieldEnum | OtherDetailsScalarFieldEnum[]
  }

  /**
   * SurveyDetails.residentialPropertyAssessments
   */
  export type SurveyDetails$residentialPropertyAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidentialPropertyAssessment
     */
    select?: ResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentialPropertyAssessmentInclude<ExtArgs> | null
    where?: ResidentialPropertyAssessmentWhereInput
    orderBy?: ResidentialPropertyAssessmentOrderByWithRelationInput | ResidentialPropertyAssessmentOrderByWithRelationInput[]
    cursor?: ResidentialPropertyAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResidentialPropertyAssessmentScalarFieldEnum | ResidentialPropertyAssessmentScalarFieldEnum[]
  }

  /**
   * SurveyDetails.nonResidentialPropertyAssessments
   */
  export type SurveyDetails$nonResidentialPropertyAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonResidentialPropertyAssessment
     */
    select?: NonResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonResidentialPropertyAssessmentInclude<ExtArgs> | null
    where?: NonResidentialPropertyAssessmentWhereInput
    orderBy?: NonResidentialPropertyAssessmentOrderByWithRelationInput | NonResidentialPropertyAssessmentOrderByWithRelationInput[]
    cursor?: NonResidentialPropertyAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NonResidentialPropertyAssessmentScalarFieldEnum | NonResidentialPropertyAssessmentScalarFieldEnum[]
  }

  /**
   * SurveyDetails.propertyAttachments
   */
  export type SurveyDetails$propertyAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachmentDetails
     */
    select?: PropertyAttachmentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentDetailsInclude<ExtArgs> | null
    where?: PropertyAttachmentDetailsWhereInput
    orderBy?: PropertyAttachmentDetailsOrderByWithRelationInput | PropertyAttachmentDetailsOrderByWithRelationInput[]
    cursor?: PropertyAttachmentDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyAttachmentDetailsScalarFieldEnum | PropertyAttachmentDetailsScalarFieldEnum[]
  }

  /**
   * SurveyDetails.surveyStatusMaps
   */
  export type SurveyDetails$surveyStatusMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyStatusMapping
     */
    select?: SurveyStatusMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyStatusMappingInclude<ExtArgs> | null
    where?: SurveyStatusMappingWhereInput
    orderBy?: SurveyStatusMappingOrderByWithRelationInput | SurveyStatusMappingOrderByWithRelationInput[]
    cursor?: SurveyStatusMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyStatusMappingScalarFieldEnum | SurveyStatusMappingScalarFieldEnum[]
  }

  /**
   * SurveyDetails without action
   */
  export type SurveyDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyDetails
     */
    select?: SurveyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyDetailsInclude<ExtArgs> | null
  }


  /**
   * Model PropertyDetails
   */

  export type AggregatePropertyDetails = {
    _count: PropertyDetailsCountAggregateOutputType | null
    _min: PropertyDetailsMinAggregateOutputType | null
    _max: PropertyDetailsMaxAggregateOutputType | null
  }

  export type PropertyDetailsMinAggregateOutputType = {
    surveyUniqueCode: string | null
    responseTypeId: string | null
    oldHouseNumber: string | null
    electricityConsumerName: string | null
    waterSewerageConnectionNumber: string | null
    respondentName: string | null
    respondentStatusId: string | null
  }

  export type PropertyDetailsMaxAggregateOutputType = {
    surveyUniqueCode: string | null
    responseTypeId: string | null
    oldHouseNumber: string | null
    electricityConsumerName: string | null
    waterSewerageConnectionNumber: string | null
    respondentName: string | null
    respondentStatusId: string | null
  }

  export type PropertyDetailsCountAggregateOutputType = {
    surveyUniqueCode: number
    responseTypeId: number
    oldHouseNumber: number
    electricityConsumerName: number
    waterSewerageConnectionNumber: number
    respondentName: number
    respondentStatusId: number
    _all: number
  }


  export type PropertyDetailsMinAggregateInputType = {
    surveyUniqueCode?: true
    responseTypeId?: true
    oldHouseNumber?: true
    electricityConsumerName?: true
    waterSewerageConnectionNumber?: true
    respondentName?: true
    respondentStatusId?: true
  }

  export type PropertyDetailsMaxAggregateInputType = {
    surveyUniqueCode?: true
    responseTypeId?: true
    oldHouseNumber?: true
    electricityConsumerName?: true
    waterSewerageConnectionNumber?: true
    respondentName?: true
    respondentStatusId?: true
  }

  export type PropertyDetailsCountAggregateInputType = {
    surveyUniqueCode?: true
    responseTypeId?: true
    oldHouseNumber?: true
    electricityConsumerName?: true
    waterSewerageConnectionNumber?: true
    respondentName?: true
    respondentStatusId?: true
    _all?: true
  }

  export type PropertyDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyDetails to aggregate.
     */
    where?: PropertyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyDetails to fetch.
     */
    orderBy?: PropertyDetailsOrderByWithRelationInput | PropertyDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyDetails
    **/
    _count?: true | PropertyDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyDetailsMaxAggregateInputType
  }

  export type GetPropertyDetailsAggregateType<T extends PropertyDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyDetails[P]>
      : GetScalarType<T[P], AggregatePropertyDetails[P]>
  }




  export type PropertyDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyDetailsWhereInput
    orderBy?: PropertyDetailsOrderByWithAggregationInput | PropertyDetailsOrderByWithAggregationInput[]
    by: PropertyDetailsScalarFieldEnum[] | PropertyDetailsScalarFieldEnum
    having?: PropertyDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyDetailsCountAggregateInputType | true
    _min?: PropertyDetailsMinAggregateInputType
    _max?: PropertyDetailsMaxAggregateInputType
  }

  export type PropertyDetailsGroupByOutputType = {
    surveyUniqueCode: string
    responseTypeId: string
    oldHouseNumber: string | null
    electricityConsumerName: string | null
    waterSewerageConnectionNumber: string | null
    respondentName: string
    respondentStatusId: string
    _count: PropertyDetailsCountAggregateOutputType | null
    _min: PropertyDetailsMinAggregateOutputType | null
    _max: PropertyDetailsMaxAggregateOutputType | null
  }

  type GetPropertyDetailsGroupByPayload<T extends PropertyDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyDetailsGroupByOutputType[P]>
        }
      >
    >


  export type PropertyDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surveyUniqueCode?: boolean
    responseTypeId?: boolean
    oldHouseNumber?: boolean
    electricityConsumerName?: boolean
    waterSewerageConnectionNumber?: boolean
    respondentName?: boolean
    respondentStatusId?: boolean
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    responseType?: boolean | ResponseTypeMasterDefaultArgs<ExtArgs>
    respondentStatus?: boolean | RespondentStatusMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyDetails"]>

  export type PropertyDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surveyUniqueCode?: boolean
    responseTypeId?: boolean
    oldHouseNumber?: boolean
    electricityConsumerName?: boolean
    waterSewerageConnectionNumber?: boolean
    respondentName?: boolean
    respondentStatusId?: boolean
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    responseType?: boolean | ResponseTypeMasterDefaultArgs<ExtArgs>
    respondentStatus?: boolean | RespondentStatusMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyDetails"]>

  export type PropertyDetailsSelectScalar = {
    surveyUniqueCode?: boolean
    responseTypeId?: boolean
    oldHouseNumber?: boolean
    electricityConsumerName?: boolean
    waterSewerageConnectionNumber?: boolean
    respondentName?: boolean
    respondentStatusId?: boolean
  }

  export type PropertyDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    responseType?: boolean | ResponseTypeMasterDefaultArgs<ExtArgs>
    respondentStatus?: boolean | RespondentStatusMasterDefaultArgs<ExtArgs>
  }
  export type PropertyDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    responseType?: boolean | ResponseTypeMasterDefaultArgs<ExtArgs>
    respondentStatus?: boolean | RespondentStatusMasterDefaultArgs<ExtArgs>
  }

  export type $PropertyDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyDetails"
    objects: {
      survey: Prisma.$SurveyDetailsPayload<ExtArgs>
      responseType: Prisma.$ResponseTypeMasterPayload<ExtArgs>
      respondentStatus: Prisma.$RespondentStatusMasterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      surveyUniqueCode: string
      responseTypeId: string
      oldHouseNumber: string | null
      electricityConsumerName: string | null
      waterSewerageConnectionNumber: string | null
      respondentName: string
      respondentStatusId: string
    }, ExtArgs["result"]["propertyDetails"]>
    composites: {}
  }

  type PropertyDetailsGetPayload<S extends boolean | null | undefined | PropertyDetailsDefaultArgs> = $Result.GetResult<Prisma.$PropertyDetailsPayload, S>

  type PropertyDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PropertyDetailsCountAggregateInputType | true
    }

  export interface PropertyDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyDetails'], meta: { name: 'PropertyDetails' } }
    /**
     * Find zero or one PropertyDetails that matches the filter.
     * @param {PropertyDetailsFindUniqueArgs} args - Arguments to find a PropertyDetails
     * @example
     * // Get one PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyDetailsFindUniqueArgs>(args: SelectSubset<T, PropertyDetailsFindUniqueArgs<ExtArgs>>): Prisma__PropertyDetailsClient<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PropertyDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PropertyDetailsFindUniqueOrThrowArgs} args - Arguments to find a PropertyDetails
     * @example
     * // Get one PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyDetailsClient<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PropertyDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDetailsFindFirstArgs} args - Arguments to find a PropertyDetails
     * @example
     * // Get one PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyDetailsFindFirstArgs>(args?: SelectSubset<T, PropertyDetailsFindFirstArgs<ExtArgs>>): Prisma__PropertyDetailsClient<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PropertyDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDetailsFindFirstOrThrowArgs} args - Arguments to find a PropertyDetails
     * @example
     * // Get one PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyDetailsClient<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PropertyDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.findMany()
     * 
     * // Get first 10 PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.findMany({ take: 10 })
     * 
     * // Only select the `surveyUniqueCode`
     * const propertyDetailsWithSurveyUniqueCodeOnly = await prisma.propertyDetails.findMany({ select: { surveyUniqueCode: true } })
     * 
     */
    findMany<T extends PropertyDetailsFindManyArgs>(args?: SelectSubset<T, PropertyDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PropertyDetails.
     * @param {PropertyDetailsCreateArgs} args - Arguments to create a PropertyDetails.
     * @example
     * // Create one PropertyDetails
     * const PropertyDetails = await prisma.propertyDetails.create({
     *   data: {
     *     // ... data to create a PropertyDetails
     *   }
     * })
     * 
     */
    create<T extends PropertyDetailsCreateArgs>(args: SelectSubset<T, PropertyDetailsCreateArgs<ExtArgs>>): Prisma__PropertyDetailsClient<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PropertyDetails.
     * @param {PropertyDetailsCreateManyArgs} args - Arguments to create many PropertyDetails.
     * @example
     * // Create many PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyDetailsCreateManyArgs>(args?: SelectSubset<T, PropertyDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyDetails and returns the data saved in the database.
     * @param {PropertyDetailsCreateManyAndReturnArgs} args - Arguments to create many PropertyDetails.
     * @example
     * // Create many PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyDetails and only return the `surveyUniqueCode`
     * const propertyDetailsWithSurveyUniqueCodeOnly = await prisma.propertyDetails.createManyAndReturn({ 
     *   select: { surveyUniqueCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PropertyDetails.
     * @param {PropertyDetailsDeleteArgs} args - Arguments to delete one PropertyDetails.
     * @example
     * // Delete one PropertyDetails
     * const PropertyDetails = await prisma.propertyDetails.delete({
     *   where: {
     *     // ... filter to delete one PropertyDetails
     *   }
     * })
     * 
     */
    delete<T extends PropertyDetailsDeleteArgs>(args: SelectSubset<T, PropertyDetailsDeleteArgs<ExtArgs>>): Prisma__PropertyDetailsClient<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PropertyDetails.
     * @param {PropertyDetailsUpdateArgs} args - Arguments to update one PropertyDetails.
     * @example
     * // Update one PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyDetailsUpdateArgs>(args: SelectSubset<T, PropertyDetailsUpdateArgs<ExtArgs>>): Prisma__PropertyDetailsClient<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PropertyDetails.
     * @param {PropertyDetailsDeleteManyArgs} args - Arguments to filter PropertyDetails to delete.
     * @example
     * // Delete a few PropertyDetails
     * const { count } = await prisma.propertyDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDetailsDeleteManyArgs>(args?: SelectSubset<T, PropertyDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyDetailsUpdateManyArgs>(args: SelectSubset<T, PropertyDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyDetails.
     * @param {PropertyDetailsUpsertArgs} args - Arguments to update or create a PropertyDetails.
     * @example
     * // Update or create a PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.upsert({
     *   create: {
     *     // ... data to create a PropertyDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyDetails we want to update
     *   }
     * })
     */
    upsert<T extends PropertyDetailsUpsertArgs>(args: SelectSubset<T, PropertyDetailsUpsertArgs<ExtArgs>>): Prisma__PropertyDetailsClient<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PropertyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDetailsCountArgs} args - Arguments to filter PropertyDetails to count.
     * @example
     * // Count the number of PropertyDetails
     * const count = await prisma.propertyDetails.count({
     *   where: {
     *     // ... the filter for the PropertyDetails we want to count
     *   }
     * })
    **/
    count<T extends PropertyDetailsCountArgs>(
      args?: Subset<T, PropertyDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyDetailsAggregateArgs>(args: Subset<T, PropertyDetailsAggregateArgs>): Prisma.PrismaPromise<GetPropertyDetailsAggregateType<T>>

    /**
     * Group by PropertyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyDetailsGroupByArgs['orderBy'] }
        : { orderBy?: PropertyDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyDetails model
   */
  readonly fields: PropertyDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDetailsDefaultArgs<ExtArgs>>): Prisma__SurveyDetailsClient<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    responseType<T extends ResponseTypeMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResponseTypeMasterDefaultArgs<ExtArgs>>): Prisma__ResponseTypeMasterClient<$Result.GetResult<Prisma.$ResponseTypeMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    respondentStatus<T extends RespondentStatusMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RespondentStatusMasterDefaultArgs<ExtArgs>>): Prisma__RespondentStatusMasterClient<$Result.GetResult<Prisma.$RespondentStatusMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyDetails model
   */ 
  interface PropertyDetailsFieldRefs {
    readonly surveyUniqueCode: FieldRef<"PropertyDetails", 'String'>
    readonly responseTypeId: FieldRef<"PropertyDetails", 'String'>
    readonly oldHouseNumber: FieldRef<"PropertyDetails", 'String'>
    readonly electricityConsumerName: FieldRef<"PropertyDetails", 'String'>
    readonly waterSewerageConnectionNumber: FieldRef<"PropertyDetails", 'String'>
    readonly respondentName: FieldRef<"PropertyDetails", 'String'>
    readonly respondentStatusId: FieldRef<"PropertyDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PropertyDetails findUnique
   */
  export type PropertyDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyDetails to fetch.
     */
    where: PropertyDetailsWhereUniqueInput
  }

  /**
   * PropertyDetails findUniqueOrThrow
   */
  export type PropertyDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyDetails to fetch.
     */
    where: PropertyDetailsWhereUniqueInput
  }

  /**
   * PropertyDetails findFirst
   */
  export type PropertyDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyDetails to fetch.
     */
    where?: PropertyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyDetails to fetch.
     */
    orderBy?: PropertyDetailsOrderByWithRelationInput | PropertyDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyDetails.
     */
    cursor?: PropertyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyDetails.
     */
    distinct?: PropertyDetailsScalarFieldEnum | PropertyDetailsScalarFieldEnum[]
  }

  /**
   * PropertyDetails findFirstOrThrow
   */
  export type PropertyDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyDetails to fetch.
     */
    where?: PropertyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyDetails to fetch.
     */
    orderBy?: PropertyDetailsOrderByWithRelationInput | PropertyDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyDetails.
     */
    cursor?: PropertyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyDetails.
     */
    distinct?: PropertyDetailsScalarFieldEnum | PropertyDetailsScalarFieldEnum[]
  }

  /**
   * PropertyDetails findMany
   */
  export type PropertyDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyDetails to fetch.
     */
    where?: PropertyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyDetails to fetch.
     */
    orderBy?: PropertyDetailsOrderByWithRelationInput | PropertyDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyDetails.
     */
    cursor?: PropertyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyDetails.
     */
    skip?: number
    distinct?: PropertyDetailsScalarFieldEnum | PropertyDetailsScalarFieldEnum[]
  }

  /**
   * PropertyDetails create
   */
  export type PropertyDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyDetails.
     */
    data: XOR<PropertyDetailsCreateInput, PropertyDetailsUncheckedCreateInput>
  }

  /**
   * PropertyDetails createMany
   */
  export type PropertyDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyDetails.
     */
    data: PropertyDetailsCreateManyInput | PropertyDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyDetails createManyAndReturn
   */
  export type PropertyDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PropertyDetails.
     */
    data: PropertyDetailsCreateManyInput | PropertyDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyDetails update
   */
  export type PropertyDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyDetails.
     */
    data: XOR<PropertyDetailsUpdateInput, PropertyDetailsUncheckedUpdateInput>
    /**
     * Choose, which PropertyDetails to update.
     */
    where: PropertyDetailsWhereUniqueInput
  }

  /**
   * PropertyDetails updateMany
   */
  export type PropertyDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyDetails.
     */
    data: XOR<PropertyDetailsUpdateManyMutationInput, PropertyDetailsUncheckedUpdateManyInput>
    /**
     * Filter which PropertyDetails to update
     */
    where?: PropertyDetailsWhereInput
  }

  /**
   * PropertyDetails upsert
   */
  export type PropertyDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyDetails to update in case it exists.
     */
    where: PropertyDetailsWhereUniqueInput
    /**
     * In case the PropertyDetails found by the `where` argument doesn't exist, create a new PropertyDetails with this data.
     */
    create: XOR<PropertyDetailsCreateInput, PropertyDetailsUncheckedCreateInput>
    /**
     * In case the PropertyDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyDetailsUpdateInput, PropertyDetailsUncheckedUpdateInput>
  }

  /**
   * PropertyDetails delete
   */
  export type PropertyDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * Filter which PropertyDetails to delete.
     */
    where: PropertyDetailsWhereUniqueInput
  }

  /**
   * PropertyDetails deleteMany
   */
  export type PropertyDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyDetails to delete
     */
    where?: PropertyDetailsWhereInput
  }

  /**
   * PropertyDetails without action
   */
  export type PropertyDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
  }


  /**
   * Model OwnerDetails
   */

  export type AggregateOwnerDetails = {
    _count: OwnerDetailsCountAggregateOutputType | null
    _min: OwnerDetailsMinAggregateOutputType | null
    _max: OwnerDetailsMaxAggregateOutputType | null
  }

  export type OwnerDetailsMinAggregateOutputType = {
    surveyUniqueCode: string | null
    ownerName: string | null
    fatherHusbandName: string | null
    mobileNumber: string | null
    aadharNumber: string | null
  }

  export type OwnerDetailsMaxAggregateOutputType = {
    surveyUniqueCode: string | null
    ownerName: string | null
    fatherHusbandName: string | null
    mobileNumber: string | null
    aadharNumber: string | null
  }

  export type OwnerDetailsCountAggregateOutputType = {
    surveyUniqueCode: number
    ownerName: number
    fatherHusbandName: number
    mobileNumber: number
    aadharNumber: number
    _all: number
  }


  export type OwnerDetailsMinAggregateInputType = {
    surveyUniqueCode?: true
    ownerName?: true
    fatherHusbandName?: true
    mobileNumber?: true
    aadharNumber?: true
  }

  export type OwnerDetailsMaxAggregateInputType = {
    surveyUniqueCode?: true
    ownerName?: true
    fatherHusbandName?: true
    mobileNumber?: true
    aadharNumber?: true
  }

  export type OwnerDetailsCountAggregateInputType = {
    surveyUniqueCode?: true
    ownerName?: true
    fatherHusbandName?: true
    mobileNumber?: true
    aadharNumber?: true
    _all?: true
  }

  export type OwnerDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerDetails to aggregate.
     */
    where?: OwnerDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerDetails to fetch.
     */
    orderBy?: OwnerDetailsOrderByWithRelationInput | OwnerDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnerDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OwnerDetails
    **/
    _count?: true | OwnerDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnerDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnerDetailsMaxAggregateInputType
  }

  export type GetOwnerDetailsAggregateType<T extends OwnerDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateOwnerDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwnerDetails[P]>
      : GetScalarType<T[P], AggregateOwnerDetails[P]>
  }




  export type OwnerDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerDetailsWhereInput
    orderBy?: OwnerDetailsOrderByWithAggregationInput | OwnerDetailsOrderByWithAggregationInput[]
    by: OwnerDetailsScalarFieldEnum[] | OwnerDetailsScalarFieldEnum
    having?: OwnerDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnerDetailsCountAggregateInputType | true
    _min?: OwnerDetailsMinAggregateInputType
    _max?: OwnerDetailsMaxAggregateInputType
  }

  export type OwnerDetailsGroupByOutputType = {
    surveyUniqueCode: string
    ownerName: string
    fatherHusbandName: string
    mobileNumber: string | null
    aadharNumber: string | null
    _count: OwnerDetailsCountAggregateOutputType | null
    _min: OwnerDetailsMinAggregateOutputType | null
    _max: OwnerDetailsMaxAggregateOutputType | null
  }

  type GetOwnerDetailsGroupByPayload<T extends OwnerDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnerDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnerDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnerDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], OwnerDetailsGroupByOutputType[P]>
        }
      >
    >


  export type OwnerDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surveyUniqueCode?: boolean
    ownerName?: boolean
    fatherHusbandName?: boolean
    mobileNumber?: boolean
    aadharNumber?: boolean
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerDetails"]>

  export type OwnerDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surveyUniqueCode?: boolean
    ownerName?: boolean
    fatherHusbandName?: boolean
    mobileNumber?: boolean
    aadharNumber?: boolean
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerDetails"]>

  export type OwnerDetailsSelectScalar = {
    surveyUniqueCode?: boolean
    ownerName?: boolean
    fatherHusbandName?: boolean
    mobileNumber?: boolean
    aadharNumber?: boolean
  }

  export type OwnerDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
  }
  export type OwnerDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
  }

  export type $OwnerDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OwnerDetails"
    objects: {
      survey: Prisma.$SurveyDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      surveyUniqueCode: string
      ownerName: string
      fatherHusbandName: string
      mobileNumber: string | null
      aadharNumber: string | null
    }, ExtArgs["result"]["ownerDetails"]>
    composites: {}
  }

  type OwnerDetailsGetPayload<S extends boolean | null | undefined | OwnerDetailsDefaultArgs> = $Result.GetResult<Prisma.$OwnerDetailsPayload, S>

  type OwnerDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OwnerDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OwnerDetailsCountAggregateInputType | true
    }

  export interface OwnerDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OwnerDetails'], meta: { name: 'OwnerDetails' } }
    /**
     * Find zero or one OwnerDetails that matches the filter.
     * @param {OwnerDetailsFindUniqueArgs} args - Arguments to find a OwnerDetails
     * @example
     * // Get one OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OwnerDetailsFindUniqueArgs>(args: SelectSubset<T, OwnerDetailsFindUniqueArgs<ExtArgs>>): Prisma__OwnerDetailsClient<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OwnerDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OwnerDetailsFindUniqueOrThrowArgs} args - Arguments to find a OwnerDetails
     * @example
     * // Get one OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OwnerDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, OwnerDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OwnerDetailsClient<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OwnerDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDetailsFindFirstArgs} args - Arguments to find a OwnerDetails
     * @example
     * // Get one OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OwnerDetailsFindFirstArgs>(args?: SelectSubset<T, OwnerDetailsFindFirstArgs<ExtArgs>>): Prisma__OwnerDetailsClient<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OwnerDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDetailsFindFirstOrThrowArgs} args - Arguments to find a OwnerDetails
     * @example
     * // Get one OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OwnerDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, OwnerDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__OwnerDetailsClient<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OwnerDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.findMany()
     * 
     * // Get first 10 OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.findMany({ take: 10 })
     * 
     * // Only select the `surveyUniqueCode`
     * const ownerDetailsWithSurveyUniqueCodeOnly = await prisma.ownerDetails.findMany({ select: { surveyUniqueCode: true } })
     * 
     */
    findMany<T extends OwnerDetailsFindManyArgs>(args?: SelectSubset<T, OwnerDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OwnerDetails.
     * @param {OwnerDetailsCreateArgs} args - Arguments to create a OwnerDetails.
     * @example
     * // Create one OwnerDetails
     * const OwnerDetails = await prisma.ownerDetails.create({
     *   data: {
     *     // ... data to create a OwnerDetails
     *   }
     * })
     * 
     */
    create<T extends OwnerDetailsCreateArgs>(args: SelectSubset<T, OwnerDetailsCreateArgs<ExtArgs>>): Prisma__OwnerDetailsClient<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OwnerDetails.
     * @param {OwnerDetailsCreateManyArgs} args - Arguments to create many OwnerDetails.
     * @example
     * // Create many OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OwnerDetailsCreateManyArgs>(args?: SelectSubset<T, OwnerDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OwnerDetails and returns the data saved in the database.
     * @param {OwnerDetailsCreateManyAndReturnArgs} args - Arguments to create many OwnerDetails.
     * @example
     * // Create many OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OwnerDetails and only return the `surveyUniqueCode`
     * const ownerDetailsWithSurveyUniqueCodeOnly = await prisma.ownerDetails.createManyAndReturn({ 
     *   select: { surveyUniqueCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OwnerDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, OwnerDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OwnerDetails.
     * @param {OwnerDetailsDeleteArgs} args - Arguments to delete one OwnerDetails.
     * @example
     * // Delete one OwnerDetails
     * const OwnerDetails = await prisma.ownerDetails.delete({
     *   where: {
     *     // ... filter to delete one OwnerDetails
     *   }
     * })
     * 
     */
    delete<T extends OwnerDetailsDeleteArgs>(args: SelectSubset<T, OwnerDetailsDeleteArgs<ExtArgs>>): Prisma__OwnerDetailsClient<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OwnerDetails.
     * @param {OwnerDetailsUpdateArgs} args - Arguments to update one OwnerDetails.
     * @example
     * // Update one OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OwnerDetailsUpdateArgs>(args: SelectSubset<T, OwnerDetailsUpdateArgs<ExtArgs>>): Prisma__OwnerDetailsClient<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OwnerDetails.
     * @param {OwnerDetailsDeleteManyArgs} args - Arguments to filter OwnerDetails to delete.
     * @example
     * // Delete a few OwnerDetails
     * const { count } = await prisma.ownerDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OwnerDetailsDeleteManyArgs>(args?: SelectSubset<T, OwnerDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnerDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OwnerDetailsUpdateManyArgs>(args: SelectSubset<T, OwnerDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OwnerDetails.
     * @param {OwnerDetailsUpsertArgs} args - Arguments to update or create a OwnerDetails.
     * @example
     * // Update or create a OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.upsert({
     *   create: {
     *     // ... data to create a OwnerDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OwnerDetails we want to update
     *   }
     * })
     */
    upsert<T extends OwnerDetailsUpsertArgs>(args: SelectSubset<T, OwnerDetailsUpsertArgs<ExtArgs>>): Prisma__OwnerDetailsClient<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OwnerDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDetailsCountArgs} args - Arguments to filter OwnerDetails to count.
     * @example
     * // Count the number of OwnerDetails
     * const count = await prisma.ownerDetails.count({
     *   where: {
     *     // ... the filter for the OwnerDetails we want to count
     *   }
     * })
    **/
    count<T extends OwnerDetailsCountArgs>(
      args?: Subset<T, OwnerDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnerDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OwnerDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnerDetailsAggregateArgs>(args: Subset<T, OwnerDetailsAggregateArgs>): Prisma.PrismaPromise<GetOwnerDetailsAggregateType<T>>

    /**
     * Group by OwnerDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnerDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnerDetailsGroupByArgs['orderBy'] }
        : { orderBy?: OwnerDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnerDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnerDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OwnerDetails model
   */
  readonly fields: OwnerDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OwnerDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnerDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDetailsDefaultArgs<ExtArgs>>): Prisma__SurveyDetailsClient<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OwnerDetails model
   */ 
  interface OwnerDetailsFieldRefs {
    readonly surveyUniqueCode: FieldRef<"OwnerDetails", 'String'>
    readonly ownerName: FieldRef<"OwnerDetails", 'String'>
    readonly fatherHusbandName: FieldRef<"OwnerDetails", 'String'>
    readonly mobileNumber: FieldRef<"OwnerDetails", 'String'>
    readonly aadharNumber: FieldRef<"OwnerDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OwnerDetails findUnique
   */
  export type OwnerDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDetails to fetch.
     */
    where: OwnerDetailsWhereUniqueInput
  }

  /**
   * OwnerDetails findUniqueOrThrow
   */
  export type OwnerDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDetails to fetch.
     */
    where: OwnerDetailsWhereUniqueInput
  }

  /**
   * OwnerDetails findFirst
   */
  export type OwnerDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDetails to fetch.
     */
    where?: OwnerDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerDetails to fetch.
     */
    orderBy?: OwnerDetailsOrderByWithRelationInput | OwnerDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerDetails.
     */
    cursor?: OwnerDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerDetails.
     */
    distinct?: OwnerDetailsScalarFieldEnum | OwnerDetailsScalarFieldEnum[]
  }

  /**
   * OwnerDetails findFirstOrThrow
   */
  export type OwnerDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDetails to fetch.
     */
    where?: OwnerDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerDetails to fetch.
     */
    orderBy?: OwnerDetailsOrderByWithRelationInput | OwnerDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerDetails.
     */
    cursor?: OwnerDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerDetails.
     */
    distinct?: OwnerDetailsScalarFieldEnum | OwnerDetailsScalarFieldEnum[]
  }

  /**
   * OwnerDetails findMany
   */
  export type OwnerDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDetails to fetch.
     */
    where?: OwnerDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerDetails to fetch.
     */
    orderBy?: OwnerDetailsOrderByWithRelationInput | OwnerDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OwnerDetails.
     */
    cursor?: OwnerDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerDetails.
     */
    skip?: number
    distinct?: OwnerDetailsScalarFieldEnum | OwnerDetailsScalarFieldEnum[]
  }

  /**
   * OwnerDetails create
   */
  export type OwnerDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a OwnerDetails.
     */
    data: XOR<OwnerDetailsCreateInput, OwnerDetailsUncheckedCreateInput>
  }

  /**
   * OwnerDetails createMany
   */
  export type OwnerDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OwnerDetails.
     */
    data: OwnerDetailsCreateManyInput | OwnerDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OwnerDetails createManyAndReturn
   */
  export type OwnerDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OwnerDetails.
     */
    data: OwnerDetailsCreateManyInput | OwnerDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OwnerDetails update
   */
  export type OwnerDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a OwnerDetails.
     */
    data: XOR<OwnerDetailsUpdateInput, OwnerDetailsUncheckedUpdateInput>
    /**
     * Choose, which OwnerDetails to update.
     */
    where: OwnerDetailsWhereUniqueInput
  }

  /**
   * OwnerDetails updateMany
   */
  export type OwnerDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OwnerDetails.
     */
    data: XOR<OwnerDetailsUpdateManyMutationInput, OwnerDetailsUncheckedUpdateManyInput>
    /**
     * Filter which OwnerDetails to update
     */
    where?: OwnerDetailsWhereInput
  }

  /**
   * OwnerDetails upsert
   */
  export type OwnerDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the OwnerDetails to update in case it exists.
     */
    where: OwnerDetailsWhereUniqueInput
    /**
     * In case the OwnerDetails found by the `where` argument doesn't exist, create a new OwnerDetails with this data.
     */
    create: XOR<OwnerDetailsCreateInput, OwnerDetailsUncheckedCreateInput>
    /**
     * In case the OwnerDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnerDetailsUpdateInput, OwnerDetailsUncheckedUpdateInput>
  }

  /**
   * OwnerDetails delete
   */
  export type OwnerDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * Filter which OwnerDetails to delete.
     */
    where: OwnerDetailsWhereUniqueInput
  }

  /**
   * OwnerDetails deleteMany
   */
  export type OwnerDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerDetails to delete
     */
    where?: OwnerDetailsWhereInput
  }

  /**
   * OwnerDetails without action
   */
  export type OwnerDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
  }


  /**
   * Model LocationDetails
   */

  export type AggregateLocationDetails = {
    _count: LocationDetailsCountAggregateOutputType | null
    _avg: LocationDetailsAvgAggregateOutputType | null
    _sum: LocationDetailsSumAggregateOutputType | null
    _min: LocationDetailsMinAggregateOutputType | null
    _max: LocationDetailsMaxAggregateOutputType | null
  }

  export type LocationDetailsAvgAggregateOutputType = {
    propertyLatitude: Decimal | null
    propertyLongitude: Decimal | null
    pinCode: number | null
  }

  export type LocationDetailsSumAggregateOutputType = {
    propertyLatitude: Decimal | null
    propertyLongitude: Decimal | null
    pinCode: number | null
  }

  export type LocationDetailsMinAggregateOutputType = {
    surveyUniqueCode: string | null
    propertyLatitude: Decimal | null
    propertyLongitude: Decimal | null
    assessmentYear: string | null
    propertyTypeId: string | null
    buildingName: string | null
    roadTypeId: string | null
    constructionYear: string | null
    constructionTypeId: string | null
    addressRoadName: string | null
    locality: string | null
    pinCode: number | null
    landmark: string | null
    fourWayEast: string | null
    fourWayWest: string | null
    fourWayNorth: string | null
    fourWaySouth: string | null
    newWard: string | null
  }

  export type LocationDetailsMaxAggregateOutputType = {
    surveyUniqueCode: string | null
    propertyLatitude: Decimal | null
    propertyLongitude: Decimal | null
    assessmentYear: string | null
    propertyTypeId: string | null
    buildingName: string | null
    roadTypeId: string | null
    constructionYear: string | null
    constructionTypeId: string | null
    addressRoadName: string | null
    locality: string | null
    pinCode: number | null
    landmark: string | null
    fourWayEast: string | null
    fourWayWest: string | null
    fourWayNorth: string | null
    fourWaySouth: string | null
    newWard: string | null
  }

  export type LocationDetailsCountAggregateOutputType = {
    surveyUniqueCode: number
    propertyLatitude: number
    propertyLongitude: number
    assessmentYear: number
    propertyTypeId: number
    buildingName: number
    roadTypeId: number
    constructionYear: number
    constructionTypeId: number
    addressRoadName: number
    locality: number
    pinCode: number
    landmark: number
    fourWayEast: number
    fourWayWest: number
    fourWayNorth: number
    fourWaySouth: number
    newWard: number
    _all: number
  }


  export type LocationDetailsAvgAggregateInputType = {
    propertyLatitude?: true
    propertyLongitude?: true
    pinCode?: true
  }

  export type LocationDetailsSumAggregateInputType = {
    propertyLatitude?: true
    propertyLongitude?: true
    pinCode?: true
  }

  export type LocationDetailsMinAggregateInputType = {
    surveyUniqueCode?: true
    propertyLatitude?: true
    propertyLongitude?: true
    assessmentYear?: true
    propertyTypeId?: true
    buildingName?: true
    roadTypeId?: true
    constructionYear?: true
    constructionTypeId?: true
    addressRoadName?: true
    locality?: true
    pinCode?: true
    landmark?: true
    fourWayEast?: true
    fourWayWest?: true
    fourWayNorth?: true
    fourWaySouth?: true
    newWard?: true
  }

  export type LocationDetailsMaxAggregateInputType = {
    surveyUniqueCode?: true
    propertyLatitude?: true
    propertyLongitude?: true
    assessmentYear?: true
    propertyTypeId?: true
    buildingName?: true
    roadTypeId?: true
    constructionYear?: true
    constructionTypeId?: true
    addressRoadName?: true
    locality?: true
    pinCode?: true
    landmark?: true
    fourWayEast?: true
    fourWayWest?: true
    fourWayNorth?: true
    fourWaySouth?: true
    newWard?: true
  }

  export type LocationDetailsCountAggregateInputType = {
    surveyUniqueCode?: true
    propertyLatitude?: true
    propertyLongitude?: true
    assessmentYear?: true
    propertyTypeId?: true
    buildingName?: true
    roadTypeId?: true
    constructionYear?: true
    constructionTypeId?: true
    addressRoadName?: true
    locality?: true
    pinCode?: true
    landmark?: true
    fourWayEast?: true
    fourWayWest?: true
    fourWayNorth?: true
    fourWaySouth?: true
    newWard?: true
    _all?: true
  }

  export type LocationDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationDetails to aggregate.
     */
    where?: LocationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationDetails to fetch.
     */
    orderBy?: LocationDetailsOrderByWithRelationInput | LocationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocationDetails
    **/
    _count?: true | LocationDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationDetailsMaxAggregateInputType
  }

  export type GetLocationDetailsAggregateType<T extends LocationDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateLocationDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocationDetails[P]>
      : GetScalarType<T[P], AggregateLocationDetails[P]>
  }




  export type LocationDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationDetailsWhereInput
    orderBy?: LocationDetailsOrderByWithAggregationInput | LocationDetailsOrderByWithAggregationInput[]
    by: LocationDetailsScalarFieldEnum[] | LocationDetailsScalarFieldEnum
    having?: LocationDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationDetailsCountAggregateInputType | true
    _avg?: LocationDetailsAvgAggregateInputType
    _sum?: LocationDetailsSumAggregateInputType
    _min?: LocationDetailsMinAggregateInputType
    _max?: LocationDetailsMaxAggregateInputType
  }

  export type LocationDetailsGroupByOutputType = {
    surveyUniqueCode: string
    propertyLatitude: Decimal
    propertyLongitude: Decimal
    assessmentYear: string
    propertyTypeId: string
    buildingName: string | null
    roadTypeId: string
    constructionYear: string
    constructionTypeId: string
    addressRoadName: string
    locality: string | null
    pinCode: number
    landmark: string | null
    fourWayEast: string | null
    fourWayWest: string | null
    fourWayNorth: string | null
    fourWaySouth: string | null
    newWard: string
    _count: LocationDetailsCountAggregateOutputType | null
    _avg: LocationDetailsAvgAggregateOutputType | null
    _sum: LocationDetailsSumAggregateOutputType | null
    _min: LocationDetailsMinAggregateOutputType | null
    _max: LocationDetailsMaxAggregateOutputType | null
  }

  type GetLocationDetailsGroupByPayload<T extends LocationDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], LocationDetailsGroupByOutputType[P]>
        }
      >
    >


  export type LocationDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surveyUniqueCode?: boolean
    propertyLatitude?: boolean
    propertyLongitude?: boolean
    assessmentYear?: boolean
    propertyTypeId?: boolean
    buildingName?: boolean
    roadTypeId?: boolean
    constructionYear?: boolean
    constructionTypeId?: boolean
    addressRoadName?: boolean
    locality?: boolean
    pinCode?: boolean
    landmark?: boolean
    fourWayEast?: boolean
    fourWayWest?: boolean
    fourWayNorth?: boolean
    fourWaySouth?: boolean
    newWard?: boolean
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    propertyType?: boolean | PropertyTypeMasterDefaultArgs<ExtArgs>
    roadType?: boolean | RoadTypeMasterDefaultArgs<ExtArgs>
    constructionType?: boolean | ConstructionTypeMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationDetails"]>

  export type LocationDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surveyUniqueCode?: boolean
    propertyLatitude?: boolean
    propertyLongitude?: boolean
    assessmentYear?: boolean
    propertyTypeId?: boolean
    buildingName?: boolean
    roadTypeId?: boolean
    constructionYear?: boolean
    constructionTypeId?: boolean
    addressRoadName?: boolean
    locality?: boolean
    pinCode?: boolean
    landmark?: boolean
    fourWayEast?: boolean
    fourWayWest?: boolean
    fourWayNorth?: boolean
    fourWaySouth?: boolean
    newWard?: boolean
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    propertyType?: boolean | PropertyTypeMasterDefaultArgs<ExtArgs>
    roadType?: boolean | RoadTypeMasterDefaultArgs<ExtArgs>
    constructionType?: boolean | ConstructionTypeMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationDetails"]>

  export type LocationDetailsSelectScalar = {
    surveyUniqueCode?: boolean
    propertyLatitude?: boolean
    propertyLongitude?: boolean
    assessmentYear?: boolean
    propertyTypeId?: boolean
    buildingName?: boolean
    roadTypeId?: boolean
    constructionYear?: boolean
    constructionTypeId?: boolean
    addressRoadName?: boolean
    locality?: boolean
    pinCode?: boolean
    landmark?: boolean
    fourWayEast?: boolean
    fourWayWest?: boolean
    fourWayNorth?: boolean
    fourWaySouth?: boolean
    newWard?: boolean
  }

  export type LocationDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    propertyType?: boolean | PropertyTypeMasterDefaultArgs<ExtArgs>
    roadType?: boolean | RoadTypeMasterDefaultArgs<ExtArgs>
    constructionType?: boolean | ConstructionTypeMasterDefaultArgs<ExtArgs>
  }
  export type LocationDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    propertyType?: boolean | PropertyTypeMasterDefaultArgs<ExtArgs>
    roadType?: boolean | RoadTypeMasterDefaultArgs<ExtArgs>
    constructionType?: boolean | ConstructionTypeMasterDefaultArgs<ExtArgs>
  }

  export type $LocationDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocationDetails"
    objects: {
      survey: Prisma.$SurveyDetailsPayload<ExtArgs>
      propertyType: Prisma.$PropertyTypeMasterPayload<ExtArgs>
      roadType: Prisma.$RoadTypeMasterPayload<ExtArgs>
      constructionType: Prisma.$ConstructionTypeMasterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      surveyUniqueCode: string
      propertyLatitude: Prisma.Decimal
      propertyLongitude: Prisma.Decimal
      assessmentYear: string
      propertyTypeId: string
      buildingName: string | null
      roadTypeId: string
      constructionYear: string
      constructionTypeId: string
      addressRoadName: string
      locality: string | null
      pinCode: number
      landmark: string | null
      fourWayEast: string | null
      fourWayWest: string | null
      fourWayNorth: string | null
      fourWaySouth: string | null
      newWard: string
    }, ExtArgs["result"]["locationDetails"]>
    composites: {}
  }

  type LocationDetailsGetPayload<S extends boolean | null | undefined | LocationDetailsDefaultArgs> = $Result.GetResult<Prisma.$LocationDetailsPayload, S>

  type LocationDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocationDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationDetailsCountAggregateInputType | true
    }

  export interface LocationDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocationDetails'], meta: { name: 'LocationDetails' } }
    /**
     * Find zero or one LocationDetails that matches the filter.
     * @param {LocationDetailsFindUniqueArgs} args - Arguments to find a LocationDetails
     * @example
     * // Get one LocationDetails
     * const locationDetails = await prisma.locationDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationDetailsFindUniqueArgs>(args: SelectSubset<T, LocationDetailsFindUniqueArgs<ExtArgs>>): Prisma__LocationDetailsClient<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LocationDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocationDetailsFindUniqueOrThrowArgs} args - Arguments to find a LocationDetails
     * @example
     * // Get one LocationDetails
     * const locationDetails = await prisma.locationDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationDetailsClient<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LocationDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDetailsFindFirstArgs} args - Arguments to find a LocationDetails
     * @example
     * // Get one LocationDetails
     * const locationDetails = await prisma.locationDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationDetailsFindFirstArgs>(args?: SelectSubset<T, LocationDetailsFindFirstArgs<ExtArgs>>): Prisma__LocationDetailsClient<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LocationDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDetailsFindFirstOrThrowArgs} args - Arguments to find a LocationDetails
     * @example
     * // Get one LocationDetails
     * const locationDetails = await prisma.locationDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationDetailsClient<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LocationDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocationDetails
     * const locationDetails = await prisma.locationDetails.findMany()
     * 
     * // Get first 10 LocationDetails
     * const locationDetails = await prisma.locationDetails.findMany({ take: 10 })
     * 
     * // Only select the `surveyUniqueCode`
     * const locationDetailsWithSurveyUniqueCodeOnly = await prisma.locationDetails.findMany({ select: { surveyUniqueCode: true } })
     * 
     */
    findMany<T extends LocationDetailsFindManyArgs>(args?: SelectSubset<T, LocationDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LocationDetails.
     * @param {LocationDetailsCreateArgs} args - Arguments to create a LocationDetails.
     * @example
     * // Create one LocationDetails
     * const LocationDetails = await prisma.locationDetails.create({
     *   data: {
     *     // ... data to create a LocationDetails
     *   }
     * })
     * 
     */
    create<T extends LocationDetailsCreateArgs>(args: SelectSubset<T, LocationDetailsCreateArgs<ExtArgs>>): Prisma__LocationDetailsClient<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LocationDetails.
     * @param {LocationDetailsCreateManyArgs} args - Arguments to create many LocationDetails.
     * @example
     * // Create many LocationDetails
     * const locationDetails = await prisma.locationDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationDetailsCreateManyArgs>(args?: SelectSubset<T, LocationDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocationDetails and returns the data saved in the database.
     * @param {LocationDetailsCreateManyAndReturnArgs} args - Arguments to create many LocationDetails.
     * @example
     * // Create many LocationDetails
     * const locationDetails = await prisma.locationDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocationDetails and only return the `surveyUniqueCode`
     * const locationDetailsWithSurveyUniqueCodeOnly = await prisma.locationDetails.createManyAndReturn({ 
     *   select: { surveyUniqueCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LocationDetails.
     * @param {LocationDetailsDeleteArgs} args - Arguments to delete one LocationDetails.
     * @example
     * // Delete one LocationDetails
     * const LocationDetails = await prisma.locationDetails.delete({
     *   where: {
     *     // ... filter to delete one LocationDetails
     *   }
     * })
     * 
     */
    delete<T extends LocationDetailsDeleteArgs>(args: SelectSubset<T, LocationDetailsDeleteArgs<ExtArgs>>): Prisma__LocationDetailsClient<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LocationDetails.
     * @param {LocationDetailsUpdateArgs} args - Arguments to update one LocationDetails.
     * @example
     * // Update one LocationDetails
     * const locationDetails = await prisma.locationDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationDetailsUpdateArgs>(args: SelectSubset<T, LocationDetailsUpdateArgs<ExtArgs>>): Prisma__LocationDetailsClient<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LocationDetails.
     * @param {LocationDetailsDeleteManyArgs} args - Arguments to filter LocationDetails to delete.
     * @example
     * // Delete a few LocationDetails
     * const { count } = await prisma.locationDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDetailsDeleteManyArgs>(args?: SelectSubset<T, LocationDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocationDetails
     * const locationDetails = await prisma.locationDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationDetailsUpdateManyArgs>(args: SelectSubset<T, LocationDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocationDetails.
     * @param {LocationDetailsUpsertArgs} args - Arguments to update or create a LocationDetails.
     * @example
     * // Update or create a LocationDetails
     * const locationDetails = await prisma.locationDetails.upsert({
     *   create: {
     *     // ... data to create a LocationDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocationDetails we want to update
     *   }
     * })
     */
    upsert<T extends LocationDetailsUpsertArgs>(args: SelectSubset<T, LocationDetailsUpsertArgs<ExtArgs>>): Prisma__LocationDetailsClient<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LocationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDetailsCountArgs} args - Arguments to filter LocationDetails to count.
     * @example
     * // Count the number of LocationDetails
     * const count = await prisma.locationDetails.count({
     *   where: {
     *     // ... the filter for the LocationDetails we want to count
     *   }
     * })
    **/
    count<T extends LocationDetailsCountArgs>(
      args?: Subset<T, LocationDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationDetailsAggregateArgs>(args: Subset<T, LocationDetailsAggregateArgs>): Prisma.PrismaPromise<GetLocationDetailsAggregateType<T>>

    /**
     * Group by LocationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationDetailsGroupByArgs['orderBy'] }
        : { orderBy?: LocationDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocationDetails model
   */
  readonly fields: LocationDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocationDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDetailsDefaultArgs<ExtArgs>>): Prisma__SurveyDetailsClient<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    propertyType<T extends PropertyTypeMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyTypeMasterDefaultArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    roadType<T extends RoadTypeMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoadTypeMasterDefaultArgs<ExtArgs>>): Prisma__RoadTypeMasterClient<$Result.GetResult<Prisma.$RoadTypeMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    constructionType<T extends ConstructionTypeMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionTypeMasterDefaultArgs<ExtArgs>>): Prisma__ConstructionTypeMasterClient<$Result.GetResult<Prisma.$ConstructionTypeMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocationDetails model
   */ 
  interface LocationDetailsFieldRefs {
    readonly surveyUniqueCode: FieldRef<"LocationDetails", 'String'>
    readonly propertyLatitude: FieldRef<"LocationDetails", 'Decimal'>
    readonly propertyLongitude: FieldRef<"LocationDetails", 'Decimal'>
    readonly assessmentYear: FieldRef<"LocationDetails", 'String'>
    readonly propertyTypeId: FieldRef<"LocationDetails", 'String'>
    readonly buildingName: FieldRef<"LocationDetails", 'String'>
    readonly roadTypeId: FieldRef<"LocationDetails", 'String'>
    readonly constructionYear: FieldRef<"LocationDetails", 'String'>
    readonly constructionTypeId: FieldRef<"LocationDetails", 'String'>
    readonly addressRoadName: FieldRef<"LocationDetails", 'String'>
    readonly locality: FieldRef<"LocationDetails", 'String'>
    readonly pinCode: FieldRef<"LocationDetails", 'Int'>
    readonly landmark: FieldRef<"LocationDetails", 'String'>
    readonly fourWayEast: FieldRef<"LocationDetails", 'String'>
    readonly fourWayWest: FieldRef<"LocationDetails", 'String'>
    readonly fourWayNorth: FieldRef<"LocationDetails", 'String'>
    readonly fourWaySouth: FieldRef<"LocationDetails", 'String'>
    readonly newWard: FieldRef<"LocationDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LocationDetails findUnique
   */
  export type LocationDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which LocationDetails to fetch.
     */
    where: LocationDetailsWhereUniqueInput
  }

  /**
   * LocationDetails findUniqueOrThrow
   */
  export type LocationDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which LocationDetails to fetch.
     */
    where: LocationDetailsWhereUniqueInput
  }

  /**
   * LocationDetails findFirst
   */
  export type LocationDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which LocationDetails to fetch.
     */
    where?: LocationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationDetails to fetch.
     */
    orderBy?: LocationDetailsOrderByWithRelationInput | LocationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationDetails.
     */
    cursor?: LocationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationDetails.
     */
    distinct?: LocationDetailsScalarFieldEnum | LocationDetailsScalarFieldEnum[]
  }

  /**
   * LocationDetails findFirstOrThrow
   */
  export type LocationDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which LocationDetails to fetch.
     */
    where?: LocationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationDetails to fetch.
     */
    orderBy?: LocationDetailsOrderByWithRelationInput | LocationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationDetails.
     */
    cursor?: LocationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationDetails.
     */
    distinct?: LocationDetailsScalarFieldEnum | LocationDetailsScalarFieldEnum[]
  }

  /**
   * LocationDetails findMany
   */
  export type LocationDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which LocationDetails to fetch.
     */
    where?: LocationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationDetails to fetch.
     */
    orderBy?: LocationDetailsOrderByWithRelationInput | LocationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocationDetails.
     */
    cursor?: LocationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationDetails.
     */
    skip?: number
    distinct?: LocationDetailsScalarFieldEnum | LocationDetailsScalarFieldEnum[]
  }

  /**
   * LocationDetails create
   */
  export type LocationDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a LocationDetails.
     */
    data: XOR<LocationDetailsCreateInput, LocationDetailsUncheckedCreateInput>
  }

  /**
   * LocationDetails createMany
   */
  export type LocationDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocationDetails.
     */
    data: LocationDetailsCreateManyInput | LocationDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LocationDetails createManyAndReturn
   */
  export type LocationDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LocationDetails.
     */
    data: LocationDetailsCreateManyInput | LocationDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LocationDetails update
   */
  export type LocationDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a LocationDetails.
     */
    data: XOR<LocationDetailsUpdateInput, LocationDetailsUncheckedUpdateInput>
    /**
     * Choose, which LocationDetails to update.
     */
    where: LocationDetailsWhereUniqueInput
  }

  /**
   * LocationDetails updateMany
   */
  export type LocationDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocationDetails.
     */
    data: XOR<LocationDetailsUpdateManyMutationInput, LocationDetailsUncheckedUpdateManyInput>
    /**
     * Filter which LocationDetails to update
     */
    where?: LocationDetailsWhereInput
  }

  /**
   * LocationDetails upsert
   */
  export type LocationDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the LocationDetails to update in case it exists.
     */
    where: LocationDetailsWhereUniqueInput
    /**
     * In case the LocationDetails found by the `where` argument doesn't exist, create a new LocationDetails with this data.
     */
    create: XOR<LocationDetailsCreateInput, LocationDetailsUncheckedCreateInput>
    /**
     * In case the LocationDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationDetailsUpdateInput, LocationDetailsUncheckedUpdateInput>
  }

  /**
   * LocationDetails delete
   */
  export type LocationDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * Filter which LocationDetails to delete.
     */
    where: LocationDetailsWhereUniqueInput
  }

  /**
   * LocationDetails deleteMany
   */
  export type LocationDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationDetails to delete
     */
    where?: LocationDetailsWhereInput
  }

  /**
   * LocationDetails without action
   */
  export type LocationDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
  }


  /**
   * Model OtherDetails
   */

  export type AggregateOtherDetails = {
    _count: OtherDetailsCountAggregateOutputType | null
    _avg: OtherDetailsAvgAggregateOutputType | null
    _sum: OtherDetailsSumAggregateOutputType | null
    _min: OtherDetailsMinAggregateOutputType | null
    _max: OtherDetailsMaxAggregateOutputType | null
  }

  export type OtherDetailsAvgAggregateOutputType = {
    totalPlotArea: number | null
    builtupAreaOfGroundFloor: number | null
  }

  export type OtherDetailsSumAggregateOutputType = {
    totalPlotArea: number | null
    builtupAreaOfGroundFloor: number | null
  }

  export type OtherDetailsMinAggregateOutputType = {
    surveyUniqueCode: string | null
    waterSourceId: string | null
    rainWaterHarvestingSystem: string | null
    plantation: string | null
    parking: string | null
    pollution: string | null
    pollutionMeasurementTaken: string | null
    waterSupplyWithin200Meters: string | null
    sewerageLineWithin100Meters: string | null
    disposalTypeId: string | null
    totalPlotArea: number | null
    builtupAreaOfGroundFloor: number | null
    remarks: string | null
  }

  export type OtherDetailsMaxAggregateOutputType = {
    surveyUniqueCode: string | null
    waterSourceId: string | null
    rainWaterHarvestingSystem: string | null
    plantation: string | null
    parking: string | null
    pollution: string | null
    pollutionMeasurementTaken: string | null
    waterSupplyWithin200Meters: string | null
    sewerageLineWithin100Meters: string | null
    disposalTypeId: string | null
    totalPlotArea: number | null
    builtupAreaOfGroundFloor: number | null
    remarks: string | null
  }

  export type OtherDetailsCountAggregateOutputType = {
    surveyUniqueCode: number
    waterSourceId: number
    rainWaterHarvestingSystem: number
    plantation: number
    parking: number
    pollution: number
    pollutionMeasurementTaken: number
    waterSupplyWithin200Meters: number
    sewerageLineWithin100Meters: number
    disposalTypeId: number
    totalPlotArea: number
    builtupAreaOfGroundFloor: number
    remarks: number
    _all: number
  }


  export type OtherDetailsAvgAggregateInputType = {
    totalPlotArea?: true
    builtupAreaOfGroundFloor?: true
  }

  export type OtherDetailsSumAggregateInputType = {
    totalPlotArea?: true
    builtupAreaOfGroundFloor?: true
  }

  export type OtherDetailsMinAggregateInputType = {
    surveyUniqueCode?: true
    waterSourceId?: true
    rainWaterHarvestingSystem?: true
    plantation?: true
    parking?: true
    pollution?: true
    pollutionMeasurementTaken?: true
    waterSupplyWithin200Meters?: true
    sewerageLineWithin100Meters?: true
    disposalTypeId?: true
    totalPlotArea?: true
    builtupAreaOfGroundFloor?: true
    remarks?: true
  }

  export type OtherDetailsMaxAggregateInputType = {
    surveyUniqueCode?: true
    waterSourceId?: true
    rainWaterHarvestingSystem?: true
    plantation?: true
    parking?: true
    pollution?: true
    pollutionMeasurementTaken?: true
    waterSupplyWithin200Meters?: true
    sewerageLineWithin100Meters?: true
    disposalTypeId?: true
    totalPlotArea?: true
    builtupAreaOfGroundFloor?: true
    remarks?: true
  }

  export type OtherDetailsCountAggregateInputType = {
    surveyUniqueCode?: true
    waterSourceId?: true
    rainWaterHarvestingSystem?: true
    plantation?: true
    parking?: true
    pollution?: true
    pollutionMeasurementTaken?: true
    waterSupplyWithin200Meters?: true
    sewerageLineWithin100Meters?: true
    disposalTypeId?: true
    totalPlotArea?: true
    builtupAreaOfGroundFloor?: true
    remarks?: true
    _all?: true
  }

  export type OtherDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtherDetails to aggregate.
     */
    where?: OtherDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtherDetails to fetch.
     */
    orderBy?: OtherDetailsOrderByWithRelationInput | OtherDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtherDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtherDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtherDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OtherDetails
    **/
    _count?: true | OtherDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OtherDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OtherDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtherDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtherDetailsMaxAggregateInputType
  }

  export type GetOtherDetailsAggregateType<T extends OtherDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateOtherDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtherDetails[P]>
      : GetScalarType<T[P], AggregateOtherDetails[P]>
  }




  export type OtherDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtherDetailsWhereInput
    orderBy?: OtherDetailsOrderByWithAggregationInput | OtherDetailsOrderByWithAggregationInput[]
    by: OtherDetailsScalarFieldEnum[] | OtherDetailsScalarFieldEnum
    having?: OtherDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtherDetailsCountAggregateInputType | true
    _avg?: OtherDetailsAvgAggregateInputType
    _sum?: OtherDetailsSumAggregateInputType
    _min?: OtherDetailsMinAggregateInputType
    _max?: OtherDetailsMaxAggregateInputType
  }

  export type OtherDetailsGroupByOutputType = {
    surveyUniqueCode: string
    waterSourceId: string
    rainWaterHarvestingSystem: string | null
    plantation: string | null
    parking: string | null
    pollution: string | null
    pollutionMeasurementTaken: string | null
    waterSupplyWithin200Meters: string | null
    sewerageLineWithin100Meters: string | null
    disposalTypeId: string
    totalPlotArea: number
    builtupAreaOfGroundFloor: number
    remarks: string | null
    _count: OtherDetailsCountAggregateOutputType | null
    _avg: OtherDetailsAvgAggregateOutputType | null
    _sum: OtherDetailsSumAggregateOutputType | null
    _min: OtherDetailsMinAggregateOutputType | null
    _max: OtherDetailsMaxAggregateOutputType | null
  }

  type GetOtherDetailsGroupByPayload<T extends OtherDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtherDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtherDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtherDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], OtherDetailsGroupByOutputType[P]>
        }
      >
    >


  export type OtherDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surveyUniqueCode?: boolean
    waterSourceId?: boolean
    rainWaterHarvestingSystem?: boolean
    plantation?: boolean
    parking?: boolean
    pollution?: boolean
    pollutionMeasurementTaken?: boolean
    waterSupplyWithin200Meters?: boolean
    sewerageLineWithin100Meters?: boolean
    disposalTypeId?: boolean
    totalPlotArea?: boolean
    builtupAreaOfGroundFloor?: boolean
    remarks?: boolean
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    waterSource?: boolean | WaterSourceMasterDefaultArgs<ExtArgs>
    disposalType?: boolean | DisposalTypeMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otherDetails"]>

  export type OtherDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surveyUniqueCode?: boolean
    waterSourceId?: boolean
    rainWaterHarvestingSystem?: boolean
    plantation?: boolean
    parking?: boolean
    pollution?: boolean
    pollutionMeasurementTaken?: boolean
    waterSupplyWithin200Meters?: boolean
    sewerageLineWithin100Meters?: boolean
    disposalTypeId?: boolean
    totalPlotArea?: boolean
    builtupAreaOfGroundFloor?: boolean
    remarks?: boolean
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    waterSource?: boolean | WaterSourceMasterDefaultArgs<ExtArgs>
    disposalType?: boolean | DisposalTypeMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otherDetails"]>

  export type OtherDetailsSelectScalar = {
    surveyUniqueCode?: boolean
    waterSourceId?: boolean
    rainWaterHarvestingSystem?: boolean
    plantation?: boolean
    parking?: boolean
    pollution?: boolean
    pollutionMeasurementTaken?: boolean
    waterSupplyWithin200Meters?: boolean
    sewerageLineWithin100Meters?: boolean
    disposalTypeId?: boolean
    totalPlotArea?: boolean
    builtupAreaOfGroundFloor?: boolean
    remarks?: boolean
  }

  export type OtherDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    waterSource?: boolean | WaterSourceMasterDefaultArgs<ExtArgs>
    disposalType?: boolean | DisposalTypeMasterDefaultArgs<ExtArgs>
  }
  export type OtherDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    waterSource?: boolean | WaterSourceMasterDefaultArgs<ExtArgs>
    disposalType?: boolean | DisposalTypeMasterDefaultArgs<ExtArgs>
  }

  export type $OtherDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OtherDetails"
    objects: {
      survey: Prisma.$SurveyDetailsPayload<ExtArgs>
      waterSource: Prisma.$WaterSourceMasterPayload<ExtArgs>
      disposalType: Prisma.$DisposalTypeMasterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      surveyUniqueCode: string
      waterSourceId: string
      rainWaterHarvestingSystem: string | null
      plantation: string | null
      parking: string | null
      pollution: string | null
      pollutionMeasurementTaken: string | null
      waterSupplyWithin200Meters: string | null
      sewerageLineWithin100Meters: string | null
      disposalTypeId: string
      totalPlotArea: number
      builtupAreaOfGroundFloor: number
      remarks: string | null
    }, ExtArgs["result"]["otherDetails"]>
    composites: {}
  }

  type OtherDetailsGetPayload<S extends boolean | null | undefined | OtherDetailsDefaultArgs> = $Result.GetResult<Prisma.$OtherDetailsPayload, S>

  type OtherDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OtherDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OtherDetailsCountAggregateInputType | true
    }

  export interface OtherDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OtherDetails'], meta: { name: 'OtherDetails' } }
    /**
     * Find zero or one OtherDetails that matches the filter.
     * @param {OtherDetailsFindUniqueArgs} args - Arguments to find a OtherDetails
     * @example
     * // Get one OtherDetails
     * const otherDetails = await prisma.otherDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtherDetailsFindUniqueArgs>(args: SelectSubset<T, OtherDetailsFindUniqueArgs<ExtArgs>>): Prisma__OtherDetailsClient<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OtherDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OtherDetailsFindUniqueOrThrowArgs} args - Arguments to find a OtherDetails
     * @example
     * // Get one OtherDetails
     * const otherDetails = await prisma.otherDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtherDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, OtherDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtherDetailsClient<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OtherDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherDetailsFindFirstArgs} args - Arguments to find a OtherDetails
     * @example
     * // Get one OtherDetails
     * const otherDetails = await prisma.otherDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtherDetailsFindFirstArgs>(args?: SelectSubset<T, OtherDetailsFindFirstArgs<ExtArgs>>): Prisma__OtherDetailsClient<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OtherDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherDetailsFindFirstOrThrowArgs} args - Arguments to find a OtherDetails
     * @example
     * // Get one OtherDetails
     * const otherDetails = await prisma.otherDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtherDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, OtherDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtherDetailsClient<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OtherDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OtherDetails
     * const otherDetails = await prisma.otherDetails.findMany()
     * 
     * // Get first 10 OtherDetails
     * const otherDetails = await prisma.otherDetails.findMany({ take: 10 })
     * 
     * // Only select the `surveyUniqueCode`
     * const otherDetailsWithSurveyUniqueCodeOnly = await prisma.otherDetails.findMany({ select: { surveyUniqueCode: true } })
     * 
     */
    findMany<T extends OtherDetailsFindManyArgs>(args?: SelectSubset<T, OtherDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OtherDetails.
     * @param {OtherDetailsCreateArgs} args - Arguments to create a OtherDetails.
     * @example
     * // Create one OtherDetails
     * const OtherDetails = await prisma.otherDetails.create({
     *   data: {
     *     // ... data to create a OtherDetails
     *   }
     * })
     * 
     */
    create<T extends OtherDetailsCreateArgs>(args: SelectSubset<T, OtherDetailsCreateArgs<ExtArgs>>): Prisma__OtherDetailsClient<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OtherDetails.
     * @param {OtherDetailsCreateManyArgs} args - Arguments to create many OtherDetails.
     * @example
     * // Create many OtherDetails
     * const otherDetails = await prisma.otherDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtherDetailsCreateManyArgs>(args?: SelectSubset<T, OtherDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OtherDetails and returns the data saved in the database.
     * @param {OtherDetailsCreateManyAndReturnArgs} args - Arguments to create many OtherDetails.
     * @example
     * // Create many OtherDetails
     * const otherDetails = await prisma.otherDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OtherDetails and only return the `surveyUniqueCode`
     * const otherDetailsWithSurveyUniqueCodeOnly = await prisma.otherDetails.createManyAndReturn({ 
     *   select: { surveyUniqueCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OtherDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, OtherDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OtherDetails.
     * @param {OtherDetailsDeleteArgs} args - Arguments to delete one OtherDetails.
     * @example
     * // Delete one OtherDetails
     * const OtherDetails = await prisma.otherDetails.delete({
     *   where: {
     *     // ... filter to delete one OtherDetails
     *   }
     * })
     * 
     */
    delete<T extends OtherDetailsDeleteArgs>(args: SelectSubset<T, OtherDetailsDeleteArgs<ExtArgs>>): Prisma__OtherDetailsClient<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OtherDetails.
     * @param {OtherDetailsUpdateArgs} args - Arguments to update one OtherDetails.
     * @example
     * // Update one OtherDetails
     * const otherDetails = await prisma.otherDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtherDetailsUpdateArgs>(args: SelectSubset<T, OtherDetailsUpdateArgs<ExtArgs>>): Prisma__OtherDetailsClient<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OtherDetails.
     * @param {OtherDetailsDeleteManyArgs} args - Arguments to filter OtherDetails to delete.
     * @example
     * // Delete a few OtherDetails
     * const { count } = await prisma.otherDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtherDetailsDeleteManyArgs>(args?: SelectSubset<T, OtherDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OtherDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OtherDetails
     * const otherDetails = await prisma.otherDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtherDetailsUpdateManyArgs>(args: SelectSubset<T, OtherDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OtherDetails.
     * @param {OtherDetailsUpsertArgs} args - Arguments to update or create a OtherDetails.
     * @example
     * // Update or create a OtherDetails
     * const otherDetails = await prisma.otherDetails.upsert({
     *   create: {
     *     // ... data to create a OtherDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OtherDetails we want to update
     *   }
     * })
     */
    upsert<T extends OtherDetailsUpsertArgs>(args: SelectSubset<T, OtherDetailsUpsertArgs<ExtArgs>>): Prisma__OtherDetailsClient<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OtherDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherDetailsCountArgs} args - Arguments to filter OtherDetails to count.
     * @example
     * // Count the number of OtherDetails
     * const count = await prisma.otherDetails.count({
     *   where: {
     *     // ... the filter for the OtherDetails we want to count
     *   }
     * })
    **/
    count<T extends OtherDetailsCountArgs>(
      args?: Subset<T, OtherDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtherDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OtherDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtherDetailsAggregateArgs>(args: Subset<T, OtherDetailsAggregateArgs>): Prisma.PrismaPromise<GetOtherDetailsAggregateType<T>>

    /**
     * Group by OtherDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtherDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtherDetailsGroupByArgs['orderBy'] }
        : { orderBy?: OtherDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtherDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtherDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OtherDetails model
   */
  readonly fields: OtherDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OtherDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtherDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDetailsDefaultArgs<ExtArgs>>): Prisma__SurveyDetailsClient<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    waterSource<T extends WaterSourceMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WaterSourceMasterDefaultArgs<ExtArgs>>): Prisma__WaterSourceMasterClient<$Result.GetResult<Prisma.$WaterSourceMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    disposalType<T extends DisposalTypeMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DisposalTypeMasterDefaultArgs<ExtArgs>>): Prisma__DisposalTypeMasterClient<$Result.GetResult<Prisma.$DisposalTypeMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OtherDetails model
   */ 
  interface OtherDetailsFieldRefs {
    readonly surveyUniqueCode: FieldRef<"OtherDetails", 'String'>
    readonly waterSourceId: FieldRef<"OtherDetails", 'String'>
    readonly rainWaterHarvestingSystem: FieldRef<"OtherDetails", 'String'>
    readonly plantation: FieldRef<"OtherDetails", 'String'>
    readonly parking: FieldRef<"OtherDetails", 'String'>
    readonly pollution: FieldRef<"OtherDetails", 'String'>
    readonly pollutionMeasurementTaken: FieldRef<"OtherDetails", 'String'>
    readonly waterSupplyWithin200Meters: FieldRef<"OtherDetails", 'String'>
    readonly sewerageLineWithin100Meters: FieldRef<"OtherDetails", 'String'>
    readonly disposalTypeId: FieldRef<"OtherDetails", 'String'>
    readonly totalPlotArea: FieldRef<"OtherDetails", 'Float'>
    readonly builtupAreaOfGroundFloor: FieldRef<"OtherDetails", 'Float'>
    readonly remarks: FieldRef<"OtherDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OtherDetails findUnique
   */
  export type OtherDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OtherDetails to fetch.
     */
    where: OtherDetailsWhereUniqueInput
  }

  /**
   * OtherDetails findUniqueOrThrow
   */
  export type OtherDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OtherDetails to fetch.
     */
    where: OtherDetailsWhereUniqueInput
  }

  /**
   * OtherDetails findFirst
   */
  export type OtherDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OtherDetails to fetch.
     */
    where?: OtherDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtherDetails to fetch.
     */
    orderBy?: OtherDetailsOrderByWithRelationInput | OtherDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtherDetails.
     */
    cursor?: OtherDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtherDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtherDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtherDetails.
     */
    distinct?: OtherDetailsScalarFieldEnum | OtherDetailsScalarFieldEnum[]
  }

  /**
   * OtherDetails findFirstOrThrow
   */
  export type OtherDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OtherDetails to fetch.
     */
    where?: OtherDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtherDetails to fetch.
     */
    orderBy?: OtherDetailsOrderByWithRelationInput | OtherDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtherDetails.
     */
    cursor?: OtherDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtherDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtherDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtherDetails.
     */
    distinct?: OtherDetailsScalarFieldEnum | OtherDetailsScalarFieldEnum[]
  }

  /**
   * OtherDetails findMany
   */
  export type OtherDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OtherDetails to fetch.
     */
    where?: OtherDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtherDetails to fetch.
     */
    orderBy?: OtherDetailsOrderByWithRelationInput | OtherDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OtherDetails.
     */
    cursor?: OtherDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtherDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtherDetails.
     */
    skip?: number
    distinct?: OtherDetailsScalarFieldEnum | OtherDetailsScalarFieldEnum[]
  }

  /**
   * OtherDetails create
   */
  export type OtherDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a OtherDetails.
     */
    data: XOR<OtherDetailsCreateInput, OtherDetailsUncheckedCreateInput>
  }

  /**
   * OtherDetails createMany
   */
  export type OtherDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OtherDetails.
     */
    data: OtherDetailsCreateManyInput | OtherDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OtherDetails createManyAndReturn
   */
  export type OtherDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OtherDetails.
     */
    data: OtherDetailsCreateManyInput | OtherDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OtherDetails update
   */
  export type OtherDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a OtherDetails.
     */
    data: XOR<OtherDetailsUpdateInput, OtherDetailsUncheckedUpdateInput>
    /**
     * Choose, which OtherDetails to update.
     */
    where: OtherDetailsWhereUniqueInput
  }

  /**
   * OtherDetails updateMany
   */
  export type OtherDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OtherDetails.
     */
    data: XOR<OtherDetailsUpdateManyMutationInput, OtherDetailsUncheckedUpdateManyInput>
    /**
     * Filter which OtherDetails to update
     */
    where?: OtherDetailsWhereInput
  }

  /**
   * OtherDetails upsert
   */
  export type OtherDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the OtherDetails to update in case it exists.
     */
    where: OtherDetailsWhereUniqueInput
    /**
     * In case the OtherDetails found by the `where` argument doesn't exist, create a new OtherDetails with this data.
     */
    create: XOR<OtherDetailsCreateInput, OtherDetailsUncheckedCreateInput>
    /**
     * In case the OtherDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtherDetailsUpdateInput, OtherDetailsUncheckedUpdateInput>
  }

  /**
   * OtherDetails delete
   */
  export type OtherDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * Filter which OtherDetails to delete.
     */
    where: OtherDetailsWhereUniqueInput
  }

  /**
   * OtherDetails deleteMany
   */
  export type OtherDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtherDetails to delete
     */
    where?: OtherDetailsWhereInput
  }

  /**
   * OtherDetails without action
   */
  export type OtherDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
  }


  /**
   * Model ResidentialPropertyAssessment
   */

  export type AggregateResidentialPropertyAssessment = {
    _count: ResidentialPropertyAssessmentCountAggregateOutputType | null
    _avg: ResidentialPropertyAssessmentAvgAggregateOutputType | null
    _sum: ResidentialPropertyAssessmentSumAggregateOutputType | null
    _min: ResidentialPropertyAssessmentMinAggregateOutputType | null
    _max: ResidentialPropertyAssessmentMaxAggregateOutputType | null
  }

  export type ResidentialPropertyAssessmentAvgAggregateOutputType = {
    coveredArea: Decimal | null
    allRoomVerandaArea: Decimal | null
    allBalconyKitchenArea: Decimal | null
    allGarageArea: Decimal | null
    carpetArea: Decimal | null
  }

  export type ResidentialPropertyAssessmentSumAggregateOutputType = {
    coveredArea: Decimal | null
    allRoomVerandaArea: Decimal | null
    allBalconyKitchenArea: Decimal | null
    allGarageArea: Decimal | null
    carpetArea: Decimal | null
  }

  export type ResidentialPropertyAssessmentMinAggregateOutputType = {
    floorAssessmentId: string | null
    surveyUniqueCode: string | null
    floorNumber: string | null
    occupancyStatusId: string | null
    constructionNatureId: string | null
    coveredArea: Decimal | null
    allRoomVerandaArea: Decimal | null
    allBalconyKitchenArea: Decimal | null
    allGarageArea: Decimal | null
    carpetArea: Decimal | null
  }

  export type ResidentialPropertyAssessmentMaxAggregateOutputType = {
    floorAssessmentId: string | null
    surveyUniqueCode: string | null
    floorNumber: string | null
    occupancyStatusId: string | null
    constructionNatureId: string | null
    coveredArea: Decimal | null
    allRoomVerandaArea: Decimal | null
    allBalconyKitchenArea: Decimal | null
    allGarageArea: Decimal | null
    carpetArea: Decimal | null
  }

  export type ResidentialPropertyAssessmentCountAggregateOutputType = {
    floorAssessmentId: number
    surveyUniqueCode: number
    floorNumber: number
    occupancyStatusId: number
    constructionNatureId: number
    coveredArea: number
    allRoomVerandaArea: number
    allBalconyKitchenArea: number
    allGarageArea: number
    carpetArea: number
    _all: number
  }


  export type ResidentialPropertyAssessmentAvgAggregateInputType = {
    coveredArea?: true
    allRoomVerandaArea?: true
    allBalconyKitchenArea?: true
    allGarageArea?: true
    carpetArea?: true
  }

  export type ResidentialPropertyAssessmentSumAggregateInputType = {
    coveredArea?: true
    allRoomVerandaArea?: true
    allBalconyKitchenArea?: true
    allGarageArea?: true
    carpetArea?: true
  }

  export type ResidentialPropertyAssessmentMinAggregateInputType = {
    floorAssessmentId?: true
    surveyUniqueCode?: true
    floorNumber?: true
    occupancyStatusId?: true
    constructionNatureId?: true
    coveredArea?: true
    allRoomVerandaArea?: true
    allBalconyKitchenArea?: true
    allGarageArea?: true
    carpetArea?: true
  }

  export type ResidentialPropertyAssessmentMaxAggregateInputType = {
    floorAssessmentId?: true
    surveyUniqueCode?: true
    floorNumber?: true
    occupancyStatusId?: true
    constructionNatureId?: true
    coveredArea?: true
    allRoomVerandaArea?: true
    allBalconyKitchenArea?: true
    allGarageArea?: true
    carpetArea?: true
  }

  export type ResidentialPropertyAssessmentCountAggregateInputType = {
    floorAssessmentId?: true
    surveyUniqueCode?: true
    floorNumber?: true
    occupancyStatusId?: true
    constructionNatureId?: true
    coveredArea?: true
    allRoomVerandaArea?: true
    allBalconyKitchenArea?: true
    allGarageArea?: true
    carpetArea?: true
    _all?: true
  }

  export type ResidentialPropertyAssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResidentialPropertyAssessment to aggregate.
     */
    where?: ResidentialPropertyAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResidentialPropertyAssessments to fetch.
     */
    orderBy?: ResidentialPropertyAssessmentOrderByWithRelationInput | ResidentialPropertyAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResidentialPropertyAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResidentialPropertyAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResidentialPropertyAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResidentialPropertyAssessments
    **/
    _count?: true | ResidentialPropertyAssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResidentialPropertyAssessmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResidentialPropertyAssessmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResidentialPropertyAssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResidentialPropertyAssessmentMaxAggregateInputType
  }

  export type GetResidentialPropertyAssessmentAggregateType<T extends ResidentialPropertyAssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateResidentialPropertyAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResidentialPropertyAssessment[P]>
      : GetScalarType<T[P], AggregateResidentialPropertyAssessment[P]>
  }




  export type ResidentialPropertyAssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResidentialPropertyAssessmentWhereInput
    orderBy?: ResidentialPropertyAssessmentOrderByWithAggregationInput | ResidentialPropertyAssessmentOrderByWithAggregationInput[]
    by: ResidentialPropertyAssessmentScalarFieldEnum[] | ResidentialPropertyAssessmentScalarFieldEnum
    having?: ResidentialPropertyAssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResidentialPropertyAssessmentCountAggregateInputType | true
    _avg?: ResidentialPropertyAssessmentAvgAggregateInputType
    _sum?: ResidentialPropertyAssessmentSumAggregateInputType
    _min?: ResidentialPropertyAssessmentMinAggregateInputType
    _max?: ResidentialPropertyAssessmentMaxAggregateInputType
  }

  export type ResidentialPropertyAssessmentGroupByOutputType = {
    floorAssessmentId: string
    surveyUniqueCode: string
    floorNumber: string
    occupancyStatusId: string
    constructionNatureId: string
    coveredArea: Decimal
    allRoomVerandaArea: Decimal
    allBalconyKitchenArea: Decimal
    allGarageArea: Decimal
    carpetArea: Decimal
    _count: ResidentialPropertyAssessmentCountAggregateOutputType | null
    _avg: ResidentialPropertyAssessmentAvgAggregateOutputType | null
    _sum: ResidentialPropertyAssessmentSumAggregateOutputType | null
    _min: ResidentialPropertyAssessmentMinAggregateOutputType | null
    _max: ResidentialPropertyAssessmentMaxAggregateOutputType | null
  }

  type GetResidentialPropertyAssessmentGroupByPayload<T extends ResidentialPropertyAssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResidentialPropertyAssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResidentialPropertyAssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResidentialPropertyAssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], ResidentialPropertyAssessmentGroupByOutputType[P]>
        }
      >
    >


  export type ResidentialPropertyAssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    floorAssessmentId?: boolean
    surveyUniqueCode?: boolean
    floorNumber?: boolean
    occupancyStatusId?: boolean
    constructionNatureId?: boolean
    coveredArea?: boolean
    allRoomVerandaArea?: boolean
    allBalconyKitchenArea?: boolean
    allGarageArea?: boolean
    carpetArea?: boolean
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    occupancyStatus?: boolean | OccupancyStatusMasterDefaultArgs<ExtArgs>
    constructionNature?: boolean | ConstructionNatureMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["residentialPropertyAssessment"]>

  export type ResidentialPropertyAssessmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    floorAssessmentId?: boolean
    surveyUniqueCode?: boolean
    floorNumber?: boolean
    occupancyStatusId?: boolean
    constructionNatureId?: boolean
    coveredArea?: boolean
    allRoomVerandaArea?: boolean
    allBalconyKitchenArea?: boolean
    allGarageArea?: boolean
    carpetArea?: boolean
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    occupancyStatus?: boolean | OccupancyStatusMasterDefaultArgs<ExtArgs>
    constructionNature?: boolean | ConstructionNatureMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["residentialPropertyAssessment"]>

  export type ResidentialPropertyAssessmentSelectScalar = {
    floorAssessmentId?: boolean
    surveyUniqueCode?: boolean
    floorNumber?: boolean
    occupancyStatusId?: boolean
    constructionNatureId?: boolean
    coveredArea?: boolean
    allRoomVerandaArea?: boolean
    allBalconyKitchenArea?: boolean
    allGarageArea?: boolean
    carpetArea?: boolean
  }

  export type ResidentialPropertyAssessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    occupancyStatus?: boolean | OccupancyStatusMasterDefaultArgs<ExtArgs>
    constructionNature?: boolean | ConstructionNatureMasterDefaultArgs<ExtArgs>
  }
  export type ResidentialPropertyAssessmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
    occupancyStatus?: boolean | OccupancyStatusMasterDefaultArgs<ExtArgs>
    constructionNature?: boolean | ConstructionNatureMasterDefaultArgs<ExtArgs>
  }

  export type $ResidentialPropertyAssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResidentialPropertyAssessment"
    objects: {
      survey: Prisma.$SurveyDetailsPayload<ExtArgs>
      occupancyStatus: Prisma.$OccupancyStatusMasterPayload<ExtArgs>
      constructionNature: Prisma.$ConstructionNatureMasterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      floorAssessmentId: string
      surveyUniqueCode: string
      floorNumber: string
      occupancyStatusId: string
      constructionNatureId: string
      coveredArea: Prisma.Decimal
      allRoomVerandaArea: Prisma.Decimal
      allBalconyKitchenArea: Prisma.Decimal
      allGarageArea: Prisma.Decimal
      carpetArea: Prisma.Decimal
    }, ExtArgs["result"]["residentialPropertyAssessment"]>
    composites: {}
  }

  type ResidentialPropertyAssessmentGetPayload<S extends boolean | null | undefined | ResidentialPropertyAssessmentDefaultArgs> = $Result.GetResult<Prisma.$ResidentialPropertyAssessmentPayload, S>

  type ResidentialPropertyAssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResidentialPropertyAssessmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResidentialPropertyAssessmentCountAggregateInputType | true
    }

  export interface ResidentialPropertyAssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResidentialPropertyAssessment'], meta: { name: 'ResidentialPropertyAssessment' } }
    /**
     * Find zero or one ResidentialPropertyAssessment that matches the filter.
     * @param {ResidentialPropertyAssessmentFindUniqueArgs} args - Arguments to find a ResidentialPropertyAssessment
     * @example
     * // Get one ResidentialPropertyAssessment
     * const residentialPropertyAssessment = await prisma.residentialPropertyAssessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResidentialPropertyAssessmentFindUniqueArgs>(args: SelectSubset<T, ResidentialPropertyAssessmentFindUniqueArgs<ExtArgs>>): Prisma__ResidentialPropertyAssessmentClient<$Result.GetResult<Prisma.$ResidentialPropertyAssessmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ResidentialPropertyAssessment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResidentialPropertyAssessmentFindUniqueOrThrowArgs} args - Arguments to find a ResidentialPropertyAssessment
     * @example
     * // Get one ResidentialPropertyAssessment
     * const residentialPropertyAssessment = await prisma.residentialPropertyAssessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResidentialPropertyAssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ResidentialPropertyAssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResidentialPropertyAssessmentClient<$Result.GetResult<Prisma.$ResidentialPropertyAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ResidentialPropertyAssessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentialPropertyAssessmentFindFirstArgs} args - Arguments to find a ResidentialPropertyAssessment
     * @example
     * // Get one ResidentialPropertyAssessment
     * const residentialPropertyAssessment = await prisma.residentialPropertyAssessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResidentialPropertyAssessmentFindFirstArgs>(args?: SelectSubset<T, ResidentialPropertyAssessmentFindFirstArgs<ExtArgs>>): Prisma__ResidentialPropertyAssessmentClient<$Result.GetResult<Prisma.$ResidentialPropertyAssessmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ResidentialPropertyAssessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentialPropertyAssessmentFindFirstOrThrowArgs} args - Arguments to find a ResidentialPropertyAssessment
     * @example
     * // Get one ResidentialPropertyAssessment
     * const residentialPropertyAssessment = await prisma.residentialPropertyAssessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResidentialPropertyAssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ResidentialPropertyAssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResidentialPropertyAssessmentClient<$Result.GetResult<Prisma.$ResidentialPropertyAssessmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ResidentialPropertyAssessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentialPropertyAssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResidentialPropertyAssessments
     * const residentialPropertyAssessments = await prisma.residentialPropertyAssessment.findMany()
     * 
     * // Get first 10 ResidentialPropertyAssessments
     * const residentialPropertyAssessments = await prisma.residentialPropertyAssessment.findMany({ take: 10 })
     * 
     * // Only select the `floorAssessmentId`
     * const residentialPropertyAssessmentWithFloorAssessmentIdOnly = await prisma.residentialPropertyAssessment.findMany({ select: { floorAssessmentId: true } })
     * 
     */
    findMany<T extends ResidentialPropertyAssessmentFindManyArgs>(args?: SelectSubset<T, ResidentialPropertyAssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResidentialPropertyAssessmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ResidentialPropertyAssessment.
     * @param {ResidentialPropertyAssessmentCreateArgs} args - Arguments to create a ResidentialPropertyAssessment.
     * @example
     * // Create one ResidentialPropertyAssessment
     * const ResidentialPropertyAssessment = await prisma.residentialPropertyAssessment.create({
     *   data: {
     *     // ... data to create a ResidentialPropertyAssessment
     *   }
     * })
     * 
     */
    create<T extends ResidentialPropertyAssessmentCreateArgs>(args: SelectSubset<T, ResidentialPropertyAssessmentCreateArgs<ExtArgs>>): Prisma__ResidentialPropertyAssessmentClient<$Result.GetResult<Prisma.$ResidentialPropertyAssessmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ResidentialPropertyAssessments.
     * @param {ResidentialPropertyAssessmentCreateManyArgs} args - Arguments to create many ResidentialPropertyAssessments.
     * @example
     * // Create many ResidentialPropertyAssessments
     * const residentialPropertyAssessment = await prisma.residentialPropertyAssessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResidentialPropertyAssessmentCreateManyArgs>(args?: SelectSubset<T, ResidentialPropertyAssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResidentialPropertyAssessments and returns the data saved in the database.
     * @param {ResidentialPropertyAssessmentCreateManyAndReturnArgs} args - Arguments to create many ResidentialPropertyAssessments.
     * @example
     * // Create many ResidentialPropertyAssessments
     * const residentialPropertyAssessment = await prisma.residentialPropertyAssessment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResidentialPropertyAssessments and only return the `floorAssessmentId`
     * const residentialPropertyAssessmentWithFloorAssessmentIdOnly = await prisma.residentialPropertyAssessment.createManyAndReturn({ 
     *   select: { floorAssessmentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResidentialPropertyAssessmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ResidentialPropertyAssessmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResidentialPropertyAssessmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ResidentialPropertyAssessment.
     * @param {ResidentialPropertyAssessmentDeleteArgs} args - Arguments to delete one ResidentialPropertyAssessment.
     * @example
     * // Delete one ResidentialPropertyAssessment
     * const ResidentialPropertyAssessment = await prisma.residentialPropertyAssessment.delete({
     *   where: {
     *     // ... filter to delete one ResidentialPropertyAssessment
     *   }
     * })
     * 
     */
    delete<T extends ResidentialPropertyAssessmentDeleteArgs>(args: SelectSubset<T, ResidentialPropertyAssessmentDeleteArgs<ExtArgs>>): Prisma__ResidentialPropertyAssessmentClient<$Result.GetResult<Prisma.$ResidentialPropertyAssessmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ResidentialPropertyAssessment.
     * @param {ResidentialPropertyAssessmentUpdateArgs} args - Arguments to update one ResidentialPropertyAssessment.
     * @example
     * // Update one ResidentialPropertyAssessment
     * const residentialPropertyAssessment = await prisma.residentialPropertyAssessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResidentialPropertyAssessmentUpdateArgs>(args: SelectSubset<T, ResidentialPropertyAssessmentUpdateArgs<ExtArgs>>): Prisma__ResidentialPropertyAssessmentClient<$Result.GetResult<Prisma.$ResidentialPropertyAssessmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ResidentialPropertyAssessments.
     * @param {ResidentialPropertyAssessmentDeleteManyArgs} args - Arguments to filter ResidentialPropertyAssessments to delete.
     * @example
     * // Delete a few ResidentialPropertyAssessments
     * const { count } = await prisma.residentialPropertyAssessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResidentialPropertyAssessmentDeleteManyArgs>(args?: SelectSubset<T, ResidentialPropertyAssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResidentialPropertyAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentialPropertyAssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResidentialPropertyAssessments
     * const residentialPropertyAssessment = await prisma.residentialPropertyAssessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResidentialPropertyAssessmentUpdateManyArgs>(args: SelectSubset<T, ResidentialPropertyAssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResidentialPropertyAssessment.
     * @param {ResidentialPropertyAssessmentUpsertArgs} args - Arguments to update or create a ResidentialPropertyAssessment.
     * @example
     * // Update or create a ResidentialPropertyAssessment
     * const residentialPropertyAssessment = await prisma.residentialPropertyAssessment.upsert({
     *   create: {
     *     // ... data to create a ResidentialPropertyAssessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResidentialPropertyAssessment we want to update
     *   }
     * })
     */
    upsert<T extends ResidentialPropertyAssessmentUpsertArgs>(args: SelectSubset<T, ResidentialPropertyAssessmentUpsertArgs<ExtArgs>>): Prisma__ResidentialPropertyAssessmentClient<$Result.GetResult<Prisma.$ResidentialPropertyAssessmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ResidentialPropertyAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentialPropertyAssessmentCountArgs} args - Arguments to filter ResidentialPropertyAssessments to count.
     * @example
     * // Count the number of ResidentialPropertyAssessments
     * const count = await prisma.residentialPropertyAssessment.count({
     *   where: {
     *     // ... the filter for the ResidentialPropertyAssessments we want to count
     *   }
     * })
    **/
    count<T extends ResidentialPropertyAssessmentCountArgs>(
      args?: Subset<T, ResidentialPropertyAssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResidentialPropertyAssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResidentialPropertyAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentialPropertyAssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResidentialPropertyAssessmentAggregateArgs>(args: Subset<T, ResidentialPropertyAssessmentAggregateArgs>): Prisma.PrismaPromise<GetResidentialPropertyAssessmentAggregateType<T>>

    /**
     * Group by ResidentialPropertyAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentialPropertyAssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResidentialPropertyAssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResidentialPropertyAssessmentGroupByArgs['orderBy'] }
        : { orderBy?: ResidentialPropertyAssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResidentialPropertyAssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResidentialPropertyAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResidentialPropertyAssessment model
   */
  readonly fields: ResidentialPropertyAssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResidentialPropertyAssessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResidentialPropertyAssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDetailsDefaultArgs<ExtArgs>>): Prisma__SurveyDetailsClient<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    occupancyStatus<T extends OccupancyStatusMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OccupancyStatusMasterDefaultArgs<ExtArgs>>): Prisma__OccupancyStatusMasterClient<$Result.GetResult<Prisma.$OccupancyStatusMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    constructionNature<T extends ConstructionNatureMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionNatureMasterDefaultArgs<ExtArgs>>): Prisma__ConstructionNatureMasterClient<$Result.GetResult<Prisma.$ConstructionNatureMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResidentialPropertyAssessment model
   */ 
  interface ResidentialPropertyAssessmentFieldRefs {
    readonly floorAssessmentId: FieldRef<"ResidentialPropertyAssessment", 'String'>
    readonly surveyUniqueCode: FieldRef<"ResidentialPropertyAssessment", 'String'>
    readonly floorNumber: FieldRef<"ResidentialPropertyAssessment", 'String'>
    readonly occupancyStatusId: FieldRef<"ResidentialPropertyAssessment", 'String'>
    readonly constructionNatureId: FieldRef<"ResidentialPropertyAssessment", 'String'>
    readonly coveredArea: FieldRef<"ResidentialPropertyAssessment", 'Decimal'>
    readonly allRoomVerandaArea: FieldRef<"ResidentialPropertyAssessment", 'Decimal'>
    readonly allBalconyKitchenArea: FieldRef<"ResidentialPropertyAssessment", 'Decimal'>
    readonly allGarageArea: FieldRef<"ResidentialPropertyAssessment", 'Decimal'>
    readonly carpetArea: FieldRef<"ResidentialPropertyAssessment", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * ResidentialPropertyAssessment findUnique
   */
  export type ResidentialPropertyAssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidentialPropertyAssessment
     */
    select?: ResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which ResidentialPropertyAssessment to fetch.
     */
    where: ResidentialPropertyAssessmentWhereUniqueInput
  }

  /**
   * ResidentialPropertyAssessment findUniqueOrThrow
   */
  export type ResidentialPropertyAssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidentialPropertyAssessment
     */
    select?: ResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which ResidentialPropertyAssessment to fetch.
     */
    where: ResidentialPropertyAssessmentWhereUniqueInput
  }

  /**
   * ResidentialPropertyAssessment findFirst
   */
  export type ResidentialPropertyAssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidentialPropertyAssessment
     */
    select?: ResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which ResidentialPropertyAssessment to fetch.
     */
    where?: ResidentialPropertyAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResidentialPropertyAssessments to fetch.
     */
    orderBy?: ResidentialPropertyAssessmentOrderByWithRelationInput | ResidentialPropertyAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResidentialPropertyAssessments.
     */
    cursor?: ResidentialPropertyAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResidentialPropertyAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResidentialPropertyAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResidentialPropertyAssessments.
     */
    distinct?: ResidentialPropertyAssessmentScalarFieldEnum | ResidentialPropertyAssessmentScalarFieldEnum[]
  }

  /**
   * ResidentialPropertyAssessment findFirstOrThrow
   */
  export type ResidentialPropertyAssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidentialPropertyAssessment
     */
    select?: ResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which ResidentialPropertyAssessment to fetch.
     */
    where?: ResidentialPropertyAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResidentialPropertyAssessments to fetch.
     */
    orderBy?: ResidentialPropertyAssessmentOrderByWithRelationInput | ResidentialPropertyAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResidentialPropertyAssessments.
     */
    cursor?: ResidentialPropertyAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResidentialPropertyAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResidentialPropertyAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResidentialPropertyAssessments.
     */
    distinct?: ResidentialPropertyAssessmentScalarFieldEnum | ResidentialPropertyAssessmentScalarFieldEnum[]
  }

  /**
   * ResidentialPropertyAssessment findMany
   */
  export type ResidentialPropertyAssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidentialPropertyAssessment
     */
    select?: ResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which ResidentialPropertyAssessments to fetch.
     */
    where?: ResidentialPropertyAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResidentialPropertyAssessments to fetch.
     */
    orderBy?: ResidentialPropertyAssessmentOrderByWithRelationInput | ResidentialPropertyAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResidentialPropertyAssessments.
     */
    cursor?: ResidentialPropertyAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResidentialPropertyAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResidentialPropertyAssessments.
     */
    skip?: number
    distinct?: ResidentialPropertyAssessmentScalarFieldEnum | ResidentialPropertyAssessmentScalarFieldEnum[]
  }

  /**
   * ResidentialPropertyAssessment create
   */
  export type ResidentialPropertyAssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidentialPropertyAssessment
     */
    select?: ResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ResidentialPropertyAssessment.
     */
    data: XOR<ResidentialPropertyAssessmentCreateInput, ResidentialPropertyAssessmentUncheckedCreateInput>
  }

  /**
   * ResidentialPropertyAssessment createMany
   */
  export type ResidentialPropertyAssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResidentialPropertyAssessments.
     */
    data: ResidentialPropertyAssessmentCreateManyInput | ResidentialPropertyAssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResidentialPropertyAssessment createManyAndReturn
   */
  export type ResidentialPropertyAssessmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidentialPropertyAssessment
     */
    select?: ResidentialPropertyAssessmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ResidentialPropertyAssessments.
     */
    data: ResidentialPropertyAssessmentCreateManyInput | ResidentialPropertyAssessmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentialPropertyAssessmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResidentialPropertyAssessment update
   */
  export type ResidentialPropertyAssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidentialPropertyAssessment
     */
    select?: ResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ResidentialPropertyAssessment.
     */
    data: XOR<ResidentialPropertyAssessmentUpdateInput, ResidentialPropertyAssessmentUncheckedUpdateInput>
    /**
     * Choose, which ResidentialPropertyAssessment to update.
     */
    where: ResidentialPropertyAssessmentWhereUniqueInput
  }

  /**
   * ResidentialPropertyAssessment updateMany
   */
  export type ResidentialPropertyAssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResidentialPropertyAssessments.
     */
    data: XOR<ResidentialPropertyAssessmentUpdateManyMutationInput, ResidentialPropertyAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which ResidentialPropertyAssessments to update
     */
    where?: ResidentialPropertyAssessmentWhereInput
  }

  /**
   * ResidentialPropertyAssessment upsert
   */
  export type ResidentialPropertyAssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidentialPropertyAssessment
     */
    select?: ResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ResidentialPropertyAssessment to update in case it exists.
     */
    where: ResidentialPropertyAssessmentWhereUniqueInput
    /**
     * In case the ResidentialPropertyAssessment found by the `where` argument doesn't exist, create a new ResidentialPropertyAssessment with this data.
     */
    create: XOR<ResidentialPropertyAssessmentCreateInput, ResidentialPropertyAssessmentUncheckedCreateInput>
    /**
     * In case the ResidentialPropertyAssessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResidentialPropertyAssessmentUpdateInput, ResidentialPropertyAssessmentUncheckedUpdateInput>
  }

  /**
   * ResidentialPropertyAssessment delete
   */
  export type ResidentialPropertyAssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidentialPropertyAssessment
     */
    select?: ResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter which ResidentialPropertyAssessment to delete.
     */
    where: ResidentialPropertyAssessmentWhereUniqueInput
  }

  /**
   * ResidentialPropertyAssessment deleteMany
   */
  export type ResidentialPropertyAssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResidentialPropertyAssessments to delete
     */
    where?: ResidentialPropertyAssessmentWhereInput
  }

  /**
   * ResidentialPropertyAssessment without action
   */
  export type ResidentialPropertyAssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidentialPropertyAssessment
     */
    select?: ResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentialPropertyAssessmentInclude<ExtArgs> | null
  }


  /**
   * Model NonResidentialPropertyAssessment
   */

  export type AggregateNonResidentialPropertyAssessment = {
    _count: NonResidentialPropertyAssessmentCountAggregateOutputType | null
    _avg: NonResidentialPropertyAssessmentAvgAggregateOutputType | null
    _sum: NonResidentialPropertyAssessmentSumAggregateOutputType | null
    _min: NonResidentialPropertyAssessmentMinAggregateOutputType | null
    _max: NonResidentialPropertyAssessmentMaxAggregateOutputType | null
  }

  export type NonResidentialPropertyAssessmentAvgAggregateOutputType = {
    builtupArea: Decimal | null
  }

  export type NonResidentialPropertyAssessmentSumAggregateOutputType = {
    builtupArea: Decimal | null
  }

  export type NonResidentialPropertyAssessmentMinAggregateOutputType = {
    floorAssessmentId: string | null
    surveyUniqueCode: string | null
    floorNumber: string | null
    nrPropertyCategoryId: string | null
    nrSubCategoryId: string | null
    establishmentName: string | null
    licenseNo: string | null
    licenseExpiryDate: Date | null
    occupancyStatusId: string | null
    constructionNatureId: string | null
    builtupArea: Decimal | null
  }

  export type NonResidentialPropertyAssessmentMaxAggregateOutputType = {
    floorAssessmentId: string | null
    surveyUniqueCode: string | null
    floorNumber: string | null
    nrPropertyCategoryId: string | null
    nrSubCategoryId: string | null
    establishmentName: string | null
    licenseNo: string | null
    licenseExpiryDate: Date | null
    occupancyStatusId: string | null
    constructionNatureId: string | null
    builtupArea: Decimal | null
  }

  export type NonResidentialPropertyAssessmentCountAggregateOutputType = {
    floorAssessmentId: number
    surveyUniqueCode: number
    floorNumber: number
    nrPropertyCategoryId: number
    nrSubCategoryId: number
    establishmentName: number
    licenseNo: number
    licenseExpiryDate: number
    occupancyStatusId: number
    constructionNatureId: number
    builtupArea: number
    _all: number
  }


  export type NonResidentialPropertyAssessmentAvgAggregateInputType = {
    builtupArea?: true
  }

  export type NonResidentialPropertyAssessmentSumAggregateInputType = {
    builtupArea?: true
  }

  export type NonResidentialPropertyAssessmentMinAggregateInputType = {
    floorAssessmentId?: true
    surveyUniqueCode?: true
    floorNumber?: true
    nrPropertyCategoryId?: true
    nrSubCategoryId?: true
    establishmentName?: true
    licenseNo?: true
    licenseExpiryDate?: true
    occupancyStatusId?: true
    constructionNatureId?: true
    builtupArea?: true
  }

  export type NonResidentialPropertyAssessmentMaxAggregateInputType = {
    floorAssessmentId?: true
    surveyUniqueCode?: true
    floorNumber?: true
    nrPropertyCategoryId?: true
    nrSubCategoryId?: true
    establishmentName?: true
    licenseNo?: true
    licenseExpiryDate?: true
    occupancyStatusId?: true
    constructionNatureId?: true
    builtupArea?: true
  }

  export type NonResidentialPropertyAssessmentCountAggregateInputType = {
    floorAssessmentId?: true
    surveyUniqueCode?: true
    floorNumber?: true
    nrPropertyCategoryId?: true
    nrSubCategoryId?: true
    establishmentName?: true
    licenseNo?: true
    licenseExpiryDate?: true
    occupancyStatusId?: true
    constructionNatureId?: true
    builtupArea?: true
    _all?: true
  }

  export type NonResidentialPropertyAssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NonResidentialPropertyAssessment to aggregate.
     */
    where?: NonResidentialPropertyAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonResidentialPropertyAssessments to fetch.
     */
    orderBy?: NonResidentialPropertyAssessmentOrderByWithRelationInput | NonResidentialPropertyAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NonResidentialPropertyAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonResidentialPropertyAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonResidentialPropertyAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NonResidentialPropertyAssessments
    **/
    _count?: true | NonResidentialPropertyAssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NonResidentialPropertyAssessmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NonResidentialPropertyAssessmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NonResidentialPropertyAssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NonResidentialPropertyAssessmentMaxAggregateInputType
  }

  export type GetNonResidentialPropertyAssessmentAggregateType<T extends NonResidentialPropertyAssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateNonResidentialPropertyAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNonResidentialPropertyAssessment[P]>
      : GetScalarType<T[P], AggregateNonResidentialPropertyAssessment[P]>
  }




  export type NonResidentialPropertyAssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NonResidentialPropertyAssessmentWhereInput
    orderBy?: NonResidentialPropertyAssessmentOrderByWithAggregationInput | NonResidentialPropertyAssessmentOrderByWithAggregationInput[]
    by: NonResidentialPropertyAssessmentScalarFieldEnum[] | NonResidentialPropertyAssessmentScalarFieldEnum
    having?: NonResidentialPropertyAssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NonResidentialPropertyAssessmentCountAggregateInputType | true
    _avg?: NonResidentialPropertyAssessmentAvgAggregateInputType
    _sum?: NonResidentialPropertyAssessmentSumAggregateInputType
    _min?: NonResidentialPropertyAssessmentMinAggregateInputType
    _max?: NonResidentialPropertyAssessmentMaxAggregateInputType
  }

  export type NonResidentialPropertyAssessmentGroupByOutputType = {
    floorAssessmentId: string
    surveyUniqueCode: string
    floorNumber: string
    nrPropertyCategoryId: string
    nrSubCategoryId: string
    establishmentName: string
    licenseNo: string | null
    licenseExpiryDate: Date | null
    occupancyStatusId: string
    constructionNatureId: string
    builtupArea: Decimal
    _count: NonResidentialPropertyAssessmentCountAggregateOutputType | null
    _avg: NonResidentialPropertyAssessmentAvgAggregateOutputType | null
    _sum: NonResidentialPropertyAssessmentSumAggregateOutputType | null
    _min: NonResidentialPropertyAssessmentMinAggregateOutputType | null
    _max: NonResidentialPropertyAssessmentMaxAggregateOutputType | null
  }

  type GetNonResidentialPropertyAssessmentGroupByPayload<T extends NonResidentialPropertyAssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NonResidentialPropertyAssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NonResidentialPropertyAssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NonResidentialPropertyAssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], NonResidentialPropertyAssessmentGroupByOutputType[P]>
        }
      >
    >


  export type NonResidentialPropertyAssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    floorAssessmentId?: boolean
    surveyUniqueCode?: boolean
    floorNumber?: boolean
    nrPropertyCategoryId?: boolean
    nrSubCategoryId?: boolean
    establishmentName?: boolean
    licenseNo?: boolean
    licenseExpiryDate?: boolean
    occupancyStatusId?: boolean
    constructionNatureId?: boolean
    builtupArea?: boolean
    nrPropertyCategory?: boolean | NrPropertyCategoryMasterDefaultArgs<ExtArgs>
    nrSubCategory?: boolean | NrPropertySubCategoryMasterDefaultArgs<ExtArgs>
    occupancyStatus?: boolean | OccupancyStatusMasterDefaultArgs<ExtArgs>
    constructionNature?: boolean | ConstructionNatureMasterDefaultArgs<ExtArgs>
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nonResidentialPropertyAssessment"]>

  export type NonResidentialPropertyAssessmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    floorAssessmentId?: boolean
    surveyUniqueCode?: boolean
    floorNumber?: boolean
    nrPropertyCategoryId?: boolean
    nrSubCategoryId?: boolean
    establishmentName?: boolean
    licenseNo?: boolean
    licenseExpiryDate?: boolean
    occupancyStatusId?: boolean
    constructionNatureId?: boolean
    builtupArea?: boolean
    nrPropertyCategory?: boolean | NrPropertyCategoryMasterDefaultArgs<ExtArgs>
    nrSubCategory?: boolean | NrPropertySubCategoryMasterDefaultArgs<ExtArgs>
    occupancyStatus?: boolean | OccupancyStatusMasterDefaultArgs<ExtArgs>
    constructionNature?: boolean | ConstructionNatureMasterDefaultArgs<ExtArgs>
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nonResidentialPropertyAssessment"]>

  export type NonResidentialPropertyAssessmentSelectScalar = {
    floorAssessmentId?: boolean
    surveyUniqueCode?: boolean
    floorNumber?: boolean
    nrPropertyCategoryId?: boolean
    nrSubCategoryId?: boolean
    establishmentName?: boolean
    licenseNo?: boolean
    licenseExpiryDate?: boolean
    occupancyStatusId?: boolean
    constructionNatureId?: boolean
    builtupArea?: boolean
  }

  export type NonResidentialPropertyAssessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nrPropertyCategory?: boolean | NrPropertyCategoryMasterDefaultArgs<ExtArgs>
    nrSubCategory?: boolean | NrPropertySubCategoryMasterDefaultArgs<ExtArgs>
    occupancyStatus?: boolean | OccupancyStatusMasterDefaultArgs<ExtArgs>
    constructionNature?: boolean | ConstructionNatureMasterDefaultArgs<ExtArgs>
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
  }
  export type NonResidentialPropertyAssessmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nrPropertyCategory?: boolean | NrPropertyCategoryMasterDefaultArgs<ExtArgs>
    nrSubCategory?: boolean | NrPropertySubCategoryMasterDefaultArgs<ExtArgs>
    occupancyStatus?: boolean | OccupancyStatusMasterDefaultArgs<ExtArgs>
    constructionNature?: boolean | ConstructionNatureMasterDefaultArgs<ExtArgs>
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
  }

  export type $NonResidentialPropertyAssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NonResidentialPropertyAssessment"
    objects: {
      nrPropertyCategory: Prisma.$NrPropertyCategoryMasterPayload<ExtArgs>
      nrSubCategory: Prisma.$NrPropertySubCategoryMasterPayload<ExtArgs>
      occupancyStatus: Prisma.$OccupancyStatusMasterPayload<ExtArgs>
      constructionNature: Prisma.$ConstructionNatureMasterPayload<ExtArgs>
      survey: Prisma.$SurveyDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      floorAssessmentId: string
      surveyUniqueCode: string
      floorNumber: string
      nrPropertyCategoryId: string
      nrSubCategoryId: string
      establishmentName: string
      licenseNo: string | null
      licenseExpiryDate: Date | null
      occupancyStatusId: string
      constructionNatureId: string
      builtupArea: Prisma.Decimal
    }, ExtArgs["result"]["nonResidentialPropertyAssessment"]>
    composites: {}
  }

  type NonResidentialPropertyAssessmentGetPayload<S extends boolean | null | undefined | NonResidentialPropertyAssessmentDefaultArgs> = $Result.GetResult<Prisma.$NonResidentialPropertyAssessmentPayload, S>

  type NonResidentialPropertyAssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NonResidentialPropertyAssessmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NonResidentialPropertyAssessmentCountAggregateInputType | true
    }

  export interface NonResidentialPropertyAssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NonResidentialPropertyAssessment'], meta: { name: 'NonResidentialPropertyAssessment' } }
    /**
     * Find zero or one NonResidentialPropertyAssessment that matches the filter.
     * @param {NonResidentialPropertyAssessmentFindUniqueArgs} args - Arguments to find a NonResidentialPropertyAssessment
     * @example
     * // Get one NonResidentialPropertyAssessment
     * const nonResidentialPropertyAssessment = await prisma.nonResidentialPropertyAssessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NonResidentialPropertyAssessmentFindUniqueArgs>(args: SelectSubset<T, NonResidentialPropertyAssessmentFindUniqueArgs<ExtArgs>>): Prisma__NonResidentialPropertyAssessmentClient<$Result.GetResult<Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NonResidentialPropertyAssessment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NonResidentialPropertyAssessmentFindUniqueOrThrowArgs} args - Arguments to find a NonResidentialPropertyAssessment
     * @example
     * // Get one NonResidentialPropertyAssessment
     * const nonResidentialPropertyAssessment = await prisma.nonResidentialPropertyAssessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NonResidentialPropertyAssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, NonResidentialPropertyAssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NonResidentialPropertyAssessmentClient<$Result.GetResult<Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NonResidentialPropertyAssessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonResidentialPropertyAssessmentFindFirstArgs} args - Arguments to find a NonResidentialPropertyAssessment
     * @example
     * // Get one NonResidentialPropertyAssessment
     * const nonResidentialPropertyAssessment = await prisma.nonResidentialPropertyAssessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NonResidentialPropertyAssessmentFindFirstArgs>(args?: SelectSubset<T, NonResidentialPropertyAssessmentFindFirstArgs<ExtArgs>>): Prisma__NonResidentialPropertyAssessmentClient<$Result.GetResult<Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NonResidentialPropertyAssessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonResidentialPropertyAssessmentFindFirstOrThrowArgs} args - Arguments to find a NonResidentialPropertyAssessment
     * @example
     * // Get one NonResidentialPropertyAssessment
     * const nonResidentialPropertyAssessment = await prisma.nonResidentialPropertyAssessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NonResidentialPropertyAssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, NonResidentialPropertyAssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__NonResidentialPropertyAssessmentClient<$Result.GetResult<Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NonResidentialPropertyAssessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonResidentialPropertyAssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NonResidentialPropertyAssessments
     * const nonResidentialPropertyAssessments = await prisma.nonResidentialPropertyAssessment.findMany()
     * 
     * // Get first 10 NonResidentialPropertyAssessments
     * const nonResidentialPropertyAssessments = await prisma.nonResidentialPropertyAssessment.findMany({ take: 10 })
     * 
     * // Only select the `floorAssessmentId`
     * const nonResidentialPropertyAssessmentWithFloorAssessmentIdOnly = await prisma.nonResidentialPropertyAssessment.findMany({ select: { floorAssessmentId: true } })
     * 
     */
    findMany<T extends NonResidentialPropertyAssessmentFindManyArgs>(args?: SelectSubset<T, NonResidentialPropertyAssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NonResidentialPropertyAssessment.
     * @param {NonResidentialPropertyAssessmentCreateArgs} args - Arguments to create a NonResidentialPropertyAssessment.
     * @example
     * // Create one NonResidentialPropertyAssessment
     * const NonResidentialPropertyAssessment = await prisma.nonResidentialPropertyAssessment.create({
     *   data: {
     *     // ... data to create a NonResidentialPropertyAssessment
     *   }
     * })
     * 
     */
    create<T extends NonResidentialPropertyAssessmentCreateArgs>(args: SelectSubset<T, NonResidentialPropertyAssessmentCreateArgs<ExtArgs>>): Prisma__NonResidentialPropertyAssessmentClient<$Result.GetResult<Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NonResidentialPropertyAssessments.
     * @param {NonResidentialPropertyAssessmentCreateManyArgs} args - Arguments to create many NonResidentialPropertyAssessments.
     * @example
     * // Create many NonResidentialPropertyAssessments
     * const nonResidentialPropertyAssessment = await prisma.nonResidentialPropertyAssessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NonResidentialPropertyAssessmentCreateManyArgs>(args?: SelectSubset<T, NonResidentialPropertyAssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NonResidentialPropertyAssessments and returns the data saved in the database.
     * @param {NonResidentialPropertyAssessmentCreateManyAndReturnArgs} args - Arguments to create many NonResidentialPropertyAssessments.
     * @example
     * // Create many NonResidentialPropertyAssessments
     * const nonResidentialPropertyAssessment = await prisma.nonResidentialPropertyAssessment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NonResidentialPropertyAssessments and only return the `floorAssessmentId`
     * const nonResidentialPropertyAssessmentWithFloorAssessmentIdOnly = await prisma.nonResidentialPropertyAssessment.createManyAndReturn({ 
     *   select: { floorAssessmentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NonResidentialPropertyAssessmentCreateManyAndReturnArgs>(args?: SelectSubset<T, NonResidentialPropertyAssessmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NonResidentialPropertyAssessment.
     * @param {NonResidentialPropertyAssessmentDeleteArgs} args - Arguments to delete one NonResidentialPropertyAssessment.
     * @example
     * // Delete one NonResidentialPropertyAssessment
     * const NonResidentialPropertyAssessment = await prisma.nonResidentialPropertyAssessment.delete({
     *   where: {
     *     // ... filter to delete one NonResidentialPropertyAssessment
     *   }
     * })
     * 
     */
    delete<T extends NonResidentialPropertyAssessmentDeleteArgs>(args: SelectSubset<T, NonResidentialPropertyAssessmentDeleteArgs<ExtArgs>>): Prisma__NonResidentialPropertyAssessmentClient<$Result.GetResult<Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NonResidentialPropertyAssessment.
     * @param {NonResidentialPropertyAssessmentUpdateArgs} args - Arguments to update one NonResidentialPropertyAssessment.
     * @example
     * // Update one NonResidentialPropertyAssessment
     * const nonResidentialPropertyAssessment = await prisma.nonResidentialPropertyAssessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NonResidentialPropertyAssessmentUpdateArgs>(args: SelectSubset<T, NonResidentialPropertyAssessmentUpdateArgs<ExtArgs>>): Prisma__NonResidentialPropertyAssessmentClient<$Result.GetResult<Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NonResidentialPropertyAssessments.
     * @param {NonResidentialPropertyAssessmentDeleteManyArgs} args - Arguments to filter NonResidentialPropertyAssessments to delete.
     * @example
     * // Delete a few NonResidentialPropertyAssessments
     * const { count } = await prisma.nonResidentialPropertyAssessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NonResidentialPropertyAssessmentDeleteManyArgs>(args?: SelectSubset<T, NonResidentialPropertyAssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NonResidentialPropertyAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonResidentialPropertyAssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NonResidentialPropertyAssessments
     * const nonResidentialPropertyAssessment = await prisma.nonResidentialPropertyAssessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NonResidentialPropertyAssessmentUpdateManyArgs>(args: SelectSubset<T, NonResidentialPropertyAssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NonResidentialPropertyAssessment.
     * @param {NonResidentialPropertyAssessmentUpsertArgs} args - Arguments to update or create a NonResidentialPropertyAssessment.
     * @example
     * // Update or create a NonResidentialPropertyAssessment
     * const nonResidentialPropertyAssessment = await prisma.nonResidentialPropertyAssessment.upsert({
     *   create: {
     *     // ... data to create a NonResidentialPropertyAssessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NonResidentialPropertyAssessment we want to update
     *   }
     * })
     */
    upsert<T extends NonResidentialPropertyAssessmentUpsertArgs>(args: SelectSubset<T, NonResidentialPropertyAssessmentUpsertArgs<ExtArgs>>): Prisma__NonResidentialPropertyAssessmentClient<$Result.GetResult<Prisma.$NonResidentialPropertyAssessmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NonResidentialPropertyAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonResidentialPropertyAssessmentCountArgs} args - Arguments to filter NonResidentialPropertyAssessments to count.
     * @example
     * // Count the number of NonResidentialPropertyAssessments
     * const count = await prisma.nonResidentialPropertyAssessment.count({
     *   where: {
     *     // ... the filter for the NonResidentialPropertyAssessments we want to count
     *   }
     * })
    **/
    count<T extends NonResidentialPropertyAssessmentCountArgs>(
      args?: Subset<T, NonResidentialPropertyAssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NonResidentialPropertyAssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NonResidentialPropertyAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonResidentialPropertyAssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NonResidentialPropertyAssessmentAggregateArgs>(args: Subset<T, NonResidentialPropertyAssessmentAggregateArgs>): Prisma.PrismaPromise<GetNonResidentialPropertyAssessmentAggregateType<T>>

    /**
     * Group by NonResidentialPropertyAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonResidentialPropertyAssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NonResidentialPropertyAssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NonResidentialPropertyAssessmentGroupByArgs['orderBy'] }
        : { orderBy?: NonResidentialPropertyAssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NonResidentialPropertyAssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNonResidentialPropertyAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NonResidentialPropertyAssessment model
   */
  readonly fields: NonResidentialPropertyAssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NonResidentialPropertyAssessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NonResidentialPropertyAssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nrPropertyCategory<T extends NrPropertyCategoryMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NrPropertyCategoryMasterDefaultArgs<ExtArgs>>): Prisma__NrPropertyCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertyCategoryMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    nrSubCategory<T extends NrPropertySubCategoryMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NrPropertySubCategoryMasterDefaultArgs<ExtArgs>>): Prisma__NrPropertySubCategoryMasterClient<$Result.GetResult<Prisma.$NrPropertySubCategoryMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    occupancyStatus<T extends OccupancyStatusMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OccupancyStatusMasterDefaultArgs<ExtArgs>>): Prisma__OccupancyStatusMasterClient<$Result.GetResult<Prisma.$OccupancyStatusMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    constructionNature<T extends ConstructionNatureMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionNatureMasterDefaultArgs<ExtArgs>>): Prisma__ConstructionNatureMasterClient<$Result.GetResult<Prisma.$ConstructionNatureMasterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    survey<T extends SurveyDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDetailsDefaultArgs<ExtArgs>>): Prisma__SurveyDetailsClient<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NonResidentialPropertyAssessment model
   */ 
  interface NonResidentialPropertyAssessmentFieldRefs {
    readonly floorAssessmentId: FieldRef<"NonResidentialPropertyAssessment", 'String'>
    readonly surveyUniqueCode: FieldRef<"NonResidentialPropertyAssessment", 'String'>
    readonly floorNumber: FieldRef<"NonResidentialPropertyAssessment", 'String'>
    readonly nrPropertyCategoryId: FieldRef<"NonResidentialPropertyAssessment", 'String'>
    readonly nrSubCategoryId: FieldRef<"NonResidentialPropertyAssessment", 'String'>
    readonly establishmentName: FieldRef<"NonResidentialPropertyAssessment", 'String'>
    readonly licenseNo: FieldRef<"NonResidentialPropertyAssessment", 'String'>
    readonly licenseExpiryDate: FieldRef<"NonResidentialPropertyAssessment", 'DateTime'>
    readonly occupancyStatusId: FieldRef<"NonResidentialPropertyAssessment", 'String'>
    readonly constructionNatureId: FieldRef<"NonResidentialPropertyAssessment", 'String'>
    readonly builtupArea: FieldRef<"NonResidentialPropertyAssessment", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * NonResidentialPropertyAssessment findUnique
   */
  export type NonResidentialPropertyAssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonResidentialPropertyAssessment
     */
    select?: NonResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which NonResidentialPropertyAssessment to fetch.
     */
    where: NonResidentialPropertyAssessmentWhereUniqueInput
  }

  /**
   * NonResidentialPropertyAssessment findUniqueOrThrow
   */
  export type NonResidentialPropertyAssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonResidentialPropertyAssessment
     */
    select?: NonResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which NonResidentialPropertyAssessment to fetch.
     */
    where: NonResidentialPropertyAssessmentWhereUniqueInput
  }

  /**
   * NonResidentialPropertyAssessment findFirst
   */
  export type NonResidentialPropertyAssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonResidentialPropertyAssessment
     */
    select?: NonResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which NonResidentialPropertyAssessment to fetch.
     */
    where?: NonResidentialPropertyAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonResidentialPropertyAssessments to fetch.
     */
    orderBy?: NonResidentialPropertyAssessmentOrderByWithRelationInput | NonResidentialPropertyAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NonResidentialPropertyAssessments.
     */
    cursor?: NonResidentialPropertyAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonResidentialPropertyAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonResidentialPropertyAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NonResidentialPropertyAssessments.
     */
    distinct?: NonResidentialPropertyAssessmentScalarFieldEnum | NonResidentialPropertyAssessmentScalarFieldEnum[]
  }

  /**
   * NonResidentialPropertyAssessment findFirstOrThrow
   */
  export type NonResidentialPropertyAssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonResidentialPropertyAssessment
     */
    select?: NonResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which NonResidentialPropertyAssessment to fetch.
     */
    where?: NonResidentialPropertyAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonResidentialPropertyAssessments to fetch.
     */
    orderBy?: NonResidentialPropertyAssessmentOrderByWithRelationInput | NonResidentialPropertyAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NonResidentialPropertyAssessments.
     */
    cursor?: NonResidentialPropertyAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonResidentialPropertyAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonResidentialPropertyAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NonResidentialPropertyAssessments.
     */
    distinct?: NonResidentialPropertyAssessmentScalarFieldEnum | NonResidentialPropertyAssessmentScalarFieldEnum[]
  }

  /**
   * NonResidentialPropertyAssessment findMany
   */
  export type NonResidentialPropertyAssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonResidentialPropertyAssessment
     */
    select?: NonResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which NonResidentialPropertyAssessments to fetch.
     */
    where?: NonResidentialPropertyAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonResidentialPropertyAssessments to fetch.
     */
    orderBy?: NonResidentialPropertyAssessmentOrderByWithRelationInput | NonResidentialPropertyAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NonResidentialPropertyAssessments.
     */
    cursor?: NonResidentialPropertyAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonResidentialPropertyAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonResidentialPropertyAssessments.
     */
    skip?: number
    distinct?: NonResidentialPropertyAssessmentScalarFieldEnum | NonResidentialPropertyAssessmentScalarFieldEnum[]
  }

  /**
   * NonResidentialPropertyAssessment create
   */
  export type NonResidentialPropertyAssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonResidentialPropertyAssessment
     */
    select?: NonResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a NonResidentialPropertyAssessment.
     */
    data: XOR<NonResidentialPropertyAssessmentCreateInput, NonResidentialPropertyAssessmentUncheckedCreateInput>
  }

  /**
   * NonResidentialPropertyAssessment createMany
   */
  export type NonResidentialPropertyAssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NonResidentialPropertyAssessments.
     */
    data: NonResidentialPropertyAssessmentCreateManyInput | NonResidentialPropertyAssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NonResidentialPropertyAssessment createManyAndReturn
   */
  export type NonResidentialPropertyAssessmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonResidentialPropertyAssessment
     */
    select?: NonResidentialPropertyAssessmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NonResidentialPropertyAssessments.
     */
    data: NonResidentialPropertyAssessmentCreateManyInput | NonResidentialPropertyAssessmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonResidentialPropertyAssessmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NonResidentialPropertyAssessment update
   */
  export type NonResidentialPropertyAssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonResidentialPropertyAssessment
     */
    select?: NonResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a NonResidentialPropertyAssessment.
     */
    data: XOR<NonResidentialPropertyAssessmentUpdateInput, NonResidentialPropertyAssessmentUncheckedUpdateInput>
    /**
     * Choose, which NonResidentialPropertyAssessment to update.
     */
    where: NonResidentialPropertyAssessmentWhereUniqueInput
  }

  /**
   * NonResidentialPropertyAssessment updateMany
   */
  export type NonResidentialPropertyAssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NonResidentialPropertyAssessments.
     */
    data: XOR<NonResidentialPropertyAssessmentUpdateManyMutationInput, NonResidentialPropertyAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which NonResidentialPropertyAssessments to update
     */
    where?: NonResidentialPropertyAssessmentWhereInput
  }

  /**
   * NonResidentialPropertyAssessment upsert
   */
  export type NonResidentialPropertyAssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonResidentialPropertyAssessment
     */
    select?: NonResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the NonResidentialPropertyAssessment to update in case it exists.
     */
    where: NonResidentialPropertyAssessmentWhereUniqueInput
    /**
     * In case the NonResidentialPropertyAssessment found by the `where` argument doesn't exist, create a new NonResidentialPropertyAssessment with this data.
     */
    create: XOR<NonResidentialPropertyAssessmentCreateInput, NonResidentialPropertyAssessmentUncheckedCreateInput>
    /**
     * In case the NonResidentialPropertyAssessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NonResidentialPropertyAssessmentUpdateInput, NonResidentialPropertyAssessmentUncheckedUpdateInput>
  }

  /**
   * NonResidentialPropertyAssessment delete
   */
  export type NonResidentialPropertyAssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonResidentialPropertyAssessment
     */
    select?: NonResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonResidentialPropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter which NonResidentialPropertyAssessment to delete.
     */
    where: NonResidentialPropertyAssessmentWhereUniqueInput
  }

  /**
   * NonResidentialPropertyAssessment deleteMany
   */
  export type NonResidentialPropertyAssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NonResidentialPropertyAssessments to delete
     */
    where?: NonResidentialPropertyAssessmentWhereInput
  }

  /**
   * NonResidentialPropertyAssessment without action
   */
  export type NonResidentialPropertyAssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonResidentialPropertyAssessment
     */
    select?: NonResidentialPropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonResidentialPropertyAssessmentInclude<ExtArgs> | null
  }


  /**
   * Model PropertyAttachmentDetails
   */

  export type AggregatePropertyAttachmentDetails = {
    _count: PropertyAttachmentDetailsCountAggregateOutputType | null
    _min: PropertyAttachmentDetailsMinAggregateOutputType | null
    _max: PropertyAttachmentDetailsMaxAggregateOutputType | null
  }

  export type PropertyAttachmentDetailsMinAggregateOutputType = {
    surveyUniqueCode: string | null
    image1Url: string | null
    image2Url: string | null
    image3Url: string | null
    image4Url: string | null
    image5Url: string | null
    image6Url: string | null
    image7Url: string | null
    image8Url: string | null
    image9Url: string | null
    image10Url: string | null
  }

  export type PropertyAttachmentDetailsMaxAggregateOutputType = {
    surveyUniqueCode: string | null
    image1Url: string | null
    image2Url: string | null
    image3Url: string | null
    image4Url: string | null
    image5Url: string | null
    image6Url: string | null
    image7Url: string | null
    image8Url: string | null
    image9Url: string | null
    image10Url: string | null
  }

  export type PropertyAttachmentDetailsCountAggregateOutputType = {
    surveyUniqueCode: number
    image1Url: number
    image2Url: number
    image3Url: number
    image4Url: number
    image5Url: number
    image6Url: number
    image7Url: number
    image8Url: number
    image9Url: number
    image10Url: number
    _all: number
  }


  export type PropertyAttachmentDetailsMinAggregateInputType = {
    surveyUniqueCode?: true
    image1Url?: true
    image2Url?: true
    image3Url?: true
    image4Url?: true
    image5Url?: true
    image6Url?: true
    image7Url?: true
    image8Url?: true
    image9Url?: true
    image10Url?: true
  }

  export type PropertyAttachmentDetailsMaxAggregateInputType = {
    surveyUniqueCode?: true
    image1Url?: true
    image2Url?: true
    image3Url?: true
    image4Url?: true
    image5Url?: true
    image6Url?: true
    image7Url?: true
    image8Url?: true
    image9Url?: true
    image10Url?: true
  }

  export type PropertyAttachmentDetailsCountAggregateInputType = {
    surveyUniqueCode?: true
    image1Url?: true
    image2Url?: true
    image3Url?: true
    image4Url?: true
    image5Url?: true
    image6Url?: true
    image7Url?: true
    image8Url?: true
    image9Url?: true
    image10Url?: true
    _all?: true
  }

  export type PropertyAttachmentDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyAttachmentDetails to aggregate.
     */
    where?: PropertyAttachmentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAttachmentDetails to fetch.
     */
    orderBy?: PropertyAttachmentDetailsOrderByWithRelationInput | PropertyAttachmentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyAttachmentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAttachmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAttachmentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyAttachmentDetails
    **/
    _count?: true | PropertyAttachmentDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyAttachmentDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyAttachmentDetailsMaxAggregateInputType
  }

  export type GetPropertyAttachmentDetailsAggregateType<T extends PropertyAttachmentDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyAttachmentDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyAttachmentDetails[P]>
      : GetScalarType<T[P], AggregatePropertyAttachmentDetails[P]>
  }




  export type PropertyAttachmentDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyAttachmentDetailsWhereInput
    orderBy?: PropertyAttachmentDetailsOrderByWithAggregationInput | PropertyAttachmentDetailsOrderByWithAggregationInput[]
    by: PropertyAttachmentDetailsScalarFieldEnum[] | PropertyAttachmentDetailsScalarFieldEnum
    having?: PropertyAttachmentDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyAttachmentDetailsCountAggregateInputType | true
    _min?: PropertyAttachmentDetailsMinAggregateInputType
    _max?: PropertyAttachmentDetailsMaxAggregateInputType
  }

  export type PropertyAttachmentDetailsGroupByOutputType = {
    surveyUniqueCode: string
    image1Url: string | null
    image2Url: string | null
    image3Url: string | null
    image4Url: string | null
    image5Url: string | null
    image6Url: string | null
    image7Url: string | null
    image8Url: string | null
    image9Url: string | null
    image10Url: string | null
    _count: PropertyAttachmentDetailsCountAggregateOutputType | null
    _min: PropertyAttachmentDetailsMinAggregateOutputType | null
    _max: PropertyAttachmentDetailsMaxAggregateOutputType | null
  }

  type GetPropertyAttachmentDetailsGroupByPayload<T extends PropertyAttachmentDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyAttachmentDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyAttachmentDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyAttachmentDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyAttachmentDetailsGroupByOutputType[P]>
        }
      >
    >


  export type PropertyAttachmentDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surveyUniqueCode?: boolean
    image1Url?: boolean
    image2Url?: boolean
    image3Url?: boolean
    image4Url?: boolean
    image5Url?: boolean
    image6Url?: boolean
    image7Url?: boolean
    image8Url?: boolean
    image9Url?: boolean
    image10Url?: boolean
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyAttachmentDetails"]>

  export type PropertyAttachmentDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surveyUniqueCode?: boolean
    image1Url?: boolean
    image2Url?: boolean
    image3Url?: boolean
    image4Url?: boolean
    image5Url?: boolean
    image6Url?: boolean
    image7Url?: boolean
    image8Url?: boolean
    image9Url?: boolean
    image10Url?: boolean
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyAttachmentDetails"]>

  export type PropertyAttachmentDetailsSelectScalar = {
    surveyUniqueCode?: boolean
    image1Url?: boolean
    image2Url?: boolean
    image3Url?: boolean
    image4Url?: boolean
    image5Url?: boolean
    image6Url?: boolean
    image7Url?: boolean
    image8Url?: boolean
    image9Url?: boolean
    image10Url?: boolean
  }

  export type PropertyAttachmentDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
  }
  export type PropertyAttachmentDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDetailsDefaultArgs<ExtArgs>
  }

  export type $PropertyAttachmentDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyAttachmentDetails"
    objects: {
      survey: Prisma.$SurveyDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      surveyUniqueCode: string
      image1Url: string | null
      image2Url: string | null
      image3Url: string | null
      image4Url: string | null
      image5Url: string | null
      image6Url: string | null
      image7Url: string | null
      image8Url: string | null
      image9Url: string | null
      image10Url: string | null
    }, ExtArgs["result"]["propertyAttachmentDetails"]>
    composites: {}
  }

  type PropertyAttachmentDetailsGetPayload<S extends boolean | null | undefined | PropertyAttachmentDetailsDefaultArgs> = $Result.GetResult<Prisma.$PropertyAttachmentDetailsPayload, S>

  type PropertyAttachmentDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyAttachmentDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PropertyAttachmentDetailsCountAggregateInputType | true
    }

  export interface PropertyAttachmentDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyAttachmentDetails'], meta: { name: 'PropertyAttachmentDetails' } }
    /**
     * Find zero or one PropertyAttachmentDetails that matches the filter.
     * @param {PropertyAttachmentDetailsFindUniqueArgs} args - Arguments to find a PropertyAttachmentDetails
     * @example
     * // Get one PropertyAttachmentDetails
     * const propertyAttachmentDetails = await prisma.propertyAttachmentDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyAttachmentDetailsFindUniqueArgs>(args: SelectSubset<T, PropertyAttachmentDetailsFindUniqueArgs<ExtArgs>>): Prisma__PropertyAttachmentDetailsClient<$Result.GetResult<Prisma.$PropertyAttachmentDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PropertyAttachmentDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PropertyAttachmentDetailsFindUniqueOrThrowArgs} args - Arguments to find a PropertyAttachmentDetails
     * @example
     * // Get one PropertyAttachmentDetails
     * const propertyAttachmentDetails = await prisma.propertyAttachmentDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyAttachmentDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyAttachmentDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyAttachmentDetailsClient<$Result.GetResult<Prisma.$PropertyAttachmentDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PropertyAttachmentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAttachmentDetailsFindFirstArgs} args - Arguments to find a PropertyAttachmentDetails
     * @example
     * // Get one PropertyAttachmentDetails
     * const propertyAttachmentDetails = await prisma.propertyAttachmentDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyAttachmentDetailsFindFirstArgs>(args?: SelectSubset<T, PropertyAttachmentDetailsFindFirstArgs<ExtArgs>>): Prisma__PropertyAttachmentDetailsClient<$Result.GetResult<Prisma.$PropertyAttachmentDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PropertyAttachmentDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAttachmentDetailsFindFirstOrThrowArgs} args - Arguments to find a PropertyAttachmentDetails
     * @example
     * // Get one PropertyAttachmentDetails
     * const propertyAttachmentDetails = await prisma.propertyAttachmentDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyAttachmentDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyAttachmentDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyAttachmentDetailsClient<$Result.GetResult<Prisma.$PropertyAttachmentDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PropertyAttachmentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAttachmentDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyAttachmentDetails
     * const propertyAttachmentDetails = await prisma.propertyAttachmentDetails.findMany()
     * 
     * // Get first 10 PropertyAttachmentDetails
     * const propertyAttachmentDetails = await prisma.propertyAttachmentDetails.findMany({ take: 10 })
     * 
     * // Only select the `surveyUniqueCode`
     * const propertyAttachmentDetailsWithSurveyUniqueCodeOnly = await prisma.propertyAttachmentDetails.findMany({ select: { surveyUniqueCode: true } })
     * 
     */
    findMany<T extends PropertyAttachmentDetailsFindManyArgs>(args?: SelectSubset<T, PropertyAttachmentDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAttachmentDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PropertyAttachmentDetails.
     * @param {PropertyAttachmentDetailsCreateArgs} args - Arguments to create a PropertyAttachmentDetails.
     * @example
     * // Create one PropertyAttachmentDetails
     * const PropertyAttachmentDetails = await prisma.propertyAttachmentDetails.create({
     *   data: {
     *     // ... data to create a PropertyAttachmentDetails
     *   }
     * })
     * 
     */
    create<T extends PropertyAttachmentDetailsCreateArgs>(args: SelectSubset<T, PropertyAttachmentDetailsCreateArgs<ExtArgs>>): Prisma__PropertyAttachmentDetailsClient<$Result.GetResult<Prisma.$PropertyAttachmentDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PropertyAttachmentDetails.
     * @param {PropertyAttachmentDetailsCreateManyArgs} args - Arguments to create many PropertyAttachmentDetails.
     * @example
     * // Create many PropertyAttachmentDetails
     * const propertyAttachmentDetails = await prisma.propertyAttachmentDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyAttachmentDetailsCreateManyArgs>(args?: SelectSubset<T, PropertyAttachmentDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyAttachmentDetails and returns the data saved in the database.
     * @param {PropertyAttachmentDetailsCreateManyAndReturnArgs} args - Arguments to create many PropertyAttachmentDetails.
     * @example
     * // Create many PropertyAttachmentDetails
     * const propertyAttachmentDetails = await prisma.propertyAttachmentDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyAttachmentDetails and only return the `surveyUniqueCode`
     * const propertyAttachmentDetailsWithSurveyUniqueCodeOnly = await prisma.propertyAttachmentDetails.createManyAndReturn({ 
     *   select: { surveyUniqueCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyAttachmentDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyAttachmentDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAttachmentDetailsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PropertyAttachmentDetails.
     * @param {PropertyAttachmentDetailsDeleteArgs} args - Arguments to delete one PropertyAttachmentDetails.
     * @example
     * // Delete one PropertyAttachmentDetails
     * const PropertyAttachmentDetails = await prisma.propertyAttachmentDetails.delete({
     *   where: {
     *     // ... filter to delete one PropertyAttachmentDetails
     *   }
     * })
     * 
     */
    delete<T extends PropertyAttachmentDetailsDeleteArgs>(args: SelectSubset<T, PropertyAttachmentDetailsDeleteArgs<ExtArgs>>): Prisma__PropertyAttachmentDetailsClient<$Result.GetResult<Prisma.$PropertyAttachmentDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PropertyAttachmentDetails.
     * @param {PropertyAttachmentDetailsUpdateArgs} args - Arguments to update one PropertyAttachmentDetails.
     * @example
     * // Update one PropertyAttachmentDetails
     * const propertyAttachmentDetails = await prisma.propertyAttachmentDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyAttachmentDetailsUpdateArgs>(args: SelectSubset<T, PropertyAttachmentDetailsUpdateArgs<ExtArgs>>): Prisma__PropertyAttachmentDetailsClient<$Result.GetResult<Prisma.$PropertyAttachmentDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PropertyAttachmentDetails.
     * @param {PropertyAttachmentDetailsDeleteManyArgs} args - Arguments to filter PropertyAttachmentDetails to delete.
     * @example
     * // Delete a few PropertyAttachmentDetails
     * const { count } = await prisma.propertyAttachmentDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyAttachmentDetailsDeleteManyArgs>(args?: SelectSubset<T, PropertyAttachmentDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyAttachmentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAttachmentDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyAttachmentDetails
     * const propertyAttachmentDetails = await prisma.propertyAttachmentDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyAttachmentDetailsUpdateManyArgs>(args: SelectSubset<T, PropertyAttachmentDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyAttachmentDetails.
     * @param {PropertyAttachmentDetailsUpsertArgs} args - Arguments to update or create a PropertyAttachmentDetails.
     * @example
     * // Update or create a PropertyAttachmentDetails
     * const propertyAttachmentDetails = await prisma.propertyAttachmentDetails.upsert({
     *   create: {
     *     // ... data to create a PropertyAttachmentDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyAttachmentDetails we want to update
     *   }
     * })
     */
    upsert<T extends PropertyAttachmentDetailsUpsertArgs>(args: SelectSubset<T, PropertyAttachmentDetailsUpsertArgs<ExtArgs>>): Prisma__PropertyAttachmentDetailsClient<$Result.GetResult<Prisma.$PropertyAttachmentDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PropertyAttachmentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAttachmentDetailsCountArgs} args - Arguments to filter PropertyAttachmentDetails to count.
     * @example
     * // Count the number of PropertyAttachmentDetails
     * const count = await prisma.propertyAttachmentDetails.count({
     *   where: {
     *     // ... the filter for the PropertyAttachmentDetails we want to count
     *   }
     * })
    **/
    count<T extends PropertyAttachmentDetailsCountArgs>(
      args?: Subset<T, PropertyAttachmentDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyAttachmentDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyAttachmentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAttachmentDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAttachmentDetailsAggregateArgs>(args: Subset<T, PropertyAttachmentDetailsAggregateArgs>): Prisma.PrismaPromise<GetPropertyAttachmentDetailsAggregateType<T>>

    /**
     * Group by PropertyAttachmentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAttachmentDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyAttachmentDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyAttachmentDetailsGroupByArgs['orderBy'] }
        : { orderBy?: PropertyAttachmentDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyAttachmentDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyAttachmentDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyAttachmentDetails model
   */
  readonly fields: PropertyAttachmentDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyAttachmentDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyAttachmentDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDetailsDefaultArgs<ExtArgs>>): Prisma__SurveyDetailsClient<$Result.GetResult<Prisma.$SurveyDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyAttachmentDetails model
   */ 
  interface PropertyAttachmentDetailsFieldRefs {
    readonly surveyUniqueCode: FieldRef<"PropertyAttachmentDetails", 'String'>
    readonly image1Url: FieldRef<"PropertyAttachmentDetails", 'String'>
    readonly image2Url: FieldRef<"PropertyAttachmentDetails", 'String'>
    readonly image3Url: FieldRef<"PropertyAttachmentDetails", 'String'>
    readonly image4Url: FieldRef<"PropertyAttachmentDetails", 'String'>
    readonly image5Url: FieldRef<"PropertyAttachmentDetails", 'String'>
    readonly image6Url: FieldRef<"PropertyAttachmentDetails", 'String'>
    readonly image7Url: FieldRef<"PropertyAttachmentDetails", 'String'>
    readonly image8Url: FieldRef<"PropertyAttachmentDetails", 'String'>
    readonly image9Url: FieldRef<"PropertyAttachmentDetails", 'String'>
    readonly image10Url: FieldRef<"PropertyAttachmentDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PropertyAttachmentDetails findUnique
   */
  export type PropertyAttachmentDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachmentDetails
     */
    select?: PropertyAttachmentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAttachmentDetails to fetch.
     */
    where: PropertyAttachmentDetailsWhereUniqueInput
  }

  /**
   * PropertyAttachmentDetails findUniqueOrThrow
   */
  export type PropertyAttachmentDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachmentDetails
     */
    select?: PropertyAttachmentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAttachmentDetails to fetch.
     */
    where: PropertyAttachmentDetailsWhereUniqueInput
  }

  /**
   * PropertyAttachmentDetails findFirst
   */
  export type PropertyAttachmentDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachmentDetails
     */
    select?: PropertyAttachmentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAttachmentDetails to fetch.
     */
    where?: PropertyAttachmentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAttachmentDetails to fetch.
     */
    orderBy?: PropertyAttachmentDetailsOrderByWithRelationInput | PropertyAttachmentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyAttachmentDetails.
     */
    cursor?: PropertyAttachmentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAttachmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAttachmentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyAttachmentDetails.
     */
    distinct?: PropertyAttachmentDetailsScalarFieldEnum | PropertyAttachmentDetailsScalarFieldEnum[]
  }

  /**
   * PropertyAttachmentDetails findFirstOrThrow
   */
  export type PropertyAttachmentDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachmentDetails
     */
    select?: PropertyAttachmentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAttachmentDetails to fetch.
     */
    where?: PropertyAttachmentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAttachmentDetails to fetch.
     */
    orderBy?: PropertyAttachmentDetailsOrderByWithRelationInput | PropertyAttachmentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyAttachmentDetails.
     */
    cursor?: PropertyAttachmentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAttachmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAttachmentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyAttachmentDetails.
     */
    distinct?: PropertyAttachmentDetailsScalarFieldEnum | PropertyAttachmentDetailsScalarFieldEnum[]
  }

  /**
   * PropertyAttachmentDetails findMany
   */
  export type PropertyAttachmentDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachmentDetails
     */
    select?: PropertyAttachmentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAttachmentDetails to fetch.
     */
    where?: PropertyAttachmentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAttachmentDetails to fetch.
     */
    orderBy?: PropertyAttachmentDetailsOrderByWithRelationInput | PropertyAttachmentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyAttachmentDetails.
     */
    cursor?: PropertyAttachmentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAttachmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAttachmentDetails.
     */
    skip?: number
    distinct?: PropertyAttachmentDetailsScalarFieldEnum | PropertyAttachmentDetailsScalarFieldEnum[]
  }

  /**
   * PropertyAttachmentDetails create
   */
  export type PropertyAttachmentDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachmentDetails
     */
    select?: PropertyAttachmentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyAttachmentDetails.
     */
    data: XOR<PropertyAttachmentDetailsCreateInput, PropertyAttachmentDetailsUncheckedCreateInput>
  }

  /**
   * PropertyAttachmentDetails createMany
   */
  export type PropertyAttachmentDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyAttachmentDetails.
     */
    data: PropertyAttachmentDetailsCreateManyInput | PropertyAttachmentDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyAttachmentDetails createManyAndReturn
   */
  export type PropertyAttachmentDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachmentDetails
     */
    select?: PropertyAttachmentDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PropertyAttachmentDetails.
     */
    data: PropertyAttachmentDetailsCreateManyInput | PropertyAttachmentDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyAttachmentDetails update
   */
  export type PropertyAttachmentDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachmentDetails
     */
    select?: PropertyAttachmentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyAttachmentDetails.
     */
    data: XOR<PropertyAttachmentDetailsUpdateInput, PropertyAttachmentDetailsUncheckedUpdateInput>
    /**
     * Choose, which PropertyAttachmentDetails to update.
     */
    where: PropertyAttachmentDetailsWhereUniqueInput
  }

  /**
   * PropertyAttachmentDetails updateMany
   */
  export type PropertyAttachmentDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyAttachmentDetails.
     */
    data: XOR<PropertyAttachmentDetailsUpdateManyMutationInput, PropertyAttachmentDetailsUncheckedUpdateManyInput>
    /**
     * Filter which PropertyAttachmentDetails to update
     */
    where?: PropertyAttachmentDetailsWhereInput
  }

  /**
   * PropertyAttachmentDetails upsert
   */
  export type PropertyAttachmentDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachmentDetails
     */
    select?: PropertyAttachmentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyAttachmentDetails to update in case it exists.
     */
    where: PropertyAttachmentDetailsWhereUniqueInput
    /**
     * In case the PropertyAttachmentDetails found by the `where` argument doesn't exist, create a new PropertyAttachmentDetails with this data.
     */
    create: XOR<PropertyAttachmentDetailsCreateInput, PropertyAttachmentDetailsUncheckedCreateInput>
    /**
     * In case the PropertyAttachmentDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyAttachmentDetailsUpdateInput, PropertyAttachmentDetailsUncheckedUpdateInput>
  }

  /**
   * PropertyAttachmentDetails delete
   */
  export type PropertyAttachmentDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachmentDetails
     */
    select?: PropertyAttachmentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentDetailsInclude<ExtArgs> | null
    /**
     * Filter which PropertyAttachmentDetails to delete.
     */
    where: PropertyAttachmentDetailsWhereUniqueInput
  }

  /**
   * PropertyAttachmentDetails deleteMany
   */
  export type PropertyAttachmentDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyAttachmentDetails to delete
     */
    where?: PropertyAttachmentDetailsWhereInput
  }

  /**
   * PropertyAttachmentDetails without action
   */
  export type PropertyAttachmentDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachmentDetails
     */
    select?: PropertyAttachmentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentDetailsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UlbMasterScalarFieldEnum: {
    ulbId: 'ulbId',
    ulbName: 'ulbName',
    isActive: 'isActive',
    description: 'description'
  };

  export type UlbMasterScalarFieldEnum = (typeof UlbMasterScalarFieldEnum)[keyof typeof UlbMasterScalarFieldEnum]


  export const ZoneMasterScalarFieldEnum: {
    zoneId: 'zoneId',
    zoneNumber: 'zoneNumber',
    isActive: 'isActive',
    description: 'description'
  };

  export type ZoneMasterScalarFieldEnum = (typeof ZoneMasterScalarFieldEnum)[keyof typeof ZoneMasterScalarFieldEnum]


  export const WardMasterScalarFieldEnum: {
    wardId: 'wardId',
    wardNumber: 'wardNumber',
    isActive: 'isActive',
    wardName: 'wardName',
    description: 'description'
  };

  export type WardMasterScalarFieldEnum = (typeof WardMasterScalarFieldEnum)[keyof typeof WardMasterScalarFieldEnum]


  export const MohallaMasterScalarFieldEnum: {
    mohallaId: 'mohallaId',
    mohallaName: 'mohallaName',
    isActive: 'isActive',
    description: 'description'
  };

  export type MohallaMasterScalarFieldEnum = (typeof MohallaMasterScalarFieldEnum)[keyof typeof MohallaMasterScalarFieldEnum]


  export const ResponseTypeMasterScalarFieldEnum: {
    responseTypeId: 'responseTypeId',
    responseTypeName: 'responseTypeName',
    isActive: 'isActive',
    description: 'description'
  };

  export type ResponseTypeMasterScalarFieldEnum = (typeof ResponseTypeMasterScalarFieldEnum)[keyof typeof ResponseTypeMasterScalarFieldEnum]


  export const PropertyTypeMasterScalarFieldEnum: {
    propertyTypeId: 'propertyTypeId',
    propertyTypeName: 'propertyTypeName',
    isActive: 'isActive',
    description: 'description'
  };

  export type PropertyTypeMasterScalarFieldEnum = (typeof PropertyTypeMasterScalarFieldEnum)[keyof typeof PropertyTypeMasterScalarFieldEnum]


  export const RespondentStatusMasterScalarFieldEnum: {
    respondentStatusId: 'respondentStatusId',
    respondentStatusName: 'respondentStatusName',
    isActive: 'isActive',
    description: 'description'
  };

  export type RespondentStatusMasterScalarFieldEnum = (typeof RespondentStatusMasterScalarFieldEnum)[keyof typeof RespondentStatusMasterScalarFieldEnum]


  export const RoadTypeMasterScalarFieldEnum: {
    roadTypeId: 'roadTypeId',
    roadTypeName: 'roadTypeName',
    isActive: 'isActive',
    description: 'description'
  };

  export type RoadTypeMasterScalarFieldEnum = (typeof RoadTypeMasterScalarFieldEnum)[keyof typeof RoadTypeMasterScalarFieldEnum]


  export const ConstructionTypeMasterScalarFieldEnum: {
    constructionTypeId: 'constructionTypeId',
    constructionTypeName: 'constructionTypeName',
    isActive: 'isActive',
    description: 'description'
  };

  export type ConstructionTypeMasterScalarFieldEnum = (typeof ConstructionTypeMasterScalarFieldEnum)[keyof typeof ConstructionTypeMasterScalarFieldEnum]


  export const WaterSourceMasterScalarFieldEnum: {
    waterSourceId: 'waterSourceId',
    waterSourceName: 'waterSourceName',
    isActive: 'isActive',
    description: 'description'
  };

  export type WaterSourceMasterScalarFieldEnum = (typeof WaterSourceMasterScalarFieldEnum)[keyof typeof WaterSourceMasterScalarFieldEnum]


  export const DisposalTypeMasterScalarFieldEnum: {
    disposalTypeId: 'disposalTypeId',
    disposalTypeName: 'disposalTypeName',
    isActive: 'isActive',
    description: 'description'
  };

  export type DisposalTypeMasterScalarFieldEnum = (typeof DisposalTypeMasterScalarFieldEnum)[keyof typeof DisposalTypeMasterScalarFieldEnum]


  export const NrPropertyCategoryMasterScalarFieldEnum: {
    propertyCategoryId: 'propertyCategoryId',
    propertyCategoryNumber: 'propertyCategoryNumber',
    propertyCategoryName: 'propertyCategoryName',
    isActive: 'isActive',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type NrPropertyCategoryMasterScalarFieldEnum = (typeof NrPropertyCategoryMasterScalarFieldEnum)[keyof typeof NrPropertyCategoryMasterScalarFieldEnum]


  export const NrPropertySubCategoryMasterScalarFieldEnum: {
    subCategoryId: 'subCategoryId',
    subCategoryNumber: 'subCategoryNumber',
    subCategoryName: 'subCategoryName',
    isActive: 'isActive',
    description: 'description',
    createdAt: 'createdAt',
    propertyCategoryId: 'propertyCategoryId'
  };

  export type NrPropertySubCategoryMasterScalarFieldEnum = (typeof NrPropertySubCategoryMasterScalarFieldEnum)[keyof typeof NrPropertySubCategoryMasterScalarFieldEnum]


  export const ConstructionNatureMasterScalarFieldEnum: {
    constructionNatureId: 'constructionNatureId',
    constructionNatureName: 'constructionNatureName',
    isActive: 'isActive',
    description: 'description'
  };

  export type ConstructionNatureMasterScalarFieldEnum = (typeof ConstructionNatureMasterScalarFieldEnum)[keyof typeof ConstructionNatureMasterScalarFieldEnum]


  export const SurveyTypeMasterScalarFieldEnum: {
    surveyTypeId: 'surveyTypeId',
    surveyTypeName: 'surveyTypeName',
    isActive: 'isActive',
    description: 'description'
  };

  export type SurveyTypeMasterScalarFieldEnum = (typeof SurveyTypeMasterScalarFieldEnum)[keyof typeof SurveyTypeMasterScalarFieldEnum]


  export const OccupancyStatusMasterScalarFieldEnum: {
    occupancyStatusId: 'occupancyStatusId',
    occupancyStatusName: 'occupancyStatusName',
    isActive: 'isActive',
    description: 'description'
  };

  export type OccupancyStatusMasterScalarFieldEnum = (typeof OccupancyStatusMasterScalarFieldEnum)[keyof typeof OccupancyStatusMasterScalarFieldEnum]


  export const SurveyStatusMasterScalarFieldEnum: {
    statusId: 'statusId',
    statusName: 'statusName',
    isActive: 'isActive',
    description: 'description'
  };

  export type SurveyStatusMasterScalarFieldEnum = (typeof SurveyStatusMasterScalarFieldEnum)[keyof typeof SurveyStatusMasterScalarFieldEnum]


  export const WardStatusMasterScalarFieldEnum: {
    statusId: 'statusId',
    statusName: 'statusName',
    isActive: 'isActive',
    description: 'description'
  };

  export type WardStatusMasterScalarFieldEnum = (typeof WardStatusMasterScalarFieldEnum)[keyof typeof WardStatusMasterScalarFieldEnum]


  export const UsersMasterScalarFieldEnum: {
    userId: 'userId',
    username: 'username',
    password: 'password',
    mobileNumber: 'mobileNumber',
    isCreatedAt: 'isCreatedAt',
    isActive: 'isActive',
    description: 'description'
  };

  export type UsersMasterScalarFieldEnum = (typeof UsersMasterScalarFieldEnum)[keyof typeof UsersMasterScalarFieldEnum]


  export const RolePermissionMasterScalarFieldEnum: {
    roleId: 'roleId',
    roleName: 'roleName',
    isActive: 'isActive',
    description: 'description'
  };

  export type RolePermissionMasterScalarFieldEnum = (typeof RolePermissionMasterScalarFieldEnum)[keyof typeof RolePermissionMasterScalarFieldEnum]


  export const UlbZoneMappingScalarFieldEnum: {
    ulbZoneMapId: 'ulbZoneMapId',
    ulbId: 'ulbId',
    zoneId: 'zoneId',
    isActive: 'isActive'
  };

  export type UlbZoneMappingScalarFieldEnum = (typeof UlbZoneMappingScalarFieldEnum)[keyof typeof UlbZoneMappingScalarFieldEnum]


  export const ZoneWardMappingScalarFieldEnum: {
    zoneWardMapId: 'zoneWardMapId',
    zoneId: 'zoneId',
    wardId: 'wardId',
    isActive: 'isActive'
  };

  export type ZoneWardMappingScalarFieldEnum = (typeof ZoneWardMappingScalarFieldEnum)[keyof typeof ZoneWardMappingScalarFieldEnum]


  export const WardMohallaMappingScalarFieldEnum: {
    wardMohallaMapId: 'wardMohallaMapId',
    wardId: 'wardId',
    mohallaId: 'mohallaId',
    isActive: 'isActive'
  };

  export type WardMohallaMappingScalarFieldEnum = (typeof WardMohallaMappingScalarFieldEnum)[keyof typeof WardMohallaMappingScalarFieldEnum]


  export const SurveyorAssignmentScalarFieldEnum: {
    assignmentId: 'assignmentId',
    userId: 'userId',
    assignmentType: 'assignmentType',
    wardId: 'wardId',
    mohallaId: 'mohallaId',
    wardMohallaMapId: 'wardMohallaMapId',
    assignedById: 'assignedById',
    isActive: 'isActive'
  };

  export type SurveyorAssignmentScalarFieldEnum = (typeof SurveyorAssignmentScalarFieldEnum)[keyof typeof SurveyorAssignmentScalarFieldEnum]


  export const WardStatusMappingScalarFieldEnum: {
    wardStatusId: 'wardStatusId',
    wardId: 'wardId',
    statusId: 'statusId',
    changedById: 'changedById',
    isActive: 'isActive'
  };

  export type WardStatusMappingScalarFieldEnum = (typeof WardStatusMappingScalarFieldEnum)[keyof typeof WardStatusMappingScalarFieldEnum]


  export const SurveyStatusMappingScalarFieldEnum: {
    statusMappingId: 'statusMappingId',
    surveyUniqueCode: 'surveyUniqueCode',
    statusId: 'statusId',
    revertedFromId: 'revertedFromId',
    changedById: 'changedById',
    isActive: 'isActive'
  };

  export type SurveyStatusMappingScalarFieldEnum = (typeof SurveyStatusMappingScalarFieldEnum)[keyof typeof SurveyStatusMappingScalarFieldEnum]


  export const UserRoleMappingScalarFieldEnum: {
    userRoleMapId: 'userRoleMapId',
    userId: 'userId',
    roleId: 'roleId',
    isActive: 'isActive'
  };

  export type UserRoleMappingScalarFieldEnum = (typeof UserRoleMappingScalarFieldEnum)[keyof typeof UserRoleMappingScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    sessionId: 'sessionId',
    userId: 'userId',
    loginTime: 'loginTime',
    logoutTime: 'logoutTime',
    isActive: 'isActive'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SurveyorsScalarFieldEnum: {
    userId: 'userId',
    surveyorName: 'surveyorName',
    username: 'username',
    password: 'password',
    wardNumber: 'wardNumber',
    wardMohallaMapId: 'wardMohallaMapId',
    zoneWardMapId: 'zoneWardMapId',
    ulbZoneMapId: 'ulbZoneMapId'
  };

  export type SurveyorsScalarFieldEnum = (typeof SurveyorsScalarFieldEnum)[keyof typeof SurveyorsScalarFieldEnum]


  export const SupervisorsScalarFieldEnum: {
    userId: 'userId',
    supervisorName: 'supervisorName',
    username: 'username',
    password: 'password',
    wardId: 'wardId'
  };

  export type SupervisorsScalarFieldEnum = (typeof SupervisorsScalarFieldEnum)[keyof typeof SupervisorsScalarFieldEnum]


  export const AdminsScalarFieldEnum: {
    userId: 'userId',
    adminName: 'adminName',
    username: 'username',
    password: 'password'
  };

  export type AdminsScalarFieldEnum = (typeof AdminsScalarFieldEnum)[keyof typeof AdminsScalarFieldEnum]


  export const SurveyDetailsScalarFieldEnum: {
    surveyUniqueCode: 'surveyUniqueCode',
    ulbId: 'ulbId',
    zoneId: 'zoneId',
    wardId: 'wardId',
    mohallaId: 'mohallaId',
    surveyTypeId: 'surveyTypeId',
    entryDate: 'entryDate',
    parcelId: 'parcelId',
    mapId: 'mapId',
    gisId: 'gisId',
    subGisId: 'subGisId'
  };

  export type SurveyDetailsScalarFieldEnum = (typeof SurveyDetailsScalarFieldEnum)[keyof typeof SurveyDetailsScalarFieldEnum]


  export const PropertyDetailsScalarFieldEnum: {
    surveyUniqueCode: 'surveyUniqueCode',
    responseTypeId: 'responseTypeId',
    oldHouseNumber: 'oldHouseNumber',
    electricityConsumerName: 'electricityConsumerName',
    waterSewerageConnectionNumber: 'waterSewerageConnectionNumber',
    respondentName: 'respondentName',
    respondentStatusId: 'respondentStatusId'
  };

  export type PropertyDetailsScalarFieldEnum = (typeof PropertyDetailsScalarFieldEnum)[keyof typeof PropertyDetailsScalarFieldEnum]


  export const OwnerDetailsScalarFieldEnum: {
    surveyUniqueCode: 'surveyUniqueCode',
    ownerName: 'ownerName',
    fatherHusbandName: 'fatherHusbandName',
    mobileNumber: 'mobileNumber',
    aadharNumber: 'aadharNumber'
  };

  export type OwnerDetailsScalarFieldEnum = (typeof OwnerDetailsScalarFieldEnum)[keyof typeof OwnerDetailsScalarFieldEnum]


  export const LocationDetailsScalarFieldEnum: {
    surveyUniqueCode: 'surveyUniqueCode',
    propertyLatitude: 'propertyLatitude',
    propertyLongitude: 'propertyLongitude',
    assessmentYear: 'assessmentYear',
    propertyTypeId: 'propertyTypeId',
    buildingName: 'buildingName',
    roadTypeId: 'roadTypeId',
    constructionYear: 'constructionYear',
    constructionTypeId: 'constructionTypeId',
    addressRoadName: 'addressRoadName',
    locality: 'locality',
    pinCode: 'pinCode',
    landmark: 'landmark',
    fourWayEast: 'fourWayEast',
    fourWayWest: 'fourWayWest',
    fourWayNorth: 'fourWayNorth',
    fourWaySouth: 'fourWaySouth',
    newWard: 'newWard'
  };

  export type LocationDetailsScalarFieldEnum = (typeof LocationDetailsScalarFieldEnum)[keyof typeof LocationDetailsScalarFieldEnum]


  export const OtherDetailsScalarFieldEnum: {
    surveyUniqueCode: 'surveyUniqueCode',
    waterSourceId: 'waterSourceId',
    rainWaterHarvestingSystem: 'rainWaterHarvestingSystem',
    plantation: 'plantation',
    parking: 'parking',
    pollution: 'pollution',
    pollutionMeasurementTaken: 'pollutionMeasurementTaken',
    waterSupplyWithin200Meters: 'waterSupplyWithin200Meters',
    sewerageLineWithin100Meters: 'sewerageLineWithin100Meters',
    disposalTypeId: 'disposalTypeId',
    totalPlotArea: 'totalPlotArea',
    builtupAreaOfGroundFloor: 'builtupAreaOfGroundFloor',
    remarks: 'remarks'
  };

  export type OtherDetailsScalarFieldEnum = (typeof OtherDetailsScalarFieldEnum)[keyof typeof OtherDetailsScalarFieldEnum]


  export const ResidentialPropertyAssessmentScalarFieldEnum: {
    floorAssessmentId: 'floorAssessmentId',
    surveyUniqueCode: 'surveyUniqueCode',
    floorNumber: 'floorNumber',
    occupancyStatusId: 'occupancyStatusId',
    constructionNatureId: 'constructionNatureId',
    coveredArea: 'coveredArea',
    allRoomVerandaArea: 'allRoomVerandaArea',
    allBalconyKitchenArea: 'allBalconyKitchenArea',
    allGarageArea: 'allGarageArea',
    carpetArea: 'carpetArea'
  };

  export type ResidentialPropertyAssessmentScalarFieldEnum = (typeof ResidentialPropertyAssessmentScalarFieldEnum)[keyof typeof ResidentialPropertyAssessmentScalarFieldEnum]


  export const NonResidentialPropertyAssessmentScalarFieldEnum: {
    floorAssessmentId: 'floorAssessmentId',
    surveyUniqueCode: 'surveyUniqueCode',
    floorNumber: 'floorNumber',
    nrPropertyCategoryId: 'nrPropertyCategoryId',
    nrSubCategoryId: 'nrSubCategoryId',
    establishmentName: 'establishmentName',
    licenseNo: 'licenseNo',
    licenseExpiryDate: 'licenseExpiryDate',
    occupancyStatusId: 'occupancyStatusId',
    constructionNatureId: 'constructionNatureId',
    builtupArea: 'builtupArea'
  };

  export type NonResidentialPropertyAssessmentScalarFieldEnum = (typeof NonResidentialPropertyAssessmentScalarFieldEnum)[keyof typeof NonResidentialPropertyAssessmentScalarFieldEnum]


  export const PropertyAttachmentDetailsScalarFieldEnum: {
    surveyUniqueCode: 'surveyUniqueCode',
    image1Url: 'image1Url',
    image2Url: 'image2Url',
    image3Url: 'image3Url',
    image4Url: 'image4Url',
    image5Url: 'image5Url',
    image6Url: 'image6Url',
    image7Url: 'image7Url',
    image8Url: 'image8Url',
    image9Url: 'image9Url',
    image10Url: 'image10Url'
  };

  export type PropertyAttachmentDetailsScalarFieldEnum = (typeof PropertyAttachmentDetailsScalarFieldEnum)[keyof typeof PropertyAttachmentDetailsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UlbMasterWhereInput = {
    AND?: UlbMasterWhereInput | UlbMasterWhereInput[]
    OR?: UlbMasterWhereInput[]
    NOT?: UlbMasterWhereInput | UlbMasterWhereInput[]
    ulbId?: StringFilter<"UlbMaster"> | string
    ulbName?: StringFilter<"UlbMaster"> | string
    isActive?: BoolFilter<"UlbMaster"> | boolean
    description?: StringNullableFilter<"UlbMaster"> | string | null
    ulbZoneMaps?: UlbZoneMappingListRelationFilter
    surveyDetails?: SurveyDetailsListRelationFilter
  }

  export type UlbMasterOrderByWithRelationInput = {
    ulbId?: SortOrder
    ulbName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    ulbZoneMaps?: UlbZoneMappingOrderByRelationAggregateInput
    surveyDetails?: SurveyDetailsOrderByRelationAggregateInput
  }

  export type UlbMasterWhereUniqueInput = Prisma.AtLeast<{
    ulbId?: string
    AND?: UlbMasterWhereInput | UlbMasterWhereInput[]
    OR?: UlbMasterWhereInput[]
    NOT?: UlbMasterWhereInput | UlbMasterWhereInput[]
    ulbName?: StringFilter<"UlbMaster"> | string
    isActive?: BoolFilter<"UlbMaster"> | boolean
    description?: StringNullableFilter<"UlbMaster"> | string | null
    ulbZoneMaps?: UlbZoneMappingListRelationFilter
    surveyDetails?: SurveyDetailsListRelationFilter
  }, "ulbId">

  export type UlbMasterOrderByWithAggregationInput = {
    ulbId?: SortOrder
    ulbName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: UlbMasterCountOrderByAggregateInput
    _max?: UlbMasterMaxOrderByAggregateInput
    _min?: UlbMasterMinOrderByAggregateInput
  }

  export type UlbMasterScalarWhereWithAggregatesInput = {
    AND?: UlbMasterScalarWhereWithAggregatesInput | UlbMasterScalarWhereWithAggregatesInput[]
    OR?: UlbMasterScalarWhereWithAggregatesInput[]
    NOT?: UlbMasterScalarWhereWithAggregatesInput | UlbMasterScalarWhereWithAggregatesInput[]
    ulbId?: StringWithAggregatesFilter<"UlbMaster"> | string
    ulbName?: StringWithAggregatesFilter<"UlbMaster"> | string
    isActive?: BoolWithAggregatesFilter<"UlbMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"UlbMaster"> | string | null
  }

  export type ZoneMasterWhereInput = {
    AND?: ZoneMasterWhereInput | ZoneMasterWhereInput[]
    OR?: ZoneMasterWhereInput[]
    NOT?: ZoneMasterWhereInput | ZoneMasterWhereInput[]
    zoneId?: StringFilter<"ZoneMaster"> | string
    zoneNumber?: StringFilter<"ZoneMaster"> | string
    isActive?: BoolFilter<"ZoneMaster"> | boolean
    description?: StringNullableFilter<"ZoneMaster"> | string | null
    ulbZoneMaps?: UlbZoneMappingListRelationFilter
    zoneWardMaps?: ZoneWardMappingListRelationFilter
    surveyDetails?: SurveyDetailsListRelationFilter
  }

  export type ZoneMasterOrderByWithRelationInput = {
    zoneId?: SortOrder
    zoneNumber?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    ulbZoneMaps?: UlbZoneMappingOrderByRelationAggregateInput
    zoneWardMaps?: ZoneWardMappingOrderByRelationAggregateInput
    surveyDetails?: SurveyDetailsOrderByRelationAggregateInput
  }

  export type ZoneMasterWhereUniqueInput = Prisma.AtLeast<{
    zoneId?: string
    AND?: ZoneMasterWhereInput | ZoneMasterWhereInput[]
    OR?: ZoneMasterWhereInput[]
    NOT?: ZoneMasterWhereInput | ZoneMasterWhereInput[]
    zoneNumber?: StringFilter<"ZoneMaster"> | string
    isActive?: BoolFilter<"ZoneMaster"> | boolean
    description?: StringNullableFilter<"ZoneMaster"> | string | null
    ulbZoneMaps?: UlbZoneMappingListRelationFilter
    zoneWardMaps?: ZoneWardMappingListRelationFilter
    surveyDetails?: SurveyDetailsListRelationFilter
  }, "zoneId">

  export type ZoneMasterOrderByWithAggregationInput = {
    zoneId?: SortOrder
    zoneNumber?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: ZoneMasterCountOrderByAggregateInput
    _max?: ZoneMasterMaxOrderByAggregateInput
    _min?: ZoneMasterMinOrderByAggregateInput
  }

  export type ZoneMasterScalarWhereWithAggregatesInput = {
    AND?: ZoneMasterScalarWhereWithAggregatesInput | ZoneMasterScalarWhereWithAggregatesInput[]
    OR?: ZoneMasterScalarWhereWithAggregatesInput[]
    NOT?: ZoneMasterScalarWhereWithAggregatesInput | ZoneMasterScalarWhereWithAggregatesInput[]
    zoneId?: StringWithAggregatesFilter<"ZoneMaster"> | string
    zoneNumber?: StringWithAggregatesFilter<"ZoneMaster"> | string
    isActive?: BoolWithAggregatesFilter<"ZoneMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"ZoneMaster"> | string | null
  }

  export type WardMasterWhereInput = {
    AND?: WardMasterWhereInput | WardMasterWhereInput[]
    OR?: WardMasterWhereInput[]
    NOT?: WardMasterWhereInput | WardMasterWhereInput[]
    wardId?: StringFilter<"WardMaster"> | string
    wardNumber?: StringFilter<"WardMaster"> | string
    isActive?: BoolFilter<"WardMaster"> | boolean
    wardName?: StringFilter<"WardMaster"> | string
    description?: StringNullableFilter<"WardMaster"> | string | null
    zoneWardMaps?: ZoneWardMappingListRelationFilter
    wardMohallaMaps?: WardMohallaMappingListRelationFilter
    surveyorAssignments?: SurveyorAssignmentListRelationFilter
    wardStatusMaps?: WardStatusMappingListRelationFilter
    surveyDetails?: SurveyDetailsListRelationFilter
    supervisors?: SupervisorsListRelationFilter
  }

  export type WardMasterOrderByWithRelationInput = {
    wardId?: SortOrder
    wardNumber?: SortOrder
    isActive?: SortOrder
    wardName?: SortOrder
    description?: SortOrderInput | SortOrder
    zoneWardMaps?: ZoneWardMappingOrderByRelationAggregateInput
    wardMohallaMaps?: WardMohallaMappingOrderByRelationAggregateInput
    surveyorAssignments?: SurveyorAssignmentOrderByRelationAggregateInput
    wardStatusMaps?: WardStatusMappingOrderByRelationAggregateInput
    surveyDetails?: SurveyDetailsOrderByRelationAggregateInput
    supervisors?: SupervisorsOrderByRelationAggregateInput
  }

  export type WardMasterWhereUniqueInput = Prisma.AtLeast<{
    wardId?: string
    AND?: WardMasterWhereInput | WardMasterWhereInput[]
    OR?: WardMasterWhereInput[]
    NOT?: WardMasterWhereInput | WardMasterWhereInput[]
    wardNumber?: StringFilter<"WardMaster"> | string
    isActive?: BoolFilter<"WardMaster"> | boolean
    wardName?: StringFilter<"WardMaster"> | string
    description?: StringNullableFilter<"WardMaster"> | string | null
    zoneWardMaps?: ZoneWardMappingListRelationFilter
    wardMohallaMaps?: WardMohallaMappingListRelationFilter
    surveyorAssignments?: SurveyorAssignmentListRelationFilter
    wardStatusMaps?: WardStatusMappingListRelationFilter
    surveyDetails?: SurveyDetailsListRelationFilter
    supervisors?: SupervisorsListRelationFilter
  }, "wardId">

  export type WardMasterOrderByWithAggregationInput = {
    wardId?: SortOrder
    wardNumber?: SortOrder
    isActive?: SortOrder
    wardName?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: WardMasterCountOrderByAggregateInput
    _max?: WardMasterMaxOrderByAggregateInput
    _min?: WardMasterMinOrderByAggregateInput
  }

  export type WardMasterScalarWhereWithAggregatesInput = {
    AND?: WardMasterScalarWhereWithAggregatesInput | WardMasterScalarWhereWithAggregatesInput[]
    OR?: WardMasterScalarWhereWithAggregatesInput[]
    NOT?: WardMasterScalarWhereWithAggregatesInput | WardMasterScalarWhereWithAggregatesInput[]
    wardId?: StringWithAggregatesFilter<"WardMaster"> | string
    wardNumber?: StringWithAggregatesFilter<"WardMaster"> | string
    isActive?: BoolWithAggregatesFilter<"WardMaster"> | boolean
    wardName?: StringWithAggregatesFilter<"WardMaster"> | string
    description?: StringNullableWithAggregatesFilter<"WardMaster"> | string | null
  }

  export type MohallaMasterWhereInput = {
    AND?: MohallaMasterWhereInput | MohallaMasterWhereInput[]
    OR?: MohallaMasterWhereInput[]
    NOT?: MohallaMasterWhereInput | MohallaMasterWhereInput[]
    mohallaId?: StringFilter<"MohallaMaster"> | string
    mohallaName?: StringFilter<"MohallaMaster"> | string
    isActive?: BoolFilter<"MohallaMaster"> | boolean
    description?: StringNullableFilter<"MohallaMaster"> | string | null
    wardMohallaMaps?: WardMohallaMappingListRelationFilter
    surveyorAssignments?: SurveyorAssignmentListRelationFilter
    surveyDetails?: SurveyDetailsListRelationFilter
  }

  export type MohallaMasterOrderByWithRelationInput = {
    mohallaId?: SortOrder
    mohallaName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    wardMohallaMaps?: WardMohallaMappingOrderByRelationAggregateInput
    surveyorAssignments?: SurveyorAssignmentOrderByRelationAggregateInput
    surveyDetails?: SurveyDetailsOrderByRelationAggregateInput
  }

  export type MohallaMasterWhereUniqueInput = Prisma.AtLeast<{
    mohallaId?: string
    AND?: MohallaMasterWhereInput | MohallaMasterWhereInput[]
    OR?: MohallaMasterWhereInput[]
    NOT?: MohallaMasterWhereInput | MohallaMasterWhereInput[]
    mohallaName?: StringFilter<"MohallaMaster"> | string
    isActive?: BoolFilter<"MohallaMaster"> | boolean
    description?: StringNullableFilter<"MohallaMaster"> | string | null
    wardMohallaMaps?: WardMohallaMappingListRelationFilter
    surveyorAssignments?: SurveyorAssignmentListRelationFilter
    surveyDetails?: SurveyDetailsListRelationFilter
  }, "mohallaId">

  export type MohallaMasterOrderByWithAggregationInput = {
    mohallaId?: SortOrder
    mohallaName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: MohallaMasterCountOrderByAggregateInput
    _max?: MohallaMasterMaxOrderByAggregateInput
    _min?: MohallaMasterMinOrderByAggregateInput
  }

  export type MohallaMasterScalarWhereWithAggregatesInput = {
    AND?: MohallaMasterScalarWhereWithAggregatesInput | MohallaMasterScalarWhereWithAggregatesInput[]
    OR?: MohallaMasterScalarWhereWithAggregatesInput[]
    NOT?: MohallaMasterScalarWhereWithAggregatesInput | MohallaMasterScalarWhereWithAggregatesInput[]
    mohallaId?: StringWithAggregatesFilter<"MohallaMaster"> | string
    mohallaName?: StringWithAggregatesFilter<"MohallaMaster"> | string
    isActive?: BoolWithAggregatesFilter<"MohallaMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"MohallaMaster"> | string | null
  }

  export type ResponseTypeMasterWhereInput = {
    AND?: ResponseTypeMasterWhereInput | ResponseTypeMasterWhereInput[]
    OR?: ResponseTypeMasterWhereInput[]
    NOT?: ResponseTypeMasterWhereInput | ResponseTypeMasterWhereInput[]
    responseTypeId?: StringFilter<"ResponseTypeMaster"> | string
    responseTypeName?: StringFilter<"ResponseTypeMaster"> | string
    isActive?: BoolFilter<"ResponseTypeMaster"> | boolean
    description?: StringNullableFilter<"ResponseTypeMaster"> | string | null
    propertyDetails?: PropertyDetailsListRelationFilter
  }

  export type ResponseTypeMasterOrderByWithRelationInput = {
    responseTypeId?: SortOrder
    responseTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    propertyDetails?: PropertyDetailsOrderByRelationAggregateInput
  }

  export type ResponseTypeMasterWhereUniqueInput = Prisma.AtLeast<{
    responseTypeId?: string
    AND?: ResponseTypeMasterWhereInput | ResponseTypeMasterWhereInput[]
    OR?: ResponseTypeMasterWhereInput[]
    NOT?: ResponseTypeMasterWhereInput | ResponseTypeMasterWhereInput[]
    responseTypeName?: StringFilter<"ResponseTypeMaster"> | string
    isActive?: BoolFilter<"ResponseTypeMaster"> | boolean
    description?: StringNullableFilter<"ResponseTypeMaster"> | string | null
    propertyDetails?: PropertyDetailsListRelationFilter
  }, "responseTypeId">

  export type ResponseTypeMasterOrderByWithAggregationInput = {
    responseTypeId?: SortOrder
    responseTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: ResponseTypeMasterCountOrderByAggregateInput
    _max?: ResponseTypeMasterMaxOrderByAggregateInput
    _min?: ResponseTypeMasterMinOrderByAggregateInput
  }

  export type ResponseTypeMasterScalarWhereWithAggregatesInput = {
    AND?: ResponseTypeMasterScalarWhereWithAggregatesInput | ResponseTypeMasterScalarWhereWithAggregatesInput[]
    OR?: ResponseTypeMasterScalarWhereWithAggregatesInput[]
    NOT?: ResponseTypeMasterScalarWhereWithAggregatesInput | ResponseTypeMasterScalarWhereWithAggregatesInput[]
    responseTypeId?: StringWithAggregatesFilter<"ResponseTypeMaster"> | string
    responseTypeName?: StringWithAggregatesFilter<"ResponseTypeMaster"> | string
    isActive?: BoolWithAggregatesFilter<"ResponseTypeMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"ResponseTypeMaster"> | string | null
  }

  export type PropertyTypeMasterWhereInput = {
    AND?: PropertyTypeMasterWhereInput | PropertyTypeMasterWhereInput[]
    OR?: PropertyTypeMasterWhereInput[]
    NOT?: PropertyTypeMasterWhereInput | PropertyTypeMasterWhereInput[]
    propertyTypeId?: StringFilter<"PropertyTypeMaster"> | string
    propertyTypeName?: StringFilter<"PropertyTypeMaster"> | string
    isActive?: BoolFilter<"PropertyTypeMaster"> | boolean
    description?: StringNullableFilter<"PropertyTypeMaster"> | string | null
    locationDetails?: LocationDetailsListRelationFilter
  }

  export type PropertyTypeMasterOrderByWithRelationInput = {
    propertyTypeId?: SortOrder
    propertyTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    locationDetails?: LocationDetailsOrderByRelationAggregateInput
  }

  export type PropertyTypeMasterWhereUniqueInput = Prisma.AtLeast<{
    propertyTypeId?: string
    AND?: PropertyTypeMasterWhereInput | PropertyTypeMasterWhereInput[]
    OR?: PropertyTypeMasterWhereInput[]
    NOT?: PropertyTypeMasterWhereInput | PropertyTypeMasterWhereInput[]
    propertyTypeName?: StringFilter<"PropertyTypeMaster"> | string
    isActive?: BoolFilter<"PropertyTypeMaster"> | boolean
    description?: StringNullableFilter<"PropertyTypeMaster"> | string | null
    locationDetails?: LocationDetailsListRelationFilter
  }, "propertyTypeId">

  export type PropertyTypeMasterOrderByWithAggregationInput = {
    propertyTypeId?: SortOrder
    propertyTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: PropertyTypeMasterCountOrderByAggregateInput
    _max?: PropertyTypeMasterMaxOrderByAggregateInput
    _min?: PropertyTypeMasterMinOrderByAggregateInput
  }

  export type PropertyTypeMasterScalarWhereWithAggregatesInput = {
    AND?: PropertyTypeMasterScalarWhereWithAggregatesInput | PropertyTypeMasterScalarWhereWithAggregatesInput[]
    OR?: PropertyTypeMasterScalarWhereWithAggregatesInput[]
    NOT?: PropertyTypeMasterScalarWhereWithAggregatesInput | PropertyTypeMasterScalarWhereWithAggregatesInput[]
    propertyTypeId?: StringWithAggregatesFilter<"PropertyTypeMaster"> | string
    propertyTypeName?: StringWithAggregatesFilter<"PropertyTypeMaster"> | string
    isActive?: BoolWithAggregatesFilter<"PropertyTypeMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"PropertyTypeMaster"> | string | null
  }

  export type RespondentStatusMasterWhereInput = {
    AND?: RespondentStatusMasterWhereInput | RespondentStatusMasterWhereInput[]
    OR?: RespondentStatusMasterWhereInput[]
    NOT?: RespondentStatusMasterWhereInput | RespondentStatusMasterWhereInput[]
    respondentStatusId?: StringFilter<"RespondentStatusMaster"> | string
    respondentStatusName?: StringFilter<"RespondentStatusMaster"> | string
    isActive?: BoolFilter<"RespondentStatusMaster"> | boolean
    description?: StringNullableFilter<"RespondentStatusMaster"> | string | null
    propertyDetails?: PropertyDetailsListRelationFilter
  }

  export type RespondentStatusMasterOrderByWithRelationInput = {
    respondentStatusId?: SortOrder
    respondentStatusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    propertyDetails?: PropertyDetailsOrderByRelationAggregateInput
  }

  export type RespondentStatusMasterWhereUniqueInput = Prisma.AtLeast<{
    respondentStatusId?: string
    AND?: RespondentStatusMasterWhereInput | RespondentStatusMasterWhereInput[]
    OR?: RespondentStatusMasterWhereInput[]
    NOT?: RespondentStatusMasterWhereInput | RespondentStatusMasterWhereInput[]
    respondentStatusName?: StringFilter<"RespondentStatusMaster"> | string
    isActive?: BoolFilter<"RespondentStatusMaster"> | boolean
    description?: StringNullableFilter<"RespondentStatusMaster"> | string | null
    propertyDetails?: PropertyDetailsListRelationFilter
  }, "respondentStatusId">

  export type RespondentStatusMasterOrderByWithAggregationInput = {
    respondentStatusId?: SortOrder
    respondentStatusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: RespondentStatusMasterCountOrderByAggregateInput
    _max?: RespondentStatusMasterMaxOrderByAggregateInput
    _min?: RespondentStatusMasterMinOrderByAggregateInput
  }

  export type RespondentStatusMasterScalarWhereWithAggregatesInput = {
    AND?: RespondentStatusMasterScalarWhereWithAggregatesInput | RespondentStatusMasterScalarWhereWithAggregatesInput[]
    OR?: RespondentStatusMasterScalarWhereWithAggregatesInput[]
    NOT?: RespondentStatusMasterScalarWhereWithAggregatesInput | RespondentStatusMasterScalarWhereWithAggregatesInput[]
    respondentStatusId?: StringWithAggregatesFilter<"RespondentStatusMaster"> | string
    respondentStatusName?: StringWithAggregatesFilter<"RespondentStatusMaster"> | string
    isActive?: BoolWithAggregatesFilter<"RespondentStatusMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"RespondentStatusMaster"> | string | null
  }

  export type RoadTypeMasterWhereInput = {
    AND?: RoadTypeMasterWhereInput | RoadTypeMasterWhereInput[]
    OR?: RoadTypeMasterWhereInput[]
    NOT?: RoadTypeMasterWhereInput | RoadTypeMasterWhereInput[]
    roadTypeId?: StringFilter<"RoadTypeMaster"> | string
    roadTypeName?: StringFilter<"RoadTypeMaster"> | string
    isActive?: BoolFilter<"RoadTypeMaster"> | boolean
    description?: StringNullableFilter<"RoadTypeMaster"> | string | null
    locationDetails?: LocationDetailsListRelationFilter
  }

  export type RoadTypeMasterOrderByWithRelationInput = {
    roadTypeId?: SortOrder
    roadTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    locationDetails?: LocationDetailsOrderByRelationAggregateInput
  }

  export type RoadTypeMasterWhereUniqueInput = Prisma.AtLeast<{
    roadTypeId?: string
    AND?: RoadTypeMasterWhereInput | RoadTypeMasterWhereInput[]
    OR?: RoadTypeMasterWhereInput[]
    NOT?: RoadTypeMasterWhereInput | RoadTypeMasterWhereInput[]
    roadTypeName?: StringFilter<"RoadTypeMaster"> | string
    isActive?: BoolFilter<"RoadTypeMaster"> | boolean
    description?: StringNullableFilter<"RoadTypeMaster"> | string | null
    locationDetails?: LocationDetailsListRelationFilter
  }, "roadTypeId">

  export type RoadTypeMasterOrderByWithAggregationInput = {
    roadTypeId?: SortOrder
    roadTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: RoadTypeMasterCountOrderByAggregateInput
    _max?: RoadTypeMasterMaxOrderByAggregateInput
    _min?: RoadTypeMasterMinOrderByAggregateInput
  }

  export type RoadTypeMasterScalarWhereWithAggregatesInput = {
    AND?: RoadTypeMasterScalarWhereWithAggregatesInput | RoadTypeMasterScalarWhereWithAggregatesInput[]
    OR?: RoadTypeMasterScalarWhereWithAggregatesInput[]
    NOT?: RoadTypeMasterScalarWhereWithAggregatesInput | RoadTypeMasterScalarWhereWithAggregatesInput[]
    roadTypeId?: StringWithAggregatesFilter<"RoadTypeMaster"> | string
    roadTypeName?: StringWithAggregatesFilter<"RoadTypeMaster"> | string
    isActive?: BoolWithAggregatesFilter<"RoadTypeMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"RoadTypeMaster"> | string | null
  }

  export type ConstructionTypeMasterWhereInput = {
    AND?: ConstructionTypeMasterWhereInput | ConstructionTypeMasterWhereInput[]
    OR?: ConstructionTypeMasterWhereInput[]
    NOT?: ConstructionTypeMasterWhereInput | ConstructionTypeMasterWhereInput[]
    constructionTypeId?: StringFilter<"ConstructionTypeMaster"> | string
    constructionTypeName?: StringFilter<"ConstructionTypeMaster"> | string
    isActive?: BoolFilter<"ConstructionTypeMaster"> | boolean
    description?: StringNullableFilter<"ConstructionTypeMaster"> | string | null
    locationDetails?: LocationDetailsListRelationFilter
  }

  export type ConstructionTypeMasterOrderByWithRelationInput = {
    constructionTypeId?: SortOrder
    constructionTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    locationDetails?: LocationDetailsOrderByRelationAggregateInput
  }

  export type ConstructionTypeMasterWhereUniqueInput = Prisma.AtLeast<{
    constructionTypeId?: string
    AND?: ConstructionTypeMasterWhereInput | ConstructionTypeMasterWhereInput[]
    OR?: ConstructionTypeMasterWhereInput[]
    NOT?: ConstructionTypeMasterWhereInput | ConstructionTypeMasterWhereInput[]
    constructionTypeName?: StringFilter<"ConstructionTypeMaster"> | string
    isActive?: BoolFilter<"ConstructionTypeMaster"> | boolean
    description?: StringNullableFilter<"ConstructionTypeMaster"> | string | null
    locationDetails?: LocationDetailsListRelationFilter
  }, "constructionTypeId">

  export type ConstructionTypeMasterOrderByWithAggregationInput = {
    constructionTypeId?: SortOrder
    constructionTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: ConstructionTypeMasterCountOrderByAggregateInput
    _max?: ConstructionTypeMasterMaxOrderByAggregateInput
    _min?: ConstructionTypeMasterMinOrderByAggregateInput
  }

  export type ConstructionTypeMasterScalarWhereWithAggregatesInput = {
    AND?: ConstructionTypeMasterScalarWhereWithAggregatesInput | ConstructionTypeMasterScalarWhereWithAggregatesInput[]
    OR?: ConstructionTypeMasterScalarWhereWithAggregatesInput[]
    NOT?: ConstructionTypeMasterScalarWhereWithAggregatesInput | ConstructionTypeMasterScalarWhereWithAggregatesInput[]
    constructionTypeId?: StringWithAggregatesFilter<"ConstructionTypeMaster"> | string
    constructionTypeName?: StringWithAggregatesFilter<"ConstructionTypeMaster"> | string
    isActive?: BoolWithAggregatesFilter<"ConstructionTypeMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"ConstructionTypeMaster"> | string | null
  }

  export type WaterSourceMasterWhereInput = {
    AND?: WaterSourceMasterWhereInput | WaterSourceMasterWhereInput[]
    OR?: WaterSourceMasterWhereInput[]
    NOT?: WaterSourceMasterWhereInput | WaterSourceMasterWhereInput[]
    waterSourceId?: StringFilter<"WaterSourceMaster"> | string
    waterSourceName?: StringFilter<"WaterSourceMaster"> | string
    isActive?: BoolFilter<"WaterSourceMaster"> | boolean
    description?: StringNullableFilter<"WaterSourceMaster"> | string | null
    otherDetails?: OtherDetailsListRelationFilter
  }

  export type WaterSourceMasterOrderByWithRelationInput = {
    waterSourceId?: SortOrder
    waterSourceName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    otherDetails?: OtherDetailsOrderByRelationAggregateInput
  }

  export type WaterSourceMasterWhereUniqueInput = Prisma.AtLeast<{
    waterSourceId?: string
    AND?: WaterSourceMasterWhereInput | WaterSourceMasterWhereInput[]
    OR?: WaterSourceMasterWhereInput[]
    NOT?: WaterSourceMasterWhereInput | WaterSourceMasterWhereInput[]
    waterSourceName?: StringFilter<"WaterSourceMaster"> | string
    isActive?: BoolFilter<"WaterSourceMaster"> | boolean
    description?: StringNullableFilter<"WaterSourceMaster"> | string | null
    otherDetails?: OtherDetailsListRelationFilter
  }, "waterSourceId">

  export type WaterSourceMasterOrderByWithAggregationInput = {
    waterSourceId?: SortOrder
    waterSourceName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: WaterSourceMasterCountOrderByAggregateInput
    _max?: WaterSourceMasterMaxOrderByAggregateInput
    _min?: WaterSourceMasterMinOrderByAggregateInput
  }

  export type WaterSourceMasterScalarWhereWithAggregatesInput = {
    AND?: WaterSourceMasterScalarWhereWithAggregatesInput | WaterSourceMasterScalarWhereWithAggregatesInput[]
    OR?: WaterSourceMasterScalarWhereWithAggregatesInput[]
    NOT?: WaterSourceMasterScalarWhereWithAggregatesInput | WaterSourceMasterScalarWhereWithAggregatesInput[]
    waterSourceId?: StringWithAggregatesFilter<"WaterSourceMaster"> | string
    waterSourceName?: StringWithAggregatesFilter<"WaterSourceMaster"> | string
    isActive?: BoolWithAggregatesFilter<"WaterSourceMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"WaterSourceMaster"> | string | null
  }

  export type DisposalTypeMasterWhereInput = {
    AND?: DisposalTypeMasterWhereInput | DisposalTypeMasterWhereInput[]
    OR?: DisposalTypeMasterWhereInput[]
    NOT?: DisposalTypeMasterWhereInput | DisposalTypeMasterWhereInput[]
    disposalTypeId?: StringFilter<"DisposalTypeMaster"> | string
    disposalTypeName?: StringFilter<"DisposalTypeMaster"> | string
    isActive?: BoolFilter<"DisposalTypeMaster"> | boolean
    description?: StringNullableFilter<"DisposalTypeMaster"> | string | null
    otherDetails?: OtherDetailsListRelationFilter
  }

  export type DisposalTypeMasterOrderByWithRelationInput = {
    disposalTypeId?: SortOrder
    disposalTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    otherDetails?: OtherDetailsOrderByRelationAggregateInput
  }

  export type DisposalTypeMasterWhereUniqueInput = Prisma.AtLeast<{
    disposalTypeId?: string
    AND?: DisposalTypeMasterWhereInput | DisposalTypeMasterWhereInput[]
    OR?: DisposalTypeMasterWhereInput[]
    NOT?: DisposalTypeMasterWhereInput | DisposalTypeMasterWhereInput[]
    disposalTypeName?: StringFilter<"DisposalTypeMaster"> | string
    isActive?: BoolFilter<"DisposalTypeMaster"> | boolean
    description?: StringNullableFilter<"DisposalTypeMaster"> | string | null
    otherDetails?: OtherDetailsListRelationFilter
  }, "disposalTypeId">

  export type DisposalTypeMasterOrderByWithAggregationInput = {
    disposalTypeId?: SortOrder
    disposalTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: DisposalTypeMasterCountOrderByAggregateInput
    _max?: DisposalTypeMasterMaxOrderByAggregateInput
    _min?: DisposalTypeMasterMinOrderByAggregateInput
  }

  export type DisposalTypeMasterScalarWhereWithAggregatesInput = {
    AND?: DisposalTypeMasterScalarWhereWithAggregatesInput | DisposalTypeMasterScalarWhereWithAggregatesInput[]
    OR?: DisposalTypeMasterScalarWhereWithAggregatesInput[]
    NOT?: DisposalTypeMasterScalarWhereWithAggregatesInput | DisposalTypeMasterScalarWhereWithAggregatesInput[]
    disposalTypeId?: StringWithAggregatesFilter<"DisposalTypeMaster"> | string
    disposalTypeName?: StringWithAggregatesFilter<"DisposalTypeMaster"> | string
    isActive?: BoolWithAggregatesFilter<"DisposalTypeMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"DisposalTypeMaster"> | string | null
  }

  export type NrPropertyCategoryMasterWhereInput = {
    AND?: NrPropertyCategoryMasterWhereInput | NrPropertyCategoryMasterWhereInput[]
    OR?: NrPropertyCategoryMasterWhereInput[]
    NOT?: NrPropertyCategoryMasterWhereInput | NrPropertyCategoryMasterWhereInput[]
    propertyCategoryId?: StringFilter<"NrPropertyCategoryMaster"> | string
    propertyCategoryNumber?: IntFilter<"NrPropertyCategoryMaster"> | number
    propertyCategoryName?: StringFilter<"NrPropertyCategoryMaster"> | string
    isActive?: BoolFilter<"NrPropertyCategoryMaster"> | boolean
    description?: StringNullableFilter<"NrPropertyCategoryMaster"> | string | null
    createdAt?: DateTimeFilter<"NrPropertyCategoryMaster"> | Date | string
    subCategories?: NrPropertySubCategoryMasterListRelationFilter
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentListRelationFilter
  }

  export type NrPropertyCategoryMasterOrderByWithRelationInput = {
    propertyCategoryId?: SortOrder
    propertyCategoryNumber?: SortOrder
    propertyCategoryName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    subCategories?: NrPropertySubCategoryMasterOrderByRelationAggregateInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentOrderByRelationAggregateInput
  }

  export type NrPropertyCategoryMasterWhereUniqueInput = Prisma.AtLeast<{
    propertyCategoryId?: string
    AND?: NrPropertyCategoryMasterWhereInput | NrPropertyCategoryMasterWhereInput[]
    OR?: NrPropertyCategoryMasterWhereInput[]
    NOT?: NrPropertyCategoryMasterWhereInput | NrPropertyCategoryMasterWhereInput[]
    propertyCategoryNumber?: IntFilter<"NrPropertyCategoryMaster"> | number
    propertyCategoryName?: StringFilter<"NrPropertyCategoryMaster"> | string
    isActive?: BoolFilter<"NrPropertyCategoryMaster"> | boolean
    description?: StringNullableFilter<"NrPropertyCategoryMaster"> | string | null
    createdAt?: DateTimeFilter<"NrPropertyCategoryMaster"> | Date | string
    subCategories?: NrPropertySubCategoryMasterListRelationFilter
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentListRelationFilter
  }, "propertyCategoryId">

  export type NrPropertyCategoryMasterOrderByWithAggregationInput = {
    propertyCategoryId?: SortOrder
    propertyCategoryNumber?: SortOrder
    propertyCategoryName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NrPropertyCategoryMasterCountOrderByAggregateInput
    _avg?: NrPropertyCategoryMasterAvgOrderByAggregateInput
    _max?: NrPropertyCategoryMasterMaxOrderByAggregateInput
    _min?: NrPropertyCategoryMasterMinOrderByAggregateInput
    _sum?: NrPropertyCategoryMasterSumOrderByAggregateInput
  }

  export type NrPropertyCategoryMasterScalarWhereWithAggregatesInput = {
    AND?: NrPropertyCategoryMasterScalarWhereWithAggregatesInput | NrPropertyCategoryMasterScalarWhereWithAggregatesInput[]
    OR?: NrPropertyCategoryMasterScalarWhereWithAggregatesInput[]
    NOT?: NrPropertyCategoryMasterScalarWhereWithAggregatesInput | NrPropertyCategoryMasterScalarWhereWithAggregatesInput[]
    propertyCategoryId?: StringWithAggregatesFilter<"NrPropertyCategoryMaster"> | string
    propertyCategoryNumber?: IntWithAggregatesFilter<"NrPropertyCategoryMaster"> | number
    propertyCategoryName?: StringWithAggregatesFilter<"NrPropertyCategoryMaster"> | string
    isActive?: BoolWithAggregatesFilter<"NrPropertyCategoryMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"NrPropertyCategoryMaster"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NrPropertyCategoryMaster"> | Date | string
  }

  export type NrPropertySubCategoryMasterWhereInput = {
    AND?: NrPropertySubCategoryMasterWhereInput | NrPropertySubCategoryMasterWhereInput[]
    OR?: NrPropertySubCategoryMasterWhereInput[]
    NOT?: NrPropertySubCategoryMasterWhereInput | NrPropertySubCategoryMasterWhereInput[]
    subCategoryId?: StringFilter<"NrPropertySubCategoryMaster"> | string
    subCategoryNumber?: IntFilter<"NrPropertySubCategoryMaster"> | number
    subCategoryName?: StringFilter<"NrPropertySubCategoryMaster"> | string
    isActive?: BoolFilter<"NrPropertySubCategoryMaster"> | boolean
    description?: StringNullableFilter<"NrPropertySubCategoryMaster"> | string | null
    createdAt?: DateTimeFilter<"NrPropertySubCategoryMaster"> | Date | string
    propertyCategoryId?: StringFilter<"NrPropertySubCategoryMaster"> | string
    propertyCategory?: XOR<NrPropertyCategoryMasterRelationFilter, NrPropertyCategoryMasterWhereInput>
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentListRelationFilter
  }

  export type NrPropertySubCategoryMasterOrderByWithRelationInput = {
    subCategoryId?: SortOrder
    subCategoryNumber?: SortOrder
    subCategoryName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    propertyCategoryId?: SortOrder
    propertyCategory?: NrPropertyCategoryMasterOrderByWithRelationInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentOrderByRelationAggregateInput
  }

  export type NrPropertySubCategoryMasterWhereUniqueInput = Prisma.AtLeast<{
    subCategoryId?: string
    AND?: NrPropertySubCategoryMasterWhereInput | NrPropertySubCategoryMasterWhereInput[]
    OR?: NrPropertySubCategoryMasterWhereInput[]
    NOT?: NrPropertySubCategoryMasterWhereInput | NrPropertySubCategoryMasterWhereInput[]
    subCategoryNumber?: IntFilter<"NrPropertySubCategoryMaster"> | number
    subCategoryName?: StringFilter<"NrPropertySubCategoryMaster"> | string
    isActive?: BoolFilter<"NrPropertySubCategoryMaster"> | boolean
    description?: StringNullableFilter<"NrPropertySubCategoryMaster"> | string | null
    createdAt?: DateTimeFilter<"NrPropertySubCategoryMaster"> | Date | string
    propertyCategoryId?: StringFilter<"NrPropertySubCategoryMaster"> | string
    propertyCategory?: XOR<NrPropertyCategoryMasterRelationFilter, NrPropertyCategoryMasterWhereInput>
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentListRelationFilter
  }, "subCategoryId">

  export type NrPropertySubCategoryMasterOrderByWithAggregationInput = {
    subCategoryId?: SortOrder
    subCategoryNumber?: SortOrder
    subCategoryName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    propertyCategoryId?: SortOrder
    _count?: NrPropertySubCategoryMasterCountOrderByAggregateInput
    _avg?: NrPropertySubCategoryMasterAvgOrderByAggregateInput
    _max?: NrPropertySubCategoryMasterMaxOrderByAggregateInput
    _min?: NrPropertySubCategoryMasterMinOrderByAggregateInput
    _sum?: NrPropertySubCategoryMasterSumOrderByAggregateInput
  }

  export type NrPropertySubCategoryMasterScalarWhereWithAggregatesInput = {
    AND?: NrPropertySubCategoryMasterScalarWhereWithAggregatesInput | NrPropertySubCategoryMasterScalarWhereWithAggregatesInput[]
    OR?: NrPropertySubCategoryMasterScalarWhereWithAggregatesInput[]
    NOT?: NrPropertySubCategoryMasterScalarWhereWithAggregatesInput | NrPropertySubCategoryMasterScalarWhereWithAggregatesInput[]
    subCategoryId?: StringWithAggregatesFilter<"NrPropertySubCategoryMaster"> | string
    subCategoryNumber?: IntWithAggregatesFilter<"NrPropertySubCategoryMaster"> | number
    subCategoryName?: StringWithAggregatesFilter<"NrPropertySubCategoryMaster"> | string
    isActive?: BoolWithAggregatesFilter<"NrPropertySubCategoryMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"NrPropertySubCategoryMaster"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NrPropertySubCategoryMaster"> | Date | string
    propertyCategoryId?: StringWithAggregatesFilter<"NrPropertySubCategoryMaster"> | string
  }

  export type ConstructionNatureMasterWhereInput = {
    AND?: ConstructionNatureMasterWhereInput | ConstructionNatureMasterWhereInput[]
    OR?: ConstructionNatureMasterWhereInput[]
    NOT?: ConstructionNatureMasterWhereInput | ConstructionNatureMasterWhereInput[]
    constructionNatureId?: StringFilter<"ConstructionNatureMaster"> | string
    constructionNatureName?: StringFilter<"ConstructionNatureMaster"> | string
    isActive?: BoolFilter<"ConstructionNatureMaster"> | boolean
    description?: StringNullableFilter<"ConstructionNatureMaster"> | string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentListRelationFilter
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentListRelationFilter
  }

  export type ConstructionNatureMasterOrderByWithRelationInput = {
    constructionNatureId?: SortOrder
    constructionNatureName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    residentialPropertyAssessments?: ResidentialPropertyAssessmentOrderByRelationAggregateInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentOrderByRelationAggregateInput
  }

  export type ConstructionNatureMasterWhereUniqueInput = Prisma.AtLeast<{
    constructionNatureId?: string
    AND?: ConstructionNatureMasterWhereInput | ConstructionNatureMasterWhereInput[]
    OR?: ConstructionNatureMasterWhereInput[]
    NOT?: ConstructionNatureMasterWhereInput | ConstructionNatureMasterWhereInput[]
    constructionNatureName?: StringFilter<"ConstructionNatureMaster"> | string
    isActive?: BoolFilter<"ConstructionNatureMaster"> | boolean
    description?: StringNullableFilter<"ConstructionNatureMaster"> | string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentListRelationFilter
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentListRelationFilter
  }, "constructionNatureId">

  export type ConstructionNatureMasterOrderByWithAggregationInput = {
    constructionNatureId?: SortOrder
    constructionNatureName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: ConstructionNatureMasterCountOrderByAggregateInput
    _max?: ConstructionNatureMasterMaxOrderByAggregateInput
    _min?: ConstructionNatureMasterMinOrderByAggregateInput
  }

  export type ConstructionNatureMasterScalarWhereWithAggregatesInput = {
    AND?: ConstructionNatureMasterScalarWhereWithAggregatesInput | ConstructionNatureMasterScalarWhereWithAggregatesInput[]
    OR?: ConstructionNatureMasterScalarWhereWithAggregatesInput[]
    NOT?: ConstructionNatureMasterScalarWhereWithAggregatesInput | ConstructionNatureMasterScalarWhereWithAggregatesInput[]
    constructionNatureId?: StringWithAggregatesFilter<"ConstructionNatureMaster"> | string
    constructionNatureName?: StringWithAggregatesFilter<"ConstructionNatureMaster"> | string
    isActive?: BoolWithAggregatesFilter<"ConstructionNatureMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"ConstructionNatureMaster"> | string | null
  }

  export type SurveyTypeMasterWhereInput = {
    AND?: SurveyTypeMasterWhereInput | SurveyTypeMasterWhereInput[]
    OR?: SurveyTypeMasterWhereInput[]
    NOT?: SurveyTypeMasterWhereInput | SurveyTypeMasterWhereInput[]
    surveyTypeId?: StringFilter<"SurveyTypeMaster"> | string
    surveyTypeName?: StringFilter<"SurveyTypeMaster"> | string
    isActive?: BoolFilter<"SurveyTypeMaster"> | boolean
    description?: StringNullableFilter<"SurveyTypeMaster"> | string | null
    surveyDetails?: SurveyDetailsListRelationFilter
  }

  export type SurveyTypeMasterOrderByWithRelationInput = {
    surveyTypeId?: SortOrder
    surveyTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    surveyDetails?: SurveyDetailsOrderByRelationAggregateInput
  }

  export type SurveyTypeMasterWhereUniqueInput = Prisma.AtLeast<{
    surveyTypeId?: string
    AND?: SurveyTypeMasterWhereInput | SurveyTypeMasterWhereInput[]
    OR?: SurveyTypeMasterWhereInput[]
    NOT?: SurveyTypeMasterWhereInput | SurveyTypeMasterWhereInput[]
    surveyTypeName?: StringFilter<"SurveyTypeMaster"> | string
    isActive?: BoolFilter<"SurveyTypeMaster"> | boolean
    description?: StringNullableFilter<"SurveyTypeMaster"> | string | null
    surveyDetails?: SurveyDetailsListRelationFilter
  }, "surveyTypeId">

  export type SurveyTypeMasterOrderByWithAggregationInput = {
    surveyTypeId?: SortOrder
    surveyTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: SurveyTypeMasterCountOrderByAggregateInput
    _max?: SurveyTypeMasterMaxOrderByAggregateInput
    _min?: SurveyTypeMasterMinOrderByAggregateInput
  }

  export type SurveyTypeMasterScalarWhereWithAggregatesInput = {
    AND?: SurveyTypeMasterScalarWhereWithAggregatesInput | SurveyTypeMasterScalarWhereWithAggregatesInput[]
    OR?: SurveyTypeMasterScalarWhereWithAggregatesInput[]
    NOT?: SurveyTypeMasterScalarWhereWithAggregatesInput | SurveyTypeMasterScalarWhereWithAggregatesInput[]
    surveyTypeId?: StringWithAggregatesFilter<"SurveyTypeMaster"> | string
    surveyTypeName?: StringWithAggregatesFilter<"SurveyTypeMaster"> | string
    isActive?: BoolWithAggregatesFilter<"SurveyTypeMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"SurveyTypeMaster"> | string | null
  }

  export type OccupancyStatusMasterWhereInput = {
    AND?: OccupancyStatusMasterWhereInput | OccupancyStatusMasterWhereInput[]
    OR?: OccupancyStatusMasterWhereInput[]
    NOT?: OccupancyStatusMasterWhereInput | OccupancyStatusMasterWhereInput[]
    occupancyStatusId?: StringFilter<"OccupancyStatusMaster"> | string
    occupancyStatusName?: StringFilter<"OccupancyStatusMaster"> | string
    isActive?: BoolFilter<"OccupancyStatusMaster"> | boolean
    description?: StringNullableFilter<"OccupancyStatusMaster"> | string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentListRelationFilter
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentListRelationFilter
  }

  export type OccupancyStatusMasterOrderByWithRelationInput = {
    occupancyStatusId?: SortOrder
    occupancyStatusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    residentialPropertyAssessments?: ResidentialPropertyAssessmentOrderByRelationAggregateInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentOrderByRelationAggregateInput
  }

  export type OccupancyStatusMasterWhereUniqueInput = Prisma.AtLeast<{
    occupancyStatusId?: string
    AND?: OccupancyStatusMasterWhereInput | OccupancyStatusMasterWhereInput[]
    OR?: OccupancyStatusMasterWhereInput[]
    NOT?: OccupancyStatusMasterWhereInput | OccupancyStatusMasterWhereInput[]
    occupancyStatusName?: StringFilter<"OccupancyStatusMaster"> | string
    isActive?: BoolFilter<"OccupancyStatusMaster"> | boolean
    description?: StringNullableFilter<"OccupancyStatusMaster"> | string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentListRelationFilter
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentListRelationFilter
  }, "occupancyStatusId">

  export type OccupancyStatusMasterOrderByWithAggregationInput = {
    occupancyStatusId?: SortOrder
    occupancyStatusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: OccupancyStatusMasterCountOrderByAggregateInput
    _max?: OccupancyStatusMasterMaxOrderByAggregateInput
    _min?: OccupancyStatusMasterMinOrderByAggregateInput
  }

  export type OccupancyStatusMasterScalarWhereWithAggregatesInput = {
    AND?: OccupancyStatusMasterScalarWhereWithAggregatesInput | OccupancyStatusMasterScalarWhereWithAggregatesInput[]
    OR?: OccupancyStatusMasterScalarWhereWithAggregatesInput[]
    NOT?: OccupancyStatusMasterScalarWhereWithAggregatesInput | OccupancyStatusMasterScalarWhereWithAggregatesInput[]
    occupancyStatusId?: StringWithAggregatesFilter<"OccupancyStatusMaster"> | string
    occupancyStatusName?: StringWithAggregatesFilter<"OccupancyStatusMaster"> | string
    isActive?: BoolWithAggregatesFilter<"OccupancyStatusMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"OccupancyStatusMaster"> | string | null
  }

  export type SurveyStatusMasterWhereInput = {
    AND?: SurveyStatusMasterWhereInput | SurveyStatusMasterWhereInput[]
    OR?: SurveyStatusMasterWhereInput[]
    NOT?: SurveyStatusMasterWhereInput | SurveyStatusMasterWhereInput[]
    statusId?: StringFilter<"SurveyStatusMaster"> | string
    statusName?: StringFilter<"SurveyStatusMaster"> | string
    isActive?: BoolFilter<"SurveyStatusMaster"> | boolean
    description?: StringNullableFilter<"SurveyStatusMaster"> | string | null
    surveyStatusMaps?: SurveyStatusMappingListRelationFilter
    surveyStatusMapsReverted?: SurveyStatusMappingListRelationFilter
  }

  export type SurveyStatusMasterOrderByWithRelationInput = {
    statusId?: SortOrder
    statusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    surveyStatusMaps?: SurveyStatusMappingOrderByRelationAggregateInput
    surveyStatusMapsReverted?: SurveyStatusMappingOrderByRelationAggregateInput
  }

  export type SurveyStatusMasterWhereUniqueInput = Prisma.AtLeast<{
    statusId?: string
    AND?: SurveyStatusMasterWhereInput | SurveyStatusMasterWhereInput[]
    OR?: SurveyStatusMasterWhereInput[]
    NOT?: SurveyStatusMasterWhereInput | SurveyStatusMasterWhereInput[]
    statusName?: StringFilter<"SurveyStatusMaster"> | string
    isActive?: BoolFilter<"SurveyStatusMaster"> | boolean
    description?: StringNullableFilter<"SurveyStatusMaster"> | string | null
    surveyStatusMaps?: SurveyStatusMappingListRelationFilter
    surveyStatusMapsReverted?: SurveyStatusMappingListRelationFilter
  }, "statusId">

  export type SurveyStatusMasterOrderByWithAggregationInput = {
    statusId?: SortOrder
    statusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: SurveyStatusMasterCountOrderByAggregateInput
    _max?: SurveyStatusMasterMaxOrderByAggregateInput
    _min?: SurveyStatusMasterMinOrderByAggregateInput
  }

  export type SurveyStatusMasterScalarWhereWithAggregatesInput = {
    AND?: SurveyStatusMasterScalarWhereWithAggregatesInput | SurveyStatusMasterScalarWhereWithAggregatesInput[]
    OR?: SurveyStatusMasterScalarWhereWithAggregatesInput[]
    NOT?: SurveyStatusMasterScalarWhereWithAggregatesInput | SurveyStatusMasterScalarWhereWithAggregatesInput[]
    statusId?: StringWithAggregatesFilter<"SurveyStatusMaster"> | string
    statusName?: StringWithAggregatesFilter<"SurveyStatusMaster"> | string
    isActive?: BoolWithAggregatesFilter<"SurveyStatusMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"SurveyStatusMaster"> | string | null
  }

  export type WardStatusMasterWhereInput = {
    AND?: WardStatusMasterWhereInput | WardStatusMasterWhereInput[]
    OR?: WardStatusMasterWhereInput[]
    NOT?: WardStatusMasterWhereInput | WardStatusMasterWhereInput[]
    statusId?: StringFilter<"WardStatusMaster"> | string
    statusName?: StringFilter<"WardStatusMaster"> | string
    isActive?: BoolFilter<"WardStatusMaster"> | boolean
    description?: StringNullableFilter<"WardStatusMaster"> | string | null
    wardStatusMaps?: WardStatusMappingListRelationFilter
  }

  export type WardStatusMasterOrderByWithRelationInput = {
    statusId?: SortOrder
    statusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    wardStatusMaps?: WardStatusMappingOrderByRelationAggregateInput
  }

  export type WardStatusMasterWhereUniqueInput = Prisma.AtLeast<{
    statusId?: string
    AND?: WardStatusMasterWhereInput | WardStatusMasterWhereInput[]
    OR?: WardStatusMasterWhereInput[]
    NOT?: WardStatusMasterWhereInput | WardStatusMasterWhereInput[]
    statusName?: StringFilter<"WardStatusMaster"> | string
    isActive?: BoolFilter<"WardStatusMaster"> | boolean
    description?: StringNullableFilter<"WardStatusMaster"> | string | null
    wardStatusMaps?: WardStatusMappingListRelationFilter
  }, "statusId">

  export type WardStatusMasterOrderByWithAggregationInput = {
    statusId?: SortOrder
    statusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: WardStatusMasterCountOrderByAggregateInput
    _max?: WardStatusMasterMaxOrderByAggregateInput
    _min?: WardStatusMasterMinOrderByAggregateInput
  }

  export type WardStatusMasterScalarWhereWithAggregatesInput = {
    AND?: WardStatusMasterScalarWhereWithAggregatesInput | WardStatusMasterScalarWhereWithAggregatesInput[]
    OR?: WardStatusMasterScalarWhereWithAggregatesInput[]
    NOT?: WardStatusMasterScalarWhereWithAggregatesInput | WardStatusMasterScalarWhereWithAggregatesInput[]
    statusId?: StringWithAggregatesFilter<"WardStatusMaster"> | string
    statusName?: StringWithAggregatesFilter<"WardStatusMaster"> | string
    isActive?: BoolWithAggregatesFilter<"WardStatusMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"WardStatusMaster"> | string | null
  }

  export type UsersMasterWhereInput = {
    AND?: UsersMasterWhereInput | UsersMasterWhereInput[]
    OR?: UsersMasterWhereInput[]
    NOT?: UsersMasterWhereInput | UsersMasterWhereInput[]
    userId?: StringFilter<"UsersMaster"> | string
    username?: StringFilter<"UsersMaster"> | string
    password?: StringFilter<"UsersMaster"> | string
    mobileNumber?: StringNullableFilter<"UsersMaster"> | string | null
    isCreatedAt?: DateTimeFilter<"UsersMaster"> | Date | string
    isActive?: BoolFilter<"UsersMaster"> | boolean
    description?: StringNullableFilter<"UsersMaster"> | string | null
    surveyorAssignments?: SurveyorAssignmentListRelationFilter
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentListRelationFilter
    wardStatusMaps?: WardStatusMappingListRelationFilter
    surveyStatusMaps?: SurveyStatusMappingListRelationFilter
    userRoleMaps?: UserRoleMappingListRelationFilter
    sessions?: SessionListRelationFilter
    surveyors?: SurveyorsListRelationFilter
    supervisors?: SupervisorsListRelationFilter
    admins?: AdminsListRelationFilter
  }

  export type UsersMasterOrderByWithRelationInput = {
    userId?: SortOrder
    username?: SortOrder
    password?: SortOrder
    mobileNumber?: SortOrderInput | SortOrder
    isCreatedAt?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    surveyorAssignments?: SurveyorAssignmentOrderByRelationAggregateInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentOrderByRelationAggregateInput
    wardStatusMaps?: WardStatusMappingOrderByRelationAggregateInput
    surveyStatusMaps?: SurveyStatusMappingOrderByRelationAggregateInput
    userRoleMaps?: UserRoleMappingOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    surveyors?: SurveyorsOrderByRelationAggregateInput
    supervisors?: SupervisorsOrderByRelationAggregateInput
    admins?: AdminsOrderByRelationAggregateInput
  }

  export type UsersMasterWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: UsersMasterWhereInput | UsersMasterWhereInput[]
    OR?: UsersMasterWhereInput[]
    NOT?: UsersMasterWhereInput | UsersMasterWhereInput[]
    username?: StringFilter<"UsersMaster"> | string
    password?: StringFilter<"UsersMaster"> | string
    mobileNumber?: StringNullableFilter<"UsersMaster"> | string | null
    isCreatedAt?: DateTimeFilter<"UsersMaster"> | Date | string
    isActive?: BoolFilter<"UsersMaster"> | boolean
    description?: StringNullableFilter<"UsersMaster"> | string | null
    surveyorAssignments?: SurveyorAssignmentListRelationFilter
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentListRelationFilter
    wardStatusMaps?: WardStatusMappingListRelationFilter
    surveyStatusMaps?: SurveyStatusMappingListRelationFilter
    userRoleMaps?: UserRoleMappingListRelationFilter
    sessions?: SessionListRelationFilter
    surveyors?: SurveyorsListRelationFilter
    supervisors?: SupervisorsListRelationFilter
    admins?: AdminsListRelationFilter
  }, "userId">

  export type UsersMasterOrderByWithAggregationInput = {
    userId?: SortOrder
    username?: SortOrder
    password?: SortOrder
    mobileNumber?: SortOrderInput | SortOrder
    isCreatedAt?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: UsersMasterCountOrderByAggregateInput
    _max?: UsersMasterMaxOrderByAggregateInput
    _min?: UsersMasterMinOrderByAggregateInput
  }

  export type UsersMasterScalarWhereWithAggregatesInput = {
    AND?: UsersMasterScalarWhereWithAggregatesInput | UsersMasterScalarWhereWithAggregatesInput[]
    OR?: UsersMasterScalarWhereWithAggregatesInput[]
    NOT?: UsersMasterScalarWhereWithAggregatesInput | UsersMasterScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UsersMaster"> | string
    username?: StringWithAggregatesFilter<"UsersMaster"> | string
    password?: StringWithAggregatesFilter<"UsersMaster"> | string
    mobileNumber?: StringNullableWithAggregatesFilter<"UsersMaster"> | string | null
    isCreatedAt?: DateTimeWithAggregatesFilter<"UsersMaster"> | Date | string
    isActive?: BoolWithAggregatesFilter<"UsersMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"UsersMaster"> | string | null
  }

  export type RolePermissionMasterWhereInput = {
    AND?: RolePermissionMasterWhereInput | RolePermissionMasterWhereInput[]
    OR?: RolePermissionMasterWhereInput[]
    NOT?: RolePermissionMasterWhereInput | RolePermissionMasterWhereInput[]
    roleId?: StringFilter<"RolePermissionMaster"> | string
    roleName?: StringFilter<"RolePermissionMaster"> | string
    isActive?: BoolFilter<"RolePermissionMaster"> | boolean
    description?: StringNullableFilter<"RolePermissionMaster"> | string | null
    userRoleMaps?: UserRoleMappingListRelationFilter
  }

  export type RolePermissionMasterOrderByWithRelationInput = {
    roleId?: SortOrder
    roleName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    userRoleMaps?: UserRoleMappingOrderByRelationAggregateInput
  }

  export type RolePermissionMasterWhereUniqueInput = Prisma.AtLeast<{
    roleId?: string
    AND?: RolePermissionMasterWhereInput | RolePermissionMasterWhereInput[]
    OR?: RolePermissionMasterWhereInput[]
    NOT?: RolePermissionMasterWhereInput | RolePermissionMasterWhereInput[]
    roleName?: StringFilter<"RolePermissionMaster"> | string
    isActive?: BoolFilter<"RolePermissionMaster"> | boolean
    description?: StringNullableFilter<"RolePermissionMaster"> | string | null
    userRoleMaps?: UserRoleMappingListRelationFilter
  }, "roleId">

  export type RolePermissionMasterOrderByWithAggregationInput = {
    roleId?: SortOrder
    roleName?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: RolePermissionMasterCountOrderByAggregateInput
    _max?: RolePermissionMasterMaxOrderByAggregateInput
    _min?: RolePermissionMasterMinOrderByAggregateInput
  }

  export type RolePermissionMasterScalarWhereWithAggregatesInput = {
    AND?: RolePermissionMasterScalarWhereWithAggregatesInput | RolePermissionMasterScalarWhereWithAggregatesInput[]
    OR?: RolePermissionMasterScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionMasterScalarWhereWithAggregatesInput | RolePermissionMasterScalarWhereWithAggregatesInput[]
    roleId?: StringWithAggregatesFilter<"RolePermissionMaster"> | string
    roleName?: StringWithAggregatesFilter<"RolePermissionMaster"> | string
    isActive?: BoolWithAggregatesFilter<"RolePermissionMaster"> | boolean
    description?: StringNullableWithAggregatesFilter<"RolePermissionMaster"> | string | null
  }

  export type UlbZoneMappingWhereInput = {
    AND?: UlbZoneMappingWhereInput | UlbZoneMappingWhereInput[]
    OR?: UlbZoneMappingWhereInput[]
    NOT?: UlbZoneMappingWhereInput | UlbZoneMappingWhereInput[]
    ulbZoneMapId?: StringFilter<"UlbZoneMapping"> | string
    ulbId?: StringFilter<"UlbZoneMapping"> | string
    zoneId?: StringFilter<"UlbZoneMapping"> | string
    isActive?: BoolFilter<"UlbZoneMapping"> | boolean
    ulb?: XOR<UlbMasterRelationFilter, UlbMasterWhereInput>
    zone?: XOR<ZoneMasterRelationFilter, ZoneMasterWhereInput>
    surveyors?: SurveyorsListRelationFilter
  }

  export type UlbZoneMappingOrderByWithRelationInput = {
    ulbZoneMapId?: SortOrder
    ulbId?: SortOrder
    zoneId?: SortOrder
    isActive?: SortOrder
    ulb?: UlbMasterOrderByWithRelationInput
    zone?: ZoneMasterOrderByWithRelationInput
    surveyors?: SurveyorsOrderByRelationAggregateInput
  }

  export type UlbZoneMappingWhereUniqueInput = Prisma.AtLeast<{
    ulbZoneMapId?: string
    ulbId_zoneId?: UlbZoneMappingUlbIdZoneIdCompoundUniqueInput
    AND?: UlbZoneMappingWhereInput | UlbZoneMappingWhereInput[]
    OR?: UlbZoneMappingWhereInput[]
    NOT?: UlbZoneMappingWhereInput | UlbZoneMappingWhereInput[]
    ulbId?: StringFilter<"UlbZoneMapping"> | string
    zoneId?: StringFilter<"UlbZoneMapping"> | string
    isActive?: BoolFilter<"UlbZoneMapping"> | boolean
    ulb?: XOR<UlbMasterRelationFilter, UlbMasterWhereInput>
    zone?: XOR<ZoneMasterRelationFilter, ZoneMasterWhereInput>
    surveyors?: SurveyorsListRelationFilter
  }, "ulbZoneMapId" | "ulbId_zoneId">

  export type UlbZoneMappingOrderByWithAggregationInput = {
    ulbZoneMapId?: SortOrder
    ulbId?: SortOrder
    zoneId?: SortOrder
    isActive?: SortOrder
    _count?: UlbZoneMappingCountOrderByAggregateInput
    _max?: UlbZoneMappingMaxOrderByAggregateInput
    _min?: UlbZoneMappingMinOrderByAggregateInput
  }

  export type UlbZoneMappingScalarWhereWithAggregatesInput = {
    AND?: UlbZoneMappingScalarWhereWithAggregatesInput | UlbZoneMappingScalarWhereWithAggregatesInput[]
    OR?: UlbZoneMappingScalarWhereWithAggregatesInput[]
    NOT?: UlbZoneMappingScalarWhereWithAggregatesInput | UlbZoneMappingScalarWhereWithAggregatesInput[]
    ulbZoneMapId?: StringWithAggregatesFilter<"UlbZoneMapping"> | string
    ulbId?: StringWithAggregatesFilter<"UlbZoneMapping"> | string
    zoneId?: StringWithAggregatesFilter<"UlbZoneMapping"> | string
    isActive?: BoolWithAggregatesFilter<"UlbZoneMapping"> | boolean
  }

  export type ZoneWardMappingWhereInput = {
    AND?: ZoneWardMappingWhereInput | ZoneWardMappingWhereInput[]
    OR?: ZoneWardMappingWhereInput[]
    NOT?: ZoneWardMappingWhereInput | ZoneWardMappingWhereInput[]
    zoneWardMapId?: StringFilter<"ZoneWardMapping"> | string
    zoneId?: StringFilter<"ZoneWardMapping"> | string
    wardId?: StringFilter<"ZoneWardMapping"> | string
    isActive?: BoolFilter<"ZoneWardMapping"> | boolean
    zone?: XOR<ZoneMasterRelationFilter, ZoneMasterWhereInput>
    ward?: XOR<WardMasterRelationFilter, WardMasterWhereInput>
    surveyors?: SurveyorsListRelationFilter
  }

  export type ZoneWardMappingOrderByWithRelationInput = {
    zoneWardMapId?: SortOrder
    zoneId?: SortOrder
    wardId?: SortOrder
    isActive?: SortOrder
    zone?: ZoneMasterOrderByWithRelationInput
    ward?: WardMasterOrderByWithRelationInput
    surveyors?: SurveyorsOrderByRelationAggregateInput
  }

  export type ZoneWardMappingWhereUniqueInput = Prisma.AtLeast<{
    zoneWardMapId?: string
    zoneId_wardId?: ZoneWardMappingZoneIdWardIdCompoundUniqueInput
    AND?: ZoneWardMappingWhereInput | ZoneWardMappingWhereInput[]
    OR?: ZoneWardMappingWhereInput[]
    NOT?: ZoneWardMappingWhereInput | ZoneWardMappingWhereInput[]
    zoneId?: StringFilter<"ZoneWardMapping"> | string
    wardId?: StringFilter<"ZoneWardMapping"> | string
    isActive?: BoolFilter<"ZoneWardMapping"> | boolean
    zone?: XOR<ZoneMasterRelationFilter, ZoneMasterWhereInput>
    ward?: XOR<WardMasterRelationFilter, WardMasterWhereInput>
    surveyors?: SurveyorsListRelationFilter
  }, "zoneWardMapId" | "zoneId_wardId">

  export type ZoneWardMappingOrderByWithAggregationInput = {
    zoneWardMapId?: SortOrder
    zoneId?: SortOrder
    wardId?: SortOrder
    isActive?: SortOrder
    _count?: ZoneWardMappingCountOrderByAggregateInput
    _max?: ZoneWardMappingMaxOrderByAggregateInput
    _min?: ZoneWardMappingMinOrderByAggregateInput
  }

  export type ZoneWardMappingScalarWhereWithAggregatesInput = {
    AND?: ZoneWardMappingScalarWhereWithAggregatesInput | ZoneWardMappingScalarWhereWithAggregatesInput[]
    OR?: ZoneWardMappingScalarWhereWithAggregatesInput[]
    NOT?: ZoneWardMappingScalarWhereWithAggregatesInput | ZoneWardMappingScalarWhereWithAggregatesInput[]
    zoneWardMapId?: StringWithAggregatesFilter<"ZoneWardMapping"> | string
    zoneId?: StringWithAggregatesFilter<"ZoneWardMapping"> | string
    wardId?: StringWithAggregatesFilter<"ZoneWardMapping"> | string
    isActive?: BoolWithAggregatesFilter<"ZoneWardMapping"> | boolean
  }

  export type WardMohallaMappingWhereInput = {
    AND?: WardMohallaMappingWhereInput | WardMohallaMappingWhereInput[]
    OR?: WardMohallaMappingWhereInput[]
    NOT?: WardMohallaMappingWhereInput | WardMohallaMappingWhereInput[]
    wardMohallaMapId?: StringFilter<"WardMohallaMapping"> | string
    wardId?: StringFilter<"WardMohallaMapping"> | string
    mohallaId?: StringFilter<"WardMohallaMapping"> | string
    isActive?: BoolFilter<"WardMohallaMapping"> | boolean
    ward?: XOR<WardMasterRelationFilter, WardMasterWhereInput>
    mohalla?: XOR<MohallaMasterRelationFilter, MohallaMasterWhereInput>
    surveyorAssignments?: SurveyorAssignmentListRelationFilter
    surveyors?: SurveyorsListRelationFilter
  }

  export type WardMohallaMappingOrderByWithRelationInput = {
    wardMohallaMapId?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    isActive?: SortOrder
    ward?: WardMasterOrderByWithRelationInput
    mohalla?: MohallaMasterOrderByWithRelationInput
    surveyorAssignments?: SurveyorAssignmentOrderByRelationAggregateInput
    surveyors?: SurveyorsOrderByRelationAggregateInput
  }

  export type WardMohallaMappingWhereUniqueInput = Prisma.AtLeast<{
    wardMohallaMapId?: string
    wardId_mohallaId?: WardMohallaMappingWardIdMohallaIdCompoundUniqueInput
    AND?: WardMohallaMappingWhereInput | WardMohallaMappingWhereInput[]
    OR?: WardMohallaMappingWhereInput[]
    NOT?: WardMohallaMappingWhereInput | WardMohallaMappingWhereInput[]
    wardId?: StringFilter<"WardMohallaMapping"> | string
    mohallaId?: StringFilter<"WardMohallaMapping"> | string
    isActive?: BoolFilter<"WardMohallaMapping"> | boolean
    ward?: XOR<WardMasterRelationFilter, WardMasterWhereInput>
    mohalla?: XOR<MohallaMasterRelationFilter, MohallaMasterWhereInput>
    surveyorAssignments?: SurveyorAssignmentListRelationFilter
    surveyors?: SurveyorsListRelationFilter
  }, "wardMohallaMapId" | "wardId_mohallaId">

  export type WardMohallaMappingOrderByWithAggregationInput = {
    wardMohallaMapId?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    isActive?: SortOrder
    _count?: WardMohallaMappingCountOrderByAggregateInput
    _max?: WardMohallaMappingMaxOrderByAggregateInput
    _min?: WardMohallaMappingMinOrderByAggregateInput
  }

  export type WardMohallaMappingScalarWhereWithAggregatesInput = {
    AND?: WardMohallaMappingScalarWhereWithAggregatesInput | WardMohallaMappingScalarWhereWithAggregatesInput[]
    OR?: WardMohallaMappingScalarWhereWithAggregatesInput[]
    NOT?: WardMohallaMappingScalarWhereWithAggregatesInput | WardMohallaMappingScalarWhereWithAggregatesInput[]
    wardMohallaMapId?: StringWithAggregatesFilter<"WardMohallaMapping"> | string
    wardId?: StringWithAggregatesFilter<"WardMohallaMapping"> | string
    mohallaId?: StringWithAggregatesFilter<"WardMohallaMapping"> | string
    isActive?: BoolWithAggregatesFilter<"WardMohallaMapping"> | boolean
  }

  export type SurveyorAssignmentWhereInput = {
    AND?: SurveyorAssignmentWhereInput | SurveyorAssignmentWhereInput[]
    OR?: SurveyorAssignmentWhereInput[]
    NOT?: SurveyorAssignmentWhereInput | SurveyorAssignmentWhereInput[]
    assignmentId?: StringFilter<"SurveyorAssignment"> | string
    userId?: StringFilter<"SurveyorAssignment"> | string
    assignmentType?: StringFilter<"SurveyorAssignment"> | string
    wardId?: StringFilter<"SurveyorAssignment"> | string
    mohallaId?: StringFilter<"SurveyorAssignment"> | string
    wardMohallaMapId?: StringFilter<"SurveyorAssignment"> | string
    assignedById?: StringFilter<"SurveyorAssignment"> | string
    isActive?: BoolFilter<"SurveyorAssignment"> | boolean
    user?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
    ward?: XOR<WardMasterRelationFilter, WardMasterWhereInput>
    mohalla?: XOR<MohallaMasterRelationFilter, MohallaMasterWhereInput>
    wardMohallaMap?: XOR<WardMohallaMappingRelationFilter, WardMohallaMappingWhereInput>
    assignedBy?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
  }

  export type SurveyorAssignmentOrderByWithRelationInput = {
    assignmentId?: SortOrder
    userId?: SortOrder
    assignmentType?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    wardMohallaMapId?: SortOrder
    assignedById?: SortOrder
    isActive?: SortOrder
    user?: UsersMasterOrderByWithRelationInput
    ward?: WardMasterOrderByWithRelationInput
    mohalla?: MohallaMasterOrderByWithRelationInput
    wardMohallaMap?: WardMohallaMappingOrderByWithRelationInput
    assignedBy?: UsersMasterOrderByWithRelationInput
  }

  export type SurveyorAssignmentWhereUniqueInput = Prisma.AtLeast<{
    assignmentId?: string
    userId_wardId_mohallaId?: SurveyorAssignmentUserIdWardIdMohallaIdCompoundUniqueInput
    AND?: SurveyorAssignmentWhereInput | SurveyorAssignmentWhereInput[]
    OR?: SurveyorAssignmentWhereInput[]
    NOT?: SurveyorAssignmentWhereInput | SurveyorAssignmentWhereInput[]
    userId?: StringFilter<"SurveyorAssignment"> | string
    assignmentType?: StringFilter<"SurveyorAssignment"> | string
    wardId?: StringFilter<"SurveyorAssignment"> | string
    mohallaId?: StringFilter<"SurveyorAssignment"> | string
    wardMohallaMapId?: StringFilter<"SurveyorAssignment"> | string
    assignedById?: StringFilter<"SurveyorAssignment"> | string
    isActive?: BoolFilter<"SurveyorAssignment"> | boolean
    user?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
    ward?: XOR<WardMasterRelationFilter, WardMasterWhereInput>
    mohalla?: XOR<MohallaMasterRelationFilter, MohallaMasterWhereInput>
    wardMohallaMap?: XOR<WardMohallaMappingRelationFilter, WardMohallaMappingWhereInput>
    assignedBy?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
  }, "assignmentId" | "userId_wardId_mohallaId">

  export type SurveyorAssignmentOrderByWithAggregationInput = {
    assignmentId?: SortOrder
    userId?: SortOrder
    assignmentType?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    wardMohallaMapId?: SortOrder
    assignedById?: SortOrder
    isActive?: SortOrder
    _count?: SurveyorAssignmentCountOrderByAggregateInput
    _max?: SurveyorAssignmentMaxOrderByAggregateInput
    _min?: SurveyorAssignmentMinOrderByAggregateInput
  }

  export type SurveyorAssignmentScalarWhereWithAggregatesInput = {
    AND?: SurveyorAssignmentScalarWhereWithAggregatesInput | SurveyorAssignmentScalarWhereWithAggregatesInput[]
    OR?: SurveyorAssignmentScalarWhereWithAggregatesInput[]
    NOT?: SurveyorAssignmentScalarWhereWithAggregatesInput | SurveyorAssignmentScalarWhereWithAggregatesInput[]
    assignmentId?: StringWithAggregatesFilter<"SurveyorAssignment"> | string
    userId?: StringWithAggregatesFilter<"SurveyorAssignment"> | string
    assignmentType?: StringWithAggregatesFilter<"SurveyorAssignment"> | string
    wardId?: StringWithAggregatesFilter<"SurveyorAssignment"> | string
    mohallaId?: StringWithAggregatesFilter<"SurveyorAssignment"> | string
    wardMohallaMapId?: StringWithAggregatesFilter<"SurveyorAssignment"> | string
    assignedById?: StringWithAggregatesFilter<"SurveyorAssignment"> | string
    isActive?: BoolWithAggregatesFilter<"SurveyorAssignment"> | boolean
  }

  export type WardStatusMappingWhereInput = {
    AND?: WardStatusMappingWhereInput | WardStatusMappingWhereInput[]
    OR?: WardStatusMappingWhereInput[]
    NOT?: WardStatusMappingWhereInput | WardStatusMappingWhereInput[]
    wardStatusId?: StringFilter<"WardStatusMapping"> | string
    wardId?: StringFilter<"WardStatusMapping"> | string
    statusId?: StringFilter<"WardStatusMapping"> | string
    changedById?: StringFilter<"WardStatusMapping"> | string
    isActive?: BoolFilter<"WardStatusMapping"> | boolean
    ward?: XOR<WardMasterRelationFilter, WardMasterWhereInput>
    status?: XOR<WardStatusMasterRelationFilter, WardStatusMasterWhereInput>
    changedBy?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
  }

  export type WardStatusMappingOrderByWithRelationInput = {
    wardStatusId?: SortOrder
    wardId?: SortOrder
    statusId?: SortOrder
    changedById?: SortOrder
    isActive?: SortOrder
    ward?: WardMasterOrderByWithRelationInput
    status?: WardStatusMasterOrderByWithRelationInput
    changedBy?: UsersMasterOrderByWithRelationInput
  }

  export type WardStatusMappingWhereUniqueInput = Prisma.AtLeast<{
    wardStatusId?: string
    wardId_statusId?: WardStatusMappingWardIdStatusIdCompoundUniqueInput
    AND?: WardStatusMappingWhereInput | WardStatusMappingWhereInput[]
    OR?: WardStatusMappingWhereInput[]
    NOT?: WardStatusMappingWhereInput | WardStatusMappingWhereInput[]
    wardId?: StringFilter<"WardStatusMapping"> | string
    statusId?: StringFilter<"WardStatusMapping"> | string
    changedById?: StringFilter<"WardStatusMapping"> | string
    isActive?: BoolFilter<"WardStatusMapping"> | boolean
    ward?: XOR<WardMasterRelationFilter, WardMasterWhereInput>
    status?: XOR<WardStatusMasterRelationFilter, WardStatusMasterWhereInput>
    changedBy?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
  }, "wardStatusId" | "wardId_statusId">

  export type WardStatusMappingOrderByWithAggregationInput = {
    wardStatusId?: SortOrder
    wardId?: SortOrder
    statusId?: SortOrder
    changedById?: SortOrder
    isActive?: SortOrder
    _count?: WardStatusMappingCountOrderByAggregateInput
    _max?: WardStatusMappingMaxOrderByAggregateInput
    _min?: WardStatusMappingMinOrderByAggregateInput
  }

  export type WardStatusMappingScalarWhereWithAggregatesInput = {
    AND?: WardStatusMappingScalarWhereWithAggregatesInput | WardStatusMappingScalarWhereWithAggregatesInput[]
    OR?: WardStatusMappingScalarWhereWithAggregatesInput[]
    NOT?: WardStatusMappingScalarWhereWithAggregatesInput | WardStatusMappingScalarWhereWithAggregatesInput[]
    wardStatusId?: StringWithAggregatesFilter<"WardStatusMapping"> | string
    wardId?: StringWithAggregatesFilter<"WardStatusMapping"> | string
    statusId?: StringWithAggregatesFilter<"WardStatusMapping"> | string
    changedById?: StringWithAggregatesFilter<"WardStatusMapping"> | string
    isActive?: BoolWithAggregatesFilter<"WardStatusMapping"> | boolean
  }

  export type SurveyStatusMappingWhereInput = {
    AND?: SurveyStatusMappingWhereInput | SurveyStatusMappingWhereInput[]
    OR?: SurveyStatusMappingWhereInput[]
    NOT?: SurveyStatusMappingWhereInput | SurveyStatusMappingWhereInput[]
    statusMappingId?: StringFilter<"SurveyStatusMapping"> | string
    surveyUniqueCode?: StringFilter<"SurveyStatusMapping"> | string
    statusId?: StringFilter<"SurveyStatusMapping"> | string
    revertedFromId?: StringNullableFilter<"SurveyStatusMapping"> | string | null
    changedById?: StringFilter<"SurveyStatusMapping"> | string
    isActive?: BoolFilter<"SurveyStatusMapping"> | boolean
    survey?: XOR<SurveyDetailsRelationFilter, SurveyDetailsWhereInput>
    status?: XOR<SurveyStatusMasterRelationFilter, SurveyStatusMasterWhereInput>
    revertedFrom?: XOR<SurveyStatusMasterNullableRelationFilter, SurveyStatusMasterWhereInput> | null
    changedBy?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
  }

  export type SurveyStatusMappingOrderByWithRelationInput = {
    statusMappingId?: SortOrder
    surveyUniqueCode?: SortOrder
    statusId?: SortOrder
    revertedFromId?: SortOrderInput | SortOrder
    changedById?: SortOrder
    isActive?: SortOrder
    survey?: SurveyDetailsOrderByWithRelationInput
    status?: SurveyStatusMasterOrderByWithRelationInput
    revertedFrom?: SurveyStatusMasterOrderByWithRelationInput
    changedBy?: UsersMasterOrderByWithRelationInput
  }

  export type SurveyStatusMappingWhereUniqueInput = Prisma.AtLeast<{
    statusMappingId?: string
    surveyUniqueCode_statusId?: SurveyStatusMappingSurveyUniqueCodeStatusIdCompoundUniqueInput
    AND?: SurveyStatusMappingWhereInput | SurveyStatusMappingWhereInput[]
    OR?: SurveyStatusMappingWhereInput[]
    NOT?: SurveyStatusMappingWhereInput | SurveyStatusMappingWhereInput[]
    surveyUniqueCode?: StringFilter<"SurveyStatusMapping"> | string
    statusId?: StringFilter<"SurveyStatusMapping"> | string
    revertedFromId?: StringNullableFilter<"SurveyStatusMapping"> | string | null
    changedById?: StringFilter<"SurveyStatusMapping"> | string
    isActive?: BoolFilter<"SurveyStatusMapping"> | boolean
    survey?: XOR<SurveyDetailsRelationFilter, SurveyDetailsWhereInput>
    status?: XOR<SurveyStatusMasterRelationFilter, SurveyStatusMasterWhereInput>
    revertedFrom?: XOR<SurveyStatusMasterNullableRelationFilter, SurveyStatusMasterWhereInput> | null
    changedBy?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
  }, "statusMappingId" | "surveyUniqueCode_statusId">

  export type SurveyStatusMappingOrderByWithAggregationInput = {
    statusMappingId?: SortOrder
    surveyUniqueCode?: SortOrder
    statusId?: SortOrder
    revertedFromId?: SortOrderInput | SortOrder
    changedById?: SortOrder
    isActive?: SortOrder
    _count?: SurveyStatusMappingCountOrderByAggregateInput
    _max?: SurveyStatusMappingMaxOrderByAggregateInput
    _min?: SurveyStatusMappingMinOrderByAggregateInput
  }

  export type SurveyStatusMappingScalarWhereWithAggregatesInput = {
    AND?: SurveyStatusMappingScalarWhereWithAggregatesInput | SurveyStatusMappingScalarWhereWithAggregatesInput[]
    OR?: SurveyStatusMappingScalarWhereWithAggregatesInput[]
    NOT?: SurveyStatusMappingScalarWhereWithAggregatesInput | SurveyStatusMappingScalarWhereWithAggregatesInput[]
    statusMappingId?: StringWithAggregatesFilter<"SurveyStatusMapping"> | string
    surveyUniqueCode?: StringWithAggregatesFilter<"SurveyStatusMapping"> | string
    statusId?: StringWithAggregatesFilter<"SurveyStatusMapping"> | string
    revertedFromId?: StringNullableWithAggregatesFilter<"SurveyStatusMapping"> | string | null
    changedById?: StringWithAggregatesFilter<"SurveyStatusMapping"> | string
    isActive?: BoolWithAggregatesFilter<"SurveyStatusMapping"> | boolean
  }

  export type UserRoleMappingWhereInput = {
    AND?: UserRoleMappingWhereInput | UserRoleMappingWhereInput[]
    OR?: UserRoleMappingWhereInput[]
    NOT?: UserRoleMappingWhereInput | UserRoleMappingWhereInput[]
    userRoleMapId?: StringFilter<"UserRoleMapping"> | string
    userId?: StringFilter<"UserRoleMapping"> | string
    roleId?: StringFilter<"UserRoleMapping"> | string
    isActive?: BoolFilter<"UserRoleMapping"> | boolean
    user?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
    role?: XOR<RolePermissionMasterRelationFilter, RolePermissionMasterWhereInput>
  }

  export type UserRoleMappingOrderByWithRelationInput = {
    userRoleMapId?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    user?: UsersMasterOrderByWithRelationInput
    role?: RolePermissionMasterOrderByWithRelationInput
  }

  export type UserRoleMappingWhereUniqueInput = Prisma.AtLeast<{
    userRoleMapId?: string
    userId_roleId?: UserRoleMappingUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleMappingWhereInput | UserRoleMappingWhereInput[]
    OR?: UserRoleMappingWhereInput[]
    NOT?: UserRoleMappingWhereInput | UserRoleMappingWhereInput[]
    userId?: StringFilter<"UserRoleMapping"> | string
    roleId?: StringFilter<"UserRoleMapping"> | string
    isActive?: BoolFilter<"UserRoleMapping"> | boolean
    user?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
    role?: XOR<RolePermissionMasterRelationFilter, RolePermissionMasterWhereInput>
  }, "userRoleMapId" | "userId_roleId">

  export type UserRoleMappingOrderByWithAggregationInput = {
    userRoleMapId?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    _count?: UserRoleMappingCountOrderByAggregateInput
    _max?: UserRoleMappingMaxOrderByAggregateInput
    _min?: UserRoleMappingMinOrderByAggregateInput
  }

  export type UserRoleMappingScalarWhereWithAggregatesInput = {
    AND?: UserRoleMappingScalarWhereWithAggregatesInput | UserRoleMappingScalarWhereWithAggregatesInput[]
    OR?: UserRoleMappingScalarWhereWithAggregatesInput[]
    NOT?: UserRoleMappingScalarWhereWithAggregatesInput | UserRoleMappingScalarWhereWithAggregatesInput[]
    userRoleMapId?: StringWithAggregatesFilter<"UserRoleMapping"> | string
    userId?: StringWithAggregatesFilter<"UserRoleMapping"> | string
    roleId?: StringWithAggregatesFilter<"UserRoleMapping"> | string
    isActive?: BoolWithAggregatesFilter<"UserRoleMapping"> | boolean
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    sessionId?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    loginTime?: DateTimeFilter<"Session"> | Date | string
    logoutTime?: DateTimeFilter<"Session"> | Date | string
    isActive?: BoolFilter<"Session"> | boolean
    user?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    sessionId?: SortOrder
    userId?: SortOrder
    loginTime?: SortOrder
    logoutTime?: SortOrder
    isActive?: SortOrder
    user?: UsersMasterOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    sessionId?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    loginTime?: DateTimeFilter<"Session"> | Date | string
    logoutTime?: DateTimeFilter<"Session"> | Date | string
    isActive?: BoolFilter<"Session"> | boolean
    user?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
  }, "sessionId">

  export type SessionOrderByWithAggregationInput = {
    sessionId?: SortOrder
    userId?: SortOrder
    loginTime?: SortOrder
    logoutTime?: SortOrder
    isActive?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    sessionId?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    loginTime?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    logoutTime?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Session"> | boolean
  }

  export type SurveyorsWhereInput = {
    AND?: SurveyorsWhereInput | SurveyorsWhereInput[]
    OR?: SurveyorsWhereInput[]
    NOT?: SurveyorsWhereInput | SurveyorsWhereInput[]
    userId?: StringFilter<"Surveyors"> | string
    surveyorName?: StringFilter<"Surveyors"> | string
    username?: StringFilter<"Surveyors"> | string
    password?: StringFilter<"Surveyors"> | string
    wardNumber?: StringFilter<"Surveyors"> | string
    wardMohallaMapId?: StringFilter<"Surveyors"> | string
    zoneWardMapId?: StringFilter<"Surveyors"> | string
    ulbZoneMapId?: StringFilter<"Surveyors"> | string
    user?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
    wardMohallaMap?: XOR<WardMohallaMappingRelationFilter, WardMohallaMappingWhereInput>
    zoneWardMap?: XOR<ZoneWardMappingRelationFilter, ZoneWardMappingWhereInput>
    ulbZoneMap?: XOR<UlbZoneMappingRelationFilter, UlbZoneMappingWhereInput>
  }

  export type SurveyorsOrderByWithRelationInput = {
    userId?: SortOrder
    surveyorName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    wardNumber?: SortOrder
    wardMohallaMapId?: SortOrder
    zoneWardMapId?: SortOrder
    ulbZoneMapId?: SortOrder
    user?: UsersMasterOrderByWithRelationInput
    wardMohallaMap?: WardMohallaMappingOrderByWithRelationInput
    zoneWardMap?: ZoneWardMappingOrderByWithRelationInput
    ulbZoneMap?: UlbZoneMappingOrderByWithRelationInput
  }

  export type SurveyorsWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: SurveyorsWhereInput | SurveyorsWhereInput[]
    OR?: SurveyorsWhereInput[]
    NOT?: SurveyorsWhereInput | SurveyorsWhereInput[]
    surveyorName?: StringFilter<"Surveyors"> | string
    username?: StringFilter<"Surveyors"> | string
    password?: StringFilter<"Surveyors"> | string
    wardNumber?: StringFilter<"Surveyors"> | string
    wardMohallaMapId?: StringFilter<"Surveyors"> | string
    zoneWardMapId?: StringFilter<"Surveyors"> | string
    ulbZoneMapId?: StringFilter<"Surveyors"> | string
    user?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
    wardMohallaMap?: XOR<WardMohallaMappingRelationFilter, WardMohallaMappingWhereInput>
    zoneWardMap?: XOR<ZoneWardMappingRelationFilter, ZoneWardMappingWhereInput>
    ulbZoneMap?: XOR<UlbZoneMappingRelationFilter, UlbZoneMappingWhereInput>
  }, "userId">

  export type SurveyorsOrderByWithAggregationInput = {
    userId?: SortOrder
    surveyorName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    wardNumber?: SortOrder
    wardMohallaMapId?: SortOrder
    zoneWardMapId?: SortOrder
    ulbZoneMapId?: SortOrder
    _count?: SurveyorsCountOrderByAggregateInput
    _max?: SurveyorsMaxOrderByAggregateInput
    _min?: SurveyorsMinOrderByAggregateInput
  }

  export type SurveyorsScalarWhereWithAggregatesInput = {
    AND?: SurveyorsScalarWhereWithAggregatesInput | SurveyorsScalarWhereWithAggregatesInput[]
    OR?: SurveyorsScalarWhereWithAggregatesInput[]
    NOT?: SurveyorsScalarWhereWithAggregatesInput | SurveyorsScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"Surveyors"> | string
    surveyorName?: StringWithAggregatesFilter<"Surveyors"> | string
    username?: StringWithAggregatesFilter<"Surveyors"> | string
    password?: StringWithAggregatesFilter<"Surveyors"> | string
    wardNumber?: StringWithAggregatesFilter<"Surveyors"> | string
    wardMohallaMapId?: StringWithAggregatesFilter<"Surveyors"> | string
    zoneWardMapId?: StringWithAggregatesFilter<"Surveyors"> | string
    ulbZoneMapId?: StringWithAggregatesFilter<"Surveyors"> | string
  }

  export type SupervisorsWhereInput = {
    AND?: SupervisorsWhereInput | SupervisorsWhereInput[]
    OR?: SupervisorsWhereInput[]
    NOT?: SupervisorsWhereInput | SupervisorsWhereInput[]
    userId?: StringFilter<"Supervisors"> | string
    supervisorName?: StringFilter<"Supervisors"> | string
    username?: StringFilter<"Supervisors"> | string
    password?: StringFilter<"Supervisors"> | string
    wardId?: StringFilter<"Supervisors"> | string
    user?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
    ward?: XOR<WardMasterRelationFilter, WardMasterWhereInput>
  }

  export type SupervisorsOrderByWithRelationInput = {
    userId?: SortOrder
    supervisorName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    wardId?: SortOrder
    user?: UsersMasterOrderByWithRelationInput
    ward?: WardMasterOrderByWithRelationInput
  }

  export type SupervisorsWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: SupervisorsWhereInput | SupervisorsWhereInput[]
    OR?: SupervisorsWhereInput[]
    NOT?: SupervisorsWhereInput | SupervisorsWhereInput[]
    supervisorName?: StringFilter<"Supervisors"> | string
    username?: StringFilter<"Supervisors"> | string
    password?: StringFilter<"Supervisors"> | string
    wardId?: StringFilter<"Supervisors"> | string
    user?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
    ward?: XOR<WardMasterRelationFilter, WardMasterWhereInput>
  }, "userId">

  export type SupervisorsOrderByWithAggregationInput = {
    userId?: SortOrder
    supervisorName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    wardId?: SortOrder
    _count?: SupervisorsCountOrderByAggregateInput
    _max?: SupervisorsMaxOrderByAggregateInput
    _min?: SupervisorsMinOrderByAggregateInput
  }

  export type SupervisorsScalarWhereWithAggregatesInput = {
    AND?: SupervisorsScalarWhereWithAggregatesInput | SupervisorsScalarWhereWithAggregatesInput[]
    OR?: SupervisorsScalarWhereWithAggregatesInput[]
    NOT?: SupervisorsScalarWhereWithAggregatesInput | SupervisorsScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"Supervisors"> | string
    supervisorName?: StringWithAggregatesFilter<"Supervisors"> | string
    username?: StringWithAggregatesFilter<"Supervisors"> | string
    password?: StringWithAggregatesFilter<"Supervisors"> | string
    wardId?: StringWithAggregatesFilter<"Supervisors"> | string
  }

  export type AdminsWhereInput = {
    AND?: AdminsWhereInput | AdminsWhereInput[]
    OR?: AdminsWhereInput[]
    NOT?: AdminsWhereInput | AdminsWhereInput[]
    userId?: StringFilter<"Admins"> | string
    adminName?: StringFilter<"Admins"> | string
    username?: StringFilter<"Admins"> | string
    password?: StringFilter<"Admins"> | string
    user?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
  }

  export type AdminsOrderByWithRelationInput = {
    userId?: SortOrder
    adminName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    user?: UsersMasterOrderByWithRelationInput
  }

  export type AdminsWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: AdminsWhereInput | AdminsWhereInput[]
    OR?: AdminsWhereInput[]
    NOT?: AdminsWhereInput | AdminsWhereInput[]
    adminName?: StringFilter<"Admins"> | string
    username?: StringFilter<"Admins"> | string
    password?: StringFilter<"Admins"> | string
    user?: XOR<UsersMasterRelationFilter, UsersMasterWhereInput>
  }, "userId">

  export type AdminsOrderByWithAggregationInput = {
    userId?: SortOrder
    adminName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    _count?: AdminsCountOrderByAggregateInput
    _max?: AdminsMaxOrderByAggregateInput
    _min?: AdminsMinOrderByAggregateInput
  }

  export type AdminsScalarWhereWithAggregatesInput = {
    AND?: AdminsScalarWhereWithAggregatesInput | AdminsScalarWhereWithAggregatesInput[]
    OR?: AdminsScalarWhereWithAggregatesInput[]
    NOT?: AdminsScalarWhereWithAggregatesInput | AdminsScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"Admins"> | string
    adminName?: StringWithAggregatesFilter<"Admins"> | string
    username?: StringWithAggregatesFilter<"Admins"> | string
    password?: StringWithAggregatesFilter<"Admins"> | string
  }

  export type SurveyDetailsWhereInput = {
    AND?: SurveyDetailsWhereInput | SurveyDetailsWhereInput[]
    OR?: SurveyDetailsWhereInput[]
    NOT?: SurveyDetailsWhereInput | SurveyDetailsWhereInput[]
    surveyUniqueCode?: StringFilter<"SurveyDetails"> | string
    ulbId?: StringFilter<"SurveyDetails"> | string
    zoneId?: StringFilter<"SurveyDetails"> | string
    wardId?: StringFilter<"SurveyDetails"> | string
    mohallaId?: StringFilter<"SurveyDetails"> | string
    surveyTypeId?: StringFilter<"SurveyDetails"> | string
    entryDate?: DateTimeFilter<"SurveyDetails"> | Date | string
    parcelId?: IntNullableFilter<"SurveyDetails"> | number | null
    mapId?: IntFilter<"SurveyDetails"> | number
    gisId?: StringFilter<"SurveyDetails"> | string
    subGisId?: StringNullableFilter<"SurveyDetails"> | string | null
    ulb?: XOR<UlbMasterRelationFilter, UlbMasterWhereInput>
    zone?: XOR<ZoneMasterRelationFilter, ZoneMasterWhereInput>
    ward?: XOR<WardMasterRelationFilter, WardMasterWhereInput>
    mohalla?: XOR<MohallaMasterRelationFilter, MohallaMasterWhereInput>
    surveyType?: XOR<SurveyTypeMasterRelationFilter, SurveyTypeMasterWhereInput>
    propertyDetails?: PropertyDetailsListRelationFilter
    ownerDetails?: OwnerDetailsListRelationFilter
    locationDetails?: LocationDetailsListRelationFilter
    otherDetails?: OtherDetailsListRelationFilter
    residentialPropertyAssessments?: ResidentialPropertyAssessmentListRelationFilter
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentListRelationFilter
    propertyAttachments?: PropertyAttachmentDetailsListRelationFilter
    surveyStatusMaps?: SurveyStatusMappingListRelationFilter
  }

  export type SurveyDetailsOrderByWithRelationInput = {
    surveyUniqueCode?: SortOrder
    ulbId?: SortOrder
    zoneId?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    surveyTypeId?: SortOrder
    entryDate?: SortOrder
    parcelId?: SortOrderInput | SortOrder
    mapId?: SortOrder
    gisId?: SortOrder
    subGisId?: SortOrderInput | SortOrder
    ulb?: UlbMasterOrderByWithRelationInput
    zone?: ZoneMasterOrderByWithRelationInput
    ward?: WardMasterOrderByWithRelationInput
    mohalla?: MohallaMasterOrderByWithRelationInput
    surveyType?: SurveyTypeMasterOrderByWithRelationInput
    propertyDetails?: PropertyDetailsOrderByRelationAggregateInput
    ownerDetails?: OwnerDetailsOrderByRelationAggregateInput
    locationDetails?: LocationDetailsOrderByRelationAggregateInput
    otherDetails?: OtherDetailsOrderByRelationAggregateInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentOrderByRelationAggregateInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentOrderByRelationAggregateInput
    propertyAttachments?: PropertyAttachmentDetailsOrderByRelationAggregateInput
    surveyStatusMaps?: SurveyStatusMappingOrderByRelationAggregateInput
  }

  export type SurveyDetailsWhereUniqueInput = Prisma.AtLeast<{
    surveyUniqueCode?: string
    AND?: SurveyDetailsWhereInput | SurveyDetailsWhereInput[]
    OR?: SurveyDetailsWhereInput[]
    NOT?: SurveyDetailsWhereInput | SurveyDetailsWhereInput[]
    ulbId?: StringFilter<"SurveyDetails"> | string
    zoneId?: StringFilter<"SurveyDetails"> | string
    wardId?: StringFilter<"SurveyDetails"> | string
    mohallaId?: StringFilter<"SurveyDetails"> | string
    surveyTypeId?: StringFilter<"SurveyDetails"> | string
    entryDate?: DateTimeFilter<"SurveyDetails"> | Date | string
    parcelId?: IntNullableFilter<"SurveyDetails"> | number | null
    mapId?: IntFilter<"SurveyDetails"> | number
    gisId?: StringFilter<"SurveyDetails"> | string
    subGisId?: StringNullableFilter<"SurveyDetails"> | string | null
    ulb?: XOR<UlbMasterRelationFilter, UlbMasterWhereInput>
    zone?: XOR<ZoneMasterRelationFilter, ZoneMasterWhereInput>
    ward?: XOR<WardMasterRelationFilter, WardMasterWhereInput>
    mohalla?: XOR<MohallaMasterRelationFilter, MohallaMasterWhereInput>
    surveyType?: XOR<SurveyTypeMasterRelationFilter, SurveyTypeMasterWhereInput>
    propertyDetails?: PropertyDetailsListRelationFilter
    ownerDetails?: OwnerDetailsListRelationFilter
    locationDetails?: LocationDetailsListRelationFilter
    otherDetails?: OtherDetailsListRelationFilter
    residentialPropertyAssessments?: ResidentialPropertyAssessmentListRelationFilter
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentListRelationFilter
    propertyAttachments?: PropertyAttachmentDetailsListRelationFilter
    surveyStatusMaps?: SurveyStatusMappingListRelationFilter
  }, "surveyUniqueCode">

  export type SurveyDetailsOrderByWithAggregationInput = {
    surveyUniqueCode?: SortOrder
    ulbId?: SortOrder
    zoneId?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    surveyTypeId?: SortOrder
    entryDate?: SortOrder
    parcelId?: SortOrderInput | SortOrder
    mapId?: SortOrder
    gisId?: SortOrder
    subGisId?: SortOrderInput | SortOrder
    _count?: SurveyDetailsCountOrderByAggregateInput
    _avg?: SurveyDetailsAvgOrderByAggregateInput
    _max?: SurveyDetailsMaxOrderByAggregateInput
    _min?: SurveyDetailsMinOrderByAggregateInput
    _sum?: SurveyDetailsSumOrderByAggregateInput
  }

  export type SurveyDetailsScalarWhereWithAggregatesInput = {
    AND?: SurveyDetailsScalarWhereWithAggregatesInput | SurveyDetailsScalarWhereWithAggregatesInput[]
    OR?: SurveyDetailsScalarWhereWithAggregatesInput[]
    NOT?: SurveyDetailsScalarWhereWithAggregatesInput | SurveyDetailsScalarWhereWithAggregatesInput[]
    surveyUniqueCode?: StringWithAggregatesFilter<"SurveyDetails"> | string
    ulbId?: StringWithAggregatesFilter<"SurveyDetails"> | string
    zoneId?: StringWithAggregatesFilter<"SurveyDetails"> | string
    wardId?: StringWithAggregatesFilter<"SurveyDetails"> | string
    mohallaId?: StringWithAggregatesFilter<"SurveyDetails"> | string
    surveyTypeId?: StringWithAggregatesFilter<"SurveyDetails"> | string
    entryDate?: DateTimeWithAggregatesFilter<"SurveyDetails"> | Date | string
    parcelId?: IntNullableWithAggregatesFilter<"SurveyDetails"> | number | null
    mapId?: IntWithAggregatesFilter<"SurveyDetails"> | number
    gisId?: StringWithAggregatesFilter<"SurveyDetails"> | string
    subGisId?: StringNullableWithAggregatesFilter<"SurveyDetails"> | string | null
  }

  export type PropertyDetailsWhereInput = {
    AND?: PropertyDetailsWhereInput | PropertyDetailsWhereInput[]
    OR?: PropertyDetailsWhereInput[]
    NOT?: PropertyDetailsWhereInput | PropertyDetailsWhereInput[]
    surveyUniqueCode?: StringFilter<"PropertyDetails"> | string
    responseTypeId?: StringFilter<"PropertyDetails"> | string
    oldHouseNumber?: StringNullableFilter<"PropertyDetails"> | string | null
    electricityConsumerName?: StringNullableFilter<"PropertyDetails"> | string | null
    waterSewerageConnectionNumber?: StringNullableFilter<"PropertyDetails"> | string | null
    respondentName?: StringFilter<"PropertyDetails"> | string
    respondentStatusId?: StringFilter<"PropertyDetails"> | string
    survey?: XOR<SurveyDetailsRelationFilter, SurveyDetailsWhereInput>
    responseType?: XOR<ResponseTypeMasterRelationFilter, ResponseTypeMasterWhereInput>
    respondentStatus?: XOR<RespondentStatusMasterRelationFilter, RespondentStatusMasterWhereInput>
  }

  export type PropertyDetailsOrderByWithRelationInput = {
    surveyUniqueCode?: SortOrder
    responseTypeId?: SortOrder
    oldHouseNumber?: SortOrderInput | SortOrder
    electricityConsumerName?: SortOrderInput | SortOrder
    waterSewerageConnectionNumber?: SortOrderInput | SortOrder
    respondentName?: SortOrder
    respondentStatusId?: SortOrder
    survey?: SurveyDetailsOrderByWithRelationInput
    responseType?: ResponseTypeMasterOrderByWithRelationInput
    respondentStatus?: RespondentStatusMasterOrderByWithRelationInput
  }

  export type PropertyDetailsWhereUniqueInput = Prisma.AtLeast<{
    surveyUniqueCode?: string
    AND?: PropertyDetailsWhereInput | PropertyDetailsWhereInput[]
    OR?: PropertyDetailsWhereInput[]
    NOT?: PropertyDetailsWhereInput | PropertyDetailsWhereInput[]
    responseTypeId?: StringFilter<"PropertyDetails"> | string
    oldHouseNumber?: StringNullableFilter<"PropertyDetails"> | string | null
    electricityConsumerName?: StringNullableFilter<"PropertyDetails"> | string | null
    waterSewerageConnectionNumber?: StringNullableFilter<"PropertyDetails"> | string | null
    respondentName?: StringFilter<"PropertyDetails"> | string
    respondentStatusId?: StringFilter<"PropertyDetails"> | string
    survey?: XOR<SurveyDetailsRelationFilter, SurveyDetailsWhereInput>
    responseType?: XOR<ResponseTypeMasterRelationFilter, ResponseTypeMasterWhereInput>
    respondentStatus?: XOR<RespondentStatusMasterRelationFilter, RespondentStatusMasterWhereInput>
  }, "surveyUniqueCode">

  export type PropertyDetailsOrderByWithAggregationInput = {
    surveyUniqueCode?: SortOrder
    responseTypeId?: SortOrder
    oldHouseNumber?: SortOrderInput | SortOrder
    electricityConsumerName?: SortOrderInput | SortOrder
    waterSewerageConnectionNumber?: SortOrderInput | SortOrder
    respondentName?: SortOrder
    respondentStatusId?: SortOrder
    _count?: PropertyDetailsCountOrderByAggregateInput
    _max?: PropertyDetailsMaxOrderByAggregateInput
    _min?: PropertyDetailsMinOrderByAggregateInput
  }

  export type PropertyDetailsScalarWhereWithAggregatesInput = {
    AND?: PropertyDetailsScalarWhereWithAggregatesInput | PropertyDetailsScalarWhereWithAggregatesInput[]
    OR?: PropertyDetailsScalarWhereWithAggregatesInput[]
    NOT?: PropertyDetailsScalarWhereWithAggregatesInput | PropertyDetailsScalarWhereWithAggregatesInput[]
    surveyUniqueCode?: StringWithAggregatesFilter<"PropertyDetails"> | string
    responseTypeId?: StringWithAggregatesFilter<"PropertyDetails"> | string
    oldHouseNumber?: StringNullableWithAggregatesFilter<"PropertyDetails"> | string | null
    electricityConsumerName?: StringNullableWithAggregatesFilter<"PropertyDetails"> | string | null
    waterSewerageConnectionNumber?: StringNullableWithAggregatesFilter<"PropertyDetails"> | string | null
    respondentName?: StringWithAggregatesFilter<"PropertyDetails"> | string
    respondentStatusId?: StringWithAggregatesFilter<"PropertyDetails"> | string
  }

  export type OwnerDetailsWhereInput = {
    AND?: OwnerDetailsWhereInput | OwnerDetailsWhereInput[]
    OR?: OwnerDetailsWhereInput[]
    NOT?: OwnerDetailsWhereInput | OwnerDetailsWhereInput[]
    surveyUniqueCode?: StringFilter<"OwnerDetails"> | string
    ownerName?: StringFilter<"OwnerDetails"> | string
    fatherHusbandName?: StringFilter<"OwnerDetails"> | string
    mobileNumber?: StringNullableFilter<"OwnerDetails"> | string | null
    aadharNumber?: StringNullableFilter<"OwnerDetails"> | string | null
    survey?: XOR<SurveyDetailsRelationFilter, SurveyDetailsWhereInput>
  }

  export type OwnerDetailsOrderByWithRelationInput = {
    surveyUniqueCode?: SortOrder
    ownerName?: SortOrder
    fatherHusbandName?: SortOrder
    mobileNumber?: SortOrderInput | SortOrder
    aadharNumber?: SortOrderInput | SortOrder
    survey?: SurveyDetailsOrderByWithRelationInput
  }

  export type OwnerDetailsWhereUniqueInput = Prisma.AtLeast<{
    surveyUniqueCode?: string
    AND?: OwnerDetailsWhereInput | OwnerDetailsWhereInput[]
    OR?: OwnerDetailsWhereInput[]
    NOT?: OwnerDetailsWhereInput | OwnerDetailsWhereInput[]
    ownerName?: StringFilter<"OwnerDetails"> | string
    fatherHusbandName?: StringFilter<"OwnerDetails"> | string
    mobileNumber?: StringNullableFilter<"OwnerDetails"> | string | null
    aadharNumber?: StringNullableFilter<"OwnerDetails"> | string | null
    survey?: XOR<SurveyDetailsRelationFilter, SurveyDetailsWhereInput>
  }, "surveyUniqueCode">

  export type OwnerDetailsOrderByWithAggregationInput = {
    surveyUniqueCode?: SortOrder
    ownerName?: SortOrder
    fatherHusbandName?: SortOrder
    mobileNumber?: SortOrderInput | SortOrder
    aadharNumber?: SortOrderInput | SortOrder
    _count?: OwnerDetailsCountOrderByAggregateInput
    _max?: OwnerDetailsMaxOrderByAggregateInput
    _min?: OwnerDetailsMinOrderByAggregateInput
  }

  export type OwnerDetailsScalarWhereWithAggregatesInput = {
    AND?: OwnerDetailsScalarWhereWithAggregatesInput | OwnerDetailsScalarWhereWithAggregatesInput[]
    OR?: OwnerDetailsScalarWhereWithAggregatesInput[]
    NOT?: OwnerDetailsScalarWhereWithAggregatesInput | OwnerDetailsScalarWhereWithAggregatesInput[]
    surveyUniqueCode?: StringWithAggregatesFilter<"OwnerDetails"> | string
    ownerName?: StringWithAggregatesFilter<"OwnerDetails"> | string
    fatherHusbandName?: StringWithAggregatesFilter<"OwnerDetails"> | string
    mobileNumber?: StringNullableWithAggregatesFilter<"OwnerDetails"> | string | null
    aadharNumber?: StringNullableWithAggregatesFilter<"OwnerDetails"> | string | null
  }

  export type LocationDetailsWhereInput = {
    AND?: LocationDetailsWhereInput | LocationDetailsWhereInput[]
    OR?: LocationDetailsWhereInput[]
    NOT?: LocationDetailsWhereInput | LocationDetailsWhereInput[]
    surveyUniqueCode?: StringFilter<"LocationDetails"> | string
    propertyLatitude?: DecimalFilter<"LocationDetails"> | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFilter<"LocationDetails"> | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFilter<"LocationDetails"> | string
    propertyTypeId?: StringFilter<"LocationDetails"> | string
    buildingName?: StringNullableFilter<"LocationDetails"> | string | null
    roadTypeId?: StringFilter<"LocationDetails"> | string
    constructionYear?: StringFilter<"LocationDetails"> | string
    constructionTypeId?: StringFilter<"LocationDetails"> | string
    addressRoadName?: StringFilter<"LocationDetails"> | string
    locality?: StringNullableFilter<"LocationDetails"> | string | null
    pinCode?: IntFilter<"LocationDetails"> | number
    landmark?: StringNullableFilter<"LocationDetails"> | string | null
    fourWayEast?: StringNullableFilter<"LocationDetails"> | string | null
    fourWayWest?: StringNullableFilter<"LocationDetails"> | string | null
    fourWayNorth?: StringNullableFilter<"LocationDetails"> | string | null
    fourWaySouth?: StringNullableFilter<"LocationDetails"> | string | null
    newWard?: StringFilter<"LocationDetails"> | string
    survey?: XOR<SurveyDetailsRelationFilter, SurveyDetailsWhereInput>
    propertyType?: XOR<PropertyTypeMasterRelationFilter, PropertyTypeMasterWhereInput>
    roadType?: XOR<RoadTypeMasterRelationFilter, RoadTypeMasterWhereInput>
    constructionType?: XOR<ConstructionTypeMasterRelationFilter, ConstructionTypeMasterWhereInput>
  }

  export type LocationDetailsOrderByWithRelationInput = {
    surveyUniqueCode?: SortOrder
    propertyLatitude?: SortOrder
    propertyLongitude?: SortOrder
    assessmentYear?: SortOrder
    propertyTypeId?: SortOrder
    buildingName?: SortOrderInput | SortOrder
    roadTypeId?: SortOrder
    constructionYear?: SortOrder
    constructionTypeId?: SortOrder
    addressRoadName?: SortOrder
    locality?: SortOrderInput | SortOrder
    pinCode?: SortOrder
    landmark?: SortOrderInput | SortOrder
    fourWayEast?: SortOrderInput | SortOrder
    fourWayWest?: SortOrderInput | SortOrder
    fourWayNorth?: SortOrderInput | SortOrder
    fourWaySouth?: SortOrderInput | SortOrder
    newWard?: SortOrder
    survey?: SurveyDetailsOrderByWithRelationInput
    propertyType?: PropertyTypeMasterOrderByWithRelationInput
    roadType?: RoadTypeMasterOrderByWithRelationInput
    constructionType?: ConstructionTypeMasterOrderByWithRelationInput
  }

  export type LocationDetailsWhereUniqueInput = Prisma.AtLeast<{
    surveyUniqueCode?: string
    AND?: LocationDetailsWhereInput | LocationDetailsWhereInput[]
    OR?: LocationDetailsWhereInput[]
    NOT?: LocationDetailsWhereInput | LocationDetailsWhereInput[]
    propertyLatitude?: DecimalFilter<"LocationDetails"> | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFilter<"LocationDetails"> | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFilter<"LocationDetails"> | string
    propertyTypeId?: StringFilter<"LocationDetails"> | string
    buildingName?: StringNullableFilter<"LocationDetails"> | string | null
    roadTypeId?: StringFilter<"LocationDetails"> | string
    constructionYear?: StringFilter<"LocationDetails"> | string
    constructionTypeId?: StringFilter<"LocationDetails"> | string
    addressRoadName?: StringFilter<"LocationDetails"> | string
    locality?: StringNullableFilter<"LocationDetails"> | string | null
    pinCode?: IntFilter<"LocationDetails"> | number
    landmark?: StringNullableFilter<"LocationDetails"> | string | null
    fourWayEast?: StringNullableFilter<"LocationDetails"> | string | null
    fourWayWest?: StringNullableFilter<"LocationDetails"> | string | null
    fourWayNorth?: StringNullableFilter<"LocationDetails"> | string | null
    fourWaySouth?: StringNullableFilter<"LocationDetails"> | string | null
    newWard?: StringFilter<"LocationDetails"> | string
    survey?: XOR<SurveyDetailsRelationFilter, SurveyDetailsWhereInput>
    propertyType?: XOR<PropertyTypeMasterRelationFilter, PropertyTypeMasterWhereInput>
    roadType?: XOR<RoadTypeMasterRelationFilter, RoadTypeMasterWhereInput>
    constructionType?: XOR<ConstructionTypeMasterRelationFilter, ConstructionTypeMasterWhereInput>
  }, "surveyUniqueCode">

  export type LocationDetailsOrderByWithAggregationInput = {
    surveyUniqueCode?: SortOrder
    propertyLatitude?: SortOrder
    propertyLongitude?: SortOrder
    assessmentYear?: SortOrder
    propertyTypeId?: SortOrder
    buildingName?: SortOrderInput | SortOrder
    roadTypeId?: SortOrder
    constructionYear?: SortOrder
    constructionTypeId?: SortOrder
    addressRoadName?: SortOrder
    locality?: SortOrderInput | SortOrder
    pinCode?: SortOrder
    landmark?: SortOrderInput | SortOrder
    fourWayEast?: SortOrderInput | SortOrder
    fourWayWest?: SortOrderInput | SortOrder
    fourWayNorth?: SortOrderInput | SortOrder
    fourWaySouth?: SortOrderInput | SortOrder
    newWard?: SortOrder
    _count?: LocationDetailsCountOrderByAggregateInput
    _avg?: LocationDetailsAvgOrderByAggregateInput
    _max?: LocationDetailsMaxOrderByAggregateInput
    _min?: LocationDetailsMinOrderByAggregateInput
    _sum?: LocationDetailsSumOrderByAggregateInput
  }

  export type LocationDetailsScalarWhereWithAggregatesInput = {
    AND?: LocationDetailsScalarWhereWithAggregatesInput | LocationDetailsScalarWhereWithAggregatesInput[]
    OR?: LocationDetailsScalarWhereWithAggregatesInput[]
    NOT?: LocationDetailsScalarWhereWithAggregatesInput | LocationDetailsScalarWhereWithAggregatesInput[]
    surveyUniqueCode?: StringWithAggregatesFilter<"LocationDetails"> | string
    propertyLatitude?: DecimalWithAggregatesFilter<"LocationDetails"> | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalWithAggregatesFilter<"LocationDetails"> | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringWithAggregatesFilter<"LocationDetails"> | string
    propertyTypeId?: StringWithAggregatesFilter<"LocationDetails"> | string
    buildingName?: StringNullableWithAggregatesFilter<"LocationDetails"> | string | null
    roadTypeId?: StringWithAggregatesFilter<"LocationDetails"> | string
    constructionYear?: StringWithAggregatesFilter<"LocationDetails"> | string
    constructionTypeId?: StringWithAggregatesFilter<"LocationDetails"> | string
    addressRoadName?: StringWithAggregatesFilter<"LocationDetails"> | string
    locality?: StringNullableWithAggregatesFilter<"LocationDetails"> | string | null
    pinCode?: IntWithAggregatesFilter<"LocationDetails"> | number
    landmark?: StringNullableWithAggregatesFilter<"LocationDetails"> | string | null
    fourWayEast?: StringNullableWithAggregatesFilter<"LocationDetails"> | string | null
    fourWayWest?: StringNullableWithAggregatesFilter<"LocationDetails"> | string | null
    fourWayNorth?: StringNullableWithAggregatesFilter<"LocationDetails"> | string | null
    fourWaySouth?: StringNullableWithAggregatesFilter<"LocationDetails"> | string | null
    newWard?: StringWithAggregatesFilter<"LocationDetails"> | string
  }

  export type OtherDetailsWhereInput = {
    AND?: OtherDetailsWhereInput | OtherDetailsWhereInput[]
    OR?: OtherDetailsWhereInput[]
    NOT?: OtherDetailsWhereInput | OtherDetailsWhereInput[]
    surveyUniqueCode?: StringFilter<"OtherDetails"> | string
    waterSourceId?: StringFilter<"OtherDetails"> | string
    rainWaterHarvestingSystem?: StringNullableFilter<"OtherDetails"> | string | null
    plantation?: StringNullableFilter<"OtherDetails"> | string | null
    parking?: StringNullableFilter<"OtherDetails"> | string | null
    pollution?: StringNullableFilter<"OtherDetails"> | string | null
    pollutionMeasurementTaken?: StringNullableFilter<"OtherDetails"> | string | null
    waterSupplyWithin200Meters?: StringNullableFilter<"OtherDetails"> | string | null
    sewerageLineWithin100Meters?: StringNullableFilter<"OtherDetails"> | string | null
    disposalTypeId?: StringFilter<"OtherDetails"> | string
    totalPlotArea?: FloatFilter<"OtherDetails"> | number
    builtupAreaOfGroundFloor?: FloatFilter<"OtherDetails"> | number
    remarks?: StringNullableFilter<"OtherDetails"> | string | null
    survey?: XOR<SurveyDetailsRelationFilter, SurveyDetailsWhereInput>
    waterSource?: XOR<WaterSourceMasterRelationFilter, WaterSourceMasterWhereInput>
    disposalType?: XOR<DisposalTypeMasterRelationFilter, DisposalTypeMasterWhereInput>
  }

  export type OtherDetailsOrderByWithRelationInput = {
    surveyUniqueCode?: SortOrder
    waterSourceId?: SortOrder
    rainWaterHarvestingSystem?: SortOrderInput | SortOrder
    plantation?: SortOrderInput | SortOrder
    parking?: SortOrderInput | SortOrder
    pollution?: SortOrderInput | SortOrder
    pollutionMeasurementTaken?: SortOrderInput | SortOrder
    waterSupplyWithin200Meters?: SortOrderInput | SortOrder
    sewerageLineWithin100Meters?: SortOrderInput | SortOrder
    disposalTypeId?: SortOrder
    totalPlotArea?: SortOrder
    builtupAreaOfGroundFloor?: SortOrder
    remarks?: SortOrderInput | SortOrder
    survey?: SurveyDetailsOrderByWithRelationInput
    waterSource?: WaterSourceMasterOrderByWithRelationInput
    disposalType?: DisposalTypeMasterOrderByWithRelationInput
  }

  export type OtherDetailsWhereUniqueInput = Prisma.AtLeast<{
    surveyUniqueCode?: string
    AND?: OtherDetailsWhereInput | OtherDetailsWhereInput[]
    OR?: OtherDetailsWhereInput[]
    NOT?: OtherDetailsWhereInput | OtherDetailsWhereInput[]
    waterSourceId?: StringFilter<"OtherDetails"> | string
    rainWaterHarvestingSystem?: StringNullableFilter<"OtherDetails"> | string | null
    plantation?: StringNullableFilter<"OtherDetails"> | string | null
    parking?: StringNullableFilter<"OtherDetails"> | string | null
    pollution?: StringNullableFilter<"OtherDetails"> | string | null
    pollutionMeasurementTaken?: StringNullableFilter<"OtherDetails"> | string | null
    waterSupplyWithin200Meters?: StringNullableFilter<"OtherDetails"> | string | null
    sewerageLineWithin100Meters?: StringNullableFilter<"OtherDetails"> | string | null
    disposalTypeId?: StringFilter<"OtherDetails"> | string
    totalPlotArea?: FloatFilter<"OtherDetails"> | number
    builtupAreaOfGroundFloor?: FloatFilter<"OtherDetails"> | number
    remarks?: StringNullableFilter<"OtherDetails"> | string | null
    survey?: XOR<SurveyDetailsRelationFilter, SurveyDetailsWhereInput>
    waterSource?: XOR<WaterSourceMasterRelationFilter, WaterSourceMasterWhereInput>
    disposalType?: XOR<DisposalTypeMasterRelationFilter, DisposalTypeMasterWhereInput>
  }, "surveyUniqueCode">

  export type OtherDetailsOrderByWithAggregationInput = {
    surveyUniqueCode?: SortOrder
    waterSourceId?: SortOrder
    rainWaterHarvestingSystem?: SortOrderInput | SortOrder
    plantation?: SortOrderInput | SortOrder
    parking?: SortOrderInput | SortOrder
    pollution?: SortOrderInput | SortOrder
    pollutionMeasurementTaken?: SortOrderInput | SortOrder
    waterSupplyWithin200Meters?: SortOrderInput | SortOrder
    sewerageLineWithin100Meters?: SortOrderInput | SortOrder
    disposalTypeId?: SortOrder
    totalPlotArea?: SortOrder
    builtupAreaOfGroundFloor?: SortOrder
    remarks?: SortOrderInput | SortOrder
    _count?: OtherDetailsCountOrderByAggregateInput
    _avg?: OtherDetailsAvgOrderByAggregateInput
    _max?: OtherDetailsMaxOrderByAggregateInput
    _min?: OtherDetailsMinOrderByAggregateInput
    _sum?: OtherDetailsSumOrderByAggregateInput
  }

  export type OtherDetailsScalarWhereWithAggregatesInput = {
    AND?: OtherDetailsScalarWhereWithAggregatesInput | OtherDetailsScalarWhereWithAggregatesInput[]
    OR?: OtherDetailsScalarWhereWithAggregatesInput[]
    NOT?: OtherDetailsScalarWhereWithAggregatesInput | OtherDetailsScalarWhereWithAggregatesInput[]
    surveyUniqueCode?: StringWithAggregatesFilter<"OtherDetails"> | string
    waterSourceId?: StringWithAggregatesFilter<"OtherDetails"> | string
    rainWaterHarvestingSystem?: StringNullableWithAggregatesFilter<"OtherDetails"> | string | null
    plantation?: StringNullableWithAggregatesFilter<"OtherDetails"> | string | null
    parking?: StringNullableWithAggregatesFilter<"OtherDetails"> | string | null
    pollution?: StringNullableWithAggregatesFilter<"OtherDetails"> | string | null
    pollutionMeasurementTaken?: StringNullableWithAggregatesFilter<"OtherDetails"> | string | null
    waterSupplyWithin200Meters?: StringNullableWithAggregatesFilter<"OtherDetails"> | string | null
    sewerageLineWithin100Meters?: StringNullableWithAggregatesFilter<"OtherDetails"> | string | null
    disposalTypeId?: StringWithAggregatesFilter<"OtherDetails"> | string
    totalPlotArea?: FloatWithAggregatesFilter<"OtherDetails"> | number
    builtupAreaOfGroundFloor?: FloatWithAggregatesFilter<"OtherDetails"> | number
    remarks?: StringNullableWithAggregatesFilter<"OtherDetails"> | string | null
  }

  export type ResidentialPropertyAssessmentWhereInput = {
    AND?: ResidentialPropertyAssessmentWhereInput | ResidentialPropertyAssessmentWhereInput[]
    OR?: ResidentialPropertyAssessmentWhereInput[]
    NOT?: ResidentialPropertyAssessmentWhereInput | ResidentialPropertyAssessmentWhereInput[]
    floorAssessmentId?: StringFilter<"ResidentialPropertyAssessment"> | string
    surveyUniqueCode?: StringFilter<"ResidentialPropertyAssessment"> | string
    floorNumber?: StringFilter<"ResidentialPropertyAssessment"> | string
    occupancyStatusId?: StringFilter<"ResidentialPropertyAssessment"> | string
    constructionNatureId?: StringFilter<"ResidentialPropertyAssessment"> | string
    coveredArea?: DecimalFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    allRoomVerandaArea?: DecimalFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea?: DecimalFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    allGarageArea?: DecimalFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    carpetArea?: DecimalFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    survey?: XOR<SurveyDetailsRelationFilter, SurveyDetailsWhereInput>
    occupancyStatus?: XOR<OccupancyStatusMasterRelationFilter, OccupancyStatusMasterWhereInput>
    constructionNature?: XOR<ConstructionNatureMasterRelationFilter, ConstructionNatureMasterWhereInput>
  }

  export type ResidentialPropertyAssessmentOrderByWithRelationInput = {
    floorAssessmentId?: SortOrder
    surveyUniqueCode?: SortOrder
    floorNumber?: SortOrder
    occupancyStatusId?: SortOrder
    constructionNatureId?: SortOrder
    coveredArea?: SortOrder
    allRoomVerandaArea?: SortOrder
    allBalconyKitchenArea?: SortOrder
    allGarageArea?: SortOrder
    carpetArea?: SortOrder
    survey?: SurveyDetailsOrderByWithRelationInput
    occupancyStatus?: OccupancyStatusMasterOrderByWithRelationInput
    constructionNature?: ConstructionNatureMasterOrderByWithRelationInput
  }

  export type ResidentialPropertyAssessmentWhereUniqueInput = Prisma.AtLeast<{
    floorAssessmentId?: string
    AND?: ResidentialPropertyAssessmentWhereInput | ResidentialPropertyAssessmentWhereInput[]
    OR?: ResidentialPropertyAssessmentWhereInput[]
    NOT?: ResidentialPropertyAssessmentWhereInput | ResidentialPropertyAssessmentWhereInput[]
    surveyUniqueCode?: StringFilter<"ResidentialPropertyAssessment"> | string
    floorNumber?: StringFilter<"ResidentialPropertyAssessment"> | string
    occupancyStatusId?: StringFilter<"ResidentialPropertyAssessment"> | string
    constructionNatureId?: StringFilter<"ResidentialPropertyAssessment"> | string
    coveredArea?: DecimalFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    allRoomVerandaArea?: DecimalFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea?: DecimalFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    allGarageArea?: DecimalFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    carpetArea?: DecimalFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    survey?: XOR<SurveyDetailsRelationFilter, SurveyDetailsWhereInput>
    occupancyStatus?: XOR<OccupancyStatusMasterRelationFilter, OccupancyStatusMasterWhereInput>
    constructionNature?: XOR<ConstructionNatureMasterRelationFilter, ConstructionNatureMasterWhereInput>
  }, "floorAssessmentId">

  export type ResidentialPropertyAssessmentOrderByWithAggregationInput = {
    floorAssessmentId?: SortOrder
    surveyUniqueCode?: SortOrder
    floorNumber?: SortOrder
    occupancyStatusId?: SortOrder
    constructionNatureId?: SortOrder
    coveredArea?: SortOrder
    allRoomVerandaArea?: SortOrder
    allBalconyKitchenArea?: SortOrder
    allGarageArea?: SortOrder
    carpetArea?: SortOrder
    _count?: ResidentialPropertyAssessmentCountOrderByAggregateInput
    _avg?: ResidentialPropertyAssessmentAvgOrderByAggregateInput
    _max?: ResidentialPropertyAssessmentMaxOrderByAggregateInput
    _min?: ResidentialPropertyAssessmentMinOrderByAggregateInput
    _sum?: ResidentialPropertyAssessmentSumOrderByAggregateInput
  }

  export type ResidentialPropertyAssessmentScalarWhereWithAggregatesInput = {
    AND?: ResidentialPropertyAssessmentScalarWhereWithAggregatesInput | ResidentialPropertyAssessmentScalarWhereWithAggregatesInput[]
    OR?: ResidentialPropertyAssessmentScalarWhereWithAggregatesInput[]
    NOT?: ResidentialPropertyAssessmentScalarWhereWithAggregatesInput | ResidentialPropertyAssessmentScalarWhereWithAggregatesInput[]
    floorAssessmentId?: StringWithAggregatesFilter<"ResidentialPropertyAssessment"> | string
    surveyUniqueCode?: StringWithAggregatesFilter<"ResidentialPropertyAssessment"> | string
    floorNumber?: StringWithAggregatesFilter<"ResidentialPropertyAssessment"> | string
    occupancyStatusId?: StringWithAggregatesFilter<"ResidentialPropertyAssessment"> | string
    constructionNatureId?: StringWithAggregatesFilter<"ResidentialPropertyAssessment"> | string
    coveredArea?: DecimalWithAggregatesFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    allRoomVerandaArea?: DecimalWithAggregatesFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea?: DecimalWithAggregatesFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    allGarageArea?: DecimalWithAggregatesFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    carpetArea?: DecimalWithAggregatesFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentWhereInput = {
    AND?: NonResidentialPropertyAssessmentWhereInput | NonResidentialPropertyAssessmentWhereInput[]
    OR?: NonResidentialPropertyAssessmentWhereInput[]
    NOT?: NonResidentialPropertyAssessmentWhereInput | NonResidentialPropertyAssessmentWhereInput[]
    floorAssessmentId?: StringFilter<"NonResidentialPropertyAssessment"> | string
    surveyUniqueCode?: StringFilter<"NonResidentialPropertyAssessment"> | string
    floorNumber?: StringFilter<"NonResidentialPropertyAssessment"> | string
    nrPropertyCategoryId?: StringFilter<"NonResidentialPropertyAssessment"> | string
    nrSubCategoryId?: StringFilter<"NonResidentialPropertyAssessment"> | string
    establishmentName?: StringFilter<"NonResidentialPropertyAssessment"> | string
    licenseNo?: StringNullableFilter<"NonResidentialPropertyAssessment"> | string | null
    licenseExpiryDate?: DateTimeNullableFilter<"NonResidentialPropertyAssessment"> | Date | string | null
    occupancyStatusId?: StringFilter<"NonResidentialPropertyAssessment"> | string
    constructionNatureId?: StringFilter<"NonResidentialPropertyAssessment"> | string
    builtupArea?: DecimalFilter<"NonResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    nrPropertyCategory?: XOR<NrPropertyCategoryMasterRelationFilter, NrPropertyCategoryMasterWhereInput>
    nrSubCategory?: XOR<NrPropertySubCategoryMasterRelationFilter, NrPropertySubCategoryMasterWhereInput>
    occupancyStatus?: XOR<OccupancyStatusMasterRelationFilter, OccupancyStatusMasterWhereInput>
    constructionNature?: XOR<ConstructionNatureMasterRelationFilter, ConstructionNatureMasterWhereInput>
    survey?: XOR<SurveyDetailsRelationFilter, SurveyDetailsWhereInput>
  }

  export type NonResidentialPropertyAssessmentOrderByWithRelationInput = {
    floorAssessmentId?: SortOrder
    surveyUniqueCode?: SortOrder
    floorNumber?: SortOrder
    nrPropertyCategoryId?: SortOrder
    nrSubCategoryId?: SortOrder
    establishmentName?: SortOrder
    licenseNo?: SortOrderInput | SortOrder
    licenseExpiryDate?: SortOrderInput | SortOrder
    occupancyStatusId?: SortOrder
    constructionNatureId?: SortOrder
    builtupArea?: SortOrder
    nrPropertyCategory?: NrPropertyCategoryMasterOrderByWithRelationInput
    nrSubCategory?: NrPropertySubCategoryMasterOrderByWithRelationInput
    occupancyStatus?: OccupancyStatusMasterOrderByWithRelationInput
    constructionNature?: ConstructionNatureMasterOrderByWithRelationInput
    survey?: SurveyDetailsOrderByWithRelationInput
  }

  export type NonResidentialPropertyAssessmentWhereUniqueInput = Prisma.AtLeast<{
    floorAssessmentId?: string
    AND?: NonResidentialPropertyAssessmentWhereInput | NonResidentialPropertyAssessmentWhereInput[]
    OR?: NonResidentialPropertyAssessmentWhereInput[]
    NOT?: NonResidentialPropertyAssessmentWhereInput | NonResidentialPropertyAssessmentWhereInput[]
    surveyUniqueCode?: StringFilter<"NonResidentialPropertyAssessment"> | string
    floorNumber?: StringFilter<"NonResidentialPropertyAssessment"> | string
    nrPropertyCategoryId?: StringFilter<"NonResidentialPropertyAssessment"> | string
    nrSubCategoryId?: StringFilter<"NonResidentialPropertyAssessment"> | string
    establishmentName?: StringFilter<"NonResidentialPropertyAssessment"> | string
    licenseNo?: StringNullableFilter<"NonResidentialPropertyAssessment"> | string | null
    licenseExpiryDate?: DateTimeNullableFilter<"NonResidentialPropertyAssessment"> | Date | string | null
    occupancyStatusId?: StringFilter<"NonResidentialPropertyAssessment"> | string
    constructionNatureId?: StringFilter<"NonResidentialPropertyAssessment"> | string
    builtupArea?: DecimalFilter<"NonResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    nrPropertyCategory?: XOR<NrPropertyCategoryMasterRelationFilter, NrPropertyCategoryMasterWhereInput>
    nrSubCategory?: XOR<NrPropertySubCategoryMasterRelationFilter, NrPropertySubCategoryMasterWhereInput>
    occupancyStatus?: XOR<OccupancyStatusMasterRelationFilter, OccupancyStatusMasterWhereInput>
    constructionNature?: XOR<ConstructionNatureMasterRelationFilter, ConstructionNatureMasterWhereInput>
    survey?: XOR<SurveyDetailsRelationFilter, SurveyDetailsWhereInput>
  }, "floorAssessmentId">

  export type NonResidentialPropertyAssessmentOrderByWithAggregationInput = {
    floorAssessmentId?: SortOrder
    surveyUniqueCode?: SortOrder
    floorNumber?: SortOrder
    nrPropertyCategoryId?: SortOrder
    nrSubCategoryId?: SortOrder
    establishmentName?: SortOrder
    licenseNo?: SortOrderInput | SortOrder
    licenseExpiryDate?: SortOrderInput | SortOrder
    occupancyStatusId?: SortOrder
    constructionNatureId?: SortOrder
    builtupArea?: SortOrder
    _count?: NonResidentialPropertyAssessmentCountOrderByAggregateInput
    _avg?: NonResidentialPropertyAssessmentAvgOrderByAggregateInput
    _max?: NonResidentialPropertyAssessmentMaxOrderByAggregateInput
    _min?: NonResidentialPropertyAssessmentMinOrderByAggregateInput
    _sum?: NonResidentialPropertyAssessmentSumOrderByAggregateInput
  }

  export type NonResidentialPropertyAssessmentScalarWhereWithAggregatesInput = {
    AND?: NonResidentialPropertyAssessmentScalarWhereWithAggregatesInput | NonResidentialPropertyAssessmentScalarWhereWithAggregatesInput[]
    OR?: NonResidentialPropertyAssessmentScalarWhereWithAggregatesInput[]
    NOT?: NonResidentialPropertyAssessmentScalarWhereWithAggregatesInput | NonResidentialPropertyAssessmentScalarWhereWithAggregatesInput[]
    floorAssessmentId?: StringWithAggregatesFilter<"NonResidentialPropertyAssessment"> | string
    surveyUniqueCode?: StringWithAggregatesFilter<"NonResidentialPropertyAssessment"> | string
    floorNumber?: StringWithAggregatesFilter<"NonResidentialPropertyAssessment"> | string
    nrPropertyCategoryId?: StringWithAggregatesFilter<"NonResidentialPropertyAssessment"> | string
    nrSubCategoryId?: StringWithAggregatesFilter<"NonResidentialPropertyAssessment"> | string
    establishmentName?: StringWithAggregatesFilter<"NonResidentialPropertyAssessment"> | string
    licenseNo?: StringNullableWithAggregatesFilter<"NonResidentialPropertyAssessment"> | string | null
    licenseExpiryDate?: DateTimeNullableWithAggregatesFilter<"NonResidentialPropertyAssessment"> | Date | string | null
    occupancyStatusId?: StringWithAggregatesFilter<"NonResidentialPropertyAssessment"> | string
    constructionNatureId?: StringWithAggregatesFilter<"NonResidentialPropertyAssessment"> | string
    builtupArea?: DecimalWithAggregatesFilter<"NonResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
  }

  export type PropertyAttachmentDetailsWhereInput = {
    AND?: PropertyAttachmentDetailsWhereInput | PropertyAttachmentDetailsWhereInput[]
    OR?: PropertyAttachmentDetailsWhereInput[]
    NOT?: PropertyAttachmentDetailsWhereInput | PropertyAttachmentDetailsWhereInput[]
    surveyUniqueCode?: StringFilter<"PropertyAttachmentDetails"> | string
    image1Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image2Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image3Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image4Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image5Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image6Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image7Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image8Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image9Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image10Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    survey?: XOR<SurveyDetailsRelationFilter, SurveyDetailsWhereInput>
  }

  export type PropertyAttachmentDetailsOrderByWithRelationInput = {
    surveyUniqueCode?: SortOrder
    image1Url?: SortOrderInput | SortOrder
    image2Url?: SortOrderInput | SortOrder
    image3Url?: SortOrderInput | SortOrder
    image4Url?: SortOrderInput | SortOrder
    image5Url?: SortOrderInput | SortOrder
    image6Url?: SortOrderInput | SortOrder
    image7Url?: SortOrderInput | SortOrder
    image8Url?: SortOrderInput | SortOrder
    image9Url?: SortOrderInput | SortOrder
    image10Url?: SortOrderInput | SortOrder
    survey?: SurveyDetailsOrderByWithRelationInput
  }

  export type PropertyAttachmentDetailsWhereUniqueInput = Prisma.AtLeast<{
    surveyUniqueCode?: string
    AND?: PropertyAttachmentDetailsWhereInput | PropertyAttachmentDetailsWhereInput[]
    OR?: PropertyAttachmentDetailsWhereInput[]
    NOT?: PropertyAttachmentDetailsWhereInput | PropertyAttachmentDetailsWhereInput[]
    image1Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image2Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image3Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image4Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image5Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image6Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image7Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image8Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image9Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image10Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    survey?: XOR<SurveyDetailsRelationFilter, SurveyDetailsWhereInput>
  }, "surveyUniqueCode">

  export type PropertyAttachmentDetailsOrderByWithAggregationInput = {
    surveyUniqueCode?: SortOrder
    image1Url?: SortOrderInput | SortOrder
    image2Url?: SortOrderInput | SortOrder
    image3Url?: SortOrderInput | SortOrder
    image4Url?: SortOrderInput | SortOrder
    image5Url?: SortOrderInput | SortOrder
    image6Url?: SortOrderInput | SortOrder
    image7Url?: SortOrderInput | SortOrder
    image8Url?: SortOrderInput | SortOrder
    image9Url?: SortOrderInput | SortOrder
    image10Url?: SortOrderInput | SortOrder
    _count?: PropertyAttachmentDetailsCountOrderByAggregateInput
    _max?: PropertyAttachmentDetailsMaxOrderByAggregateInput
    _min?: PropertyAttachmentDetailsMinOrderByAggregateInput
  }

  export type PropertyAttachmentDetailsScalarWhereWithAggregatesInput = {
    AND?: PropertyAttachmentDetailsScalarWhereWithAggregatesInput | PropertyAttachmentDetailsScalarWhereWithAggregatesInput[]
    OR?: PropertyAttachmentDetailsScalarWhereWithAggregatesInput[]
    NOT?: PropertyAttachmentDetailsScalarWhereWithAggregatesInput | PropertyAttachmentDetailsScalarWhereWithAggregatesInput[]
    surveyUniqueCode?: StringWithAggregatesFilter<"PropertyAttachmentDetails"> | string
    image1Url?: StringNullableWithAggregatesFilter<"PropertyAttachmentDetails"> | string | null
    image2Url?: StringNullableWithAggregatesFilter<"PropertyAttachmentDetails"> | string | null
    image3Url?: StringNullableWithAggregatesFilter<"PropertyAttachmentDetails"> | string | null
    image4Url?: StringNullableWithAggregatesFilter<"PropertyAttachmentDetails"> | string | null
    image5Url?: StringNullableWithAggregatesFilter<"PropertyAttachmentDetails"> | string | null
    image6Url?: StringNullableWithAggregatesFilter<"PropertyAttachmentDetails"> | string | null
    image7Url?: StringNullableWithAggregatesFilter<"PropertyAttachmentDetails"> | string | null
    image8Url?: StringNullableWithAggregatesFilter<"PropertyAttachmentDetails"> | string | null
    image9Url?: StringNullableWithAggregatesFilter<"PropertyAttachmentDetails"> | string | null
    image10Url?: StringNullableWithAggregatesFilter<"PropertyAttachmentDetails"> | string | null
  }

  export type UlbMasterCreateInput = {
    ulbId?: string
    ulbName: string
    isActive?: boolean
    description?: string | null
    ulbZoneMaps?: UlbZoneMappingCreateNestedManyWithoutUlbInput
    surveyDetails?: SurveyDetailsCreateNestedManyWithoutUlbInput
  }

  export type UlbMasterUncheckedCreateInput = {
    ulbId?: string
    ulbName: string
    isActive?: boolean
    description?: string | null
    ulbZoneMaps?: UlbZoneMappingUncheckedCreateNestedManyWithoutUlbInput
    surveyDetails?: SurveyDetailsUncheckedCreateNestedManyWithoutUlbInput
  }

  export type UlbMasterUpdateInput = {
    ulbId?: StringFieldUpdateOperationsInput | string
    ulbName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ulbZoneMaps?: UlbZoneMappingUpdateManyWithoutUlbNestedInput
    surveyDetails?: SurveyDetailsUpdateManyWithoutUlbNestedInput
  }

  export type UlbMasterUncheckedUpdateInput = {
    ulbId?: StringFieldUpdateOperationsInput | string
    ulbName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ulbZoneMaps?: UlbZoneMappingUncheckedUpdateManyWithoutUlbNestedInput
    surveyDetails?: SurveyDetailsUncheckedUpdateManyWithoutUlbNestedInput
  }

  export type UlbMasterCreateManyInput = {
    ulbId?: string
    ulbName: string
    isActive?: boolean
    description?: string | null
  }

  export type UlbMasterUpdateManyMutationInput = {
    ulbId?: StringFieldUpdateOperationsInput | string
    ulbName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UlbMasterUncheckedUpdateManyInput = {
    ulbId?: StringFieldUpdateOperationsInput | string
    ulbName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ZoneMasterCreateInput = {
    zoneId?: string
    zoneNumber: string
    isActive?: boolean
    description?: string | null
    ulbZoneMaps?: UlbZoneMappingCreateNestedManyWithoutZoneInput
    zoneWardMaps?: ZoneWardMappingCreateNestedManyWithoutZoneInput
    surveyDetails?: SurveyDetailsCreateNestedManyWithoutZoneInput
  }

  export type ZoneMasterUncheckedCreateInput = {
    zoneId?: string
    zoneNumber: string
    isActive?: boolean
    description?: string | null
    ulbZoneMaps?: UlbZoneMappingUncheckedCreateNestedManyWithoutZoneInput
    zoneWardMaps?: ZoneWardMappingUncheckedCreateNestedManyWithoutZoneInput
    surveyDetails?: SurveyDetailsUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneMasterUpdateInput = {
    zoneId?: StringFieldUpdateOperationsInput | string
    zoneNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ulbZoneMaps?: UlbZoneMappingUpdateManyWithoutZoneNestedInput
    zoneWardMaps?: ZoneWardMappingUpdateManyWithoutZoneNestedInput
    surveyDetails?: SurveyDetailsUpdateManyWithoutZoneNestedInput
  }

  export type ZoneMasterUncheckedUpdateInput = {
    zoneId?: StringFieldUpdateOperationsInput | string
    zoneNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ulbZoneMaps?: UlbZoneMappingUncheckedUpdateManyWithoutZoneNestedInput
    zoneWardMaps?: ZoneWardMappingUncheckedUpdateManyWithoutZoneNestedInput
    surveyDetails?: SurveyDetailsUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ZoneMasterCreateManyInput = {
    zoneId?: string
    zoneNumber: string
    isActive?: boolean
    description?: string | null
  }

  export type ZoneMasterUpdateManyMutationInput = {
    zoneId?: StringFieldUpdateOperationsInput | string
    zoneNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ZoneMasterUncheckedUpdateManyInput = {
    zoneId?: StringFieldUpdateOperationsInput | string
    zoneNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WardMasterCreateInput = {
    wardId?: string
    wardNumber: string
    isActive?: boolean
    wardName: string
    description?: string | null
    zoneWardMaps?: ZoneWardMappingCreateNestedManyWithoutWardInput
    wardMohallaMaps?: WardMohallaMappingCreateNestedManyWithoutWardInput
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutWardInput
    wardStatusMaps?: WardStatusMappingCreateNestedManyWithoutWardInput
    surveyDetails?: SurveyDetailsCreateNestedManyWithoutWardInput
    supervisors?: SupervisorsCreateNestedManyWithoutWardInput
  }

  export type WardMasterUncheckedCreateInput = {
    wardId?: string
    wardNumber: string
    isActive?: boolean
    wardName: string
    description?: string | null
    zoneWardMaps?: ZoneWardMappingUncheckedCreateNestedManyWithoutWardInput
    wardMohallaMaps?: WardMohallaMappingUncheckedCreateNestedManyWithoutWardInput
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutWardInput
    wardStatusMaps?: WardStatusMappingUncheckedCreateNestedManyWithoutWardInput
    surveyDetails?: SurveyDetailsUncheckedCreateNestedManyWithoutWardInput
    supervisors?: SupervisorsUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardMasterUpdateInput = {
    wardId?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    wardName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    zoneWardMaps?: ZoneWardMappingUpdateManyWithoutWardNestedInput
    wardMohallaMaps?: WardMohallaMappingUpdateManyWithoutWardNestedInput
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutWardNestedInput
    wardStatusMaps?: WardStatusMappingUpdateManyWithoutWardNestedInput
    surveyDetails?: SurveyDetailsUpdateManyWithoutWardNestedInput
    supervisors?: SupervisorsUpdateManyWithoutWardNestedInput
  }

  export type WardMasterUncheckedUpdateInput = {
    wardId?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    wardName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    zoneWardMaps?: ZoneWardMappingUncheckedUpdateManyWithoutWardNestedInput
    wardMohallaMaps?: WardMohallaMappingUncheckedUpdateManyWithoutWardNestedInput
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutWardNestedInput
    wardStatusMaps?: WardStatusMappingUncheckedUpdateManyWithoutWardNestedInput
    surveyDetails?: SurveyDetailsUncheckedUpdateManyWithoutWardNestedInput
    supervisors?: SupervisorsUncheckedUpdateManyWithoutWardNestedInput
  }

  export type WardMasterCreateManyInput = {
    wardId?: string
    wardNumber: string
    isActive?: boolean
    wardName: string
    description?: string | null
  }

  export type WardMasterUpdateManyMutationInput = {
    wardId?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    wardName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WardMasterUncheckedUpdateManyInput = {
    wardId?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    wardName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MohallaMasterCreateInput = {
    mohallaId?: string
    mohallaName: string
    isActive?: boolean
    description?: string | null
    wardMohallaMaps?: WardMohallaMappingCreateNestedManyWithoutMohallaInput
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutMohallaInput
    surveyDetails?: SurveyDetailsCreateNestedManyWithoutMohallaInput
  }

  export type MohallaMasterUncheckedCreateInput = {
    mohallaId?: string
    mohallaName: string
    isActive?: boolean
    description?: string | null
    wardMohallaMaps?: WardMohallaMappingUncheckedCreateNestedManyWithoutMohallaInput
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutMohallaInput
    surveyDetails?: SurveyDetailsUncheckedCreateNestedManyWithoutMohallaInput
  }

  export type MohallaMasterUpdateInput = {
    mohallaId?: StringFieldUpdateOperationsInput | string
    mohallaName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    wardMohallaMaps?: WardMohallaMappingUpdateManyWithoutMohallaNestedInput
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutMohallaNestedInput
    surveyDetails?: SurveyDetailsUpdateManyWithoutMohallaNestedInput
  }

  export type MohallaMasterUncheckedUpdateInput = {
    mohallaId?: StringFieldUpdateOperationsInput | string
    mohallaName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    wardMohallaMaps?: WardMohallaMappingUncheckedUpdateManyWithoutMohallaNestedInput
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutMohallaNestedInput
    surveyDetails?: SurveyDetailsUncheckedUpdateManyWithoutMohallaNestedInput
  }

  export type MohallaMasterCreateManyInput = {
    mohallaId?: string
    mohallaName: string
    isActive?: boolean
    description?: string | null
  }

  export type MohallaMasterUpdateManyMutationInput = {
    mohallaId?: StringFieldUpdateOperationsInput | string
    mohallaName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MohallaMasterUncheckedUpdateManyInput = {
    mohallaId?: StringFieldUpdateOperationsInput | string
    mohallaName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponseTypeMasterCreateInput = {
    responseTypeId?: string
    responseTypeName: string
    isActive?: boolean
    description?: string | null
    propertyDetails?: PropertyDetailsCreateNestedManyWithoutResponseTypeInput
  }

  export type ResponseTypeMasterUncheckedCreateInput = {
    responseTypeId?: string
    responseTypeName: string
    isActive?: boolean
    description?: string | null
    propertyDetails?: PropertyDetailsUncheckedCreateNestedManyWithoutResponseTypeInput
  }

  export type ResponseTypeMasterUpdateInput = {
    responseTypeId?: StringFieldUpdateOperationsInput | string
    responseTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDetails?: PropertyDetailsUpdateManyWithoutResponseTypeNestedInput
  }

  export type ResponseTypeMasterUncheckedUpdateInput = {
    responseTypeId?: StringFieldUpdateOperationsInput | string
    responseTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDetails?: PropertyDetailsUncheckedUpdateManyWithoutResponseTypeNestedInput
  }

  export type ResponseTypeMasterCreateManyInput = {
    responseTypeId?: string
    responseTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type ResponseTypeMasterUpdateManyMutationInput = {
    responseTypeId?: StringFieldUpdateOperationsInput | string
    responseTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponseTypeMasterUncheckedUpdateManyInput = {
    responseTypeId?: StringFieldUpdateOperationsInput | string
    responseTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyTypeMasterCreateInput = {
    propertyTypeId?: string
    propertyTypeName: string
    isActive?: boolean
    description?: string | null
    locationDetails?: LocationDetailsCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeMasterUncheckedCreateInput = {
    propertyTypeId?: string
    propertyTypeName: string
    isActive?: boolean
    description?: string | null
    locationDetails?: LocationDetailsUncheckedCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeMasterUpdateInput = {
    propertyTypeId?: StringFieldUpdateOperationsInput | string
    propertyTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    locationDetails?: LocationDetailsUpdateManyWithoutPropertyTypeNestedInput
  }

  export type PropertyTypeMasterUncheckedUpdateInput = {
    propertyTypeId?: StringFieldUpdateOperationsInput | string
    propertyTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    locationDetails?: LocationDetailsUncheckedUpdateManyWithoutPropertyTypeNestedInput
  }

  export type PropertyTypeMasterCreateManyInput = {
    propertyTypeId?: string
    propertyTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type PropertyTypeMasterUpdateManyMutationInput = {
    propertyTypeId?: StringFieldUpdateOperationsInput | string
    propertyTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyTypeMasterUncheckedUpdateManyInput = {
    propertyTypeId?: StringFieldUpdateOperationsInput | string
    propertyTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RespondentStatusMasterCreateInput = {
    respondentStatusId?: string
    respondentStatusName: string
    isActive?: boolean
    description?: string | null
    propertyDetails?: PropertyDetailsCreateNestedManyWithoutRespondentStatusInput
  }

  export type RespondentStatusMasterUncheckedCreateInput = {
    respondentStatusId?: string
    respondentStatusName: string
    isActive?: boolean
    description?: string | null
    propertyDetails?: PropertyDetailsUncheckedCreateNestedManyWithoutRespondentStatusInput
  }

  export type RespondentStatusMasterUpdateInput = {
    respondentStatusId?: StringFieldUpdateOperationsInput | string
    respondentStatusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDetails?: PropertyDetailsUpdateManyWithoutRespondentStatusNestedInput
  }

  export type RespondentStatusMasterUncheckedUpdateInput = {
    respondentStatusId?: StringFieldUpdateOperationsInput | string
    respondentStatusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDetails?: PropertyDetailsUncheckedUpdateManyWithoutRespondentStatusNestedInput
  }

  export type RespondentStatusMasterCreateManyInput = {
    respondentStatusId?: string
    respondentStatusName: string
    isActive?: boolean
    description?: string | null
  }

  export type RespondentStatusMasterUpdateManyMutationInput = {
    respondentStatusId?: StringFieldUpdateOperationsInput | string
    respondentStatusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RespondentStatusMasterUncheckedUpdateManyInput = {
    respondentStatusId?: StringFieldUpdateOperationsInput | string
    respondentStatusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoadTypeMasterCreateInput = {
    roadTypeId?: string
    roadTypeName: string
    isActive?: boolean
    description?: string | null
    locationDetails?: LocationDetailsCreateNestedManyWithoutRoadTypeInput
  }

  export type RoadTypeMasterUncheckedCreateInput = {
    roadTypeId?: string
    roadTypeName: string
    isActive?: boolean
    description?: string | null
    locationDetails?: LocationDetailsUncheckedCreateNestedManyWithoutRoadTypeInput
  }

  export type RoadTypeMasterUpdateInput = {
    roadTypeId?: StringFieldUpdateOperationsInput | string
    roadTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    locationDetails?: LocationDetailsUpdateManyWithoutRoadTypeNestedInput
  }

  export type RoadTypeMasterUncheckedUpdateInput = {
    roadTypeId?: StringFieldUpdateOperationsInput | string
    roadTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    locationDetails?: LocationDetailsUncheckedUpdateManyWithoutRoadTypeNestedInput
  }

  export type RoadTypeMasterCreateManyInput = {
    roadTypeId?: string
    roadTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type RoadTypeMasterUpdateManyMutationInput = {
    roadTypeId?: StringFieldUpdateOperationsInput | string
    roadTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoadTypeMasterUncheckedUpdateManyInput = {
    roadTypeId?: StringFieldUpdateOperationsInput | string
    roadTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConstructionTypeMasterCreateInput = {
    constructionTypeId?: string
    constructionTypeName: string
    isActive?: boolean
    description?: string | null
    locationDetails?: LocationDetailsCreateNestedManyWithoutConstructionTypeInput
  }

  export type ConstructionTypeMasterUncheckedCreateInput = {
    constructionTypeId?: string
    constructionTypeName: string
    isActive?: boolean
    description?: string | null
    locationDetails?: LocationDetailsUncheckedCreateNestedManyWithoutConstructionTypeInput
  }

  export type ConstructionTypeMasterUpdateInput = {
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    constructionTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    locationDetails?: LocationDetailsUpdateManyWithoutConstructionTypeNestedInput
  }

  export type ConstructionTypeMasterUncheckedUpdateInput = {
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    constructionTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    locationDetails?: LocationDetailsUncheckedUpdateManyWithoutConstructionTypeNestedInput
  }

  export type ConstructionTypeMasterCreateManyInput = {
    constructionTypeId?: string
    constructionTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type ConstructionTypeMasterUpdateManyMutationInput = {
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    constructionTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConstructionTypeMasterUncheckedUpdateManyInput = {
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    constructionTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WaterSourceMasterCreateInput = {
    waterSourceId?: string
    waterSourceName: string
    isActive?: boolean
    description?: string | null
    otherDetails?: OtherDetailsCreateNestedManyWithoutWaterSourceInput
  }

  export type WaterSourceMasterUncheckedCreateInput = {
    waterSourceId?: string
    waterSourceName: string
    isActive?: boolean
    description?: string | null
    otherDetails?: OtherDetailsUncheckedCreateNestedManyWithoutWaterSourceInput
  }

  export type WaterSourceMasterUpdateInput = {
    waterSourceId?: StringFieldUpdateOperationsInput | string
    waterSourceName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    otherDetails?: OtherDetailsUpdateManyWithoutWaterSourceNestedInput
  }

  export type WaterSourceMasterUncheckedUpdateInput = {
    waterSourceId?: StringFieldUpdateOperationsInput | string
    waterSourceName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    otherDetails?: OtherDetailsUncheckedUpdateManyWithoutWaterSourceNestedInput
  }

  export type WaterSourceMasterCreateManyInput = {
    waterSourceId?: string
    waterSourceName: string
    isActive?: boolean
    description?: string | null
  }

  export type WaterSourceMasterUpdateManyMutationInput = {
    waterSourceId?: StringFieldUpdateOperationsInput | string
    waterSourceName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WaterSourceMasterUncheckedUpdateManyInput = {
    waterSourceId?: StringFieldUpdateOperationsInput | string
    waterSourceName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DisposalTypeMasterCreateInput = {
    disposalTypeId?: string
    disposalTypeName: string
    isActive?: boolean
    description?: string | null
    otherDetails?: OtherDetailsCreateNestedManyWithoutDisposalTypeInput
  }

  export type DisposalTypeMasterUncheckedCreateInput = {
    disposalTypeId?: string
    disposalTypeName: string
    isActive?: boolean
    description?: string | null
    otherDetails?: OtherDetailsUncheckedCreateNestedManyWithoutDisposalTypeInput
  }

  export type DisposalTypeMasterUpdateInput = {
    disposalTypeId?: StringFieldUpdateOperationsInput | string
    disposalTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    otherDetails?: OtherDetailsUpdateManyWithoutDisposalTypeNestedInput
  }

  export type DisposalTypeMasterUncheckedUpdateInput = {
    disposalTypeId?: StringFieldUpdateOperationsInput | string
    disposalTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    otherDetails?: OtherDetailsUncheckedUpdateManyWithoutDisposalTypeNestedInput
  }

  export type DisposalTypeMasterCreateManyInput = {
    disposalTypeId?: string
    disposalTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type DisposalTypeMasterUpdateManyMutationInput = {
    disposalTypeId?: StringFieldUpdateOperationsInput | string
    disposalTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DisposalTypeMasterUncheckedUpdateManyInput = {
    disposalTypeId?: StringFieldUpdateOperationsInput | string
    disposalTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NrPropertyCategoryMasterCreateInput = {
    propertyCategoryId?: string
    propertyCategoryNumber: number
    propertyCategoryName: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    subCategories?: NrPropertySubCategoryMasterCreateNestedManyWithoutPropertyCategoryInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutNrPropertyCategoryInput
  }

  export type NrPropertyCategoryMasterUncheckedCreateInput = {
    propertyCategoryId?: string
    propertyCategoryNumber: number
    propertyCategoryName: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    subCategories?: NrPropertySubCategoryMasterUncheckedCreateNestedManyWithoutPropertyCategoryInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutNrPropertyCategoryInput
  }

  export type NrPropertyCategoryMasterUpdateInput = {
    propertyCategoryId?: StringFieldUpdateOperationsInput | string
    propertyCategoryNumber?: IntFieldUpdateOperationsInput | number
    propertyCategoryName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCategories?: NrPropertySubCategoryMasterUpdateManyWithoutPropertyCategoryNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutNrPropertyCategoryNestedInput
  }

  export type NrPropertyCategoryMasterUncheckedUpdateInput = {
    propertyCategoryId?: StringFieldUpdateOperationsInput | string
    propertyCategoryNumber?: IntFieldUpdateOperationsInput | number
    propertyCategoryName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCategories?: NrPropertySubCategoryMasterUncheckedUpdateManyWithoutPropertyCategoryNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutNrPropertyCategoryNestedInput
  }

  export type NrPropertyCategoryMasterCreateManyInput = {
    propertyCategoryId?: string
    propertyCategoryNumber: number
    propertyCategoryName: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
  }

  export type NrPropertyCategoryMasterUpdateManyMutationInput = {
    propertyCategoryId?: StringFieldUpdateOperationsInput | string
    propertyCategoryNumber?: IntFieldUpdateOperationsInput | number
    propertyCategoryName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NrPropertyCategoryMasterUncheckedUpdateManyInput = {
    propertyCategoryId?: StringFieldUpdateOperationsInput | string
    propertyCategoryNumber?: IntFieldUpdateOperationsInput | number
    propertyCategoryName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NrPropertySubCategoryMasterCreateInput = {
    subCategoryId?: string
    subCategoryNumber: number
    subCategoryName: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    propertyCategory: NrPropertyCategoryMasterCreateNestedOneWithoutSubCategoriesInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutNrSubCategoryInput
  }

  export type NrPropertySubCategoryMasterUncheckedCreateInput = {
    subCategoryId?: string
    subCategoryNumber: number
    subCategoryName: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    propertyCategoryId: string
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutNrSubCategoryInput
  }

  export type NrPropertySubCategoryMasterUpdateInput = {
    subCategoryId?: StringFieldUpdateOperationsInput | string
    subCategoryNumber?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyCategory?: NrPropertyCategoryMasterUpdateOneRequiredWithoutSubCategoriesNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutNrSubCategoryNestedInput
  }

  export type NrPropertySubCategoryMasterUncheckedUpdateInput = {
    subCategoryId?: StringFieldUpdateOperationsInput | string
    subCategoryNumber?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyCategoryId?: StringFieldUpdateOperationsInput | string
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutNrSubCategoryNestedInput
  }

  export type NrPropertySubCategoryMasterCreateManyInput = {
    subCategoryId?: string
    subCategoryNumber: number
    subCategoryName: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    propertyCategoryId: string
  }

  export type NrPropertySubCategoryMasterUpdateManyMutationInput = {
    subCategoryId?: StringFieldUpdateOperationsInput | string
    subCategoryNumber?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NrPropertySubCategoryMasterUncheckedUpdateManyInput = {
    subCategoryId?: StringFieldUpdateOperationsInput | string
    subCategoryNumber?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyCategoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ConstructionNatureMasterCreateInput = {
    constructionNatureId?: string
    constructionNatureName: string
    isActive?: boolean
    description?: string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentCreateNestedManyWithoutConstructionNatureInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutConstructionNatureInput
  }

  export type ConstructionNatureMasterUncheckedCreateInput = {
    constructionNatureId?: string
    constructionNatureName: string
    isActive?: boolean
    description?: string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutConstructionNatureInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutConstructionNatureInput
  }

  export type ConstructionNatureMasterUpdateInput = {
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    constructionNatureName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUpdateManyWithoutConstructionNatureNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutConstructionNatureNestedInput
  }

  export type ConstructionNatureMasterUncheckedUpdateInput = {
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    constructionNatureName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedUpdateManyWithoutConstructionNatureNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutConstructionNatureNestedInput
  }

  export type ConstructionNatureMasterCreateManyInput = {
    constructionNatureId?: string
    constructionNatureName: string
    isActive?: boolean
    description?: string | null
  }

  export type ConstructionNatureMasterUpdateManyMutationInput = {
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    constructionNatureName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConstructionNatureMasterUncheckedUpdateManyInput = {
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    constructionNatureName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SurveyTypeMasterCreateInput = {
    surveyTypeId?: string
    surveyTypeName: string
    isActive?: boolean
    description?: string | null
    surveyDetails?: SurveyDetailsCreateNestedManyWithoutSurveyTypeInput
  }

  export type SurveyTypeMasterUncheckedCreateInput = {
    surveyTypeId?: string
    surveyTypeName: string
    isActive?: boolean
    description?: string | null
    surveyDetails?: SurveyDetailsUncheckedCreateNestedManyWithoutSurveyTypeInput
  }

  export type SurveyTypeMasterUpdateInput = {
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    surveyTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyDetails?: SurveyDetailsUpdateManyWithoutSurveyTypeNestedInput
  }

  export type SurveyTypeMasterUncheckedUpdateInput = {
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    surveyTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyDetails?: SurveyDetailsUncheckedUpdateManyWithoutSurveyTypeNestedInput
  }

  export type SurveyTypeMasterCreateManyInput = {
    surveyTypeId?: string
    surveyTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type SurveyTypeMasterUpdateManyMutationInput = {
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    surveyTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SurveyTypeMasterUncheckedUpdateManyInput = {
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    surveyTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OccupancyStatusMasterCreateInput = {
    occupancyStatusId?: string
    occupancyStatusName: string
    isActive?: boolean
    description?: string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentCreateNestedManyWithoutOccupancyStatusInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutOccupancyStatusInput
  }

  export type OccupancyStatusMasterUncheckedCreateInput = {
    occupancyStatusId?: string
    occupancyStatusName: string
    isActive?: boolean
    description?: string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutOccupancyStatusInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutOccupancyStatusInput
  }

  export type OccupancyStatusMasterUpdateInput = {
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    occupancyStatusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUpdateManyWithoutOccupancyStatusNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutOccupancyStatusNestedInput
  }

  export type OccupancyStatusMasterUncheckedUpdateInput = {
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    occupancyStatusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedUpdateManyWithoutOccupancyStatusNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutOccupancyStatusNestedInput
  }

  export type OccupancyStatusMasterCreateManyInput = {
    occupancyStatusId?: string
    occupancyStatusName: string
    isActive?: boolean
    description?: string | null
  }

  export type OccupancyStatusMasterUpdateManyMutationInput = {
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    occupancyStatusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OccupancyStatusMasterUncheckedUpdateManyInput = {
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    occupancyStatusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SurveyStatusMasterCreateInput = {
    statusId?: string
    statusName: string
    isActive?: boolean
    description?: string | null
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutStatusInput
    surveyStatusMapsReverted?: SurveyStatusMappingCreateNestedManyWithoutRevertedFromInput
  }

  export type SurveyStatusMasterUncheckedCreateInput = {
    statusId?: string
    statusName: string
    isActive?: boolean
    description?: string | null
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutStatusInput
    surveyStatusMapsReverted?: SurveyStatusMappingUncheckedCreateNestedManyWithoutRevertedFromInput
  }

  export type SurveyStatusMasterUpdateInput = {
    statusId?: StringFieldUpdateOperationsInput | string
    statusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutStatusNestedInput
    surveyStatusMapsReverted?: SurveyStatusMappingUpdateManyWithoutRevertedFromNestedInput
  }

  export type SurveyStatusMasterUncheckedUpdateInput = {
    statusId?: StringFieldUpdateOperationsInput | string
    statusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutStatusNestedInput
    surveyStatusMapsReverted?: SurveyStatusMappingUncheckedUpdateManyWithoutRevertedFromNestedInput
  }

  export type SurveyStatusMasterCreateManyInput = {
    statusId?: string
    statusName: string
    isActive?: boolean
    description?: string | null
  }

  export type SurveyStatusMasterUpdateManyMutationInput = {
    statusId?: StringFieldUpdateOperationsInput | string
    statusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SurveyStatusMasterUncheckedUpdateManyInput = {
    statusId?: StringFieldUpdateOperationsInput | string
    statusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WardStatusMasterCreateInput = {
    statusId?: string
    statusName: string
    isActive?: boolean
    description?: string | null
    wardStatusMaps?: WardStatusMappingCreateNestedManyWithoutStatusInput
  }

  export type WardStatusMasterUncheckedCreateInput = {
    statusId?: string
    statusName: string
    isActive?: boolean
    description?: string | null
    wardStatusMaps?: WardStatusMappingUncheckedCreateNestedManyWithoutStatusInput
  }

  export type WardStatusMasterUpdateInput = {
    statusId?: StringFieldUpdateOperationsInput | string
    statusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    wardStatusMaps?: WardStatusMappingUpdateManyWithoutStatusNestedInput
  }

  export type WardStatusMasterUncheckedUpdateInput = {
    statusId?: StringFieldUpdateOperationsInput | string
    statusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    wardStatusMaps?: WardStatusMappingUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type WardStatusMasterCreateManyInput = {
    statusId?: string
    statusName: string
    isActive?: boolean
    description?: string | null
  }

  export type WardStatusMasterUpdateManyMutationInput = {
    statusId?: StringFieldUpdateOperationsInput | string
    statusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WardStatusMasterUncheckedUpdateManyInput = {
    statusId?: StringFieldUpdateOperationsInput | string
    statusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersMasterCreateInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutUserInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentCreateNestedManyWithoutAssignedByInput
    wardStatusMaps?: WardStatusMappingCreateNestedManyWithoutChangedByInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsCreateNestedManyWithoutUserInput
    admins?: AdminsCreateNestedManyWithoutUserInput
  }

  export type UsersMasterUncheckedCreateInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutUserInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    wardStatusMaps?: WardStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsUncheckedCreateNestedManyWithoutUserInput
    admins?: AdminsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersMasterUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutUserNestedInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUpdateManyWithoutAssignedByNestedInput
    wardStatusMaps?: WardStatusMappingUpdateManyWithoutChangedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUpdateManyWithoutUserNestedInput
    admins?: AdminsUpdateManyWithoutUserNestedInput
  }

  export type UsersMasterUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutUserNestedInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    wardStatusMaps?: WardStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUncheckedUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUncheckedUpdateManyWithoutUserNestedInput
    admins?: AdminsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersMasterCreateManyInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
  }

  export type UsersMasterUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersMasterUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionMasterCreateInput = {
    roleId?: string
    roleName: string
    isActive?: boolean
    description?: string | null
    userRoleMaps?: UserRoleMappingCreateNestedManyWithoutRoleInput
  }

  export type RolePermissionMasterUncheckedCreateInput = {
    roleId?: string
    roleName: string
    isActive?: boolean
    description?: string | null
    userRoleMaps?: UserRoleMappingUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RolePermissionMasterUpdateInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userRoleMaps?: UserRoleMappingUpdateManyWithoutRoleNestedInput
  }

  export type RolePermissionMasterUncheckedUpdateInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userRoleMaps?: UserRoleMappingUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RolePermissionMasterCreateManyInput = {
    roleId?: string
    roleName: string
    isActive?: boolean
    description?: string | null
  }

  export type RolePermissionMasterUpdateManyMutationInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionMasterUncheckedUpdateManyInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UlbZoneMappingCreateInput = {
    ulbZoneMapId?: string
    isActive?: boolean
    ulb: UlbMasterCreateNestedOneWithoutUlbZoneMapsInput
    zone: ZoneMasterCreateNestedOneWithoutUlbZoneMapsInput
    surveyors?: SurveyorsCreateNestedManyWithoutUlbZoneMapInput
  }

  export type UlbZoneMappingUncheckedCreateInput = {
    ulbZoneMapId?: string
    ulbId: string
    zoneId: string
    isActive?: boolean
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutUlbZoneMapInput
  }

  export type UlbZoneMappingUpdateInput = {
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ulb?: UlbMasterUpdateOneRequiredWithoutUlbZoneMapsNestedInput
    zone?: ZoneMasterUpdateOneRequiredWithoutUlbZoneMapsNestedInput
    surveyors?: SurveyorsUpdateManyWithoutUlbZoneMapNestedInput
  }

  export type UlbZoneMappingUncheckedUpdateInput = {
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    surveyors?: SurveyorsUncheckedUpdateManyWithoutUlbZoneMapNestedInput
  }

  export type UlbZoneMappingCreateManyInput = {
    ulbZoneMapId?: string
    ulbId: string
    zoneId: string
    isActive?: boolean
  }

  export type UlbZoneMappingUpdateManyMutationInput = {
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UlbZoneMappingUncheckedUpdateManyInput = {
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ZoneWardMappingCreateInput = {
    zoneWardMapId?: string
    isActive?: boolean
    zone: ZoneMasterCreateNestedOneWithoutZoneWardMapsInput
    ward: WardMasterCreateNestedOneWithoutZoneWardMapsInput
    surveyors?: SurveyorsCreateNestedManyWithoutZoneWardMapInput
  }

  export type ZoneWardMappingUncheckedCreateInput = {
    zoneWardMapId?: string
    zoneId: string
    wardId: string
    isActive?: boolean
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutZoneWardMapInput
  }

  export type ZoneWardMappingUpdateInput = {
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    zone?: ZoneMasterUpdateOneRequiredWithoutZoneWardMapsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutZoneWardMapsNestedInput
    surveyors?: SurveyorsUpdateManyWithoutZoneWardMapNestedInput
  }

  export type ZoneWardMappingUncheckedUpdateInput = {
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    surveyors?: SurveyorsUncheckedUpdateManyWithoutZoneWardMapNestedInput
  }

  export type ZoneWardMappingCreateManyInput = {
    zoneWardMapId?: string
    zoneId: string
    wardId: string
    isActive?: boolean
  }

  export type ZoneWardMappingUpdateManyMutationInput = {
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ZoneWardMappingUncheckedUpdateManyInput = {
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WardMohallaMappingCreateInput = {
    wardMohallaMapId?: string
    isActive?: boolean
    ward: WardMasterCreateNestedOneWithoutWardMohallaMapsInput
    mohalla: MohallaMasterCreateNestedOneWithoutWardMohallaMapsInput
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutWardMohallaMapInput
    surveyors?: SurveyorsCreateNestedManyWithoutWardMohallaMapInput
  }

  export type WardMohallaMappingUncheckedCreateInput = {
    wardMohallaMapId?: string
    wardId: string
    mohallaId: string
    isActive?: boolean
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutWardMohallaMapInput
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutWardMohallaMapInput
  }

  export type WardMohallaMappingUpdateInput = {
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ward?: WardMasterUpdateOneRequiredWithoutWardMohallaMapsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutWardMohallaMapsNestedInput
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutWardMohallaMapNestedInput
    surveyors?: SurveyorsUpdateManyWithoutWardMohallaMapNestedInput
  }

  export type WardMohallaMappingUncheckedUpdateInput = {
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutWardMohallaMapNestedInput
    surveyors?: SurveyorsUncheckedUpdateManyWithoutWardMohallaMapNestedInput
  }

  export type WardMohallaMappingCreateManyInput = {
    wardMohallaMapId?: string
    wardId: string
    mohallaId: string
    isActive?: boolean
  }

  export type WardMohallaMappingUpdateManyMutationInput = {
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WardMohallaMappingUncheckedUpdateManyInput = {
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyorAssignmentCreateInput = {
    assignmentId?: string
    assignmentType: string
    isActive?: boolean
    user: UsersMasterCreateNestedOneWithoutSurveyorAssignmentsInput
    ward: WardMasterCreateNestedOneWithoutSurveyorAssignmentsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyorAssignmentsInput
    wardMohallaMap: WardMohallaMappingCreateNestedOneWithoutSurveyorAssignmentsInput
    assignedBy: UsersMasterCreateNestedOneWithoutSurveyorAssignmentsAssignedByInput
  }

  export type SurveyorAssignmentUncheckedCreateInput = {
    assignmentId?: string
    userId: string
    assignmentType: string
    wardId: string
    mohallaId: string
    wardMohallaMapId: string
    assignedById: string
    isActive?: boolean
  }

  export type SurveyorAssignmentUpdateInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UsersMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    wardMohallaMap?: WardMohallaMappingUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    assignedBy?: UsersMasterUpdateOneRequiredWithoutSurveyorAssignmentsAssignedByNestedInput
  }

  export type SurveyorAssignmentUncheckedUpdateInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyorAssignmentCreateManyInput = {
    assignmentId?: string
    userId: string
    assignmentType: string
    wardId: string
    mohallaId: string
    wardMohallaMapId: string
    assignedById: string
    isActive?: boolean
  }

  export type SurveyorAssignmentUpdateManyMutationInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyorAssignmentUncheckedUpdateManyInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WardStatusMappingCreateInput = {
    wardStatusId?: string
    isActive?: boolean
    ward: WardMasterCreateNestedOneWithoutWardStatusMapsInput
    status: WardStatusMasterCreateNestedOneWithoutWardStatusMapsInput
    changedBy: UsersMasterCreateNestedOneWithoutWardStatusMapsInput
  }

  export type WardStatusMappingUncheckedCreateInput = {
    wardStatusId?: string
    wardId: string
    statusId: string
    changedById: string
    isActive?: boolean
  }

  export type WardStatusMappingUpdateInput = {
    wardStatusId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ward?: WardMasterUpdateOneRequiredWithoutWardStatusMapsNestedInput
    status?: WardStatusMasterUpdateOneRequiredWithoutWardStatusMapsNestedInput
    changedBy?: UsersMasterUpdateOneRequiredWithoutWardStatusMapsNestedInput
  }

  export type WardStatusMappingUncheckedUpdateInput = {
    wardStatusId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    changedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WardStatusMappingCreateManyInput = {
    wardStatusId?: string
    wardId: string
    statusId: string
    changedById: string
    isActive?: boolean
  }

  export type WardStatusMappingUpdateManyMutationInput = {
    wardStatusId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WardStatusMappingUncheckedUpdateManyInput = {
    wardStatusId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    changedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyStatusMappingCreateInput = {
    statusMappingId?: string
    isActive?: boolean
    survey: SurveyDetailsCreateNestedOneWithoutSurveyStatusMapsInput
    status: SurveyStatusMasterCreateNestedOneWithoutSurveyStatusMapsInput
    revertedFrom?: SurveyStatusMasterCreateNestedOneWithoutSurveyStatusMapsRevertedInput
    changedBy: UsersMasterCreateNestedOneWithoutSurveyStatusMapsInput
  }

  export type SurveyStatusMappingUncheckedCreateInput = {
    statusMappingId?: string
    surveyUniqueCode: string
    statusId: string
    revertedFromId?: string | null
    changedById: string
    isActive?: boolean
  }

  export type SurveyStatusMappingUpdateInput = {
    statusMappingId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    survey?: SurveyDetailsUpdateOneRequiredWithoutSurveyStatusMapsNestedInput
    status?: SurveyStatusMasterUpdateOneRequiredWithoutSurveyStatusMapsNestedInput
    revertedFrom?: SurveyStatusMasterUpdateOneWithoutSurveyStatusMapsRevertedNestedInput
    changedBy?: UsersMasterUpdateOneRequiredWithoutSurveyStatusMapsNestedInput
  }

  export type SurveyStatusMappingUncheckedUpdateInput = {
    statusMappingId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    revertedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyStatusMappingCreateManyInput = {
    statusMappingId?: string
    surveyUniqueCode: string
    statusId: string
    revertedFromId?: string | null
    changedById: string
    isActive?: boolean
  }

  export type SurveyStatusMappingUpdateManyMutationInput = {
    statusMappingId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyStatusMappingUncheckedUpdateManyInput = {
    statusMappingId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    revertedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserRoleMappingCreateInput = {
    userRoleMapId?: string
    isActive?: boolean
    user: UsersMasterCreateNestedOneWithoutUserRoleMapsInput
    role: RolePermissionMasterCreateNestedOneWithoutUserRoleMapsInput
  }

  export type UserRoleMappingUncheckedCreateInput = {
    userRoleMapId?: string
    userId: string
    roleId: string
    isActive?: boolean
  }

  export type UserRoleMappingUpdateInput = {
    userRoleMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UsersMasterUpdateOneRequiredWithoutUserRoleMapsNestedInput
    role?: RolePermissionMasterUpdateOneRequiredWithoutUserRoleMapsNestedInput
  }

  export type UserRoleMappingUncheckedUpdateInput = {
    userRoleMapId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserRoleMappingCreateManyInput = {
    userRoleMapId?: string
    userId: string
    roleId: string
    isActive?: boolean
  }

  export type UserRoleMappingUpdateManyMutationInput = {
    userRoleMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserRoleMappingUncheckedUpdateManyInput = {
    userRoleMapId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionCreateInput = {
    sessionId?: string
    loginTime: Date | string
    logoutTime: Date | string
    isActive?: boolean
    user: UsersMasterCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    sessionId?: string
    userId: string
    loginTime: Date | string
    logoutTime: Date | string
    isActive?: boolean
  }

  export type SessionUpdateInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UsersMasterUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionCreateManyInput = {
    sessionId?: string
    userId: string
    loginTime: Date | string
    logoutTime: Date | string
    isActive?: boolean
  }

  export type SessionUpdateManyMutationInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUncheckedUpdateManyInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyorsCreateInput = {
    surveyorName: string
    username: string
    password: string
    wardNumber: string
    user: UsersMasterCreateNestedOneWithoutSurveyorsInput
    wardMohallaMap: WardMohallaMappingCreateNestedOneWithoutSurveyorsInput
    zoneWardMap: ZoneWardMappingCreateNestedOneWithoutSurveyorsInput
    ulbZoneMap: UlbZoneMappingCreateNestedOneWithoutSurveyorsInput
  }

  export type SurveyorsUncheckedCreateInput = {
    userId: string
    surveyorName: string
    username: string
    password: string
    wardNumber: string
    wardMohallaMapId: string
    zoneWardMapId: string
    ulbZoneMapId: string
  }

  export type SurveyorsUpdateInput = {
    surveyorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    user?: UsersMasterUpdateOneRequiredWithoutSurveyorsNestedInput
    wardMohallaMap?: WardMohallaMappingUpdateOneRequiredWithoutSurveyorsNestedInput
    zoneWardMap?: ZoneWardMappingUpdateOneRequiredWithoutSurveyorsNestedInput
    ulbZoneMap?: UlbZoneMappingUpdateOneRequiredWithoutSurveyorsNestedInput
  }

  export type SurveyorsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    surveyorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyorsCreateManyInput = {
    userId: string
    surveyorName: string
    username: string
    password: string
    wardNumber: string
    wardMohallaMapId: string
    zoneWardMapId: string
    ulbZoneMapId: string
  }

  export type SurveyorsUpdateManyMutationInput = {
    surveyorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyorsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    surveyorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
  }

  export type SupervisorsCreateInput = {
    supervisorName: string
    username: string
    password: string
    user: UsersMasterCreateNestedOneWithoutSupervisorsInput
    ward: WardMasterCreateNestedOneWithoutSupervisorsInput
  }

  export type SupervisorsUncheckedCreateInput = {
    userId: string
    supervisorName: string
    username: string
    password: string
    wardId: string
  }

  export type SupervisorsUpdateInput = {
    supervisorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user?: UsersMasterUpdateOneRequiredWithoutSupervisorsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSupervisorsNestedInput
  }

  export type SupervisorsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    supervisorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
  }

  export type SupervisorsCreateManyInput = {
    userId: string
    supervisorName: string
    username: string
    password: string
    wardId: string
  }

  export type SupervisorsUpdateManyMutationInput = {
    supervisorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type SupervisorsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    supervisorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminsCreateInput = {
    adminName: string
    username: string
    password: string
    user: UsersMasterCreateNestedOneWithoutAdminsInput
  }

  export type AdminsUncheckedCreateInput = {
    userId: string
    adminName: string
    username: string
    password: string
  }

  export type AdminsUpdateInput = {
    adminName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user?: UsersMasterUpdateOneRequiredWithoutAdminsNestedInput
  }

  export type AdminsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    adminName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type AdminsCreateManyInput = {
    userId: string
    adminName: string
    username: string
    password: string
  }

  export type AdminsUpdateManyMutationInput = {
    adminName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type AdminsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    adminName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyDetailsCreateInput = {
    surveyUniqueCode?: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    ulb: UlbMasterCreateNestedOneWithoutSurveyDetailsInput
    zone: ZoneMasterCreateNestedOneWithoutSurveyDetailsInput
    ward: WardMasterCreateNestedOneWithoutSurveyDetailsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyDetailsInput
    surveyType: SurveyTypeMasterCreateNestedOneWithoutSurveyDetailsInput
    propertyDetails?: PropertyDetailsCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsUncheckedCreateInput = {
    surveyUniqueCode?: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    propertyDetails?: PropertyDetailsUncheckedCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsUncheckedCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsUncheckedCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsUncheckedCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsUpdateInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    ulb?: UlbMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    zone?: ZoneMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    surveyType?: SurveyTypeMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    propertyDetails?: PropertyDetailsUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDetails?: PropertyDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsCreateManyInput = {
    surveyUniqueCode?: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
  }

  export type SurveyDetailsUpdateManyMutationInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SurveyDetailsUncheckedUpdateManyInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyDetailsCreateInput = {
    oldHouseNumber?: string | null
    electricityConsumerName?: string | null
    waterSewerageConnectionNumber?: string | null
    respondentName: string
    survey: SurveyDetailsCreateNestedOneWithoutPropertyDetailsInput
    responseType: ResponseTypeMasterCreateNestedOneWithoutPropertyDetailsInput
    respondentStatus: RespondentStatusMasterCreateNestedOneWithoutPropertyDetailsInput
  }

  export type PropertyDetailsUncheckedCreateInput = {
    surveyUniqueCode: string
    responseTypeId: string
    oldHouseNumber?: string | null
    electricityConsumerName?: string | null
    waterSewerageConnectionNumber?: string | null
    respondentName: string
    respondentStatusId: string
  }

  export type PropertyDetailsUpdateInput = {
    oldHouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    electricityConsumerName?: NullableStringFieldUpdateOperationsInput | string | null
    waterSewerageConnectionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    respondentName?: StringFieldUpdateOperationsInput | string
    survey?: SurveyDetailsUpdateOneRequiredWithoutPropertyDetailsNestedInput
    responseType?: ResponseTypeMasterUpdateOneRequiredWithoutPropertyDetailsNestedInput
    respondentStatus?: RespondentStatusMasterUpdateOneRequiredWithoutPropertyDetailsNestedInput
  }

  export type PropertyDetailsUncheckedUpdateInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    responseTypeId?: StringFieldUpdateOperationsInput | string
    oldHouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    electricityConsumerName?: NullableStringFieldUpdateOperationsInput | string | null
    waterSewerageConnectionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    respondentName?: StringFieldUpdateOperationsInput | string
    respondentStatusId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyDetailsCreateManyInput = {
    surveyUniqueCode: string
    responseTypeId: string
    oldHouseNumber?: string | null
    electricityConsumerName?: string | null
    waterSewerageConnectionNumber?: string | null
    respondentName: string
    respondentStatusId: string
  }

  export type PropertyDetailsUpdateManyMutationInput = {
    oldHouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    electricityConsumerName?: NullableStringFieldUpdateOperationsInput | string | null
    waterSewerageConnectionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    respondentName?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyDetailsUncheckedUpdateManyInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    responseTypeId?: StringFieldUpdateOperationsInput | string
    oldHouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    electricityConsumerName?: NullableStringFieldUpdateOperationsInput | string | null
    waterSewerageConnectionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    respondentName?: StringFieldUpdateOperationsInput | string
    respondentStatusId?: StringFieldUpdateOperationsInput | string
  }

  export type OwnerDetailsCreateInput = {
    ownerName: string
    fatherHusbandName: string
    mobileNumber?: string | null
    aadharNumber?: string | null
    survey: SurveyDetailsCreateNestedOneWithoutOwnerDetailsInput
  }

  export type OwnerDetailsUncheckedCreateInput = {
    surveyUniqueCode: string
    ownerName: string
    fatherHusbandName: string
    mobileNumber?: string | null
    aadharNumber?: string | null
  }

  export type OwnerDetailsUpdateInput = {
    ownerName?: StringFieldUpdateOperationsInput | string
    fatherHusbandName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    survey?: SurveyDetailsUpdateOneRequiredWithoutOwnerDetailsNestedInput
  }

  export type OwnerDetailsUncheckedUpdateInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    fatherHusbandName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OwnerDetailsCreateManyInput = {
    surveyUniqueCode: string
    ownerName: string
    fatherHusbandName: string
    mobileNumber?: string | null
    aadharNumber?: string | null
  }

  export type OwnerDetailsUpdateManyMutationInput = {
    ownerName?: StringFieldUpdateOperationsInput | string
    fatherHusbandName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OwnerDetailsUncheckedUpdateManyInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    fatherHusbandName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationDetailsCreateInput = {
    propertyLatitude: Decimal | DecimalJsLike | number | string
    propertyLongitude: Decimal | DecimalJsLike | number | string
    assessmentYear: string
    buildingName?: string | null
    constructionYear: string
    addressRoadName: string
    locality?: string | null
    pinCode: number
    landmark?: string | null
    fourWayEast?: string | null
    fourWayWest?: string | null
    fourWayNorth?: string | null
    fourWaySouth?: string | null
    newWard: string
    survey: SurveyDetailsCreateNestedOneWithoutLocationDetailsInput
    propertyType: PropertyTypeMasterCreateNestedOneWithoutLocationDetailsInput
    roadType: RoadTypeMasterCreateNestedOneWithoutLocationDetailsInput
    constructionType: ConstructionTypeMasterCreateNestedOneWithoutLocationDetailsInput
  }

  export type LocationDetailsUncheckedCreateInput = {
    surveyUniqueCode: string
    propertyLatitude: Decimal | DecimalJsLike | number | string
    propertyLongitude: Decimal | DecimalJsLike | number | string
    assessmentYear: string
    propertyTypeId: string
    buildingName?: string | null
    roadTypeId: string
    constructionYear: string
    constructionTypeId: string
    addressRoadName: string
    locality?: string | null
    pinCode: number
    landmark?: string | null
    fourWayEast?: string | null
    fourWayWest?: string | null
    fourWayNorth?: string | null
    fourWaySouth?: string | null
    newWard: string
  }

  export type LocationDetailsUpdateInput = {
    propertyLatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    constructionYear?: StringFieldUpdateOperationsInput | string
    addressRoadName?: StringFieldUpdateOperationsInput | string
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: IntFieldUpdateOperationsInput | number
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayEast?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayWest?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayNorth?: NullableStringFieldUpdateOperationsInput | string | null
    fourWaySouth?: NullableStringFieldUpdateOperationsInput | string | null
    newWard?: StringFieldUpdateOperationsInput | string
    survey?: SurveyDetailsUpdateOneRequiredWithoutLocationDetailsNestedInput
    propertyType?: PropertyTypeMasterUpdateOneRequiredWithoutLocationDetailsNestedInput
    roadType?: RoadTypeMasterUpdateOneRequiredWithoutLocationDetailsNestedInput
    constructionType?: ConstructionTypeMasterUpdateOneRequiredWithoutLocationDetailsNestedInput
  }

  export type LocationDetailsUncheckedUpdateInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    propertyLatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFieldUpdateOperationsInput | string
    propertyTypeId?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    roadTypeId?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    addressRoadName?: StringFieldUpdateOperationsInput | string
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: IntFieldUpdateOperationsInput | number
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayEast?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayWest?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayNorth?: NullableStringFieldUpdateOperationsInput | string | null
    fourWaySouth?: NullableStringFieldUpdateOperationsInput | string | null
    newWard?: StringFieldUpdateOperationsInput | string
  }

  export type LocationDetailsCreateManyInput = {
    surveyUniqueCode: string
    propertyLatitude: Decimal | DecimalJsLike | number | string
    propertyLongitude: Decimal | DecimalJsLike | number | string
    assessmentYear: string
    propertyTypeId: string
    buildingName?: string | null
    roadTypeId: string
    constructionYear: string
    constructionTypeId: string
    addressRoadName: string
    locality?: string | null
    pinCode: number
    landmark?: string | null
    fourWayEast?: string | null
    fourWayWest?: string | null
    fourWayNorth?: string | null
    fourWaySouth?: string | null
    newWard: string
  }

  export type LocationDetailsUpdateManyMutationInput = {
    propertyLatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    constructionYear?: StringFieldUpdateOperationsInput | string
    addressRoadName?: StringFieldUpdateOperationsInput | string
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: IntFieldUpdateOperationsInput | number
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayEast?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayWest?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayNorth?: NullableStringFieldUpdateOperationsInput | string | null
    fourWaySouth?: NullableStringFieldUpdateOperationsInput | string | null
    newWard?: StringFieldUpdateOperationsInput | string
  }

  export type LocationDetailsUncheckedUpdateManyInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    propertyLatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFieldUpdateOperationsInput | string
    propertyTypeId?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    roadTypeId?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    addressRoadName?: StringFieldUpdateOperationsInput | string
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: IntFieldUpdateOperationsInput | number
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayEast?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayWest?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayNorth?: NullableStringFieldUpdateOperationsInput | string | null
    fourWaySouth?: NullableStringFieldUpdateOperationsInput | string | null
    newWard?: StringFieldUpdateOperationsInput | string
  }

  export type OtherDetailsCreateInput = {
    rainWaterHarvestingSystem?: string | null
    plantation?: string | null
    parking?: string | null
    pollution?: string | null
    pollutionMeasurementTaken?: string | null
    waterSupplyWithin200Meters?: string | null
    sewerageLineWithin100Meters?: string | null
    totalPlotArea: number
    builtupAreaOfGroundFloor: number
    remarks?: string | null
    survey: SurveyDetailsCreateNestedOneWithoutOtherDetailsInput
    waterSource: WaterSourceMasterCreateNestedOneWithoutOtherDetailsInput
    disposalType: DisposalTypeMasterCreateNestedOneWithoutOtherDetailsInput
  }

  export type OtherDetailsUncheckedCreateInput = {
    surveyUniqueCode: string
    waterSourceId: string
    rainWaterHarvestingSystem?: string | null
    plantation?: string | null
    parking?: string | null
    pollution?: string | null
    pollutionMeasurementTaken?: string | null
    waterSupplyWithin200Meters?: string | null
    sewerageLineWithin100Meters?: string | null
    disposalTypeId: string
    totalPlotArea: number
    builtupAreaOfGroundFloor: number
    remarks?: string | null
  }

  export type OtherDetailsUpdateInput = {
    rainWaterHarvestingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    plantation?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: NullableStringFieldUpdateOperationsInput | string | null
    pollution?: NullableStringFieldUpdateOperationsInput | string | null
    pollutionMeasurementTaken?: NullableStringFieldUpdateOperationsInput | string | null
    waterSupplyWithin200Meters?: NullableStringFieldUpdateOperationsInput | string | null
    sewerageLineWithin100Meters?: NullableStringFieldUpdateOperationsInput | string | null
    totalPlotArea?: FloatFieldUpdateOperationsInput | number
    builtupAreaOfGroundFloor?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    survey?: SurveyDetailsUpdateOneRequiredWithoutOtherDetailsNestedInput
    waterSource?: WaterSourceMasterUpdateOneRequiredWithoutOtherDetailsNestedInput
    disposalType?: DisposalTypeMasterUpdateOneRequiredWithoutOtherDetailsNestedInput
  }

  export type OtherDetailsUncheckedUpdateInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    waterSourceId?: StringFieldUpdateOperationsInput | string
    rainWaterHarvestingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    plantation?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: NullableStringFieldUpdateOperationsInput | string | null
    pollution?: NullableStringFieldUpdateOperationsInput | string | null
    pollutionMeasurementTaken?: NullableStringFieldUpdateOperationsInput | string | null
    waterSupplyWithin200Meters?: NullableStringFieldUpdateOperationsInput | string | null
    sewerageLineWithin100Meters?: NullableStringFieldUpdateOperationsInput | string | null
    disposalTypeId?: StringFieldUpdateOperationsInput | string
    totalPlotArea?: FloatFieldUpdateOperationsInput | number
    builtupAreaOfGroundFloor?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OtherDetailsCreateManyInput = {
    surveyUniqueCode: string
    waterSourceId: string
    rainWaterHarvestingSystem?: string | null
    plantation?: string | null
    parking?: string | null
    pollution?: string | null
    pollutionMeasurementTaken?: string | null
    waterSupplyWithin200Meters?: string | null
    sewerageLineWithin100Meters?: string | null
    disposalTypeId: string
    totalPlotArea: number
    builtupAreaOfGroundFloor: number
    remarks?: string | null
  }

  export type OtherDetailsUpdateManyMutationInput = {
    rainWaterHarvestingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    plantation?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: NullableStringFieldUpdateOperationsInput | string | null
    pollution?: NullableStringFieldUpdateOperationsInput | string | null
    pollutionMeasurementTaken?: NullableStringFieldUpdateOperationsInput | string | null
    waterSupplyWithin200Meters?: NullableStringFieldUpdateOperationsInput | string | null
    sewerageLineWithin100Meters?: NullableStringFieldUpdateOperationsInput | string | null
    totalPlotArea?: FloatFieldUpdateOperationsInput | number
    builtupAreaOfGroundFloor?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OtherDetailsUncheckedUpdateManyInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    waterSourceId?: StringFieldUpdateOperationsInput | string
    rainWaterHarvestingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    plantation?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: NullableStringFieldUpdateOperationsInput | string | null
    pollution?: NullableStringFieldUpdateOperationsInput | string | null
    pollutionMeasurementTaken?: NullableStringFieldUpdateOperationsInput | string | null
    waterSupplyWithin200Meters?: NullableStringFieldUpdateOperationsInput | string | null
    sewerageLineWithin100Meters?: NullableStringFieldUpdateOperationsInput | string | null
    disposalTypeId?: StringFieldUpdateOperationsInput | string
    totalPlotArea?: FloatFieldUpdateOperationsInput | number
    builtupAreaOfGroundFloor?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResidentialPropertyAssessmentCreateInput = {
    floorAssessmentId?: string
    floorNumber: string
    coveredArea: Decimal | DecimalJsLike | number | string
    allRoomVerandaArea: Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea: Decimal | DecimalJsLike | number | string
    allGarageArea: Decimal | DecimalJsLike | number | string
    carpetArea: Decimal | DecimalJsLike | number | string
    survey: SurveyDetailsCreateNestedOneWithoutResidentialPropertyAssessmentsInput
    occupancyStatus: OccupancyStatusMasterCreateNestedOneWithoutResidentialPropertyAssessmentsInput
    constructionNature: ConstructionNatureMasterCreateNestedOneWithoutResidentialPropertyAssessmentsInput
  }

  export type ResidentialPropertyAssessmentUncheckedCreateInput = {
    floorAssessmentId?: string
    surveyUniqueCode: string
    floorNumber: string
    occupancyStatusId: string
    constructionNatureId: string
    coveredArea: Decimal | DecimalJsLike | number | string
    allRoomVerandaArea: Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea: Decimal | DecimalJsLike | number | string
    allGarageArea: Decimal | DecimalJsLike | number | string
    carpetArea: Decimal | DecimalJsLike | number | string
  }

  export type ResidentialPropertyAssessmentUpdateInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    coveredArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allRoomVerandaArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allGarageArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carpetArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    survey?: SurveyDetailsUpdateOneRequiredWithoutResidentialPropertyAssessmentsNestedInput
    occupancyStatus?: OccupancyStatusMasterUpdateOneRequiredWithoutResidentialPropertyAssessmentsNestedInput
    constructionNature?: ConstructionNatureMasterUpdateOneRequiredWithoutResidentialPropertyAssessmentsNestedInput
  }

  export type ResidentialPropertyAssessmentUncheckedUpdateInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    coveredArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allRoomVerandaArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allGarageArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carpetArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ResidentialPropertyAssessmentCreateManyInput = {
    floorAssessmentId?: string
    surveyUniqueCode: string
    floorNumber: string
    occupancyStatusId: string
    constructionNatureId: string
    coveredArea: Decimal | DecimalJsLike | number | string
    allRoomVerandaArea: Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea: Decimal | DecimalJsLike | number | string
    allGarageArea: Decimal | DecimalJsLike | number | string
    carpetArea: Decimal | DecimalJsLike | number | string
  }

  export type ResidentialPropertyAssessmentUpdateManyMutationInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    coveredArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allRoomVerandaArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allGarageArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carpetArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ResidentialPropertyAssessmentUncheckedUpdateManyInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    coveredArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allRoomVerandaArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allGarageArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carpetArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentCreateInput = {
    floorAssessmentId?: string
    floorNumber: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    builtupArea: Decimal | DecimalJsLike | number | string
    nrPropertyCategory: NrPropertyCategoryMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    nrSubCategory: NrPropertySubCategoryMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    occupancyStatus: OccupancyStatusMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    constructionNature: ConstructionNatureMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    survey: SurveyDetailsCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
  }

  export type NonResidentialPropertyAssessmentUncheckedCreateInput = {
    floorAssessmentId?: string
    surveyUniqueCode: string
    floorNumber: string
    nrPropertyCategoryId: string
    nrSubCategoryId: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    occupancyStatusId: string
    constructionNatureId: string
    builtupArea: Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentUpdateInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nrPropertyCategory?: NrPropertyCategoryMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    nrSubCategory?: NrPropertySubCategoryMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    occupancyStatus?: OccupancyStatusMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    constructionNature?: ConstructionNatureMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    survey?: SurveyDetailsUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
  }

  export type NonResidentialPropertyAssessmentUncheckedUpdateInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    nrPropertyCategoryId?: StringFieldUpdateOperationsInput | string
    nrSubCategoryId?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentCreateManyInput = {
    floorAssessmentId?: string
    surveyUniqueCode: string
    floorNumber: string
    nrPropertyCategoryId: string
    nrSubCategoryId: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    occupancyStatusId: string
    constructionNatureId: string
    builtupArea: Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentUpdateManyMutationInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentUncheckedUpdateManyInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    nrPropertyCategoryId?: StringFieldUpdateOperationsInput | string
    nrSubCategoryId?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PropertyAttachmentDetailsCreateInput = {
    image1Url?: string | null
    image2Url?: string | null
    image3Url?: string | null
    image4Url?: string | null
    image5Url?: string | null
    image6Url?: string | null
    image7Url?: string | null
    image8Url?: string | null
    image9Url?: string | null
    image10Url?: string | null
    survey: SurveyDetailsCreateNestedOneWithoutPropertyAttachmentsInput
  }

  export type PropertyAttachmentDetailsUncheckedCreateInput = {
    surveyUniqueCode: string
    image1Url?: string | null
    image2Url?: string | null
    image3Url?: string | null
    image4Url?: string | null
    image5Url?: string | null
    image6Url?: string | null
    image7Url?: string | null
    image8Url?: string | null
    image9Url?: string | null
    image10Url?: string | null
  }

  export type PropertyAttachmentDetailsUpdateInput = {
    image1Url?: NullableStringFieldUpdateOperationsInput | string | null
    image2Url?: NullableStringFieldUpdateOperationsInput | string | null
    image3Url?: NullableStringFieldUpdateOperationsInput | string | null
    image4Url?: NullableStringFieldUpdateOperationsInput | string | null
    image5Url?: NullableStringFieldUpdateOperationsInput | string | null
    image6Url?: NullableStringFieldUpdateOperationsInput | string | null
    image7Url?: NullableStringFieldUpdateOperationsInput | string | null
    image8Url?: NullableStringFieldUpdateOperationsInput | string | null
    image9Url?: NullableStringFieldUpdateOperationsInput | string | null
    image10Url?: NullableStringFieldUpdateOperationsInput | string | null
    survey?: SurveyDetailsUpdateOneRequiredWithoutPropertyAttachmentsNestedInput
  }

  export type PropertyAttachmentDetailsUncheckedUpdateInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    image1Url?: NullableStringFieldUpdateOperationsInput | string | null
    image2Url?: NullableStringFieldUpdateOperationsInput | string | null
    image3Url?: NullableStringFieldUpdateOperationsInput | string | null
    image4Url?: NullableStringFieldUpdateOperationsInput | string | null
    image5Url?: NullableStringFieldUpdateOperationsInput | string | null
    image6Url?: NullableStringFieldUpdateOperationsInput | string | null
    image7Url?: NullableStringFieldUpdateOperationsInput | string | null
    image8Url?: NullableStringFieldUpdateOperationsInput | string | null
    image9Url?: NullableStringFieldUpdateOperationsInput | string | null
    image10Url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyAttachmentDetailsCreateManyInput = {
    surveyUniqueCode: string
    image1Url?: string | null
    image2Url?: string | null
    image3Url?: string | null
    image4Url?: string | null
    image5Url?: string | null
    image6Url?: string | null
    image7Url?: string | null
    image8Url?: string | null
    image9Url?: string | null
    image10Url?: string | null
  }

  export type PropertyAttachmentDetailsUpdateManyMutationInput = {
    image1Url?: NullableStringFieldUpdateOperationsInput | string | null
    image2Url?: NullableStringFieldUpdateOperationsInput | string | null
    image3Url?: NullableStringFieldUpdateOperationsInput | string | null
    image4Url?: NullableStringFieldUpdateOperationsInput | string | null
    image5Url?: NullableStringFieldUpdateOperationsInput | string | null
    image6Url?: NullableStringFieldUpdateOperationsInput | string | null
    image7Url?: NullableStringFieldUpdateOperationsInput | string | null
    image8Url?: NullableStringFieldUpdateOperationsInput | string | null
    image9Url?: NullableStringFieldUpdateOperationsInput | string | null
    image10Url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyAttachmentDetailsUncheckedUpdateManyInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    image1Url?: NullableStringFieldUpdateOperationsInput | string | null
    image2Url?: NullableStringFieldUpdateOperationsInput | string | null
    image3Url?: NullableStringFieldUpdateOperationsInput | string | null
    image4Url?: NullableStringFieldUpdateOperationsInput | string | null
    image5Url?: NullableStringFieldUpdateOperationsInput | string | null
    image6Url?: NullableStringFieldUpdateOperationsInput | string | null
    image7Url?: NullableStringFieldUpdateOperationsInput | string | null
    image8Url?: NullableStringFieldUpdateOperationsInput | string | null
    image9Url?: NullableStringFieldUpdateOperationsInput | string | null
    image10Url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UlbZoneMappingListRelationFilter = {
    every?: UlbZoneMappingWhereInput
    some?: UlbZoneMappingWhereInput
    none?: UlbZoneMappingWhereInput
  }

  export type SurveyDetailsListRelationFilter = {
    every?: SurveyDetailsWhereInput
    some?: SurveyDetailsWhereInput
    none?: SurveyDetailsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UlbZoneMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UlbMasterCountOrderByAggregateInput = {
    ulbId?: SortOrder
    ulbName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type UlbMasterMaxOrderByAggregateInput = {
    ulbId?: SortOrder
    ulbName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type UlbMasterMinOrderByAggregateInput = {
    ulbId?: SortOrder
    ulbName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ZoneWardMappingListRelationFilter = {
    every?: ZoneWardMappingWhereInput
    some?: ZoneWardMappingWhereInput
    none?: ZoneWardMappingWhereInput
  }

  export type ZoneWardMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZoneMasterCountOrderByAggregateInput = {
    zoneId?: SortOrder
    zoneNumber?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type ZoneMasterMaxOrderByAggregateInput = {
    zoneId?: SortOrder
    zoneNumber?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type ZoneMasterMinOrderByAggregateInput = {
    zoneId?: SortOrder
    zoneNumber?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type WardMohallaMappingListRelationFilter = {
    every?: WardMohallaMappingWhereInput
    some?: WardMohallaMappingWhereInput
    none?: WardMohallaMappingWhereInput
  }

  export type SurveyorAssignmentListRelationFilter = {
    every?: SurveyorAssignmentWhereInput
    some?: SurveyorAssignmentWhereInput
    none?: SurveyorAssignmentWhereInput
  }

  export type WardStatusMappingListRelationFilter = {
    every?: WardStatusMappingWhereInput
    some?: WardStatusMappingWhereInput
    none?: WardStatusMappingWhereInput
  }

  export type SupervisorsListRelationFilter = {
    every?: SupervisorsWhereInput
    some?: SupervisorsWhereInput
    none?: SupervisorsWhereInput
  }

  export type WardMohallaMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyorAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WardStatusMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupervisorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WardMasterCountOrderByAggregateInput = {
    wardId?: SortOrder
    wardNumber?: SortOrder
    isActive?: SortOrder
    wardName?: SortOrder
    description?: SortOrder
  }

  export type WardMasterMaxOrderByAggregateInput = {
    wardId?: SortOrder
    wardNumber?: SortOrder
    isActive?: SortOrder
    wardName?: SortOrder
    description?: SortOrder
  }

  export type WardMasterMinOrderByAggregateInput = {
    wardId?: SortOrder
    wardNumber?: SortOrder
    isActive?: SortOrder
    wardName?: SortOrder
    description?: SortOrder
  }

  export type MohallaMasterCountOrderByAggregateInput = {
    mohallaId?: SortOrder
    mohallaName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type MohallaMasterMaxOrderByAggregateInput = {
    mohallaId?: SortOrder
    mohallaName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type MohallaMasterMinOrderByAggregateInput = {
    mohallaId?: SortOrder
    mohallaName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type PropertyDetailsListRelationFilter = {
    every?: PropertyDetailsWhereInput
    some?: PropertyDetailsWhereInput
    none?: PropertyDetailsWhereInput
  }

  export type PropertyDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResponseTypeMasterCountOrderByAggregateInput = {
    responseTypeId?: SortOrder
    responseTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type ResponseTypeMasterMaxOrderByAggregateInput = {
    responseTypeId?: SortOrder
    responseTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type ResponseTypeMasterMinOrderByAggregateInput = {
    responseTypeId?: SortOrder
    responseTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type LocationDetailsListRelationFilter = {
    every?: LocationDetailsWhereInput
    some?: LocationDetailsWhereInput
    none?: LocationDetailsWhereInput
  }

  export type LocationDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyTypeMasterCountOrderByAggregateInput = {
    propertyTypeId?: SortOrder
    propertyTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type PropertyTypeMasterMaxOrderByAggregateInput = {
    propertyTypeId?: SortOrder
    propertyTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type PropertyTypeMasterMinOrderByAggregateInput = {
    propertyTypeId?: SortOrder
    propertyTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type RespondentStatusMasterCountOrderByAggregateInput = {
    respondentStatusId?: SortOrder
    respondentStatusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type RespondentStatusMasterMaxOrderByAggregateInput = {
    respondentStatusId?: SortOrder
    respondentStatusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type RespondentStatusMasterMinOrderByAggregateInput = {
    respondentStatusId?: SortOrder
    respondentStatusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type RoadTypeMasterCountOrderByAggregateInput = {
    roadTypeId?: SortOrder
    roadTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type RoadTypeMasterMaxOrderByAggregateInput = {
    roadTypeId?: SortOrder
    roadTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type RoadTypeMasterMinOrderByAggregateInput = {
    roadTypeId?: SortOrder
    roadTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type ConstructionTypeMasterCountOrderByAggregateInput = {
    constructionTypeId?: SortOrder
    constructionTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type ConstructionTypeMasterMaxOrderByAggregateInput = {
    constructionTypeId?: SortOrder
    constructionTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type ConstructionTypeMasterMinOrderByAggregateInput = {
    constructionTypeId?: SortOrder
    constructionTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type OtherDetailsListRelationFilter = {
    every?: OtherDetailsWhereInput
    some?: OtherDetailsWhereInput
    none?: OtherDetailsWhereInput
  }

  export type OtherDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WaterSourceMasterCountOrderByAggregateInput = {
    waterSourceId?: SortOrder
    waterSourceName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type WaterSourceMasterMaxOrderByAggregateInput = {
    waterSourceId?: SortOrder
    waterSourceName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type WaterSourceMasterMinOrderByAggregateInput = {
    waterSourceId?: SortOrder
    waterSourceName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type DisposalTypeMasterCountOrderByAggregateInput = {
    disposalTypeId?: SortOrder
    disposalTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type DisposalTypeMasterMaxOrderByAggregateInput = {
    disposalTypeId?: SortOrder
    disposalTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type DisposalTypeMasterMinOrderByAggregateInput = {
    disposalTypeId?: SortOrder
    disposalTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NrPropertySubCategoryMasterListRelationFilter = {
    every?: NrPropertySubCategoryMasterWhereInput
    some?: NrPropertySubCategoryMasterWhereInput
    none?: NrPropertySubCategoryMasterWhereInput
  }

  export type NonResidentialPropertyAssessmentListRelationFilter = {
    every?: NonResidentialPropertyAssessmentWhereInput
    some?: NonResidentialPropertyAssessmentWhereInput
    none?: NonResidentialPropertyAssessmentWhereInput
  }

  export type NrPropertySubCategoryMasterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NonResidentialPropertyAssessmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NrPropertyCategoryMasterCountOrderByAggregateInput = {
    propertyCategoryId?: SortOrder
    propertyCategoryNumber?: SortOrder
    propertyCategoryName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type NrPropertyCategoryMasterAvgOrderByAggregateInput = {
    propertyCategoryNumber?: SortOrder
  }

  export type NrPropertyCategoryMasterMaxOrderByAggregateInput = {
    propertyCategoryId?: SortOrder
    propertyCategoryNumber?: SortOrder
    propertyCategoryName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type NrPropertyCategoryMasterMinOrderByAggregateInput = {
    propertyCategoryId?: SortOrder
    propertyCategoryNumber?: SortOrder
    propertyCategoryName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type NrPropertyCategoryMasterSumOrderByAggregateInput = {
    propertyCategoryNumber?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NrPropertyCategoryMasterRelationFilter = {
    is?: NrPropertyCategoryMasterWhereInput
    isNot?: NrPropertyCategoryMasterWhereInput
  }

  export type NrPropertySubCategoryMasterCountOrderByAggregateInput = {
    subCategoryId?: SortOrder
    subCategoryNumber?: SortOrder
    subCategoryName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    propertyCategoryId?: SortOrder
  }

  export type NrPropertySubCategoryMasterAvgOrderByAggregateInput = {
    subCategoryNumber?: SortOrder
  }

  export type NrPropertySubCategoryMasterMaxOrderByAggregateInput = {
    subCategoryId?: SortOrder
    subCategoryNumber?: SortOrder
    subCategoryName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    propertyCategoryId?: SortOrder
  }

  export type NrPropertySubCategoryMasterMinOrderByAggregateInput = {
    subCategoryId?: SortOrder
    subCategoryNumber?: SortOrder
    subCategoryName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    propertyCategoryId?: SortOrder
  }

  export type NrPropertySubCategoryMasterSumOrderByAggregateInput = {
    subCategoryNumber?: SortOrder
  }

  export type ResidentialPropertyAssessmentListRelationFilter = {
    every?: ResidentialPropertyAssessmentWhereInput
    some?: ResidentialPropertyAssessmentWhereInput
    none?: ResidentialPropertyAssessmentWhereInput
  }

  export type ResidentialPropertyAssessmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConstructionNatureMasterCountOrderByAggregateInput = {
    constructionNatureId?: SortOrder
    constructionNatureName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type ConstructionNatureMasterMaxOrderByAggregateInput = {
    constructionNatureId?: SortOrder
    constructionNatureName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type ConstructionNatureMasterMinOrderByAggregateInput = {
    constructionNatureId?: SortOrder
    constructionNatureName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type SurveyTypeMasterCountOrderByAggregateInput = {
    surveyTypeId?: SortOrder
    surveyTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type SurveyTypeMasterMaxOrderByAggregateInput = {
    surveyTypeId?: SortOrder
    surveyTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type SurveyTypeMasterMinOrderByAggregateInput = {
    surveyTypeId?: SortOrder
    surveyTypeName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type OccupancyStatusMasterCountOrderByAggregateInput = {
    occupancyStatusId?: SortOrder
    occupancyStatusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type OccupancyStatusMasterMaxOrderByAggregateInput = {
    occupancyStatusId?: SortOrder
    occupancyStatusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type OccupancyStatusMasterMinOrderByAggregateInput = {
    occupancyStatusId?: SortOrder
    occupancyStatusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type SurveyStatusMappingListRelationFilter = {
    every?: SurveyStatusMappingWhereInput
    some?: SurveyStatusMappingWhereInput
    none?: SurveyStatusMappingWhereInput
  }

  export type SurveyStatusMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyStatusMasterCountOrderByAggregateInput = {
    statusId?: SortOrder
    statusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type SurveyStatusMasterMaxOrderByAggregateInput = {
    statusId?: SortOrder
    statusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type SurveyStatusMasterMinOrderByAggregateInput = {
    statusId?: SortOrder
    statusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type WardStatusMasterCountOrderByAggregateInput = {
    statusId?: SortOrder
    statusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type WardStatusMasterMaxOrderByAggregateInput = {
    statusId?: SortOrder
    statusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type WardStatusMasterMinOrderByAggregateInput = {
    statusId?: SortOrder
    statusName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type UserRoleMappingListRelationFilter = {
    every?: UserRoleMappingWhereInput
    some?: UserRoleMappingWhereInput
    none?: UserRoleMappingWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SurveyorsListRelationFilter = {
    every?: SurveyorsWhereInput
    some?: SurveyorsWhereInput
    none?: SurveyorsWhereInput
  }

  export type AdminsListRelationFilter = {
    every?: AdminsWhereInput
    some?: AdminsWhereInput
    none?: AdminsWhereInput
  }

  export type UserRoleMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersMasterCountOrderByAggregateInput = {
    userId?: SortOrder
    username?: SortOrder
    password?: SortOrder
    mobileNumber?: SortOrder
    isCreatedAt?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type UsersMasterMaxOrderByAggregateInput = {
    userId?: SortOrder
    username?: SortOrder
    password?: SortOrder
    mobileNumber?: SortOrder
    isCreatedAt?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type UsersMasterMinOrderByAggregateInput = {
    userId?: SortOrder
    username?: SortOrder
    password?: SortOrder
    mobileNumber?: SortOrder
    isCreatedAt?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type RolePermissionMasterCountOrderByAggregateInput = {
    roleId?: SortOrder
    roleName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type RolePermissionMasterMaxOrderByAggregateInput = {
    roleId?: SortOrder
    roleName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type RolePermissionMasterMinOrderByAggregateInput = {
    roleId?: SortOrder
    roleName?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type UlbMasterRelationFilter = {
    is?: UlbMasterWhereInput
    isNot?: UlbMasterWhereInput
  }

  export type ZoneMasterRelationFilter = {
    is?: ZoneMasterWhereInput
    isNot?: ZoneMasterWhereInput
  }

  export type UlbZoneMappingUlbIdZoneIdCompoundUniqueInput = {
    ulbId: string
    zoneId: string
  }

  export type UlbZoneMappingCountOrderByAggregateInput = {
    ulbZoneMapId?: SortOrder
    ulbId?: SortOrder
    zoneId?: SortOrder
    isActive?: SortOrder
  }

  export type UlbZoneMappingMaxOrderByAggregateInput = {
    ulbZoneMapId?: SortOrder
    ulbId?: SortOrder
    zoneId?: SortOrder
    isActive?: SortOrder
  }

  export type UlbZoneMappingMinOrderByAggregateInput = {
    ulbZoneMapId?: SortOrder
    ulbId?: SortOrder
    zoneId?: SortOrder
    isActive?: SortOrder
  }

  export type WardMasterRelationFilter = {
    is?: WardMasterWhereInput
    isNot?: WardMasterWhereInput
  }

  export type ZoneWardMappingZoneIdWardIdCompoundUniqueInput = {
    zoneId: string
    wardId: string
  }

  export type ZoneWardMappingCountOrderByAggregateInput = {
    zoneWardMapId?: SortOrder
    zoneId?: SortOrder
    wardId?: SortOrder
    isActive?: SortOrder
  }

  export type ZoneWardMappingMaxOrderByAggregateInput = {
    zoneWardMapId?: SortOrder
    zoneId?: SortOrder
    wardId?: SortOrder
    isActive?: SortOrder
  }

  export type ZoneWardMappingMinOrderByAggregateInput = {
    zoneWardMapId?: SortOrder
    zoneId?: SortOrder
    wardId?: SortOrder
    isActive?: SortOrder
  }

  export type MohallaMasterRelationFilter = {
    is?: MohallaMasterWhereInput
    isNot?: MohallaMasterWhereInput
  }

  export type WardMohallaMappingWardIdMohallaIdCompoundUniqueInput = {
    wardId: string
    mohallaId: string
  }

  export type WardMohallaMappingCountOrderByAggregateInput = {
    wardMohallaMapId?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    isActive?: SortOrder
  }

  export type WardMohallaMappingMaxOrderByAggregateInput = {
    wardMohallaMapId?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    isActive?: SortOrder
  }

  export type WardMohallaMappingMinOrderByAggregateInput = {
    wardMohallaMapId?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    isActive?: SortOrder
  }

  export type UsersMasterRelationFilter = {
    is?: UsersMasterWhereInput
    isNot?: UsersMasterWhereInput
  }

  export type WardMohallaMappingRelationFilter = {
    is?: WardMohallaMappingWhereInput
    isNot?: WardMohallaMappingWhereInput
  }

  export type SurveyorAssignmentUserIdWardIdMohallaIdCompoundUniqueInput = {
    userId: string
    wardId: string
    mohallaId: string
  }

  export type SurveyorAssignmentCountOrderByAggregateInput = {
    assignmentId?: SortOrder
    userId?: SortOrder
    assignmentType?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    wardMohallaMapId?: SortOrder
    assignedById?: SortOrder
    isActive?: SortOrder
  }

  export type SurveyorAssignmentMaxOrderByAggregateInput = {
    assignmentId?: SortOrder
    userId?: SortOrder
    assignmentType?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    wardMohallaMapId?: SortOrder
    assignedById?: SortOrder
    isActive?: SortOrder
  }

  export type SurveyorAssignmentMinOrderByAggregateInput = {
    assignmentId?: SortOrder
    userId?: SortOrder
    assignmentType?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    wardMohallaMapId?: SortOrder
    assignedById?: SortOrder
    isActive?: SortOrder
  }

  export type WardStatusMasterRelationFilter = {
    is?: WardStatusMasterWhereInput
    isNot?: WardStatusMasterWhereInput
  }

  export type WardStatusMappingWardIdStatusIdCompoundUniqueInput = {
    wardId: string
    statusId: string
  }

  export type WardStatusMappingCountOrderByAggregateInput = {
    wardStatusId?: SortOrder
    wardId?: SortOrder
    statusId?: SortOrder
    changedById?: SortOrder
    isActive?: SortOrder
  }

  export type WardStatusMappingMaxOrderByAggregateInput = {
    wardStatusId?: SortOrder
    wardId?: SortOrder
    statusId?: SortOrder
    changedById?: SortOrder
    isActive?: SortOrder
  }

  export type WardStatusMappingMinOrderByAggregateInput = {
    wardStatusId?: SortOrder
    wardId?: SortOrder
    statusId?: SortOrder
    changedById?: SortOrder
    isActive?: SortOrder
  }

  export type SurveyDetailsRelationFilter = {
    is?: SurveyDetailsWhereInput
    isNot?: SurveyDetailsWhereInput
  }

  export type SurveyStatusMasterRelationFilter = {
    is?: SurveyStatusMasterWhereInput
    isNot?: SurveyStatusMasterWhereInput
  }

  export type SurveyStatusMasterNullableRelationFilter = {
    is?: SurveyStatusMasterWhereInput | null
    isNot?: SurveyStatusMasterWhereInput | null
  }

  export type SurveyStatusMappingSurveyUniqueCodeStatusIdCompoundUniqueInput = {
    surveyUniqueCode: string
    statusId: string
  }

  export type SurveyStatusMappingCountOrderByAggregateInput = {
    statusMappingId?: SortOrder
    surveyUniqueCode?: SortOrder
    statusId?: SortOrder
    revertedFromId?: SortOrder
    changedById?: SortOrder
    isActive?: SortOrder
  }

  export type SurveyStatusMappingMaxOrderByAggregateInput = {
    statusMappingId?: SortOrder
    surveyUniqueCode?: SortOrder
    statusId?: SortOrder
    revertedFromId?: SortOrder
    changedById?: SortOrder
    isActive?: SortOrder
  }

  export type SurveyStatusMappingMinOrderByAggregateInput = {
    statusMappingId?: SortOrder
    surveyUniqueCode?: SortOrder
    statusId?: SortOrder
    revertedFromId?: SortOrder
    changedById?: SortOrder
    isActive?: SortOrder
  }

  export type RolePermissionMasterRelationFilter = {
    is?: RolePermissionMasterWhereInput
    isNot?: RolePermissionMasterWhereInput
  }

  export type UserRoleMappingUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: string
  }

  export type UserRoleMappingCountOrderByAggregateInput = {
    userRoleMapId?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
  }

  export type UserRoleMappingMaxOrderByAggregateInput = {
    userRoleMapId?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
  }

  export type UserRoleMappingMinOrderByAggregateInput = {
    userRoleMapId?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    sessionId?: SortOrder
    userId?: SortOrder
    loginTime?: SortOrder
    logoutTime?: SortOrder
    isActive?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    sessionId?: SortOrder
    userId?: SortOrder
    loginTime?: SortOrder
    logoutTime?: SortOrder
    isActive?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    sessionId?: SortOrder
    userId?: SortOrder
    loginTime?: SortOrder
    logoutTime?: SortOrder
    isActive?: SortOrder
  }

  export type ZoneWardMappingRelationFilter = {
    is?: ZoneWardMappingWhereInput
    isNot?: ZoneWardMappingWhereInput
  }

  export type UlbZoneMappingRelationFilter = {
    is?: UlbZoneMappingWhereInput
    isNot?: UlbZoneMappingWhereInput
  }

  export type SurveyorsCountOrderByAggregateInput = {
    userId?: SortOrder
    surveyorName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    wardNumber?: SortOrder
    wardMohallaMapId?: SortOrder
    zoneWardMapId?: SortOrder
    ulbZoneMapId?: SortOrder
  }

  export type SurveyorsMaxOrderByAggregateInput = {
    userId?: SortOrder
    surveyorName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    wardNumber?: SortOrder
    wardMohallaMapId?: SortOrder
    zoneWardMapId?: SortOrder
    ulbZoneMapId?: SortOrder
  }

  export type SurveyorsMinOrderByAggregateInput = {
    userId?: SortOrder
    surveyorName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    wardNumber?: SortOrder
    wardMohallaMapId?: SortOrder
    zoneWardMapId?: SortOrder
    ulbZoneMapId?: SortOrder
  }

  export type SupervisorsCountOrderByAggregateInput = {
    userId?: SortOrder
    supervisorName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    wardId?: SortOrder
  }

  export type SupervisorsMaxOrderByAggregateInput = {
    userId?: SortOrder
    supervisorName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    wardId?: SortOrder
  }

  export type SupervisorsMinOrderByAggregateInput = {
    userId?: SortOrder
    supervisorName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    wardId?: SortOrder
  }

  export type AdminsCountOrderByAggregateInput = {
    userId?: SortOrder
    adminName?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type AdminsMaxOrderByAggregateInput = {
    userId?: SortOrder
    adminName?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type AdminsMinOrderByAggregateInput = {
    userId?: SortOrder
    adminName?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SurveyTypeMasterRelationFilter = {
    is?: SurveyTypeMasterWhereInput
    isNot?: SurveyTypeMasterWhereInput
  }

  export type OwnerDetailsListRelationFilter = {
    every?: OwnerDetailsWhereInput
    some?: OwnerDetailsWhereInput
    none?: OwnerDetailsWhereInput
  }

  export type PropertyAttachmentDetailsListRelationFilter = {
    every?: PropertyAttachmentDetailsWhereInput
    some?: PropertyAttachmentDetailsWhereInput
    none?: PropertyAttachmentDetailsWhereInput
  }

  export type OwnerDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyAttachmentDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyDetailsCountOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    ulbId?: SortOrder
    zoneId?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    surveyTypeId?: SortOrder
    entryDate?: SortOrder
    parcelId?: SortOrder
    mapId?: SortOrder
    gisId?: SortOrder
    subGisId?: SortOrder
  }

  export type SurveyDetailsAvgOrderByAggregateInput = {
    parcelId?: SortOrder
    mapId?: SortOrder
  }

  export type SurveyDetailsMaxOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    ulbId?: SortOrder
    zoneId?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    surveyTypeId?: SortOrder
    entryDate?: SortOrder
    parcelId?: SortOrder
    mapId?: SortOrder
    gisId?: SortOrder
    subGisId?: SortOrder
  }

  export type SurveyDetailsMinOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    ulbId?: SortOrder
    zoneId?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    surveyTypeId?: SortOrder
    entryDate?: SortOrder
    parcelId?: SortOrder
    mapId?: SortOrder
    gisId?: SortOrder
    subGisId?: SortOrder
  }

  export type SurveyDetailsSumOrderByAggregateInput = {
    parcelId?: SortOrder
    mapId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ResponseTypeMasterRelationFilter = {
    is?: ResponseTypeMasterWhereInput
    isNot?: ResponseTypeMasterWhereInput
  }

  export type RespondentStatusMasterRelationFilter = {
    is?: RespondentStatusMasterWhereInput
    isNot?: RespondentStatusMasterWhereInput
  }

  export type PropertyDetailsCountOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    responseTypeId?: SortOrder
    oldHouseNumber?: SortOrder
    electricityConsumerName?: SortOrder
    waterSewerageConnectionNumber?: SortOrder
    respondentName?: SortOrder
    respondentStatusId?: SortOrder
  }

  export type PropertyDetailsMaxOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    responseTypeId?: SortOrder
    oldHouseNumber?: SortOrder
    electricityConsumerName?: SortOrder
    waterSewerageConnectionNumber?: SortOrder
    respondentName?: SortOrder
    respondentStatusId?: SortOrder
  }

  export type PropertyDetailsMinOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    responseTypeId?: SortOrder
    oldHouseNumber?: SortOrder
    electricityConsumerName?: SortOrder
    waterSewerageConnectionNumber?: SortOrder
    respondentName?: SortOrder
    respondentStatusId?: SortOrder
  }

  export type OwnerDetailsCountOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    ownerName?: SortOrder
    fatherHusbandName?: SortOrder
    mobileNumber?: SortOrder
    aadharNumber?: SortOrder
  }

  export type OwnerDetailsMaxOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    ownerName?: SortOrder
    fatherHusbandName?: SortOrder
    mobileNumber?: SortOrder
    aadharNumber?: SortOrder
  }

  export type OwnerDetailsMinOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    ownerName?: SortOrder
    fatherHusbandName?: SortOrder
    mobileNumber?: SortOrder
    aadharNumber?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type PropertyTypeMasterRelationFilter = {
    is?: PropertyTypeMasterWhereInput
    isNot?: PropertyTypeMasterWhereInput
  }

  export type RoadTypeMasterRelationFilter = {
    is?: RoadTypeMasterWhereInput
    isNot?: RoadTypeMasterWhereInput
  }

  export type ConstructionTypeMasterRelationFilter = {
    is?: ConstructionTypeMasterWhereInput
    isNot?: ConstructionTypeMasterWhereInput
  }

  export type LocationDetailsCountOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    propertyLatitude?: SortOrder
    propertyLongitude?: SortOrder
    assessmentYear?: SortOrder
    propertyTypeId?: SortOrder
    buildingName?: SortOrder
    roadTypeId?: SortOrder
    constructionYear?: SortOrder
    constructionTypeId?: SortOrder
    addressRoadName?: SortOrder
    locality?: SortOrder
    pinCode?: SortOrder
    landmark?: SortOrder
    fourWayEast?: SortOrder
    fourWayWest?: SortOrder
    fourWayNorth?: SortOrder
    fourWaySouth?: SortOrder
    newWard?: SortOrder
  }

  export type LocationDetailsAvgOrderByAggregateInput = {
    propertyLatitude?: SortOrder
    propertyLongitude?: SortOrder
    pinCode?: SortOrder
  }

  export type LocationDetailsMaxOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    propertyLatitude?: SortOrder
    propertyLongitude?: SortOrder
    assessmentYear?: SortOrder
    propertyTypeId?: SortOrder
    buildingName?: SortOrder
    roadTypeId?: SortOrder
    constructionYear?: SortOrder
    constructionTypeId?: SortOrder
    addressRoadName?: SortOrder
    locality?: SortOrder
    pinCode?: SortOrder
    landmark?: SortOrder
    fourWayEast?: SortOrder
    fourWayWest?: SortOrder
    fourWayNorth?: SortOrder
    fourWaySouth?: SortOrder
    newWard?: SortOrder
  }

  export type LocationDetailsMinOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    propertyLatitude?: SortOrder
    propertyLongitude?: SortOrder
    assessmentYear?: SortOrder
    propertyTypeId?: SortOrder
    buildingName?: SortOrder
    roadTypeId?: SortOrder
    constructionYear?: SortOrder
    constructionTypeId?: SortOrder
    addressRoadName?: SortOrder
    locality?: SortOrder
    pinCode?: SortOrder
    landmark?: SortOrder
    fourWayEast?: SortOrder
    fourWayWest?: SortOrder
    fourWayNorth?: SortOrder
    fourWaySouth?: SortOrder
    newWard?: SortOrder
  }

  export type LocationDetailsSumOrderByAggregateInput = {
    propertyLatitude?: SortOrder
    propertyLongitude?: SortOrder
    pinCode?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type WaterSourceMasterRelationFilter = {
    is?: WaterSourceMasterWhereInput
    isNot?: WaterSourceMasterWhereInput
  }

  export type DisposalTypeMasterRelationFilter = {
    is?: DisposalTypeMasterWhereInput
    isNot?: DisposalTypeMasterWhereInput
  }

  export type OtherDetailsCountOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    waterSourceId?: SortOrder
    rainWaterHarvestingSystem?: SortOrder
    plantation?: SortOrder
    parking?: SortOrder
    pollution?: SortOrder
    pollutionMeasurementTaken?: SortOrder
    waterSupplyWithin200Meters?: SortOrder
    sewerageLineWithin100Meters?: SortOrder
    disposalTypeId?: SortOrder
    totalPlotArea?: SortOrder
    builtupAreaOfGroundFloor?: SortOrder
    remarks?: SortOrder
  }

  export type OtherDetailsAvgOrderByAggregateInput = {
    totalPlotArea?: SortOrder
    builtupAreaOfGroundFloor?: SortOrder
  }

  export type OtherDetailsMaxOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    waterSourceId?: SortOrder
    rainWaterHarvestingSystem?: SortOrder
    plantation?: SortOrder
    parking?: SortOrder
    pollution?: SortOrder
    pollutionMeasurementTaken?: SortOrder
    waterSupplyWithin200Meters?: SortOrder
    sewerageLineWithin100Meters?: SortOrder
    disposalTypeId?: SortOrder
    totalPlotArea?: SortOrder
    builtupAreaOfGroundFloor?: SortOrder
    remarks?: SortOrder
  }

  export type OtherDetailsMinOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    waterSourceId?: SortOrder
    rainWaterHarvestingSystem?: SortOrder
    plantation?: SortOrder
    parking?: SortOrder
    pollution?: SortOrder
    pollutionMeasurementTaken?: SortOrder
    waterSupplyWithin200Meters?: SortOrder
    sewerageLineWithin100Meters?: SortOrder
    disposalTypeId?: SortOrder
    totalPlotArea?: SortOrder
    builtupAreaOfGroundFloor?: SortOrder
    remarks?: SortOrder
  }

  export type OtherDetailsSumOrderByAggregateInput = {
    totalPlotArea?: SortOrder
    builtupAreaOfGroundFloor?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type OccupancyStatusMasterRelationFilter = {
    is?: OccupancyStatusMasterWhereInput
    isNot?: OccupancyStatusMasterWhereInput
  }

  export type ConstructionNatureMasterRelationFilter = {
    is?: ConstructionNatureMasterWhereInput
    isNot?: ConstructionNatureMasterWhereInput
  }

  export type ResidentialPropertyAssessmentCountOrderByAggregateInput = {
    floorAssessmentId?: SortOrder
    surveyUniqueCode?: SortOrder
    floorNumber?: SortOrder
    occupancyStatusId?: SortOrder
    constructionNatureId?: SortOrder
    coveredArea?: SortOrder
    allRoomVerandaArea?: SortOrder
    allBalconyKitchenArea?: SortOrder
    allGarageArea?: SortOrder
    carpetArea?: SortOrder
  }

  export type ResidentialPropertyAssessmentAvgOrderByAggregateInput = {
    coveredArea?: SortOrder
    allRoomVerandaArea?: SortOrder
    allBalconyKitchenArea?: SortOrder
    allGarageArea?: SortOrder
    carpetArea?: SortOrder
  }

  export type ResidentialPropertyAssessmentMaxOrderByAggregateInput = {
    floorAssessmentId?: SortOrder
    surveyUniqueCode?: SortOrder
    floorNumber?: SortOrder
    occupancyStatusId?: SortOrder
    constructionNatureId?: SortOrder
    coveredArea?: SortOrder
    allRoomVerandaArea?: SortOrder
    allBalconyKitchenArea?: SortOrder
    allGarageArea?: SortOrder
    carpetArea?: SortOrder
  }

  export type ResidentialPropertyAssessmentMinOrderByAggregateInput = {
    floorAssessmentId?: SortOrder
    surveyUniqueCode?: SortOrder
    floorNumber?: SortOrder
    occupancyStatusId?: SortOrder
    constructionNatureId?: SortOrder
    coveredArea?: SortOrder
    allRoomVerandaArea?: SortOrder
    allBalconyKitchenArea?: SortOrder
    allGarageArea?: SortOrder
    carpetArea?: SortOrder
  }

  export type ResidentialPropertyAssessmentSumOrderByAggregateInput = {
    coveredArea?: SortOrder
    allRoomVerandaArea?: SortOrder
    allBalconyKitchenArea?: SortOrder
    allGarageArea?: SortOrder
    carpetArea?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NrPropertySubCategoryMasterRelationFilter = {
    is?: NrPropertySubCategoryMasterWhereInput
    isNot?: NrPropertySubCategoryMasterWhereInput
  }

  export type NonResidentialPropertyAssessmentCountOrderByAggregateInput = {
    floorAssessmentId?: SortOrder
    surveyUniqueCode?: SortOrder
    floorNumber?: SortOrder
    nrPropertyCategoryId?: SortOrder
    nrSubCategoryId?: SortOrder
    establishmentName?: SortOrder
    licenseNo?: SortOrder
    licenseExpiryDate?: SortOrder
    occupancyStatusId?: SortOrder
    constructionNatureId?: SortOrder
    builtupArea?: SortOrder
  }

  export type NonResidentialPropertyAssessmentAvgOrderByAggregateInput = {
    builtupArea?: SortOrder
  }

  export type NonResidentialPropertyAssessmentMaxOrderByAggregateInput = {
    floorAssessmentId?: SortOrder
    surveyUniqueCode?: SortOrder
    floorNumber?: SortOrder
    nrPropertyCategoryId?: SortOrder
    nrSubCategoryId?: SortOrder
    establishmentName?: SortOrder
    licenseNo?: SortOrder
    licenseExpiryDate?: SortOrder
    occupancyStatusId?: SortOrder
    constructionNatureId?: SortOrder
    builtupArea?: SortOrder
  }

  export type NonResidentialPropertyAssessmentMinOrderByAggregateInput = {
    floorAssessmentId?: SortOrder
    surveyUniqueCode?: SortOrder
    floorNumber?: SortOrder
    nrPropertyCategoryId?: SortOrder
    nrSubCategoryId?: SortOrder
    establishmentName?: SortOrder
    licenseNo?: SortOrder
    licenseExpiryDate?: SortOrder
    occupancyStatusId?: SortOrder
    constructionNatureId?: SortOrder
    builtupArea?: SortOrder
  }

  export type NonResidentialPropertyAssessmentSumOrderByAggregateInput = {
    builtupArea?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PropertyAttachmentDetailsCountOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    image1Url?: SortOrder
    image2Url?: SortOrder
    image3Url?: SortOrder
    image4Url?: SortOrder
    image5Url?: SortOrder
    image6Url?: SortOrder
    image7Url?: SortOrder
    image8Url?: SortOrder
    image9Url?: SortOrder
    image10Url?: SortOrder
  }

  export type PropertyAttachmentDetailsMaxOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    image1Url?: SortOrder
    image2Url?: SortOrder
    image3Url?: SortOrder
    image4Url?: SortOrder
    image5Url?: SortOrder
    image6Url?: SortOrder
    image7Url?: SortOrder
    image8Url?: SortOrder
    image9Url?: SortOrder
    image10Url?: SortOrder
  }

  export type PropertyAttachmentDetailsMinOrderByAggregateInput = {
    surveyUniqueCode?: SortOrder
    image1Url?: SortOrder
    image2Url?: SortOrder
    image3Url?: SortOrder
    image4Url?: SortOrder
    image5Url?: SortOrder
    image6Url?: SortOrder
    image7Url?: SortOrder
    image8Url?: SortOrder
    image9Url?: SortOrder
    image10Url?: SortOrder
  }

  export type UlbZoneMappingCreateNestedManyWithoutUlbInput = {
    create?: XOR<UlbZoneMappingCreateWithoutUlbInput, UlbZoneMappingUncheckedCreateWithoutUlbInput> | UlbZoneMappingCreateWithoutUlbInput[] | UlbZoneMappingUncheckedCreateWithoutUlbInput[]
    connectOrCreate?: UlbZoneMappingCreateOrConnectWithoutUlbInput | UlbZoneMappingCreateOrConnectWithoutUlbInput[]
    createMany?: UlbZoneMappingCreateManyUlbInputEnvelope
    connect?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
  }

  export type SurveyDetailsCreateNestedManyWithoutUlbInput = {
    create?: XOR<SurveyDetailsCreateWithoutUlbInput, SurveyDetailsUncheckedCreateWithoutUlbInput> | SurveyDetailsCreateWithoutUlbInput[] | SurveyDetailsUncheckedCreateWithoutUlbInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutUlbInput | SurveyDetailsCreateOrConnectWithoutUlbInput[]
    createMany?: SurveyDetailsCreateManyUlbInputEnvelope
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
  }

  export type UlbZoneMappingUncheckedCreateNestedManyWithoutUlbInput = {
    create?: XOR<UlbZoneMappingCreateWithoutUlbInput, UlbZoneMappingUncheckedCreateWithoutUlbInput> | UlbZoneMappingCreateWithoutUlbInput[] | UlbZoneMappingUncheckedCreateWithoutUlbInput[]
    connectOrCreate?: UlbZoneMappingCreateOrConnectWithoutUlbInput | UlbZoneMappingCreateOrConnectWithoutUlbInput[]
    createMany?: UlbZoneMappingCreateManyUlbInputEnvelope
    connect?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
  }

  export type SurveyDetailsUncheckedCreateNestedManyWithoutUlbInput = {
    create?: XOR<SurveyDetailsCreateWithoutUlbInput, SurveyDetailsUncheckedCreateWithoutUlbInput> | SurveyDetailsCreateWithoutUlbInput[] | SurveyDetailsUncheckedCreateWithoutUlbInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutUlbInput | SurveyDetailsCreateOrConnectWithoutUlbInput[]
    createMany?: SurveyDetailsCreateManyUlbInputEnvelope
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UlbZoneMappingUpdateManyWithoutUlbNestedInput = {
    create?: XOR<UlbZoneMappingCreateWithoutUlbInput, UlbZoneMappingUncheckedCreateWithoutUlbInput> | UlbZoneMappingCreateWithoutUlbInput[] | UlbZoneMappingUncheckedCreateWithoutUlbInput[]
    connectOrCreate?: UlbZoneMappingCreateOrConnectWithoutUlbInput | UlbZoneMappingCreateOrConnectWithoutUlbInput[]
    upsert?: UlbZoneMappingUpsertWithWhereUniqueWithoutUlbInput | UlbZoneMappingUpsertWithWhereUniqueWithoutUlbInput[]
    createMany?: UlbZoneMappingCreateManyUlbInputEnvelope
    set?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
    disconnect?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
    delete?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
    connect?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
    update?: UlbZoneMappingUpdateWithWhereUniqueWithoutUlbInput | UlbZoneMappingUpdateWithWhereUniqueWithoutUlbInput[]
    updateMany?: UlbZoneMappingUpdateManyWithWhereWithoutUlbInput | UlbZoneMappingUpdateManyWithWhereWithoutUlbInput[]
    deleteMany?: UlbZoneMappingScalarWhereInput | UlbZoneMappingScalarWhereInput[]
  }

  export type SurveyDetailsUpdateManyWithoutUlbNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutUlbInput, SurveyDetailsUncheckedCreateWithoutUlbInput> | SurveyDetailsCreateWithoutUlbInput[] | SurveyDetailsUncheckedCreateWithoutUlbInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutUlbInput | SurveyDetailsCreateOrConnectWithoutUlbInput[]
    upsert?: SurveyDetailsUpsertWithWhereUniqueWithoutUlbInput | SurveyDetailsUpsertWithWhereUniqueWithoutUlbInput[]
    createMany?: SurveyDetailsCreateManyUlbInputEnvelope
    set?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    disconnect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    delete?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    update?: SurveyDetailsUpdateWithWhereUniqueWithoutUlbInput | SurveyDetailsUpdateWithWhereUniqueWithoutUlbInput[]
    updateMany?: SurveyDetailsUpdateManyWithWhereWithoutUlbInput | SurveyDetailsUpdateManyWithWhereWithoutUlbInput[]
    deleteMany?: SurveyDetailsScalarWhereInput | SurveyDetailsScalarWhereInput[]
  }

  export type UlbZoneMappingUncheckedUpdateManyWithoutUlbNestedInput = {
    create?: XOR<UlbZoneMappingCreateWithoutUlbInput, UlbZoneMappingUncheckedCreateWithoutUlbInput> | UlbZoneMappingCreateWithoutUlbInput[] | UlbZoneMappingUncheckedCreateWithoutUlbInput[]
    connectOrCreate?: UlbZoneMappingCreateOrConnectWithoutUlbInput | UlbZoneMappingCreateOrConnectWithoutUlbInput[]
    upsert?: UlbZoneMappingUpsertWithWhereUniqueWithoutUlbInput | UlbZoneMappingUpsertWithWhereUniqueWithoutUlbInput[]
    createMany?: UlbZoneMappingCreateManyUlbInputEnvelope
    set?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
    disconnect?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
    delete?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
    connect?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
    update?: UlbZoneMappingUpdateWithWhereUniqueWithoutUlbInput | UlbZoneMappingUpdateWithWhereUniqueWithoutUlbInput[]
    updateMany?: UlbZoneMappingUpdateManyWithWhereWithoutUlbInput | UlbZoneMappingUpdateManyWithWhereWithoutUlbInput[]
    deleteMany?: UlbZoneMappingScalarWhereInput | UlbZoneMappingScalarWhereInput[]
  }

  export type SurveyDetailsUncheckedUpdateManyWithoutUlbNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutUlbInput, SurveyDetailsUncheckedCreateWithoutUlbInput> | SurveyDetailsCreateWithoutUlbInput[] | SurveyDetailsUncheckedCreateWithoutUlbInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutUlbInput | SurveyDetailsCreateOrConnectWithoutUlbInput[]
    upsert?: SurveyDetailsUpsertWithWhereUniqueWithoutUlbInput | SurveyDetailsUpsertWithWhereUniqueWithoutUlbInput[]
    createMany?: SurveyDetailsCreateManyUlbInputEnvelope
    set?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    disconnect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    delete?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    update?: SurveyDetailsUpdateWithWhereUniqueWithoutUlbInput | SurveyDetailsUpdateWithWhereUniqueWithoutUlbInput[]
    updateMany?: SurveyDetailsUpdateManyWithWhereWithoutUlbInput | SurveyDetailsUpdateManyWithWhereWithoutUlbInput[]
    deleteMany?: SurveyDetailsScalarWhereInput | SurveyDetailsScalarWhereInput[]
  }

  export type UlbZoneMappingCreateNestedManyWithoutZoneInput = {
    create?: XOR<UlbZoneMappingCreateWithoutZoneInput, UlbZoneMappingUncheckedCreateWithoutZoneInput> | UlbZoneMappingCreateWithoutZoneInput[] | UlbZoneMappingUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: UlbZoneMappingCreateOrConnectWithoutZoneInput | UlbZoneMappingCreateOrConnectWithoutZoneInput[]
    createMany?: UlbZoneMappingCreateManyZoneInputEnvelope
    connect?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
  }

  export type ZoneWardMappingCreateNestedManyWithoutZoneInput = {
    create?: XOR<ZoneWardMappingCreateWithoutZoneInput, ZoneWardMappingUncheckedCreateWithoutZoneInput> | ZoneWardMappingCreateWithoutZoneInput[] | ZoneWardMappingUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ZoneWardMappingCreateOrConnectWithoutZoneInput | ZoneWardMappingCreateOrConnectWithoutZoneInput[]
    createMany?: ZoneWardMappingCreateManyZoneInputEnvelope
    connect?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
  }

  export type SurveyDetailsCreateNestedManyWithoutZoneInput = {
    create?: XOR<SurveyDetailsCreateWithoutZoneInput, SurveyDetailsUncheckedCreateWithoutZoneInput> | SurveyDetailsCreateWithoutZoneInput[] | SurveyDetailsUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutZoneInput | SurveyDetailsCreateOrConnectWithoutZoneInput[]
    createMany?: SurveyDetailsCreateManyZoneInputEnvelope
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
  }

  export type UlbZoneMappingUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<UlbZoneMappingCreateWithoutZoneInput, UlbZoneMappingUncheckedCreateWithoutZoneInput> | UlbZoneMappingCreateWithoutZoneInput[] | UlbZoneMappingUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: UlbZoneMappingCreateOrConnectWithoutZoneInput | UlbZoneMappingCreateOrConnectWithoutZoneInput[]
    createMany?: UlbZoneMappingCreateManyZoneInputEnvelope
    connect?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
  }

  export type ZoneWardMappingUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<ZoneWardMappingCreateWithoutZoneInput, ZoneWardMappingUncheckedCreateWithoutZoneInput> | ZoneWardMappingCreateWithoutZoneInput[] | ZoneWardMappingUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ZoneWardMappingCreateOrConnectWithoutZoneInput | ZoneWardMappingCreateOrConnectWithoutZoneInput[]
    createMany?: ZoneWardMappingCreateManyZoneInputEnvelope
    connect?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
  }

  export type SurveyDetailsUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<SurveyDetailsCreateWithoutZoneInput, SurveyDetailsUncheckedCreateWithoutZoneInput> | SurveyDetailsCreateWithoutZoneInput[] | SurveyDetailsUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutZoneInput | SurveyDetailsCreateOrConnectWithoutZoneInput[]
    createMany?: SurveyDetailsCreateManyZoneInputEnvelope
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
  }

  export type UlbZoneMappingUpdateManyWithoutZoneNestedInput = {
    create?: XOR<UlbZoneMappingCreateWithoutZoneInput, UlbZoneMappingUncheckedCreateWithoutZoneInput> | UlbZoneMappingCreateWithoutZoneInput[] | UlbZoneMappingUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: UlbZoneMappingCreateOrConnectWithoutZoneInput | UlbZoneMappingCreateOrConnectWithoutZoneInput[]
    upsert?: UlbZoneMappingUpsertWithWhereUniqueWithoutZoneInput | UlbZoneMappingUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: UlbZoneMappingCreateManyZoneInputEnvelope
    set?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
    disconnect?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
    delete?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
    connect?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
    update?: UlbZoneMappingUpdateWithWhereUniqueWithoutZoneInput | UlbZoneMappingUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: UlbZoneMappingUpdateManyWithWhereWithoutZoneInput | UlbZoneMappingUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: UlbZoneMappingScalarWhereInput | UlbZoneMappingScalarWhereInput[]
  }

  export type ZoneWardMappingUpdateManyWithoutZoneNestedInput = {
    create?: XOR<ZoneWardMappingCreateWithoutZoneInput, ZoneWardMappingUncheckedCreateWithoutZoneInput> | ZoneWardMappingCreateWithoutZoneInput[] | ZoneWardMappingUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ZoneWardMappingCreateOrConnectWithoutZoneInput | ZoneWardMappingCreateOrConnectWithoutZoneInput[]
    upsert?: ZoneWardMappingUpsertWithWhereUniqueWithoutZoneInput | ZoneWardMappingUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: ZoneWardMappingCreateManyZoneInputEnvelope
    set?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
    disconnect?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
    delete?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
    connect?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
    update?: ZoneWardMappingUpdateWithWhereUniqueWithoutZoneInput | ZoneWardMappingUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: ZoneWardMappingUpdateManyWithWhereWithoutZoneInput | ZoneWardMappingUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: ZoneWardMappingScalarWhereInput | ZoneWardMappingScalarWhereInput[]
  }

  export type SurveyDetailsUpdateManyWithoutZoneNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutZoneInput, SurveyDetailsUncheckedCreateWithoutZoneInput> | SurveyDetailsCreateWithoutZoneInput[] | SurveyDetailsUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutZoneInput | SurveyDetailsCreateOrConnectWithoutZoneInput[]
    upsert?: SurveyDetailsUpsertWithWhereUniqueWithoutZoneInput | SurveyDetailsUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: SurveyDetailsCreateManyZoneInputEnvelope
    set?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    disconnect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    delete?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    update?: SurveyDetailsUpdateWithWhereUniqueWithoutZoneInput | SurveyDetailsUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: SurveyDetailsUpdateManyWithWhereWithoutZoneInput | SurveyDetailsUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: SurveyDetailsScalarWhereInput | SurveyDetailsScalarWhereInput[]
  }

  export type UlbZoneMappingUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<UlbZoneMappingCreateWithoutZoneInput, UlbZoneMappingUncheckedCreateWithoutZoneInput> | UlbZoneMappingCreateWithoutZoneInput[] | UlbZoneMappingUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: UlbZoneMappingCreateOrConnectWithoutZoneInput | UlbZoneMappingCreateOrConnectWithoutZoneInput[]
    upsert?: UlbZoneMappingUpsertWithWhereUniqueWithoutZoneInput | UlbZoneMappingUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: UlbZoneMappingCreateManyZoneInputEnvelope
    set?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
    disconnect?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
    delete?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
    connect?: UlbZoneMappingWhereUniqueInput | UlbZoneMappingWhereUniqueInput[]
    update?: UlbZoneMappingUpdateWithWhereUniqueWithoutZoneInput | UlbZoneMappingUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: UlbZoneMappingUpdateManyWithWhereWithoutZoneInput | UlbZoneMappingUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: UlbZoneMappingScalarWhereInput | UlbZoneMappingScalarWhereInput[]
  }

  export type ZoneWardMappingUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<ZoneWardMappingCreateWithoutZoneInput, ZoneWardMappingUncheckedCreateWithoutZoneInput> | ZoneWardMappingCreateWithoutZoneInput[] | ZoneWardMappingUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ZoneWardMappingCreateOrConnectWithoutZoneInput | ZoneWardMappingCreateOrConnectWithoutZoneInput[]
    upsert?: ZoneWardMappingUpsertWithWhereUniqueWithoutZoneInput | ZoneWardMappingUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: ZoneWardMappingCreateManyZoneInputEnvelope
    set?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
    disconnect?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
    delete?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
    connect?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
    update?: ZoneWardMappingUpdateWithWhereUniqueWithoutZoneInput | ZoneWardMappingUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: ZoneWardMappingUpdateManyWithWhereWithoutZoneInput | ZoneWardMappingUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: ZoneWardMappingScalarWhereInput | ZoneWardMappingScalarWhereInput[]
  }

  export type SurveyDetailsUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutZoneInput, SurveyDetailsUncheckedCreateWithoutZoneInput> | SurveyDetailsCreateWithoutZoneInput[] | SurveyDetailsUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutZoneInput | SurveyDetailsCreateOrConnectWithoutZoneInput[]
    upsert?: SurveyDetailsUpsertWithWhereUniqueWithoutZoneInput | SurveyDetailsUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: SurveyDetailsCreateManyZoneInputEnvelope
    set?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    disconnect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    delete?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    update?: SurveyDetailsUpdateWithWhereUniqueWithoutZoneInput | SurveyDetailsUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: SurveyDetailsUpdateManyWithWhereWithoutZoneInput | SurveyDetailsUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: SurveyDetailsScalarWhereInput | SurveyDetailsScalarWhereInput[]
  }

  export type ZoneWardMappingCreateNestedManyWithoutWardInput = {
    create?: XOR<ZoneWardMappingCreateWithoutWardInput, ZoneWardMappingUncheckedCreateWithoutWardInput> | ZoneWardMappingCreateWithoutWardInput[] | ZoneWardMappingUncheckedCreateWithoutWardInput[]
    connectOrCreate?: ZoneWardMappingCreateOrConnectWithoutWardInput | ZoneWardMappingCreateOrConnectWithoutWardInput[]
    createMany?: ZoneWardMappingCreateManyWardInputEnvelope
    connect?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
  }

  export type WardMohallaMappingCreateNestedManyWithoutWardInput = {
    create?: XOR<WardMohallaMappingCreateWithoutWardInput, WardMohallaMappingUncheckedCreateWithoutWardInput> | WardMohallaMappingCreateWithoutWardInput[] | WardMohallaMappingUncheckedCreateWithoutWardInput[]
    connectOrCreate?: WardMohallaMappingCreateOrConnectWithoutWardInput | WardMohallaMappingCreateOrConnectWithoutWardInput[]
    createMany?: WardMohallaMappingCreateManyWardInputEnvelope
    connect?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
  }

  export type SurveyorAssignmentCreateNestedManyWithoutWardInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutWardInput, SurveyorAssignmentUncheckedCreateWithoutWardInput> | SurveyorAssignmentCreateWithoutWardInput[] | SurveyorAssignmentUncheckedCreateWithoutWardInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutWardInput | SurveyorAssignmentCreateOrConnectWithoutWardInput[]
    createMany?: SurveyorAssignmentCreateManyWardInputEnvelope
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
  }

  export type WardStatusMappingCreateNestedManyWithoutWardInput = {
    create?: XOR<WardStatusMappingCreateWithoutWardInput, WardStatusMappingUncheckedCreateWithoutWardInput> | WardStatusMappingCreateWithoutWardInput[] | WardStatusMappingUncheckedCreateWithoutWardInput[]
    connectOrCreate?: WardStatusMappingCreateOrConnectWithoutWardInput | WardStatusMappingCreateOrConnectWithoutWardInput[]
    createMany?: WardStatusMappingCreateManyWardInputEnvelope
    connect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
  }

  export type SurveyDetailsCreateNestedManyWithoutWardInput = {
    create?: XOR<SurveyDetailsCreateWithoutWardInput, SurveyDetailsUncheckedCreateWithoutWardInput> | SurveyDetailsCreateWithoutWardInput[] | SurveyDetailsUncheckedCreateWithoutWardInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutWardInput | SurveyDetailsCreateOrConnectWithoutWardInput[]
    createMany?: SurveyDetailsCreateManyWardInputEnvelope
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
  }

  export type SupervisorsCreateNestedManyWithoutWardInput = {
    create?: XOR<SupervisorsCreateWithoutWardInput, SupervisorsUncheckedCreateWithoutWardInput> | SupervisorsCreateWithoutWardInput[] | SupervisorsUncheckedCreateWithoutWardInput[]
    connectOrCreate?: SupervisorsCreateOrConnectWithoutWardInput | SupervisorsCreateOrConnectWithoutWardInput[]
    createMany?: SupervisorsCreateManyWardInputEnvelope
    connect?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
  }

  export type ZoneWardMappingUncheckedCreateNestedManyWithoutWardInput = {
    create?: XOR<ZoneWardMappingCreateWithoutWardInput, ZoneWardMappingUncheckedCreateWithoutWardInput> | ZoneWardMappingCreateWithoutWardInput[] | ZoneWardMappingUncheckedCreateWithoutWardInput[]
    connectOrCreate?: ZoneWardMappingCreateOrConnectWithoutWardInput | ZoneWardMappingCreateOrConnectWithoutWardInput[]
    createMany?: ZoneWardMappingCreateManyWardInputEnvelope
    connect?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
  }

  export type WardMohallaMappingUncheckedCreateNestedManyWithoutWardInput = {
    create?: XOR<WardMohallaMappingCreateWithoutWardInput, WardMohallaMappingUncheckedCreateWithoutWardInput> | WardMohallaMappingCreateWithoutWardInput[] | WardMohallaMappingUncheckedCreateWithoutWardInput[]
    connectOrCreate?: WardMohallaMappingCreateOrConnectWithoutWardInput | WardMohallaMappingCreateOrConnectWithoutWardInput[]
    createMany?: WardMohallaMappingCreateManyWardInputEnvelope
    connect?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
  }

  export type SurveyorAssignmentUncheckedCreateNestedManyWithoutWardInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutWardInput, SurveyorAssignmentUncheckedCreateWithoutWardInput> | SurveyorAssignmentCreateWithoutWardInput[] | SurveyorAssignmentUncheckedCreateWithoutWardInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutWardInput | SurveyorAssignmentCreateOrConnectWithoutWardInput[]
    createMany?: SurveyorAssignmentCreateManyWardInputEnvelope
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
  }

  export type WardStatusMappingUncheckedCreateNestedManyWithoutWardInput = {
    create?: XOR<WardStatusMappingCreateWithoutWardInput, WardStatusMappingUncheckedCreateWithoutWardInput> | WardStatusMappingCreateWithoutWardInput[] | WardStatusMappingUncheckedCreateWithoutWardInput[]
    connectOrCreate?: WardStatusMappingCreateOrConnectWithoutWardInput | WardStatusMappingCreateOrConnectWithoutWardInput[]
    createMany?: WardStatusMappingCreateManyWardInputEnvelope
    connect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
  }

  export type SurveyDetailsUncheckedCreateNestedManyWithoutWardInput = {
    create?: XOR<SurveyDetailsCreateWithoutWardInput, SurveyDetailsUncheckedCreateWithoutWardInput> | SurveyDetailsCreateWithoutWardInput[] | SurveyDetailsUncheckedCreateWithoutWardInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutWardInput | SurveyDetailsCreateOrConnectWithoutWardInput[]
    createMany?: SurveyDetailsCreateManyWardInputEnvelope
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
  }

  export type SupervisorsUncheckedCreateNestedManyWithoutWardInput = {
    create?: XOR<SupervisorsCreateWithoutWardInput, SupervisorsUncheckedCreateWithoutWardInput> | SupervisorsCreateWithoutWardInput[] | SupervisorsUncheckedCreateWithoutWardInput[]
    connectOrCreate?: SupervisorsCreateOrConnectWithoutWardInput | SupervisorsCreateOrConnectWithoutWardInput[]
    createMany?: SupervisorsCreateManyWardInputEnvelope
    connect?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
  }

  export type ZoneWardMappingUpdateManyWithoutWardNestedInput = {
    create?: XOR<ZoneWardMappingCreateWithoutWardInput, ZoneWardMappingUncheckedCreateWithoutWardInput> | ZoneWardMappingCreateWithoutWardInput[] | ZoneWardMappingUncheckedCreateWithoutWardInput[]
    connectOrCreate?: ZoneWardMappingCreateOrConnectWithoutWardInput | ZoneWardMappingCreateOrConnectWithoutWardInput[]
    upsert?: ZoneWardMappingUpsertWithWhereUniqueWithoutWardInput | ZoneWardMappingUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: ZoneWardMappingCreateManyWardInputEnvelope
    set?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
    disconnect?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
    delete?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
    connect?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
    update?: ZoneWardMappingUpdateWithWhereUniqueWithoutWardInput | ZoneWardMappingUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: ZoneWardMappingUpdateManyWithWhereWithoutWardInput | ZoneWardMappingUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: ZoneWardMappingScalarWhereInput | ZoneWardMappingScalarWhereInput[]
  }

  export type WardMohallaMappingUpdateManyWithoutWardNestedInput = {
    create?: XOR<WardMohallaMappingCreateWithoutWardInput, WardMohallaMappingUncheckedCreateWithoutWardInput> | WardMohallaMappingCreateWithoutWardInput[] | WardMohallaMappingUncheckedCreateWithoutWardInput[]
    connectOrCreate?: WardMohallaMappingCreateOrConnectWithoutWardInput | WardMohallaMappingCreateOrConnectWithoutWardInput[]
    upsert?: WardMohallaMappingUpsertWithWhereUniqueWithoutWardInput | WardMohallaMappingUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: WardMohallaMappingCreateManyWardInputEnvelope
    set?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
    disconnect?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
    delete?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
    connect?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
    update?: WardMohallaMappingUpdateWithWhereUniqueWithoutWardInput | WardMohallaMappingUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: WardMohallaMappingUpdateManyWithWhereWithoutWardInput | WardMohallaMappingUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: WardMohallaMappingScalarWhereInput | WardMohallaMappingScalarWhereInput[]
  }

  export type SurveyorAssignmentUpdateManyWithoutWardNestedInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutWardInput, SurveyorAssignmentUncheckedCreateWithoutWardInput> | SurveyorAssignmentCreateWithoutWardInput[] | SurveyorAssignmentUncheckedCreateWithoutWardInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutWardInput | SurveyorAssignmentCreateOrConnectWithoutWardInput[]
    upsert?: SurveyorAssignmentUpsertWithWhereUniqueWithoutWardInput | SurveyorAssignmentUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: SurveyorAssignmentCreateManyWardInputEnvelope
    set?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    disconnect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    delete?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    update?: SurveyorAssignmentUpdateWithWhereUniqueWithoutWardInput | SurveyorAssignmentUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: SurveyorAssignmentUpdateManyWithWhereWithoutWardInput | SurveyorAssignmentUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: SurveyorAssignmentScalarWhereInput | SurveyorAssignmentScalarWhereInput[]
  }

  export type WardStatusMappingUpdateManyWithoutWardNestedInput = {
    create?: XOR<WardStatusMappingCreateWithoutWardInput, WardStatusMappingUncheckedCreateWithoutWardInput> | WardStatusMappingCreateWithoutWardInput[] | WardStatusMappingUncheckedCreateWithoutWardInput[]
    connectOrCreate?: WardStatusMappingCreateOrConnectWithoutWardInput | WardStatusMappingCreateOrConnectWithoutWardInput[]
    upsert?: WardStatusMappingUpsertWithWhereUniqueWithoutWardInput | WardStatusMappingUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: WardStatusMappingCreateManyWardInputEnvelope
    set?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    disconnect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    delete?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    connect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    update?: WardStatusMappingUpdateWithWhereUniqueWithoutWardInput | WardStatusMappingUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: WardStatusMappingUpdateManyWithWhereWithoutWardInput | WardStatusMappingUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: WardStatusMappingScalarWhereInput | WardStatusMappingScalarWhereInput[]
  }

  export type SurveyDetailsUpdateManyWithoutWardNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutWardInput, SurveyDetailsUncheckedCreateWithoutWardInput> | SurveyDetailsCreateWithoutWardInput[] | SurveyDetailsUncheckedCreateWithoutWardInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutWardInput | SurveyDetailsCreateOrConnectWithoutWardInput[]
    upsert?: SurveyDetailsUpsertWithWhereUniqueWithoutWardInput | SurveyDetailsUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: SurveyDetailsCreateManyWardInputEnvelope
    set?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    disconnect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    delete?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    update?: SurveyDetailsUpdateWithWhereUniqueWithoutWardInput | SurveyDetailsUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: SurveyDetailsUpdateManyWithWhereWithoutWardInput | SurveyDetailsUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: SurveyDetailsScalarWhereInput | SurveyDetailsScalarWhereInput[]
  }

  export type SupervisorsUpdateManyWithoutWardNestedInput = {
    create?: XOR<SupervisorsCreateWithoutWardInput, SupervisorsUncheckedCreateWithoutWardInput> | SupervisorsCreateWithoutWardInput[] | SupervisorsUncheckedCreateWithoutWardInput[]
    connectOrCreate?: SupervisorsCreateOrConnectWithoutWardInput | SupervisorsCreateOrConnectWithoutWardInput[]
    upsert?: SupervisorsUpsertWithWhereUniqueWithoutWardInput | SupervisorsUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: SupervisorsCreateManyWardInputEnvelope
    set?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
    disconnect?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
    delete?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
    connect?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
    update?: SupervisorsUpdateWithWhereUniqueWithoutWardInput | SupervisorsUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: SupervisorsUpdateManyWithWhereWithoutWardInput | SupervisorsUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: SupervisorsScalarWhereInput | SupervisorsScalarWhereInput[]
  }

  export type ZoneWardMappingUncheckedUpdateManyWithoutWardNestedInput = {
    create?: XOR<ZoneWardMappingCreateWithoutWardInput, ZoneWardMappingUncheckedCreateWithoutWardInput> | ZoneWardMappingCreateWithoutWardInput[] | ZoneWardMappingUncheckedCreateWithoutWardInput[]
    connectOrCreate?: ZoneWardMappingCreateOrConnectWithoutWardInput | ZoneWardMappingCreateOrConnectWithoutWardInput[]
    upsert?: ZoneWardMappingUpsertWithWhereUniqueWithoutWardInput | ZoneWardMappingUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: ZoneWardMappingCreateManyWardInputEnvelope
    set?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
    disconnect?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
    delete?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
    connect?: ZoneWardMappingWhereUniqueInput | ZoneWardMappingWhereUniqueInput[]
    update?: ZoneWardMappingUpdateWithWhereUniqueWithoutWardInput | ZoneWardMappingUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: ZoneWardMappingUpdateManyWithWhereWithoutWardInput | ZoneWardMappingUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: ZoneWardMappingScalarWhereInput | ZoneWardMappingScalarWhereInput[]
  }

  export type WardMohallaMappingUncheckedUpdateManyWithoutWardNestedInput = {
    create?: XOR<WardMohallaMappingCreateWithoutWardInput, WardMohallaMappingUncheckedCreateWithoutWardInput> | WardMohallaMappingCreateWithoutWardInput[] | WardMohallaMappingUncheckedCreateWithoutWardInput[]
    connectOrCreate?: WardMohallaMappingCreateOrConnectWithoutWardInput | WardMohallaMappingCreateOrConnectWithoutWardInput[]
    upsert?: WardMohallaMappingUpsertWithWhereUniqueWithoutWardInput | WardMohallaMappingUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: WardMohallaMappingCreateManyWardInputEnvelope
    set?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
    disconnect?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
    delete?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
    connect?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
    update?: WardMohallaMappingUpdateWithWhereUniqueWithoutWardInput | WardMohallaMappingUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: WardMohallaMappingUpdateManyWithWhereWithoutWardInput | WardMohallaMappingUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: WardMohallaMappingScalarWhereInput | WardMohallaMappingScalarWhereInput[]
  }

  export type SurveyorAssignmentUncheckedUpdateManyWithoutWardNestedInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutWardInput, SurveyorAssignmentUncheckedCreateWithoutWardInput> | SurveyorAssignmentCreateWithoutWardInput[] | SurveyorAssignmentUncheckedCreateWithoutWardInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutWardInput | SurveyorAssignmentCreateOrConnectWithoutWardInput[]
    upsert?: SurveyorAssignmentUpsertWithWhereUniqueWithoutWardInput | SurveyorAssignmentUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: SurveyorAssignmentCreateManyWardInputEnvelope
    set?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    disconnect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    delete?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    update?: SurveyorAssignmentUpdateWithWhereUniqueWithoutWardInput | SurveyorAssignmentUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: SurveyorAssignmentUpdateManyWithWhereWithoutWardInput | SurveyorAssignmentUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: SurveyorAssignmentScalarWhereInput | SurveyorAssignmentScalarWhereInput[]
  }

  export type WardStatusMappingUncheckedUpdateManyWithoutWardNestedInput = {
    create?: XOR<WardStatusMappingCreateWithoutWardInput, WardStatusMappingUncheckedCreateWithoutWardInput> | WardStatusMappingCreateWithoutWardInput[] | WardStatusMappingUncheckedCreateWithoutWardInput[]
    connectOrCreate?: WardStatusMappingCreateOrConnectWithoutWardInput | WardStatusMappingCreateOrConnectWithoutWardInput[]
    upsert?: WardStatusMappingUpsertWithWhereUniqueWithoutWardInput | WardStatusMappingUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: WardStatusMappingCreateManyWardInputEnvelope
    set?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    disconnect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    delete?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    connect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    update?: WardStatusMappingUpdateWithWhereUniqueWithoutWardInput | WardStatusMappingUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: WardStatusMappingUpdateManyWithWhereWithoutWardInput | WardStatusMappingUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: WardStatusMappingScalarWhereInput | WardStatusMappingScalarWhereInput[]
  }

  export type SurveyDetailsUncheckedUpdateManyWithoutWardNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutWardInput, SurveyDetailsUncheckedCreateWithoutWardInput> | SurveyDetailsCreateWithoutWardInput[] | SurveyDetailsUncheckedCreateWithoutWardInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutWardInput | SurveyDetailsCreateOrConnectWithoutWardInput[]
    upsert?: SurveyDetailsUpsertWithWhereUniqueWithoutWardInput | SurveyDetailsUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: SurveyDetailsCreateManyWardInputEnvelope
    set?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    disconnect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    delete?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    update?: SurveyDetailsUpdateWithWhereUniqueWithoutWardInput | SurveyDetailsUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: SurveyDetailsUpdateManyWithWhereWithoutWardInput | SurveyDetailsUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: SurveyDetailsScalarWhereInput | SurveyDetailsScalarWhereInput[]
  }

  export type SupervisorsUncheckedUpdateManyWithoutWardNestedInput = {
    create?: XOR<SupervisorsCreateWithoutWardInput, SupervisorsUncheckedCreateWithoutWardInput> | SupervisorsCreateWithoutWardInput[] | SupervisorsUncheckedCreateWithoutWardInput[]
    connectOrCreate?: SupervisorsCreateOrConnectWithoutWardInput | SupervisorsCreateOrConnectWithoutWardInput[]
    upsert?: SupervisorsUpsertWithWhereUniqueWithoutWardInput | SupervisorsUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: SupervisorsCreateManyWardInputEnvelope
    set?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
    disconnect?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
    delete?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
    connect?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
    update?: SupervisorsUpdateWithWhereUniqueWithoutWardInput | SupervisorsUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: SupervisorsUpdateManyWithWhereWithoutWardInput | SupervisorsUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: SupervisorsScalarWhereInput | SupervisorsScalarWhereInput[]
  }

  export type WardMohallaMappingCreateNestedManyWithoutMohallaInput = {
    create?: XOR<WardMohallaMappingCreateWithoutMohallaInput, WardMohallaMappingUncheckedCreateWithoutMohallaInput> | WardMohallaMappingCreateWithoutMohallaInput[] | WardMohallaMappingUncheckedCreateWithoutMohallaInput[]
    connectOrCreate?: WardMohallaMappingCreateOrConnectWithoutMohallaInput | WardMohallaMappingCreateOrConnectWithoutMohallaInput[]
    createMany?: WardMohallaMappingCreateManyMohallaInputEnvelope
    connect?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
  }

  export type SurveyorAssignmentCreateNestedManyWithoutMohallaInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutMohallaInput, SurveyorAssignmentUncheckedCreateWithoutMohallaInput> | SurveyorAssignmentCreateWithoutMohallaInput[] | SurveyorAssignmentUncheckedCreateWithoutMohallaInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutMohallaInput | SurveyorAssignmentCreateOrConnectWithoutMohallaInput[]
    createMany?: SurveyorAssignmentCreateManyMohallaInputEnvelope
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
  }

  export type SurveyDetailsCreateNestedManyWithoutMohallaInput = {
    create?: XOR<SurveyDetailsCreateWithoutMohallaInput, SurveyDetailsUncheckedCreateWithoutMohallaInput> | SurveyDetailsCreateWithoutMohallaInput[] | SurveyDetailsUncheckedCreateWithoutMohallaInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutMohallaInput | SurveyDetailsCreateOrConnectWithoutMohallaInput[]
    createMany?: SurveyDetailsCreateManyMohallaInputEnvelope
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
  }

  export type WardMohallaMappingUncheckedCreateNestedManyWithoutMohallaInput = {
    create?: XOR<WardMohallaMappingCreateWithoutMohallaInput, WardMohallaMappingUncheckedCreateWithoutMohallaInput> | WardMohallaMappingCreateWithoutMohallaInput[] | WardMohallaMappingUncheckedCreateWithoutMohallaInput[]
    connectOrCreate?: WardMohallaMappingCreateOrConnectWithoutMohallaInput | WardMohallaMappingCreateOrConnectWithoutMohallaInput[]
    createMany?: WardMohallaMappingCreateManyMohallaInputEnvelope
    connect?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
  }

  export type SurveyorAssignmentUncheckedCreateNestedManyWithoutMohallaInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutMohallaInput, SurveyorAssignmentUncheckedCreateWithoutMohallaInput> | SurveyorAssignmentCreateWithoutMohallaInput[] | SurveyorAssignmentUncheckedCreateWithoutMohallaInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutMohallaInput | SurveyorAssignmentCreateOrConnectWithoutMohallaInput[]
    createMany?: SurveyorAssignmentCreateManyMohallaInputEnvelope
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
  }

  export type SurveyDetailsUncheckedCreateNestedManyWithoutMohallaInput = {
    create?: XOR<SurveyDetailsCreateWithoutMohallaInput, SurveyDetailsUncheckedCreateWithoutMohallaInput> | SurveyDetailsCreateWithoutMohallaInput[] | SurveyDetailsUncheckedCreateWithoutMohallaInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutMohallaInput | SurveyDetailsCreateOrConnectWithoutMohallaInput[]
    createMany?: SurveyDetailsCreateManyMohallaInputEnvelope
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
  }

  export type WardMohallaMappingUpdateManyWithoutMohallaNestedInput = {
    create?: XOR<WardMohallaMappingCreateWithoutMohallaInput, WardMohallaMappingUncheckedCreateWithoutMohallaInput> | WardMohallaMappingCreateWithoutMohallaInput[] | WardMohallaMappingUncheckedCreateWithoutMohallaInput[]
    connectOrCreate?: WardMohallaMappingCreateOrConnectWithoutMohallaInput | WardMohallaMappingCreateOrConnectWithoutMohallaInput[]
    upsert?: WardMohallaMappingUpsertWithWhereUniqueWithoutMohallaInput | WardMohallaMappingUpsertWithWhereUniqueWithoutMohallaInput[]
    createMany?: WardMohallaMappingCreateManyMohallaInputEnvelope
    set?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
    disconnect?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
    delete?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
    connect?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
    update?: WardMohallaMappingUpdateWithWhereUniqueWithoutMohallaInput | WardMohallaMappingUpdateWithWhereUniqueWithoutMohallaInput[]
    updateMany?: WardMohallaMappingUpdateManyWithWhereWithoutMohallaInput | WardMohallaMappingUpdateManyWithWhereWithoutMohallaInput[]
    deleteMany?: WardMohallaMappingScalarWhereInput | WardMohallaMappingScalarWhereInput[]
  }

  export type SurveyorAssignmentUpdateManyWithoutMohallaNestedInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutMohallaInput, SurveyorAssignmentUncheckedCreateWithoutMohallaInput> | SurveyorAssignmentCreateWithoutMohallaInput[] | SurveyorAssignmentUncheckedCreateWithoutMohallaInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutMohallaInput | SurveyorAssignmentCreateOrConnectWithoutMohallaInput[]
    upsert?: SurveyorAssignmentUpsertWithWhereUniqueWithoutMohallaInput | SurveyorAssignmentUpsertWithWhereUniqueWithoutMohallaInput[]
    createMany?: SurveyorAssignmentCreateManyMohallaInputEnvelope
    set?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    disconnect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    delete?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    update?: SurveyorAssignmentUpdateWithWhereUniqueWithoutMohallaInput | SurveyorAssignmentUpdateWithWhereUniqueWithoutMohallaInput[]
    updateMany?: SurveyorAssignmentUpdateManyWithWhereWithoutMohallaInput | SurveyorAssignmentUpdateManyWithWhereWithoutMohallaInput[]
    deleteMany?: SurveyorAssignmentScalarWhereInput | SurveyorAssignmentScalarWhereInput[]
  }

  export type SurveyDetailsUpdateManyWithoutMohallaNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutMohallaInput, SurveyDetailsUncheckedCreateWithoutMohallaInput> | SurveyDetailsCreateWithoutMohallaInput[] | SurveyDetailsUncheckedCreateWithoutMohallaInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutMohallaInput | SurveyDetailsCreateOrConnectWithoutMohallaInput[]
    upsert?: SurveyDetailsUpsertWithWhereUniqueWithoutMohallaInput | SurveyDetailsUpsertWithWhereUniqueWithoutMohallaInput[]
    createMany?: SurveyDetailsCreateManyMohallaInputEnvelope
    set?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    disconnect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    delete?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    update?: SurveyDetailsUpdateWithWhereUniqueWithoutMohallaInput | SurveyDetailsUpdateWithWhereUniqueWithoutMohallaInput[]
    updateMany?: SurveyDetailsUpdateManyWithWhereWithoutMohallaInput | SurveyDetailsUpdateManyWithWhereWithoutMohallaInput[]
    deleteMany?: SurveyDetailsScalarWhereInput | SurveyDetailsScalarWhereInput[]
  }

  export type WardMohallaMappingUncheckedUpdateManyWithoutMohallaNestedInput = {
    create?: XOR<WardMohallaMappingCreateWithoutMohallaInput, WardMohallaMappingUncheckedCreateWithoutMohallaInput> | WardMohallaMappingCreateWithoutMohallaInput[] | WardMohallaMappingUncheckedCreateWithoutMohallaInput[]
    connectOrCreate?: WardMohallaMappingCreateOrConnectWithoutMohallaInput | WardMohallaMappingCreateOrConnectWithoutMohallaInput[]
    upsert?: WardMohallaMappingUpsertWithWhereUniqueWithoutMohallaInput | WardMohallaMappingUpsertWithWhereUniqueWithoutMohallaInput[]
    createMany?: WardMohallaMappingCreateManyMohallaInputEnvelope
    set?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
    disconnect?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
    delete?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
    connect?: WardMohallaMappingWhereUniqueInput | WardMohallaMappingWhereUniqueInput[]
    update?: WardMohallaMappingUpdateWithWhereUniqueWithoutMohallaInput | WardMohallaMappingUpdateWithWhereUniqueWithoutMohallaInput[]
    updateMany?: WardMohallaMappingUpdateManyWithWhereWithoutMohallaInput | WardMohallaMappingUpdateManyWithWhereWithoutMohallaInput[]
    deleteMany?: WardMohallaMappingScalarWhereInput | WardMohallaMappingScalarWhereInput[]
  }

  export type SurveyorAssignmentUncheckedUpdateManyWithoutMohallaNestedInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutMohallaInput, SurveyorAssignmentUncheckedCreateWithoutMohallaInput> | SurveyorAssignmentCreateWithoutMohallaInput[] | SurveyorAssignmentUncheckedCreateWithoutMohallaInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutMohallaInput | SurveyorAssignmentCreateOrConnectWithoutMohallaInput[]
    upsert?: SurveyorAssignmentUpsertWithWhereUniqueWithoutMohallaInput | SurveyorAssignmentUpsertWithWhereUniqueWithoutMohallaInput[]
    createMany?: SurveyorAssignmentCreateManyMohallaInputEnvelope
    set?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    disconnect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    delete?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    update?: SurveyorAssignmentUpdateWithWhereUniqueWithoutMohallaInput | SurveyorAssignmentUpdateWithWhereUniqueWithoutMohallaInput[]
    updateMany?: SurveyorAssignmentUpdateManyWithWhereWithoutMohallaInput | SurveyorAssignmentUpdateManyWithWhereWithoutMohallaInput[]
    deleteMany?: SurveyorAssignmentScalarWhereInput | SurveyorAssignmentScalarWhereInput[]
  }

  export type SurveyDetailsUncheckedUpdateManyWithoutMohallaNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutMohallaInput, SurveyDetailsUncheckedCreateWithoutMohallaInput> | SurveyDetailsCreateWithoutMohallaInput[] | SurveyDetailsUncheckedCreateWithoutMohallaInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutMohallaInput | SurveyDetailsCreateOrConnectWithoutMohallaInput[]
    upsert?: SurveyDetailsUpsertWithWhereUniqueWithoutMohallaInput | SurveyDetailsUpsertWithWhereUniqueWithoutMohallaInput[]
    createMany?: SurveyDetailsCreateManyMohallaInputEnvelope
    set?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    disconnect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    delete?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    update?: SurveyDetailsUpdateWithWhereUniqueWithoutMohallaInput | SurveyDetailsUpdateWithWhereUniqueWithoutMohallaInput[]
    updateMany?: SurveyDetailsUpdateManyWithWhereWithoutMohallaInput | SurveyDetailsUpdateManyWithWhereWithoutMohallaInput[]
    deleteMany?: SurveyDetailsScalarWhereInput | SurveyDetailsScalarWhereInput[]
  }

  export type PropertyDetailsCreateNestedManyWithoutResponseTypeInput = {
    create?: XOR<PropertyDetailsCreateWithoutResponseTypeInput, PropertyDetailsUncheckedCreateWithoutResponseTypeInput> | PropertyDetailsCreateWithoutResponseTypeInput[] | PropertyDetailsUncheckedCreateWithoutResponseTypeInput[]
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutResponseTypeInput | PropertyDetailsCreateOrConnectWithoutResponseTypeInput[]
    createMany?: PropertyDetailsCreateManyResponseTypeInputEnvelope
    connect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
  }

  export type PropertyDetailsUncheckedCreateNestedManyWithoutResponseTypeInput = {
    create?: XOR<PropertyDetailsCreateWithoutResponseTypeInput, PropertyDetailsUncheckedCreateWithoutResponseTypeInput> | PropertyDetailsCreateWithoutResponseTypeInput[] | PropertyDetailsUncheckedCreateWithoutResponseTypeInput[]
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutResponseTypeInput | PropertyDetailsCreateOrConnectWithoutResponseTypeInput[]
    createMany?: PropertyDetailsCreateManyResponseTypeInputEnvelope
    connect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
  }

  export type PropertyDetailsUpdateManyWithoutResponseTypeNestedInput = {
    create?: XOR<PropertyDetailsCreateWithoutResponseTypeInput, PropertyDetailsUncheckedCreateWithoutResponseTypeInput> | PropertyDetailsCreateWithoutResponseTypeInput[] | PropertyDetailsUncheckedCreateWithoutResponseTypeInput[]
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutResponseTypeInput | PropertyDetailsCreateOrConnectWithoutResponseTypeInput[]
    upsert?: PropertyDetailsUpsertWithWhereUniqueWithoutResponseTypeInput | PropertyDetailsUpsertWithWhereUniqueWithoutResponseTypeInput[]
    createMany?: PropertyDetailsCreateManyResponseTypeInputEnvelope
    set?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    disconnect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    delete?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    connect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    update?: PropertyDetailsUpdateWithWhereUniqueWithoutResponseTypeInput | PropertyDetailsUpdateWithWhereUniqueWithoutResponseTypeInput[]
    updateMany?: PropertyDetailsUpdateManyWithWhereWithoutResponseTypeInput | PropertyDetailsUpdateManyWithWhereWithoutResponseTypeInput[]
    deleteMany?: PropertyDetailsScalarWhereInput | PropertyDetailsScalarWhereInput[]
  }

  export type PropertyDetailsUncheckedUpdateManyWithoutResponseTypeNestedInput = {
    create?: XOR<PropertyDetailsCreateWithoutResponseTypeInput, PropertyDetailsUncheckedCreateWithoutResponseTypeInput> | PropertyDetailsCreateWithoutResponseTypeInput[] | PropertyDetailsUncheckedCreateWithoutResponseTypeInput[]
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutResponseTypeInput | PropertyDetailsCreateOrConnectWithoutResponseTypeInput[]
    upsert?: PropertyDetailsUpsertWithWhereUniqueWithoutResponseTypeInput | PropertyDetailsUpsertWithWhereUniqueWithoutResponseTypeInput[]
    createMany?: PropertyDetailsCreateManyResponseTypeInputEnvelope
    set?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    disconnect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    delete?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    connect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    update?: PropertyDetailsUpdateWithWhereUniqueWithoutResponseTypeInput | PropertyDetailsUpdateWithWhereUniqueWithoutResponseTypeInput[]
    updateMany?: PropertyDetailsUpdateManyWithWhereWithoutResponseTypeInput | PropertyDetailsUpdateManyWithWhereWithoutResponseTypeInput[]
    deleteMany?: PropertyDetailsScalarWhereInput | PropertyDetailsScalarWhereInput[]
  }

  export type LocationDetailsCreateNestedManyWithoutPropertyTypeInput = {
    create?: XOR<LocationDetailsCreateWithoutPropertyTypeInput, LocationDetailsUncheckedCreateWithoutPropertyTypeInput> | LocationDetailsCreateWithoutPropertyTypeInput[] | LocationDetailsUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutPropertyTypeInput | LocationDetailsCreateOrConnectWithoutPropertyTypeInput[]
    createMany?: LocationDetailsCreateManyPropertyTypeInputEnvelope
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
  }

  export type LocationDetailsUncheckedCreateNestedManyWithoutPropertyTypeInput = {
    create?: XOR<LocationDetailsCreateWithoutPropertyTypeInput, LocationDetailsUncheckedCreateWithoutPropertyTypeInput> | LocationDetailsCreateWithoutPropertyTypeInput[] | LocationDetailsUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutPropertyTypeInput | LocationDetailsCreateOrConnectWithoutPropertyTypeInput[]
    createMany?: LocationDetailsCreateManyPropertyTypeInputEnvelope
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
  }

  export type LocationDetailsUpdateManyWithoutPropertyTypeNestedInput = {
    create?: XOR<LocationDetailsCreateWithoutPropertyTypeInput, LocationDetailsUncheckedCreateWithoutPropertyTypeInput> | LocationDetailsCreateWithoutPropertyTypeInput[] | LocationDetailsUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutPropertyTypeInput | LocationDetailsCreateOrConnectWithoutPropertyTypeInput[]
    upsert?: LocationDetailsUpsertWithWhereUniqueWithoutPropertyTypeInput | LocationDetailsUpsertWithWhereUniqueWithoutPropertyTypeInput[]
    createMany?: LocationDetailsCreateManyPropertyTypeInputEnvelope
    set?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    disconnect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    delete?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    update?: LocationDetailsUpdateWithWhereUniqueWithoutPropertyTypeInput | LocationDetailsUpdateWithWhereUniqueWithoutPropertyTypeInput[]
    updateMany?: LocationDetailsUpdateManyWithWhereWithoutPropertyTypeInput | LocationDetailsUpdateManyWithWhereWithoutPropertyTypeInput[]
    deleteMany?: LocationDetailsScalarWhereInput | LocationDetailsScalarWhereInput[]
  }

  export type LocationDetailsUncheckedUpdateManyWithoutPropertyTypeNestedInput = {
    create?: XOR<LocationDetailsCreateWithoutPropertyTypeInput, LocationDetailsUncheckedCreateWithoutPropertyTypeInput> | LocationDetailsCreateWithoutPropertyTypeInput[] | LocationDetailsUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutPropertyTypeInput | LocationDetailsCreateOrConnectWithoutPropertyTypeInput[]
    upsert?: LocationDetailsUpsertWithWhereUniqueWithoutPropertyTypeInput | LocationDetailsUpsertWithWhereUniqueWithoutPropertyTypeInput[]
    createMany?: LocationDetailsCreateManyPropertyTypeInputEnvelope
    set?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    disconnect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    delete?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    update?: LocationDetailsUpdateWithWhereUniqueWithoutPropertyTypeInput | LocationDetailsUpdateWithWhereUniqueWithoutPropertyTypeInput[]
    updateMany?: LocationDetailsUpdateManyWithWhereWithoutPropertyTypeInput | LocationDetailsUpdateManyWithWhereWithoutPropertyTypeInput[]
    deleteMany?: LocationDetailsScalarWhereInput | LocationDetailsScalarWhereInput[]
  }

  export type PropertyDetailsCreateNestedManyWithoutRespondentStatusInput = {
    create?: XOR<PropertyDetailsCreateWithoutRespondentStatusInput, PropertyDetailsUncheckedCreateWithoutRespondentStatusInput> | PropertyDetailsCreateWithoutRespondentStatusInput[] | PropertyDetailsUncheckedCreateWithoutRespondentStatusInput[]
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutRespondentStatusInput | PropertyDetailsCreateOrConnectWithoutRespondentStatusInput[]
    createMany?: PropertyDetailsCreateManyRespondentStatusInputEnvelope
    connect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
  }

  export type PropertyDetailsUncheckedCreateNestedManyWithoutRespondentStatusInput = {
    create?: XOR<PropertyDetailsCreateWithoutRespondentStatusInput, PropertyDetailsUncheckedCreateWithoutRespondentStatusInput> | PropertyDetailsCreateWithoutRespondentStatusInput[] | PropertyDetailsUncheckedCreateWithoutRespondentStatusInput[]
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutRespondentStatusInput | PropertyDetailsCreateOrConnectWithoutRespondentStatusInput[]
    createMany?: PropertyDetailsCreateManyRespondentStatusInputEnvelope
    connect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
  }

  export type PropertyDetailsUpdateManyWithoutRespondentStatusNestedInput = {
    create?: XOR<PropertyDetailsCreateWithoutRespondentStatusInput, PropertyDetailsUncheckedCreateWithoutRespondentStatusInput> | PropertyDetailsCreateWithoutRespondentStatusInput[] | PropertyDetailsUncheckedCreateWithoutRespondentStatusInput[]
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutRespondentStatusInput | PropertyDetailsCreateOrConnectWithoutRespondentStatusInput[]
    upsert?: PropertyDetailsUpsertWithWhereUniqueWithoutRespondentStatusInput | PropertyDetailsUpsertWithWhereUniqueWithoutRespondentStatusInput[]
    createMany?: PropertyDetailsCreateManyRespondentStatusInputEnvelope
    set?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    disconnect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    delete?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    connect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    update?: PropertyDetailsUpdateWithWhereUniqueWithoutRespondentStatusInput | PropertyDetailsUpdateWithWhereUniqueWithoutRespondentStatusInput[]
    updateMany?: PropertyDetailsUpdateManyWithWhereWithoutRespondentStatusInput | PropertyDetailsUpdateManyWithWhereWithoutRespondentStatusInput[]
    deleteMany?: PropertyDetailsScalarWhereInput | PropertyDetailsScalarWhereInput[]
  }

  export type PropertyDetailsUncheckedUpdateManyWithoutRespondentStatusNestedInput = {
    create?: XOR<PropertyDetailsCreateWithoutRespondentStatusInput, PropertyDetailsUncheckedCreateWithoutRespondentStatusInput> | PropertyDetailsCreateWithoutRespondentStatusInput[] | PropertyDetailsUncheckedCreateWithoutRespondentStatusInput[]
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutRespondentStatusInput | PropertyDetailsCreateOrConnectWithoutRespondentStatusInput[]
    upsert?: PropertyDetailsUpsertWithWhereUniqueWithoutRespondentStatusInput | PropertyDetailsUpsertWithWhereUniqueWithoutRespondentStatusInput[]
    createMany?: PropertyDetailsCreateManyRespondentStatusInputEnvelope
    set?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    disconnect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    delete?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    connect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    update?: PropertyDetailsUpdateWithWhereUniqueWithoutRespondentStatusInput | PropertyDetailsUpdateWithWhereUniqueWithoutRespondentStatusInput[]
    updateMany?: PropertyDetailsUpdateManyWithWhereWithoutRespondentStatusInput | PropertyDetailsUpdateManyWithWhereWithoutRespondentStatusInput[]
    deleteMany?: PropertyDetailsScalarWhereInput | PropertyDetailsScalarWhereInput[]
  }

  export type LocationDetailsCreateNestedManyWithoutRoadTypeInput = {
    create?: XOR<LocationDetailsCreateWithoutRoadTypeInput, LocationDetailsUncheckedCreateWithoutRoadTypeInput> | LocationDetailsCreateWithoutRoadTypeInput[] | LocationDetailsUncheckedCreateWithoutRoadTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutRoadTypeInput | LocationDetailsCreateOrConnectWithoutRoadTypeInput[]
    createMany?: LocationDetailsCreateManyRoadTypeInputEnvelope
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
  }

  export type LocationDetailsUncheckedCreateNestedManyWithoutRoadTypeInput = {
    create?: XOR<LocationDetailsCreateWithoutRoadTypeInput, LocationDetailsUncheckedCreateWithoutRoadTypeInput> | LocationDetailsCreateWithoutRoadTypeInput[] | LocationDetailsUncheckedCreateWithoutRoadTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutRoadTypeInput | LocationDetailsCreateOrConnectWithoutRoadTypeInput[]
    createMany?: LocationDetailsCreateManyRoadTypeInputEnvelope
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
  }

  export type LocationDetailsUpdateManyWithoutRoadTypeNestedInput = {
    create?: XOR<LocationDetailsCreateWithoutRoadTypeInput, LocationDetailsUncheckedCreateWithoutRoadTypeInput> | LocationDetailsCreateWithoutRoadTypeInput[] | LocationDetailsUncheckedCreateWithoutRoadTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutRoadTypeInput | LocationDetailsCreateOrConnectWithoutRoadTypeInput[]
    upsert?: LocationDetailsUpsertWithWhereUniqueWithoutRoadTypeInput | LocationDetailsUpsertWithWhereUniqueWithoutRoadTypeInput[]
    createMany?: LocationDetailsCreateManyRoadTypeInputEnvelope
    set?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    disconnect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    delete?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    update?: LocationDetailsUpdateWithWhereUniqueWithoutRoadTypeInput | LocationDetailsUpdateWithWhereUniqueWithoutRoadTypeInput[]
    updateMany?: LocationDetailsUpdateManyWithWhereWithoutRoadTypeInput | LocationDetailsUpdateManyWithWhereWithoutRoadTypeInput[]
    deleteMany?: LocationDetailsScalarWhereInput | LocationDetailsScalarWhereInput[]
  }

  export type LocationDetailsUncheckedUpdateManyWithoutRoadTypeNestedInput = {
    create?: XOR<LocationDetailsCreateWithoutRoadTypeInput, LocationDetailsUncheckedCreateWithoutRoadTypeInput> | LocationDetailsCreateWithoutRoadTypeInput[] | LocationDetailsUncheckedCreateWithoutRoadTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutRoadTypeInput | LocationDetailsCreateOrConnectWithoutRoadTypeInput[]
    upsert?: LocationDetailsUpsertWithWhereUniqueWithoutRoadTypeInput | LocationDetailsUpsertWithWhereUniqueWithoutRoadTypeInput[]
    createMany?: LocationDetailsCreateManyRoadTypeInputEnvelope
    set?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    disconnect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    delete?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    update?: LocationDetailsUpdateWithWhereUniqueWithoutRoadTypeInput | LocationDetailsUpdateWithWhereUniqueWithoutRoadTypeInput[]
    updateMany?: LocationDetailsUpdateManyWithWhereWithoutRoadTypeInput | LocationDetailsUpdateManyWithWhereWithoutRoadTypeInput[]
    deleteMany?: LocationDetailsScalarWhereInput | LocationDetailsScalarWhereInput[]
  }

  export type LocationDetailsCreateNestedManyWithoutConstructionTypeInput = {
    create?: XOR<LocationDetailsCreateWithoutConstructionTypeInput, LocationDetailsUncheckedCreateWithoutConstructionTypeInput> | LocationDetailsCreateWithoutConstructionTypeInput[] | LocationDetailsUncheckedCreateWithoutConstructionTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutConstructionTypeInput | LocationDetailsCreateOrConnectWithoutConstructionTypeInput[]
    createMany?: LocationDetailsCreateManyConstructionTypeInputEnvelope
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
  }

  export type LocationDetailsUncheckedCreateNestedManyWithoutConstructionTypeInput = {
    create?: XOR<LocationDetailsCreateWithoutConstructionTypeInput, LocationDetailsUncheckedCreateWithoutConstructionTypeInput> | LocationDetailsCreateWithoutConstructionTypeInput[] | LocationDetailsUncheckedCreateWithoutConstructionTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutConstructionTypeInput | LocationDetailsCreateOrConnectWithoutConstructionTypeInput[]
    createMany?: LocationDetailsCreateManyConstructionTypeInputEnvelope
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
  }

  export type LocationDetailsUpdateManyWithoutConstructionTypeNestedInput = {
    create?: XOR<LocationDetailsCreateWithoutConstructionTypeInput, LocationDetailsUncheckedCreateWithoutConstructionTypeInput> | LocationDetailsCreateWithoutConstructionTypeInput[] | LocationDetailsUncheckedCreateWithoutConstructionTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutConstructionTypeInput | LocationDetailsCreateOrConnectWithoutConstructionTypeInput[]
    upsert?: LocationDetailsUpsertWithWhereUniqueWithoutConstructionTypeInput | LocationDetailsUpsertWithWhereUniqueWithoutConstructionTypeInput[]
    createMany?: LocationDetailsCreateManyConstructionTypeInputEnvelope
    set?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    disconnect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    delete?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    update?: LocationDetailsUpdateWithWhereUniqueWithoutConstructionTypeInput | LocationDetailsUpdateWithWhereUniqueWithoutConstructionTypeInput[]
    updateMany?: LocationDetailsUpdateManyWithWhereWithoutConstructionTypeInput | LocationDetailsUpdateManyWithWhereWithoutConstructionTypeInput[]
    deleteMany?: LocationDetailsScalarWhereInput | LocationDetailsScalarWhereInput[]
  }

  export type LocationDetailsUncheckedUpdateManyWithoutConstructionTypeNestedInput = {
    create?: XOR<LocationDetailsCreateWithoutConstructionTypeInput, LocationDetailsUncheckedCreateWithoutConstructionTypeInput> | LocationDetailsCreateWithoutConstructionTypeInput[] | LocationDetailsUncheckedCreateWithoutConstructionTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutConstructionTypeInput | LocationDetailsCreateOrConnectWithoutConstructionTypeInput[]
    upsert?: LocationDetailsUpsertWithWhereUniqueWithoutConstructionTypeInput | LocationDetailsUpsertWithWhereUniqueWithoutConstructionTypeInput[]
    createMany?: LocationDetailsCreateManyConstructionTypeInputEnvelope
    set?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    disconnect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    delete?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    update?: LocationDetailsUpdateWithWhereUniqueWithoutConstructionTypeInput | LocationDetailsUpdateWithWhereUniqueWithoutConstructionTypeInput[]
    updateMany?: LocationDetailsUpdateManyWithWhereWithoutConstructionTypeInput | LocationDetailsUpdateManyWithWhereWithoutConstructionTypeInput[]
    deleteMany?: LocationDetailsScalarWhereInput | LocationDetailsScalarWhereInput[]
  }

  export type OtherDetailsCreateNestedManyWithoutWaterSourceInput = {
    create?: XOR<OtherDetailsCreateWithoutWaterSourceInput, OtherDetailsUncheckedCreateWithoutWaterSourceInput> | OtherDetailsCreateWithoutWaterSourceInput[] | OtherDetailsUncheckedCreateWithoutWaterSourceInput[]
    connectOrCreate?: OtherDetailsCreateOrConnectWithoutWaterSourceInput | OtherDetailsCreateOrConnectWithoutWaterSourceInput[]
    createMany?: OtherDetailsCreateManyWaterSourceInputEnvelope
    connect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
  }

  export type OtherDetailsUncheckedCreateNestedManyWithoutWaterSourceInput = {
    create?: XOR<OtherDetailsCreateWithoutWaterSourceInput, OtherDetailsUncheckedCreateWithoutWaterSourceInput> | OtherDetailsCreateWithoutWaterSourceInput[] | OtherDetailsUncheckedCreateWithoutWaterSourceInput[]
    connectOrCreate?: OtherDetailsCreateOrConnectWithoutWaterSourceInput | OtherDetailsCreateOrConnectWithoutWaterSourceInput[]
    createMany?: OtherDetailsCreateManyWaterSourceInputEnvelope
    connect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
  }

  export type OtherDetailsUpdateManyWithoutWaterSourceNestedInput = {
    create?: XOR<OtherDetailsCreateWithoutWaterSourceInput, OtherDetailsUncheckedCreateWithoutWaterSourceInput> | OtherDetailsCreateWithoutWaterSourceInput[] | OtherDetailsUncheckedCreateWithoutWaterSourceInput[]
    connectOrCreate?: OtherDetailsCreateOrConnectWithoutWaterSourceInput | OtherDetailsCreateOrConnectWithoutWaterSourceInput[]
    upsert?: OtherDetailsUpsertWithWhereUniqueWithoutWaterSourceInput | OtherDetailsUpsertWithWhereUniqueWithoutWaterSourceInput[]
    createMany?: OtherDetailsCreateManyWaterSourceInputEnvelope
    set?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    disconnect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    delete?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    connect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    update?: OtherDetailsUpdateWithWhereUniqueWithoutWaterSourceInput | OtherDetailsUpdateWithWhereUniqueWithoutWaterSourceInput[]
    updateMany?: OtherDetailsUpdateManyWithWhereWithoutWaterSourceInput | OtherDetailsUpdateManyWithWhereWithoutWaterSourceInput[]
    deleteMany?: OtherDetailsScalarWhereInput | OtherDetailsScalarWhereInput[]
  }

  export type OtherDetailsUncheckedUpdateManyWithoutWaterSourceNestedInput = {
    create?: XOR<OtherDetailsCreateWithoutWaterSourceInput, OtherDetailsUncheckedCreateWithoutWaterSourceInput> | OtherDetailsCreateWithoutWaterSourceInput[] | OtherDetailsUncheckedCreateWithoutWaterSourceInput[]
    connectOrCreate?: OtherDetailsCreateOrConnectWithoutWaterSourceInput | OtherDetailsCreateOrConnectWithoutWaterSourceInput[]
    upsert?: OtherDetailsUpsertWithWhereUniqueWithoutWaterSourceInput | OtherDetailsUpsertWithWhereUniqueWithoutWaterSourceInput[]
    createMany?: OtherDetailsCreateManyWaterSourceInputEnvelope
    set?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    disconnect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    delete?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    connect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    update?: OtherDetailsUpdateWithWhereUniqueWithoutWaterSourceInput | OtherDetailsUpdateWithWhereUniqueWithoutWaterSourceInput[]
    updateMany?: OtherDetailsUpdateManyWithWhereWithoutWaterSourceInput | OtherDetailsUpdateManyWithWhereWithoutWaterSourceInput[]
    deleteMany?: OtherDetailsScalarWhereInput | OtherDetailsScalarWhereInput[]
  }

  export type OtherDetailsCreateNestedManyWithoutDisposalTypeInput = {
    create?: XOR<OtherDetailsCreateWithoutDisposalTypeInput, OtherDetailsUncheckedCreateWithoutDisposalTypeInput> | OtherDetailsCreateWithoutDisposalTypeInput[] | OtherDetailsUncheckedCreateWithoutDisposalTypeInput[]
    connectOrCreate?: OtherDetailsCreateOrConnectWithoutDisposalTypeInput | OtherDetailsCreateOrConnectWithoutDisposalTypeInput[]
    createMany?: OtherDetailsCreateManyDisposalTypeInputEnvelope
    connect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
  }

  export type OtherDetailsUncheckedCreateNestedManyWithoutDisposalTypeInput = {
    create?: XOR<OtherDetailsCreateWithoutDisposalTypeInput, OtherDetailsUncheckedCreateWithoutDisposalTypeInput> | OtherDetailsCreateWithoutDisposalTypeInput[] | OtherDetailsUncheckedCreateWithoutDisposalTypeInput[]
    connectOrCreate?: OtherDetailsCreateOrConnectWithoutDisposalTypeInput | OtherDetailsCreateOrConnectWithoutDisposalTypeInput[]
    createMany?: OtherDetailsCreateManyDisposalTypeInputEnvelope
    connect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
  }

  export type OtherDetailsUpdateManyWithoutDisposalTypeNestedInput = {
    create?: XOR<OtherDetailsCreateWithoutDisposalTypeInput, OtherDetailsUncheckedCreateWithoutDisposalTypeInput> | OtherDetailsCreateWithoutDisposalTypeInput[] | OtherDetailsUncheckedCreateWithoutDisposalTypeInput[]
    connectOrCreate?: OtherDetailsCreateOrConnectWithoutDisposalTypeInput | OtherDetailsCreateOrConnectWithoutDisposalTypeInput[]
    upsert?: OtherDetailsUpsertWithWhereUniqueWithoutDisposalTypeInput | OtherDetailsUpsertWithWhereUniqueWithoutDisposalTypeInput[]
    createMany?: OtherDetailsCreateManyDisposalTypeInputEnvelope
    set?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    disconnect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    delete?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    connect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    update?: OtherDetailsUpdateWithWhereUniqueWithoutDisposalTypeInput | OtherDetailsUpdateWithWhereUniqueWithoutDisposalTypeInput[]
    updateMany?: OtherDetailsUpdateManyWithWhereWithoutDisposalTypeInput | OtherDetailsUpdateManyWithWhereWithoutDisposalTypeInput[]
    deleteMany?: OtherDetailsScalarWhereInput | OtherDetailsScalarWhereInput[]
  }

  export type OtherDetailsUncheckedUpdateManyWithoutDisposalTypeNestedInput = {
    create?: XOR<OtherDetailsCreateWithoutDisposalTypeInput, OtherDetailsUncheckedCreateWithoutDisposalTypeInput> | OtherDetailsCreateWithoutDisposalTypeInput[] | OtherDetailsUncheckedCreateWithoutDisposalTypeInput[]
    connectOrCreate?: OtherDetailsCreateOrConnectWithoutDisposalTypeInput | OtherDetailsCreateOrConnectWithoutDisposalTypeInput[]
    upsert?: OtherDetailsUpsertWithWhereUniqueWithoutDisposalTypeInput | OtherDetailsUpsertWithWhereUniqueWithoutDisposalTypeInput[]
    createMany?: OtherDetailsCreateManyDisposalTypeInputEnvelope
    set?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    disconnect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    delete?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    connect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    update?: OtherDetailsUpdateWithWhereUniqueWithoutDisposalTypeInput | OtherDetailsUpdateWithWhereUniqueWithoutDisposalTypeInput[]
    updateMany?: OtherDetailsUpdateManyWithWhereWithoutDisposalTypeInput | OtherDetailsUpdateManyWithWhereWithoutDisposalTypeInput[]
    deleteMany?: OtherDetailsScalarWhereInput | OtherDetailsScalarWhereInput[]
  }

  export type NrPropertySubCategoryMasterCreateNestedManyWithoutPropertyCategoryInput = {
    create?: XOR<NrPropertySubCategoryMasterCreateWithoutPropertyCategoryInput, NrPropertySubCategoryMasterUncheckedCreateWithoutPropertyCategoryInput> | NrPropertySubCategoryMasterCreateWithoutPropertyCategoryInput[] | NrPropertySubCategoryMasterUncheckedCreateWithoutPropertyCategoryInput[]
    connectOrCreate?: NrPropertySubCategoryMasterCreateOrConnectWithoutPropertyCategoryInput | NrPropertySubCategoryMasterCreateOrConnectWithoutPropertyCategoryInput[]
    createMany?: NrPropertySubCategoryMasterCreateManyPropertyCategoryInputEnvelope
    connect?: NrPropertySubCategoryMasterWhereUniqueInput | NrPropertySubCategoryMasterWhereUniqueInput[]
  }

  export type NonResidentialPropertyAssessmentCreateNestedManyWithoutNrPropertyCategoryInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutNrPropertyCategoryInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutNrPropertyCategoryInput> | NonResidentialPropertyAssessmentCreateWithoutNrPropertyCategoryInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutNrPropertyCategoryInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutNrPropertyCategoryInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutNrPropertyCategoryInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManyNrPropertyCategoryInputEnvelope
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
  }

  export type NrPropertySubCategoryMasterUncheckedCreateNestedManyWithoutPropertyCategoryInput = {
    create?: XOR<NrPropertySubCategoryMasterCreateWithoutPropertyCategoryInput, NrPropertySubCategoryMasterUncheckedCreateWithoutPropertyCategoryInput> | NrPropertySubCategoryMasterCreateWithoutPropertyCategoryInput[] | NrPropertySubCategoryMasterUncheckedCreateWithoutPropertyCategoryInput[]
    connectOrCreate?: NrPropertySubCategoryMasterCreateOrConnectWithoutPropertyCategoryInput | NrPropertySubCategoryMasterCreateOrConnectWithoutPropertyCategoryInput[]
    createMany?: NrPropertySubCategoryMasterCreateManyPropertyCategoryInputEnvelope
    connect?: NrPropertySubCategoryMasterWhereUniqueInput | NrPropertySubCategoryMasterWhereUniqueInput[]
  }

  export type NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutNrPropertyCategoryInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutNrPropertyCategoryInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutNrPropertyCategoryInput> | NonResidentialPropertyAssessmentCreateWithoutNrPropertyCategoryInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutNrPropertyCategoryInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutNrPropertyCategoryInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutNrPropertyCategoryInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManyNrPropertyCategoryInputEnvelope
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NrPropertySubCategoryMasterUpdateManyWithoutPropertyCategoryNestedInput = {
    create?: XOR<NrPropertySubCategoryMasterCreateWithoutPropertyCategoryInput, NrPropertySubCategoryMasterUncheckedCreateWithoutPropertyCategoryInput> | NrPropertySubCategoryMasterCreateWithoutPropertyCategoryInput[] | NrPropertySubCategoryMasterUncheckedCreateWithoutPropertyCategoryInput[]
    connectOrCreate?: NrPropertySubCategoryMasterCreateOrConnectWithoutPropertyCategoryInput | NrPropertySubCategoryMasterCreateOrConnectWithoutPropertyCategoryInput[]
    upsert?: NrPropertySubCategoryMasterUpsertWithWhereUniqueWithoutPropertyCategoryInput | NrPropertySubCategoryMasterUpsertWithWhereUniqueWithoutPropertyCategoryInput[]
    createMany?: NrPropertySubCategoryMasterCreateManyPropertyCategoryInputEnvelope
    set?: NrPropertySubCategoryMasterWhereUniqueInput | NrPropertySubCategoryMasterWhereUniqueInput[]
    disconnect?: NrPropertySubCategoryMasterWhereUniqueInput | NrPropertySubCategoryMasterWhereUniqueInput[]
    delete?: NrPropertySubCategoryMasterWhereUniqueInput | NrPropertySubCategoryMasterWhereUniqueInput[]
    connect?: NrPropertySubCategoryMasterWhereUniqueInput | NrPropertySubCategoryMasterWhereUniqueInput[]
    update?: NrPropertySubCategoryMasterUpdateWithWhereUniqueWithoutPropertyCategoryInput | NrPropertySubCategoryMasterUpdateWithWhereUniqueWithoutPropertyCategoryInput[]
    updateMany?: NrPropertySubCategoryMasterUpdateManyWithWhereWithoutPropertyCategoryInput | NrPropertySubCategoryMasterUpdateManyWithWhereWithoutPropertyCategoryInput[]
    deleteMany?: NrPropertySubCategoryMasterScalarWhereInput | NrPropertySubCategoryMasterScalarWhereInput[]
  }

  export type NonResidentialPropertyAssessmentUpdateManyWithoutNrPropertyCategoryNestedInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutNrPropertyCategoryInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutNrPropertyCategoryInput> | NonResidentialPropertyAssessmentCreateWithoutNrPropertyCategoryInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutNrPropertyCategoryInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutNrPropertyCategoryInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutNrPropertyCategoryInput[]
    upsert?: NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutNrPropertyCategoryInput | NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutNrPropertyCategoryInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManyNrPropertyCategoryInputEnvelope
    set?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    disconnect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    delete?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    update?: NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutNrPropertyCategoryInput | NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutNrPropertyCategoryInput[]
    updateMany?: NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutNrPropertyCategoryInput | NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutNrPropertyCategoryInput[]
    deleteMany?: NonResidentialPropertyAssessmentScalarWhereInput | NonResidentialPropertyAssessmentScalarWhereInput[]
  }

  export type NrPropertySubCategoryMasterUncheckedUpdateManyWithoutPropertyCategoryNestedInput = {
    create?: XOR<NrPropertySubCategoryMasterCreateWithoutPropertyCategoryInput, NrPropertySubCategoryMasterUncheckedCreateWithoutPropertyCategoryInput> | NrPropertySubCategoryMasterCreateWithoutPropertyCategoryInput[] | NrPropertySubCategoryMasterUncheckedCreateWithoutPropertyCategoryInput[]
    connectOrCreate?: NrPropertySubCategoryMasterCreateOrConnectWithoutPropertyCategoryInput | NrPropertySubCategoryMasterCreateOrConnectWithoutPropertyCategoryInput[]
    upsert?: NrPropertySubCategoryMasterUpsertWithWhereUniqueWithoutPropertyCategoryInput | NrPropertySubCategoryMasterUpsertWithWhereUniqueWithoutPropertyCategoryInput[]
    createMany?: NrPropertySubCategoryMasterCreateManyPropertyCategoryInputEnvelope
    set?: NrPropertySubCategoryMasterWhereUniqueInput | NrPropertySubCategoryMasterWhereUniqueInput[]
    disconnect?: NrPropertySubCategoryMasterWhereUniqueInput | NrPropertySubCategoryMasterWhereUniqueInput[]
    delete?: NrPropertySubCategoryMasterWhereUniqueInput | NrPropertySubCategoryMasterWhereUniqueInput[]
    connect?: NrPropertySubCategoryMasterWhereUniqueInput | NrPropertySubCategoryMasterWhereUniqueInput[]
    update?: NrPropertySubCategoryMasterUpdateWithWhereUniqueWithoutPropertyCategoryInput | NrPropertySubCategoryMasterUpdateWithWhereUniqueWithoutPropertyCategoryInput[]
    updateMany?: NrPropertySubCategoryMasterUpdateManyWithWhereWithoutPropertyCategoryInput | NrPropertySubCategoryMasterUpdateManyWithWhereWithoutPropertyCategoryInput[]
    deleteMany?: NrPropertySubCategoryMasterScalarWhereInput | NrPropertySubCategoryMasterScalarWhereInput[]
  }

  export type NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutNrPropertyCategoryNestedInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutNrPropertyCategoryInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutNrPropertyCategoryInput> | NonResidentialPropertyAssessmentCreateWithoutNrPropertyCategoryInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutNrPropertyCategoryInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutNrPropertyCategoryInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutNrPropertyCategoryInput[]
    upsert?: NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutNrPropertyCategoryInput | NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutNrPropertyCategoryInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManyNrPropertyCategoryInputEnvelope
    set?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    disconnect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    delete?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    update?: NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutNrPropertyCategoryInput | NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutNrPropertyCategoryInput[]
    updateMany?: NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutNrPropertyCategoryInput | NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutNrPropertyCategoryInput[]
    deleteMany?: NonResidentialPropertyAssessmentScalarWhereInput | NonResidentialPropertyAssessmentScalarWhereInput[]
  }

  export type NrPropertyCategoryMasterCreateNestedOneWithoutSubCategoriesInput = {
    create?: XOR<NrPropertyCategoryMasterCreateWithoutSubCategoriesInput, NrPropertyCategoryMasterUncheckedCreateWithoutSubCategoriesInput>
    connectOrCreate?: NrPropertyCategoryMasterCreateOrConnectWithoutSubCategoriesInput
    connect?: NrPropertyCategoryMasterWhereUniqueInput
  }

  export type NonResidentialPropertyAssessmentCreateNestedManyWithoutNrSubCategoryInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutNrSubCategoryInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutNrSubCategoryInput> | NonResidentialPropertyAssessmentCreateWithoutNrSubCategoryInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutNrSubCategoryInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutNrSubCategoryInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutNrSubCategoryInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManyNrSubCategoryInputEnvelope
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
  }

  export type NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutNrSubCategoryInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutNrSubCategoryInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutNrSubCategoryInput> | NonResidentialPropertyAssessmentCreateWithoutNrSubCategoryInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutNrSubCategoryInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutNrSubCategoryInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutNrSubCategoryInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManyNrSubCategoryInputEnvelope
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
  }

  export type NrPropertyCategoryMasterUpdateOneRequiredWithoutSubCategoriesNestedInput = {
    create?: XOR<NrPropertyCategoryMasterCreateWithoutSubCategoriesInput, NrPropertyCategoryMasterUncheckedCreateWithoutSubCategoriesInput>
    connectOrCreate?: NrPropertyCategoryMasterCreateOrConnectWithoutSubCategoriesInput
    upsert?: NrPropertyCategoryMasterUpsertWithoutSubCategoriesInput
    connect?: NrPropertyCategoryMasterWhereUniqueInput
    update?: XOR<XOR<NrPropertyCategoryMasterUpdateToOneWithWhereWithoutSubCategoriesInput, NrPropertyCategoryMasterUpdateWithoutSubCategoriesInput>, NrPropertyCategoryMasterUncheckedUpdateWithoutSubCategoriesInput>
  }

  export type NonResidentialPropertyAssessmentUpdateManyWithoutNrSubCategoryNestedInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutNrSubCategoryInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutNrSubCategoryInput> | NonResidentialPropertyAssessmentCreateWithoutNrSubCategoryInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutNrSubCategoryInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutNrSubCategoryInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutNrSubCategoryInput[]
    upsert?: NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutNrSubCategoryInput | NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutNrSubCategoryInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManyNrSubCategoryInputEnvelope
    set?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    disconnect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    delete?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    update?: NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutNrSubCategoryInput | NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutNrSubCategoryInput[]
    updateMany?: NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutNrSubCategoryInput | NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutNrSubCategoryInput[]
    deleteMany?: NonResidentialPropertyAssessmentScalarWhereInput | NonResidentialPropertyAssessmentScalarWhereInput[]
  }

  export type NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutNrSubCategoryNestedInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutNrSubCategoryInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutNrSubCategoryInput> | NonResidentialPropertyAssessmentCreateWithoutNrSubCategoryInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutNrSubCategoryInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutNrSubCategoryInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutNrSubCategoryInput[]
    upsert?: NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutNrSubCategoryInput | NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutNrSubCategoryInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManyNrSubCategoryInputEnvelope
    set?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    disconnect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    delete?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    update?: NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutNrSubCategoryInput | NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutNrSubCategoryInput[]
    updateMany?: NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutNrSubCategoryInput | NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutNrSubCategoryInput[]
    deleteMany?: NonResidentialPropertyAssessmentScalarWhereInput | NonResidentialPropertyAssessmentScalarWhereInput[]
  }

  export type ResidentialPropertyAssessmentCreateNestedManyWithoutConstructionNatureInput = {
    create?: XOR<ResidentialPropertyAssessmentCreateWithoutConstructionNatureInput, ResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput> | ResidentialPropertyAssessmentCreateWithoutConstructionNatureInput[] | ResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput[]
    connectOrCreate?: ResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput | ResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput[]
    createMany?: ResidentialPropertyAssessmentCreateManyConstructionNatureInputEnvelope
    connect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
  }

  export type NonResidentialPropertyAssessmentCreateNestedManyWithoutConstructionNatureInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutConstructionNatureInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput> | NonResidentialPropertyAssessmentCreateWithoutConstructionNatureInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManyConstructionNatureInputEnvelope
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
  }

  export type ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutConstructionNatureInput = {
    create?: XOR<ResidentialPropertyAssessmentCreateWithoutConstructionNatureInput, ResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput> | ResidentialPropertyAssessmentCreateWithoutConstructionNatureInput[] | ResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput[]
    connectOrCreate?: ResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput | ResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput[]
    createMany?: ResidentialPropertyAssessmentCreateManyConstructionNatureInputEnvelope
    connect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
  }

  export type NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutConstructionNatureInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutConstructionNatureInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput> | NonResidentialPropertyAssessmentCreateWithoutConstructionNatureInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManyConstructionNatureInputEnvelope
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
  }

  export type ResidentialPropertyAssessmentUpdateManyWithoutConstructionNatureNestedInput = {
    create?: XOR<ResidentialPropertyAssessmentCreateWithoutConstructionNatureInput, ResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput> | ResidentialPropertyAssessmentCreateWithoutConstructionNatureInput[] | ResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput[]
    connectOrCreate?: ResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput | ResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput[]
    upsert?: ResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutConstructionNatureInput | ResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutConstructionNatureInput[]
    createMany?: ResidentialPropertyAssessmentCreateManyConstructionNatureInputEnvelope
    set?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    disconnect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    delete?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    connect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    update?: ResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutConstructionNatureInput | ResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutConstructionNatureInput[]
    updateMany?: ResidentialPropertyAssessmentUpdateManyWithWhereWithoutConstructionNatureInput | ResidentialPropertyAssessmentUpdateManyWithWhereWithoutConstructionNatureInput[]
    deleteMany?: ResidentialPropertyAssessmentScalarWhereInput | ResidentialPropertyAssessmentScalarWhereInput[]
  }

  export type NonResidentialPropertyAssessmentUpdateManyWithoutConstructionNatureNestedInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutConstructionNatureInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput> | NonResidentialPropertyAssessmentCreateWithoutConstructionNatureInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput[]
    upsert?: NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutConstructionNatureInput | NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutConstructionNatureInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManyConstructionNatureInputEnvelope
    set?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    disconnect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    delete?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    update?: NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutConstructionNatureInput | NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutConstructionNatureInput[]
    updateMany?: NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutConstructionNatureInput | NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutConstructionNatureInput[]
    deleteMany?: NonResidentialPropertyAssessmentScalarWhereInput | NonResidentialPropertyAssessmentScalarWhereInput[]
  }

  export type ResidentialPropertyAssessmentUncheckedUpdateManyWithoutConstructionNatureNestedInput = {
    create?: XOR<ResidentialPropertyAssessmentCreateWithoutConstructionNatureInput, ResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput> | ResidentialPropertyAssessmentCreateWithoutConstructionNatureInput[] | ResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput[]
    connectOrCreate?: ResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput | ResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput[]
    upsert?: ResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutConstructionNatureInput | ResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutConstructionNatureInput[]
    createMany?: ResidentialPropertyAssessmentCreateManyConstructionNatureInputEnvelope
    set?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    disconnect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    delete?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    connect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    update?: ResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutConstructionNatureInput | ResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutConstructionNatureInput[]
    updateMany?: ResidentialPropertyAssessmentUpdateManyWithWhereWithoutConstructionNatureInput | ResidentialPropertyAssessmentUpdateManyWithWhereWithoutConstructionNatureInput[]
    deleteMany?: ResidentialPropertyAssessmentScalarWhereInput | ResidentialPropertyAssessmentScalarWhereInput[]
  }

  export type NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutConstructionNatureNestedInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutConstructionNatureInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput> | NonResidentialPropertyAssessmentCreateWithoutConstructionNatureInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput[]
    upsert?: NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutConstructionNatureInput | NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutConstructionNatureInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManyConstructionNatureInputEnvelope
    set?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    disconnect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    delete?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    update?: NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutConstructionNatureInput | NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutConstructionNatureInput[]
    updateMany?: NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutConstructionNatureInput | NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutConstructionNatureInput[]
    deleteMany?: NonResidentialPropertyAssessmentScalarWhereInput | NonResidentialPropertyAssessmentScalarWhereInput[]
  }

  export type SurveyDetailsCreateNestedManyWithoutSurveyTypeInput = {
    create?: XOR<SurveyDetailsCreateWithoutSurveyTypeInput, SurveyDetailsUncheckedCreateWithoutSurveyTypeInput> | SurveyDetailsCreateWithoutSurveyTypeInput[] | SurveyDetailsUncheckedCreateWithoutSurveyTypeInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutSurveyTypeInput | SurveyDetailsCreateOrConnectWithoutSurveyTypeInput[]
    createMany?: SurveyDetailsCreateManySurveyTypeInputEnvelope
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
  }

  export type SurveyDetailsUncheckedCreateNestedManyWithoutSurveyTypeInput = {
    create?: XOR<SurveyDetailsCreateWithoutSurveyTypeInput, SurveyDetailsUncheckedCreateWithoutSurveyTypeInput> | SurveyDetailsCreateWithoutSurveyTypeInput[] | SurveyDetailsUncheckedCreateWithoutSurveyTypeInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutSurveyTypeInput | SurveyDetailsCreateOrConnectWithoutSurveyTypeInput[]
    createMany?: SurveyDetailsCreateManySurveyTypeInputEnvelope
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
  }

  export type SurveyDetailsUpdateManyWithoutSurveyTypeNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutSurveyTypeInput, SurveyDetailsUncheckedCreateWithoutSurveyTypeInput> | SurveyDetailsCreateWithoutSurveyTypeInput[] | SurveyDetailsUncheckedCreateWithoutSurveyTypeInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutSurveyTypeInput | SurveyDetailsCreateOrConnectWithoutSurveyTypeInput[]
    upsert?: SurveyDetailsUpsertWithWhereUniqueWithoutSurveyTypeInput | SurveyDetailsUpsertWithWhereUniqueWithoutSurveyTypeInput[]
    createMany?: SurveyDetailsCreateManySurveyTypeInputEnvelope
    set?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    disconnect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    delete?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    update?: SurveyDetailsUpdateWithWhereUniqueWithoutSurveyTypeInput | SurveyDetailsUpdateWithWhereUniqueWithoutSurveyTypeInput[]
    updateMany?: SurveyDetailsUpdateManyWithWhereWithoutSurveyTypeInput | SurveyDetailsUpdateManyWithWhereWithoutSurveyTypeInput[]
    deleteMany?: SurveyDetailsScalarWhereInput | SurveyDetailsScalarWhereInput[]
  }

  export type SurveyDetailsUncheckedUpdateManyWithoutSurveyTypeNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutSurveyTypeInput, SurveyDetailsUncheckedCreateWithoutSurveyTypeInput> | SurveyDetailsCreateWithoutSurveyTypeInput[] | SurveyDetailsUncheckedCreateWithoutSurveyTypeInput[]
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutSurveyTypeInput | SurveyDetailsCreateOrConnectWithoutSurveyTypeInput[]
    upsert?: SurveyDetailsUpsertWithWhereUniqueWithoutSurveyTypeInput | SurveyDetailsUpsertWithWhereUniqueWithoutSurveyTypeInput[]
    createMany?: SurveyDetailsCreateManySurveyTypeInputEnvelope
    set?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    disconnect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    delete?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    connect?: SurveyDetailsWhereUniqueInput | SurveyDetailsWhereUniqueInput[]
    update?: SurveyDetailsUpdateWithWhereUniqueWithoutSurveyTypeInput | SurveyDetailsUpdateWithWhereUniqueWithoutSurveyTypeInput[]
    updateMany?: SurveyDetailsUpdateManyWithWhereWithoutSurveyTypeInput | SurveyDetailsUpdateManyWithWhereWithoutSurveyTypeInput[]
    deleteMany?: SurveyDetailsScalarWhereInput | SurveyDetailsScalarWhereInput[]
  }

  export type ResidentialPropertyAssessmentCreateNestedManyWithoutOccupancyStatusInput = {
    create?: XOR<ResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput, ResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput> | ResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput[] | ResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput[]
    connectOrCreate?: ResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput | ResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput[]
    createMany?: ResidentialPropertyAssessmentCreateManyOccupancyStatusInputEnvelope
    connect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
  }

  export type NonResidentialPropertyAssessmentCreateNestedManyWithoutOccupancyStatusInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput> | NonResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManyOccupancyStatusInputEnvelope
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
  }

  export type ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutOccupancyStatusInput = {
    create?: XOR<ResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput, ResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput> | ResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput[] | ResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput[]
    connectOrCreate?: ResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput | ResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput[]
    createMany?: ResidentialPropertyAssessmentCreateManyOccupancyStatusInputEnvelope
    connect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
  }

  export type NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutOccupancyStatusInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput> | NonResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManyOccupancyStatusInputEnvelope
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
  }

  export type ResidentialPropertyAssessmentUpdateManyWithoutOccupancyStatusNestedInput = {
    create?: XOR<ResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput, ResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput> | ResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput[] | ResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput[]
    connectOrCreate?: ResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput | ResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput[]
    upsert?: ResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutOccupancyStatusInput | ResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutOccupancyStatusInput[]
    createMany?: ResidentialPropertyAssessmentCreateManyOccupancyStatusInputEnvelope
    set?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    disconnect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    delete?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    connect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    update?: ResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutOccupancyStatusInput | ResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutOccupancyStatusInput[]
    updateMany?: ResidentialPropertyAssessmentUpdateManyWithWhereWithoutOccupancyStatusInput | ResidentialPropertyAssessmentUpdateManyWithWhereWithoutOccupancyStatusInput[]
    deleteMany?: ResidentialPropertyAssessmentScalarWhereInput | ResidentialPropertyAssessmentScalarWhereInput[]
  }

  export type NonResidentialPropertyAssessmentUpdateManyWithoutOccupancyStatusNestedInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput> | NonResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput[]
    upsert?: NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutOccupancyStatusInput | NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutOccupancyStatusInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManyOccupancyStatusInputEnvelope
    set?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    disconnect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    delete?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    update?: NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutOccupancyStatusInput | NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutOccupancyStatusInput[]
    updateMany?: NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutOccupancyStatusInput | NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutOccupancyStatusInput[]
    deleteMany?: NonResidentialPropertyAssessmentScalarWhereInput | NonResidentialPropertyAssessmentScalarWhereInput[]
  }

  export type ResidentialPropertyAssessmentUncheckedUpdateManyWithoutOccupancyStatusNestedInput = {
    create?: XOR<ResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput, ResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput> | ResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput[] | ResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput[]
    connectOrCreate?: ResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput | ResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput[]
    upsert?: ResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutOccupancyStatusInput | ResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutOccupancyStatusInput[]
    createMany?: ResidentialPropertyAssessmentCreateManyOccupancyStatusInputEnvelope
    set?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    disconnect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    delete?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    connect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    update?: ResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutOccupancyStatusInput | ResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutOccupancyStatusInput[]
    updateMany?: ResidentialPropertyAssessmentUpdateManyWithWhereWithoutOccupancyStatusInput | ResidentialPropertyAssessmentUpdateManyWithWhereWithoutOccupancyStatusInput[]
    deleteMany?: ResidentialPropertyAssessmentScalarWhereInput | ResidentialPropertyAssessmentScalarWhereInput[]
  }

  export type NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutOccupancyStatusNestedInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput> | NonResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput[]
    upsert?: NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutOccupancyStatusInput | NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutOccupancyStatusInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManyOccupancyStatusInputEnvelope
    set?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    disconnect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    delete?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    update?: NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutOccupancyStatusInput | NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutOccupancyStatusInput[]
    updateMany?: NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutOccupancyStatusInput | NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutOccupancyStatusInput[]
    deleteMany?: NonResidentialPropertyAssessmentScalarWhereInput | NonResidentialPropertyAssessmentScalarWhereInput[]
  }

  export type SurveyStatusMappingCreateNestedManyWithoutStatusInput = {
    create?: XOR<SurveyStatusMappingCreateWithoutStatusInput, SurveyStatusMappingUncheckedCreateWithoutStatusInput> | SurveyStatusMappingCreateWithoutStatusInput[] | SurveyStatusMappingUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: SurveyStatusMappingCreateOrConnectWithoutStatusInput | SurveyStatusMappingCreateOrConnectWithoutStatusInput[]
    createMany?: SurveyStatusMappingCreateManyStatusInputEnvelope
    connect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
  }

  export type SurveyStatusMappingCreateNestedManyWithoutRevertedFromInput = {
    create?: XOR<SurveyStatusMappingCreateWithoutRevertedFromInput, SurveyStatusMappingUncheckedCreateWithoutRevertedFromInput> | SurveyStatusMappingCreateWithoutRevertedFromInput[] | SurveyStatusMappingUncheckedCreateWithoutRevertedFromInput[]
    connectOrCreate?: SurveyStatusMappingCreateOrConnectWithoutRevertedFromInput | SurveyStatusMappingCreateOrConnectWithoutRevertedFromInput[]
    createMany?: SurveyStatusMappingCreateManyRevertedFromInputEnvelope
    connect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
  }

  export type SurveyStatusMappingUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<SurveyStatusMappingCreateWithoutStatusInput, SurveyStatusMappingUncheckedCreateWithoutStatusInput> | SurveyStatusMappingCreateWithoutStatusInput[] | SurveyStatusMappingUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: SurveyStatusMappingCreateOrConnectWithoutStatusInput | SurveyStatusMappingCreateOrConnectWithoutStatusInput[]
    createMany?: SurveyStatusMappingCreateManyStatusInputEnvelope
    connect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
  }

  export type SurveyStatusMappingUncheckedCreateNestedManyWithoutRevertedFromInput = {
    create?: XOR<SurveyStatusMappingCreateWithoutRevertedFromInput, SurveyStatusMappingUncheckedCreateWithoutRevertedFromInput> | SurveyStatusMappingCreateWithoutRevertedFromInput[] | SurveyStatusMappingUncheckedCreateWithoutRevertedFromInput[]
    connectOrCreate?: SurveyStatusMappingCreateOrConnectWithoutRevertedFromInput | SurveyStatusMappingCreateOrConnectWithoutRevertedFromInput[]
    createMany?: SurveyStatusMappingCreateManyRevertedFromInputEnvelope
    connect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
  }

  export type SurveyStatusMappingUpdateManyWithoutStatusNestedInput = {
    create?: XOR<SurveyStatusMappingCreateWithoutStatusInput, SurveyStatusMappingUncheckedCreateWithoutStatusInput> | SurveyStatusMappingCreateWithoutStatusInput[] | SurveyStatusMappingUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: SurveyStatusMappingCreateOrConnectWithoutStatusInput | SurveyStatusMappingCreateOrConnectWithoutStatusInput[]
    upsert?: SurveyStatusMappingUpsertWithWhereUniqueWithoutStatusInput | SurveyStatusMappingUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: SurveyStatusMappingCreateManyStatusInputEnvelope
    set?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    disconnect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    delete?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    connect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    update?: SurveyStatusMappingUpdateWithWhereUniqueWithoutStatusInput | SurveyStatusMappingUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: SurveyStatusMappingUpdateManyWithWhereWithoutStatusInput | SurveyStatusMappingUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: SurveyStatusMappingScalarWhereInput | SurveyStatusMappingScalarWhereInput[]
  }

  export type SurveyStatusMappingUpdateManyWithoutRevertedFromNestedInput = {
    create?: XOR<SurveyStatusMappingCreateWithoutRevertedFromInput, SurveyStatusMappingUncheckedCreateWithoutRevertedFromInput> | SurveyStatusMappingCreateWithoutRevertedFromInput[] | SurveyStatusMappingUncheckedCreateWithoutRevertedFromInput[]
    connectOrCreate?: SurveyStatusMappingCreateOrConnectWithoutRevertedFromInput | SurveyStatusMappingCreateOrConnectWithoutRevertedFromInput[]
    upsert?: SurveyStatusMappingUpsertWithWhereUniqueWithoutRevertedFromInput | SurveyStatusMappingUpsertWithWhereUniqueWithoutRevertedFromInput[]
    createMany?: SurveyStatusMappingCreateManyRevertedFromInputEnvelope
    set?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    disconnect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    delete?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    connect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    update?: SurveyStatusMappingUpdateWithWhereUniqueWithoutRevertedFromInput | SurveyStatusMappingUpdateWithWhereUniqueWithoutRevertedFromInput[]
    updateMany?: SurveyStatusMappingUpdateManyWithWhereWithoutRevertedFromInput | SurveyStatusMappingUpdateManyWithWhereWithoutRevertedFromInput[]
    deleteMany?: SurveyStatusMappingScalarWhereInput | SurveyStatusMappingScalarWhereInput[]
  }

  export type SurveyStatusMappingUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<SurveyStatusMappingCreateWithoutStatusInput, SurveyStatusMappingUncheckedCreateWithoutStatusInput> | SurveyStatusMappingCreateWithoutStatusInput[] | SurveyStatusMappingUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: SurveyStatusMappingCreateOrConnectWithoutStatusInput | SurveyStatusMappingCreateOrConnectWithoutStatusInput[]
    upsert?: SurveyStatusMappingUpsertWithWhereUniqueWithoutStatusInput | SurveyStatusMappingUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: SurveyStatusMappingCreateManyStatusInputEnvelope
    set?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    disconnect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    delete?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    connect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    update?: SurveyStatusMappingUpdateWithWhereUniqueWithoutStatusInput | SurveyStatusMappingUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: SurveyStatusMappingUpdateManyWithWhereWithoutStatusInput | SurveyStatusMappingUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: SurveyStatusMappingScalarWhereInput | SurveyStatusMappingScalarWhereInput[]
  }

  export type SurveyStatusMappingUncheckedUpdateManyWithoutRevertedFromNestedInput = {
    create?: XOR<SurveyStatusMappingCreateWithoutRevertedFromInput, SurveyStatusMappingUncheckedCreateWithoutRevertedFromInput> | SurveyStatusMappingCreateWithoutRevertedFromInput[] | SurveyStatusMappingUncheckedCreateWithoutRevertedFromInput[]
    connectOrCreate?: SurveyStatusMappingCreateOrConnectWithoutRevertedFromInput | SurveyStatusMappingCreateOrConnectWithoutRevertedFromInput[]
    upsert?: SurveyStatusMappingUpsertWithWhereUniqueWithoutRevertedFromInput | SurveyStatusMappingUpsertWithWhereUniqueWithoutRevertedFromInput[]
    createMany?: SurveyStatusMappingCreateManyRevertedFromInputEnvelope
    set?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    disconnect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    delete?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    connect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    update?: SurveyStatusMappingUpdateWithWhereUniqueWithoutRevertedFromInput | SurveyStatusMappingUpdateWithWhereUniqueWithoutRevertedFromInput[]
    updateMany?: SurveyStatusMappingUpdateManyWithWhereWithoutRevertedFromInput | SurveyStatusMappingUpdateManyWithWhereWithoutRevertedFromInput[]
    deleteMany?: SurveyStatusMappingScalarWhereInput | SurveyStatusMappingScalarWhereInput[]
  }

  export type WardStatusMappingCreateNestedManyWithoutStatusInput = {
    create?: XOR<WardStatusMappingCreateWithoutStatusInput, WardStatusMappingUncheckedCreateWithoutStatusInput> | WardStatusMappingCreateWithoutStatusInput[] | WardStatusMappingUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: WardStatusMappingCreateOrConnectWithoutStatusInput | WardStatusMappingCreateOrConnectWithoutStatusInput[]
    createMany?: WardStatusMappingCreateManyStatusInputEnvelope
    connect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
  }

  export type WardStatusMappingUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<WardStatusMappingCreateWithoutStatusInput, WardStatusMappingUncheckedCreateWithoutStatusInput> | WardStatusMappingCreateWithoutStatusInput[] | WardStatusMappingUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: WardStatusMappingCreateOrConnectWithoutStatusInput | WardStatusMappingCreateOrConnectWithoutStatusInput[]
    createMany?: WardStatusMappingCreateManyStatusInputEnvelope
    connect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
  }

  export type WardStatusMappingUpdateManyWithoutStatusNestedInput = {
    create?: XOR<WardStatusMappingCreateWithoutStatusInput, WardStatusMappingUncheckedCreateWithoutStatusInput> | WardStatusMappingCreateWithoutStatusInput[] | WardStatusMappingUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: WardStatusMappingCreateOrConnectWithoutStatusInput | WardStatusMappingCreateOrConnectWithoutStatusInput[]
    upsert?: WardStatusMappingUpsertWithWhereUniqueWithoutStatusInput | WardStatusMappingUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: WardStatusMappingCreateManyStatusInputEnvelope
    set?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    disconnect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    delete?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    connect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    update?: WardStatusMappingUpdateWithWhereUniqueWithoutStatusInput | WardStatusMappingUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: WardStatusMappingUpdateManyWithWhereWithoutStatusInput | WardStatusMappingUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: WardStatusMappingScalarWhereInput | WardStatusMappingScalarWhereInput[]
  }

  export type WardStatusMappingUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<WardStatusMappingCreateWithoutStatusInput, WardStatusMappingUncheckedCreateWithoutStatusInput> | WardStatusMappingCreateWithoutStatusInput[] | WardStatusMappingUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: WardStatusMappingCreateOrConnectWithoutStatusInput | WardStatusMappingCreateOrConnectWithoutStatusInput[]
    upsert?: WardStatusMappingUpsertWithWhereUniqueWithoutStatusInput | WardStatusMappingUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: WardStatusMappingCreateManyStatusInputEnvelope
    set?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    disconnect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    delete?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    connect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    update?: WardStatusMappingUpdateWithWhereUniqueWithoutStatusInput | WardStatusMappingUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: WardStatusMappingUpdateManyWithWhereWithoutStatusInput | WardStatusMappingUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: WardStatusMappingScalarWhereInput | WardStatusMappingScalarWhereInput[]
  }

  export type SurveyorAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutUserInput, SurveyorAssignmentUncheckedCreateWithoutUserInput> | SurveyorAssignmentCreateWithoutUserInput[] | SurveyorAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutUserInput | SurveyorAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: SurveyorAssignmentCreateManyUserInputEnvelope
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
  }

  export type SurveyorAssignmentCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutAssignedByInput, SurveyorAssignmentUncheckedCreateWithoutAssignedByInput> | SurveyorAssignmentCreateWithoutAssignedByInput[] | SurveyorAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutAssignedByInput | SurveyorAssignmentCreateOrConnectWithoutAssignedByInput[]
    createMany?: SurveyorAssignmentCreateManyAssignedByInputEnvelope
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
  }

  export type WardStatusMappingCreateNestedManyWithoutChangedByInput = {
    create?: XOR<WardStatusMappingCreateWithoutChangedByInput, WardStatusMappingUncheckedCreateWithoutChangedByInput> | WardStatusMappingCreateWithoutChangedByInput[] | WardStatusMappingUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: WardStatusMappingCreateOrConnectWithoutChangedByInput | WardStatusMappingCreateOrConnectWithoutChangedByInput[]
    createMany?: WardStatusMappingCreateManyChangedByInputEnvelope
    connect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
  }

  export type SurveyStatusMappingCreateNestedManyWithoutChangedByInput = {
    create?: XOR<SurveyStatusMappingCreateWithoutChangedByInput, SurveyStatusMappingUncheckedCreateWithoutChangedByInput> | SurveyStatusMappingCreateWithoutChangedByInput[] | SurveyStatusMappingUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: SurveyStatusMappingCreateOrConnectWithoutChangedByInput | SurveyStatusMappingCreateOrConnectWithoutChangedByInput[]
    createMany?: SurveyStatusMappingCreateManyChangedByInputEnvelope
    connect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
  }

  export type UserRoleMappingCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleMappingCreateWithoutUserInput, UserRoleMappingUncheckedCreateWithoutUserInput> | UserRoleMappingCreateWithoutUserInput[] | UserRoleMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleMappingCreateOrConnectWithoutUserInput | UserRoleMappingCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleMappingCreateManyUserInputEnvelope
    connect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SurveyorsCreateNestedManyWithoutUserInput = {
    create?: XOR<SurveyorsCreateWithoutUserInput, SurveyorsUncheckedCreateWithoutUserInput> | SurveyorsCreateWithoutUserInput[] | SurveyorsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SurveyorsCreateOrConnectWithoutUserInput | SurveyorsCreateOrConnectWithoutUserInput[]
    createMany?: SurveyorsCreateManyUserInputEnvelope
    connect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
  }

  export type SupervisorsCreateNestedManyWithoutUserInput = {
    create?: XOR<SupervisorsCreateWithoutUserInput, SupervisorsUncheckedCreateWithoutUserInput> | SupervisorsCreateWithoutUserInput[] | SupervisorsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupervisorsCreateOrConnectWithoutUserInput | SupervisorsCreateOrConnectWithoutUserInput[]
    createMany?: SupervisorsCreateManyUserInputEnvelope
    connect?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
  }

  export type AdminsCreateNestedManyWithoutUserInput = {
    create?: XOR<AdminsCreateWithoutUserInput, AdminsUncheckedCreateWithoutUserInput> | AdminsCreateWithoutUserInput[] | AdminsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminsCreateOrConnectWithoutUserInput | AdminsCreateOrConnectWithoutUserInput[]
    createMany?: AdminsCreateManyUserInputEnvelope
    connect?: AdminsWhereUniqueInput | AdminsWhereUniqueInput[]
  }

  export type SurveyorAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutUserInput, SurveyorAssignmentUncheckedCreateWithoutUserInput> | SurveyorAssignmentCreateWithoutUserInput[] | SurveyorAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutUserInput | SurveyorAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: SurveyorAssignmentCreateManyUserInputEnvelope
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
  }

  export type SurveyorAssignmentUncheckedCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutAssignedByInput, SurveyorAssignmentUncheckedCreateWithoutAssignedByInput> | SurveyorAssignmentCreateWithoutAssignedByInput[] | SurveyorAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutAssignedByInput | SurveyorAssignmentCreateOrConnectWithoutAssignedByInput[]
    createMany?: SurveyorAssignmentCreateManyAssignedByInputEnvelope
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
  }

  export type WardStatusMappingUncheckedCreateNestedManyWithoutChangedByInput = {
    create?: XOR<WardStatusMappingCreateWithoutChangedByInput, WardStatusMappingUncheckedCreateWithoutChangedByInput> | WardStatusMappingCreateWithoutChangedByInput[] | WardStatusMappingUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: WardStatusMappingCreateOrConnectWithoutChangedByInput | WardStatusMappingCreateOrConnectWithoutChangedByInput[]
    createMany?: WardStatusMappingCreateManyChangedByInputEnvelope
    connect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
  }

  export type SurveyStatusMappingUncheckedCreateNestedManyWithoutChangedByInput = {
    create?: XOR<SurveyStatusMappingCreateWithoutChangedByInput, SurveyStatusMappingUncheckedCreateWithoutChangedByInput> | SurveyStatusMappingCreateWithoutChangedByInput[] | SurveyStatusMappingUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: SurveyStatusMappingCreateOrConnectWithoutChangedByInput | SurveyStatusMappingCreateOrConnectWithoutChangedByInput[]
    createMany?: SurveyStatusMappingCreateManyChangedByInputEnvelope
    connect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
  }

  export type UserRoleMappingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleMappingCreateWithoutUserInput, UserRoleMappingUncheckedCreateWithoutUserInput> | UserRoleMappingCreateWithoutUserInput[] | UserRoleMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleMappingCreateOrConnectWithoutUserInput | UserRoleMappingCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleMappingCreateManyUserInputEnvelope
    connect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SurveyorsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SurveyorsCreateWithoutUserInput, SurveyorsUncheckedCreateWithoutUserInput> | SurveyorsCreateWithoutUserInput[] | SurveyorsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SurveyorsCreateOrConnectWithoutUserInput | SurveyorsCreateOrConnectWithoutUserInput[]
    createMany?: SurveyorsCreateManyUserInputEnvelope
    connect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
  }

  export type SupervisorsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SupervisorsCreateWithoutUserInput, SupervisorsUncheckedCreateWithoutUserInput> | SupervisorsCreateWithoutUserInput[] | SupervisorsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupervisorsCreateOrConnectWithoutUserInput | SupervisorsCreateOrConnectWithoutUserInput[]
    createMany?: SupervisorsCreateManyUserInputEnvelope
    connect?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
  }

  export type AdminsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AdminsCreateWithoutUserInput, AdminsUncheckedCreateWithoutUserInput> | AdminsCreateWithoutUserInput[] | AdminsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminsCreateOrConnectWithoutUserInput | AdminsCreateOrConnectWithoutUserInput[]
    createMany?: AdminsCreateManyUserInputEnvelope
    connect?: AdminsWhereUniqueInput | AdminsWhereUniqueInput[]
  }

  export type SurveyorAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutUserInput, SurveyorAssignmentUncheckedCreateWithoutUserInput> | SurveyorAssignmentCreateWithoutUserInput[] | SurveyorAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutUserInput | SurveyorAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: SurveyorAssignmentUpsertWithWhereUniqueWithoutUserInput | SurveyorAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SurveyorAssignmentCreateManyUserInputEnvelope
    set?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    disconnect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    delete?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    update?: SurveyorAssignmentUpdateWithWhereUniqueWithoutUserInput | SurveyorAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SurveyorAssignmentUpdateManyWithWhereWithoutUserInput | SurveyorAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SurveyorAssignmentScalarWhereInput | SurveyorAssignmentScalarWhereInput[]
  }

  export type SurveyorAssignmentUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutAssignedByInput, SurveyorAssignmentUncheckedCreateWithoutAssignedByInput> | SurveyorAssignmentCreateWithoutAssignedByInput[] | SurveyorAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutAssignedByInput | SurveyorAssignmentCreateOrConnectWithoutAssignedByInput[]
    upsert?: SurveyorAssignmentUpsertWithWhereUniqueWithoutAssignedByInput | SurveyorAssignmentUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: SurveyorAssignmentCreateManyAssignedByInputEnvelope
    set?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    disconnect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    delete?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    update?: SurveyorAssignmentUpdateWithWhereUniqueWithoutAssignedByInput | SurveyorAssignmentUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: SurveyorAssignmentUpdateManyWithWhereWithoutAssignedByInput | SurveyorAssignmentUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: SurveyorAssignmentScalarWhereInput | SurveyorAssignmentScalarWhereInput[]
  }

  export type WardStatusMappingUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<WardStatusMappingCreateWithoutChangedByInput, WardStatusMappingUncheckedCreateWithoutChangedByInput> | WardStatusMappingCreateWithoutChangedByInput[] | WardStatusMappingUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: WardStatusMappingCreateOrConnectWithoutChangedByInput | WardStatusMappingCreateOrConnectWithoutChangedByInput[]
    upsert?: WardStatusMappingUpsertWithWhereUniqueWithoutChangedByInput | WardStatusMappingUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: WardStatusMappingCreateManyChangedByInputEnvelope
    set?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    disconnect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    delete?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    connect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    update?: WardStatusMappingUpdateWithWhereUniqueWithoutChangedByInput | WardStatusMappingUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: WardStatusMappingUpdateManyWithWhereWithoutChangedByInput | WardStatusMappingUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: WardStatusMappingScalarWhereInput | WardStatusMappingScalarWhereInput[]
  }

  export type SurveyStatusMappingUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<SurveyStatusMappingCreateWithoutChangedByInput, SurveyStatusMappingUncheckedCreateWithoutChangedByInput> | SurveyStatusMappingCreateWithoutChangedByInput[] | SurveyStatusMappingUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: SurveyStatusMappingCreateOrConnectWithoutChangedByInput | SurveyStatusMappingCreateOrConnectWithoutChangedByInput[]
    upsert?: SurveyStatusMappingUpsertWithWhereUniqueWithoutChangedByInput | SurveyStatusMappingUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: SurveyStatusMappingCreateManyChangedByInputEnvelope
    set?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    disconnect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    delete?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    connect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    update?: SurveyStatusMappingUpdateWithWhereUniqueWithoutChangedByInput | SurveyStatusMappingUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: SurveyStatusMappingUpdateManyWithWhereWithoutChangedByInput | SurveyStatusMappingUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: SurveyStatusMappingScalarWhereInput | SurveyStatusMappingScalarWhereInput[]
  }

  export type UserRoleMappingUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleMappingCreateWithoutUserInput, UserRoleMappingUncheckedCreateWithoutUserInput> | UserRoleMappingCreateWithoutUserInput[] | UserRoleMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleMappingCreateOrConnectWithoutUserInput | UserRoleMappingCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleMappingUpsertWithWhereUniqueWithoutUserInput | UserRoleMappingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleMappingCreateManyUserInputEnvelope
    set?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    disconnect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    delete?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    connect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    update?: UserRoleMappingUpdateWithWhereUniqueWithoutUserInput | UserRoleMappingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleMappingUpdateManyWithWhereWithoutUserInput | UserRoleMappingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleMappingScalarWhereInput | UserRoleMappingScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SurveyorsUpdateManyWithoutUserNestedInput = {
    create?: XOR<SurveyorsCreateWithoutUserInput, SurveyorsUncheckedCreateWithoutUserInput> | SurveyorsCreateWithoutUserInput[] | SurveyorsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SurveyorsCreateOrConnectWithoutUserInput | SurveyorsCreateOrConnectWithoutUserInput[]
    upsert?: SurveyorsUpsertWithWhereUniqueWithoutUserInput | SurveyorsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SurveyorsCreateManyUserInputEnvelope
    set?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    disconnect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    delete?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    connect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    update?: SurveyorsUpdateWithWhereUniqueWithoutUserInput | SurveyorsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SurveyorsUpdateManyWithWhereWithoutUserInput | SurveyorsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SurveyorsScalarWhereInput | SurveyorsScalarWhereInput[]
  }

  export type SupervisorsUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupervisorsCreateWithoutUserInput, SupervisorsUncheckedCreateWithoutUserInput> | SupervisorsCreateWithoutUserInput[] | SupervisorsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupervisorsCreateOrConnectWithoutUserInput | SupervisorsCreateOrConnectWithoutUserInput[]
    upsert?: SupervisorsUpsertWithWhereUniqueWithoutUserInput | SupervisorsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupervisorsCreateManyUserInputEnvelope
    set?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
    disconnect?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
    delete?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
    connect?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
    update?: SupervisorsUpdateWithWhereUniqueWithoutUserInput | SupervisorsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupervisorsUpdateManyWithWhereWithoutUserInput | SupervisorsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupervisorsScalarWhereInput | SupervisorsScalarWhereInput[]
  }

  export type AdminsUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdminsCreateWithoutUserInput, AdminsUncheckedCreateWithoutUserInput> | AdminsCreateWithoutUserInput[] | AdminsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminsCreateOrConnectWithoutUserInput | AdminsCreateOrConnectWithoutUserInput[]
    upsert?: AdminsUpsertWithWhereUniqueWithoutUserInput | AdminsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdminsCreateManyUserInputEnvelope
    set?: AdminsWhereUniqueInput | AdminsWhereUniqueInput[]
    disconnect?: AdminsWhereUniqueInput | AdminsWhereUniqueInput[]
    delete?: AdminsWhereUniqueInput | AdminsWhereUniqueInput[]
    connect?: AdminsWhereUniqueInput | AdminsWhereUniqueInput[]
    update?: AdminsUpdateWithWhereUniqueWithoutUserInput | AdminsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdminsUpdateManyWithWhereWithoutUserInput | AdminsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdminsScalarWhereInput | AdminsScalarWhereInput[]
  }

  export type SurveyorAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutUserInput, SurveyorAssignmentUncheckedCreateWithoutUserInput> | SurveyorAssignmentCreateWithoutUserInput[] | SurveyorAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutUserInput | SurveyorAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: SurveyorAssignmentUpsertWithWhereUniqueWithoutUserInput | SurveyorAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SurveyorAssignmentCreateManyUserInputEnvelope
    set?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    disconnect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    delete?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    update?: SurveyorAssignmentUpdateWithWhereUniqueWithoutUserInput | SurveyorAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SurveyorAssignmentUpdateManyWithWhereWithoutUserInput | SurveyorAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SurveyorAssignmentScalarWhereInput | SurveyorAssignmentScalarWhereInput[]
  }

  export type SurveyorAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutAssignedByInput, SurveyorAssignmentUncheckedCreateWithoutAssignedByInput> | SurveyorAssignmentCreateWithoutAssignedByInput[] | SurveyorAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutAssignedByInput | SurveyorAssignmentCreateOrConnectWithoutAssignedByInput[]
    upsert?: SurveyorAssignmentUpsertWithWhereUniqueWithoutAssignedByInput | SurveyorAssignmentUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: SurveyorAssignmentCreateManyAssignedByInputEnvelope
    set?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    disconnect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    delete?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    update?: SurveyorAssignmentUpdateWithWhereUniqueWithoutAssignedByInput | SurveyorAssignmentUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: SurveyorAssignmentUpdateManyWithWhereWithoutAssignedByInput | SurveyorAssignmentUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: SurveyorAssignmentScalarWhereInput | SurveyorAssignmentScalarWhereInput[]
  }

  export type WardStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<WardStatusMappingCreateWithoutChangedByInput, WardStatusMappingUncheckedCreateWithoutChangedByInput> | WardStatusMappingCreateWithoutChangedByInput[] | WardStatusMappingUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: WardStatusMappingCreateOrConnectWithoutChangedByInput | WardStatusMappingCreateOrConnectWithoutChangedByInput[]
    upsert?: WardStatusMappingUpsertWithWhereUniqueWithoutChangedByInput | WardStatusMappingUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: WardStatusMappingCreateManyChangedByInputEnvelope
    set?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    disconnect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    delete?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    connect?: WardStatusMappingWhereUniqueInput | WardStatusMappingWhereUniqueInput[]
    update?: WardStatusMappingUpdateWithWhereUniqueWithoutChangedByInput | WardStatusMappingUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: WardStatusMappingUpdateManyWithWhereWithoutChangedByInput | WardStatusMappingUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: WardStatusMappingScalarWhereInput | WardStatusMappingScalarWhereInput[]
  }

  export type SurveyStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<SurveyStatusMappingCreateWithoutChangedByInput, SurveyStatusMappingUncheckedCreateWithoutChangedByInput> | SurveyStatusMappingCreateWithoutChangedByInput[] | SurveyStatusMappingUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: SurveyStatusMappingCreateOrConnectWithoutChangedByInput | SurveyStatusMappingCreateOrConnectWithoutChangedByInput[]
    upsert?: SurveyStatusMappingUpsertWithWhereUniqueWithoutChangedByInput | SurveyStatusMappingUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: SurveyStatusMappingCreateManyChangedByInputEnvelope
    set?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    disconnect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    delete?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    connect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    update?: SurveyStatusMappingUpdateWithWhereUniqueWithoutChangedByInput | SurveyStatusMappingUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: SurveyStatusMappingUpdateManyWithWhereWithoutChangedByInput | SurveyStatusMappingUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: SurveyStatusMappingScalarWhereInput | SurveyStatusMappingScalarWhereInput[]
  }

  export type UserRoleMappingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleMappingCreateWithoutUserInput, UserRoleMappingUncheckedCreateWithoutUserInput> | UserRoleMappingCreateWithoutUserInput[] | UserRoleMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleMappingCreateOrConnectWithoutUserInput | UserRoleMappingCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleMappingUpsertWithWhereUniqueWithoutUserInput | UserRoleMappingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleMappingCreateManyUserInputEnvelope
    set?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    disconnect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    delete?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    connect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    update?: UserRoleMappingUpdateWithWhereUniqueWithoutUserInput | UserRoleMappingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleMappingUpdateManyWithWhereWithoutUserInput | UserRoleMappingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleMappingScalarWhereInput | UserRoleMappingScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SurveyorsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SurveyorsCreateWithoutUserInput, SurveyorsUncheckedCreateWithoutUserInput> | SurveyorsCreateWithoutUserInput[] | SurveyorsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SurveyorsCreateOrConnectWithoutUserInput | SurveyorsCreateOrConnectWithoutUserInput[]
    upsert?: SurveyorsUpsertWithWhereUniqueWithoutUserInput | SurveyorsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SurveyorsCreateManyUserInputEnvelope
    set?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    disconnect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    delete?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    connect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    update?: SurveyorsUpdateWithWhereUniqueWithoutUserInput | SurveyorsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SurveyorsUpdateManyWithWhereWithoutUserInput | SurveyorsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SurveyorsScalarWhereInput | SurveyorsScalarWhereInput[]
  }

  export type SupervisorsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupervisorsCreateWithoutUserInput, SupervisorsUncheckedCreateWithoutUserInput> | SupervisorsCreateWithoutUserInput[] | SupervisorsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupervisorsCreateOrConnectWithoutUserInput | SupervisorsCreateOrConnectWithoutUserInput[]
    upsert?: SupervisorsUpsertWithWhereUniqueWithoutUserInput | SupervisorsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupervisorsCreateManyUserInputEnvelope
    set?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
    disconnect?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
    delete?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
    connect?: SupervisorsWhereUniqueInput | SupervisorsWhereUniqueInput[]
    update?: SupervisorsUpdateWithWhereUniqueWithoutUserInput | SupervisorsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupervisorsUpdateManyWithWhereWithoutUserInput | SupervisorsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupervisorsScalarWhereInput | SupervisorsScalarWhereInput[]
  }

  export type AdminsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdminsCreateWithoutUserInput, AdminsUncheckedCreateWithoutUserInput> | AdminsCreateWithoutUserInput[] | AdminsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminsCreateOrConnectWithoutUserInput | AdminsCreateOrConnectWithoutUserInput[]
    upsert?: AdminsUpsertWithWhereUniqueWithoutUserInput | AdminsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdminsCreateManyUserInputEnvelope
    set?: AdminsWhereUniqueInput | AdminsWhereUniqueInput[]
    disconnect?: AdminsWhereUniqueInput | AdminsWhereUniqueInput[]
    delete?: AdminsWhereUniqueInput | AdminsWhereUniqueInput[]
    connect?: AdminsWhereUniqueInput | AdminsWhereUniqueInput[]
    update?: AdminsUpdateWithWhereUniqueWithoutUserInput | AdminsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdminsUpdateManyWithWhereWithoutUserInput | AdminsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdminsScalarWhereInput | AdminsScalarWhereInput[]
  }

  export type UserRoleMappingCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleMappingCreateWithoutRoleInput, UserRoleMappingUncheckedCreateWithoutRoleInput> | UserRoleMappingCreateWithoutRoleInput[] | UserRoleMappingUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleMappingCreateOrConnectWithoutRoleInput | UserRoleMappingCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleMappingCreateManyRoleInputEnvelope
    connect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
  }

  export type UserRoleMappingUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleMappingCreateWithoutRoleInput, UserRoleMappingUncheckedCreateWithoutRoleInput> | UserRoleMappingCreateWithoutRoleInput[] | UserRoleMappingUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleMappingCreateOrConnectWithoutRoleInput | UserRoleMappingCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleMappingCreateManyRoleInputEnvelope
    connect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
  }

  export type UserRoleMappingUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleMappingCreateWithoutRoleInput, UserRoleMappingUncheckedCreateWithoutRoleInput> | UserRoleMappingCreateWithoutRoleInput[] | UserRoleMappingUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleMappingCreateOrConnectWithoutRoleInput | UserRoleMappingCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleMappingUpsertWithWhereUniqueWithoutRoleInput | UserRoleMappingUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleMappingCreateManyRoleInputEnvelope
    set?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    disconnect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    delete?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    connect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    update?: UserRoleMappingUpdateWithWhereUniqueWithoutRoleInput | UserRoleMappingUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleMappingUpdateManyWithWhereWithoutRoleInput | UserRoleMappingUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleMappingScalarWhereInput | UserRoleMappingScalarWhereInput[]
  }

  export type UserRoleMappingUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleMappingCreateWithoutRoleInput, UserRoleMappingUncheckedCreateWithoutRoleInput> | UserRoleMappingCreateWithoutRoleInput[] | UserRoleMappingUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleMappingCreateOrConnectWithoutRoleInput | UserRoleMappingCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleMappingUpsertWithWhereUniqueWithoutRoleInput | UserRoleMappingUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleMappingCreateManyRoleInputEnvelope
    set?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    disconnect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    delete?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    connect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    update?: UserRoleMappingUpdateWithWhereUniqueWithoutRoleInput | UserRoleMappingUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleMappingUpdateManyWithWhereWithoutRoleInput | UserRoleMappingUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleMappingScalarWhereInput | UserRoleMappingScalarWhereInput[]
  }

  export type UlbMasterCreateNestedOneWithoutUlbZoneMapsInput = {
    create?: XOR<UlbMasterCreateWithoutUlbZoneMapsInput, UlbMasterUncheckedCreateWithoutUlbZoneMapsInput>
    connectOrCreate?: UlbMasterCreateOrConnectWithoutUlbZoneMapsInput
    connect?: UlbMasterWhereUniqueInput
  }

  export type ZoneMasterCreateNestedOneWithoutUlbZoneMapsInput = {
    create?: XOR<ZoneMasterCreateWithoutUlbZoneMapsInput, ZoneMasterUncheckedCreateWithoutUlbZoneMapsInput>
    connectOrCreate?: ZoneMasterCreateOrConnectWithoutUlbZoneMapsInput
    connect?: ZoneMasterWhereUniqueInput
  }

  export type SurveyorsCreateNestedManyWithoutUlbZoneMapInput = {
    create?: XOR<SurveyorsCreateWithoutUlbZoneMapInput, SurveyorsUncheckedCreateWithoutUlbZoneMapInput> | SurveyorsCreateWithoutUlbZoneMapInput[] | SurveyorsUncheckedCreateWithoutUlbZoneMapInput[]
    connectOrCreate?: SurveyorsCreateOrConnectWithoutUlbZoneMapInput | SurveyorsCreateOrConnectWithoutUlbZoneMapInput[]
    createMany?: SurveyorsCreateManyUlbZoneMapInputEnvelope
    connect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
  }

  export type SurveyorsUncheckedCreateNestedManyWithoutUlbZoneMapInput = {
    create?: XOR<SurveyorsCreateWithoutUlbZoneMapInput, SurveyorsUncheckedCreateWithoutUlbZoneMapInput> | SurveyorsCreateWithoutUlbZoneMapInput[] | SurveyorsUncheckedCreateWithoutUlbZoneMapInput[]
    connectOrCreate?: SurveyorsCreateOrConnectWithoutUlbZoneMapInput | SurveyorsCreateOrConnectWithoutUlbZoneMapInput[]
    createMany?: SurveyorsCreateManyUlbZoneMapInputEnvelope
    connect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
  }

  export type UlbMasterUpdateOneRequiredWithoutUlbZoneMapsNestedInput = {
    create?: XOR<UlbMasterCreateWithoutUlbZoneMapsInput, UlbMasterUncheckedCreateWithoutUlbZoneMapsInput>
    connectOrCreate?: UlbMasterCreateOrConnectWithoutUlbZoneMapsInput
    upsert?: UlbMasterUpsertWithoutUlbZoneMapsInput
    connect?: UlbMasterWhereUniqueInput
    update?: XOR<XOR<UlbMasterUpdateToOneWithWhereWithoutUlbZoneMapsInput, UlbMasterUpdateWithoutUlbZoneMapsInput>, UlbMasterUncheckedUpdateWithoutUlbZoneMapsInput>
  }

  export type ZoneMasterUpdateOneRequiredWithoutUlbZoneMapsNestedInput = {
    create?: XOR<ZoneMasterCreateWithoutUlbZoneMapsInput, ZoneMasterUncheckedCreateWithoutUlbZoneMapsInput>
    connectOrCreate?: ZoneMasterCreateOrConnectWithoutUlbZoneMapsInput
    upsert?: ZoneMasterUpsertWithoutUlbZoneMapsInput
    connect?: ZoneMasterWhereUniqueInput
    update?: XOR<XOR<ZoneMasterUpdateToOneWithWhereWithoutUlbZoneMapsInput, ZoneMasterUpdateWithoutUlbZoneMapsInput>, ZoneMasterUncheckedUpdateWithoutUlbZoneMapsInput>
  }

  export type SurveyorsUpdateManyWithoutUlbZoneMapNestedInput = {
    create?: XOR<SurveyorsCreateWithoutUlbZoneMapInput, SurveyorsUncheckedCreateWithoutUlbZoneMapInput> | SurveyorsCreateWithoutUlbZoneMapInput[] | SurveyorsUncheckedCreateWithoutUlbZoneMapInput[]
    connectOrCreate?: SurveyorsCreateOrConnectWithoutUlbZoneMapInput | SurveyorsCreateOrConnectWithoutUlbZoneMapInput[]
    upsert?: SurveyorsUpsertWithWhereUniqueWithoutUlbZoneMapInput | SurveyorsUpsertWithWhereUniqueWithoutUlbZoneMapInput[]
    createMany?: SurveyorsCreateManyUlbZoneMapInputEnvelope
    set?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    disconnect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    delete?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    connect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    update?: SurveyorsUpdateWithWhereUniqueWithoutUlbZoneMapInput | SurveyorsUpdateWithWhereUniqueWithoutUlbZoneMapInput[]
    updateMany?: SurveyorsUpdateManyWithWhereWithoutUlbZoneMapInput | SurveyorsUpdateManyWithWhereWithoutUlbZoneMapInput[]
    deleteMany?: SurveyorsScalarWhereInput | SurveyorsScalarWhereInput[]
  }

  export type SurveyorsUncheckedUpdateManyWithoutUlbZoneMapNestedInput = {
    create?: XOR<SurveyorsCreateWithoutUlbZoneMapInput, SurveyorsUncheckedCreateWithoutUlbZoneMapInput> | SurveyorsCreateWithoutUlbZoneMapInput[] | SurveyorsUncheckedCreateWithoutUlbZoneMapInput[]
    connectOrCreate?: SurveyorsCreateOrConnectWithoutUlbZoneMapInput | SurveyorsCreateOrConnectWithoutUlbZoneMapInput[]
    upsert?: SurveyorsUpsertWithWhereUniqueWithoutUlbZoneMapInput | SurveyorsUpsertWithWhereUniqueWithoutUlbZoneMapInput[]
    createMany?: SurveyorsCreateManyUlbZoneMapInputEnvelope
    set?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    disconnect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    delete?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    connect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    update?: SurveyorsUpdateWithWhereUniqueWithoutUlbZoneMapInput | SurveyorsUpdateWithWhereUniqueWithoutUlbZoneMapInput[]
    updateMany?: SurveyorsUpdateManyWithWhereWithoutUlbZoneMapInput | SurveyorsUpdateManyWithWhereWithoutUlbZoneMapInput[]
    deleteMany?: SurveyorsScalarWhereInput | SurveyorsScalarWhereInput[]
  }

  export type ZoneMasterCreateNestedOneWithoutZoneWardMapsInput = {
    create?: XOR<ZoneMasterCreateWithoutZoneWardMapsInput, ZoneMasterUncheckedCreateWithoutZoneWardMapsInput>
    connectOrCreate?: ZoneMasterCreateOrConnectWithoutZoneWardMapsInput
    connect?: ZoneMasterWhereUniqueInput
  }

  export type WardMasterCreateNestedOneWithoutZoneWardMapsInput = {
    create?: XOR<WardMasterCreateWithoutZoneWardMapsInput, WardMasterUncheckedCreateWithoutZoneWardMapsInput>
    connectOrCreate?: WardMasterCreateOrConnectWithoutZoneWardMapsInput
    connect?: WardMasterWhereUniqueInput
  }

  export type SurveyorsCreateNestedManyWithoutZoneWardMapInput = {
    create?: XOR<SurveyorsCreateWithoutZoneWardMapInput, SurveyorsUncheckedCreateWithoutZoneWardMapInput> | SurveyorsCreateWithoutZoneWardMapInput[] | SurveyorsUncheckedCreateWithoutZoneWardMapInput[]
    connectOrCreate?: SurveyorsCreateOrConnectWithoutZoneWardMapInput | SurveyorsCreateOrConnectWithoutZoneWardMapInput[]
    createMany?: SurveyorsCreateManyZoneWardMapInputEnvelope
    connect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
  }

  export type SurveyorsUncheckedCreateNestedManyWithoutZoneWardMapInput = {
    create?: XOR<SurveyorsCreateWithoutZoneWardMapInput, SurveyorsUncheckedCreateWithoutZoneWardMapInput> | SurveyorsCreateWithoutZoneWardMapInput[] | SurveyorsUncheckedCreateWithoutZoneWardMapInput[]
    connectOrCreate?: SurveyorsCreateOrConnectWithoutZoneWardMapInput | SurveyorsCreateOrConnectWithoutZoneWardMapInput[]
    createMany?: SurveyorsCreateManyZoneWardMapInputEnvelope
    connect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
  }

  export type ZoneMasterUpdateOneRequiredWithoutZoneWardMapsNestedInput = {
    create?: XOR<ZoneMasterCreateWithoutZoneWardMapsInput, ZoneMasterUncheckedCreateWithoutZoneWardMapsInput>
    connectOrCreate?: ZoneMasterCreateOrConnectWithoutZoneWardMapsInput
    upsert?: ZoneMasterUpsertWithoutZoneWardMapsInput
    connect?: ZoneMasterWhereUniqueInput
    update?: XOR<XOR<ZoneMasterUpdateToOneWithWhereWithoutZoneWardMapsInput, ZoneMasterUpdateWithoutZoneWardMapsInput>, ZoneMasterUncheckedUpdateWithoutZoneWardMapsInput>
  }

  export type WardMasterUpdateOneRequiredWithoutZoneWardMapsNestedInput = {
    create?: XOR<WardMasterCreateWithoutZoneWardMapsInput, WardMasterUncheckedCreateWithoutZoneWardMapsInput>
    connectOrCreate?: WardMasterCreateOrConnectWithoutZoneWardMapsInput
    upsert?: WardMasterUpsertWithoutZoneWardMapsInput
    connect?: WardMasterWhereUniqueInput
    update?: XOR<XOR<WardMasterUpdateToOneWithWhereWithoutZoneWardMapsInput, WardMasterUpdateWithoutZoneWardMapsInput>, WardMasterUncheckedUpdateWithoutZoneWardMapsInput>
  }

  export type SurveyorsUpdateManyWithoutZoneWardMapNestedInput = {
    create?: XOR<SurveyorsCreateWithoutZoneWardMapInput, SurveyorsUncheckedCreateWithoutZoneWardMapInput> | SurveyorsCreateWithoutZoneWardMapInput[] | SurveyorsUncheckedCreateWithoutZoneWardMapInput[]
    connectOrCreate?: SurveyorsCreateOrConnectWithoutZoneWardMapInput | SurveyorsCreateOrConnectWithoutZoneWardMapInput[]
    upsert?: SurveyorsUpsertWithWhereUniqueWithoutZoneWardMapInput | SurveyorsUpsertWithWhereUniqueWithoutZoneWardMapInput[]
    createMany?: SurveyorsCreateManyZoneWardMapInputEnvelope
    set?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    disconnect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    delete?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    connect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    update?: SurveyorsUpdateWithWhereUniqueWithoutZoneWardMapInput | SurveyorsUpdateWithWhereUniqueWithoutZoneWardMapInput[]
    updateMany?: SurveyorsUpdateManyWithWhereWithoutZoneWardMapInput | SurveyorsUpdateManyWithWhereWithoutZoneWardMapInput[]
    deleteMany?: SurveyorsScalarWhereInput | SurveyorsScalarWhereInput[]
  }

  export type SurveyorsUncheckedUpdateManyWithoutZoneWardMapNestedInput = {
    create?: XOR<SurveyorsCreateWithoutZoneWardMapInput, SurveyorsUncheckedCreateWithoutZoneWardMapInput> | SurveyorsCreateWithoutZoneWardMapInput[] | SurveyorsUncheckedCreateWithoutZoneWardMapInput[]
    connectOrCreate?: SurveyorsCreateOrConnectWithoutZoneWardMapInput | SurveyorsCreateOrConnectWithoutZoneWardMapInput[]
    upsert?: SurveyorsUpsertWithWhereUniqueWithoutZoneWardMapInput | SurveyorsUpsertWithWhereUniqueWithoutZoneWardMapInput[]
    createMany?: SurveyorsCreateManyZoneWardMapInputEnvelope
    set?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    disconnect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    delete?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    connect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    update?: SurveyorsUpdateWithWhereUniqueWithoutZoneWardMapInput | SurveyorsUpdateWithWhereUniqueWithoutZoneWardMapInput[]
    updateMany?: SurveyorsUpdateManyWithWhereWithoutZoneWardMapInput | SurveyorsUpdateManyWithWhereWithoutZoneWardMapInput[]
    deleteMany?: SurveyorsScalarWhereInput | SurveyorsScalarWhereInput[]
  }

  export type WardMasterCreateNestedOneWithoutWardMohallaMapsInput = {
    create?: XOR<WardMasterCreateWithoutWardMohallaMapsInput, WardMasterUncheckedCreateWithoutWardMohallaMapsInput>
    connectOrCreate?: WardMasterCreateOrConnectWithoutWardMohallaMapsInput
    connect?: WardMasterWhereUniqueInput
  }

  export type MohallaMasterCreateNestedOneWithoutWardMohallaMapsInput = {
    create?: XOR<MohallaMasterCreateWithoutWardMohallaMapsInput, MohallaMasterUncheckedCreateWithoutWardMohallaMapsInput>
    connectOrCreate?: MohallaMasterCreateOrConnectWithoutWardMohallaMapsInput
    connect?: MohallaMasterWhereUniqueInput
  }

  export type SurveyorAssignmentCreateNestedManyWithoutWardMohallaMapInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutWardMohallaMapInput, SurveyorAssignmentUncheckedCreateWithoutWardMohallaMapInput> | SurveyorAssignmentCreateWithoutWardMohallaMapInput[] | SurveyorAssignmentUncheckedCreateWithoutWardMohallaMapInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutWardMohallaMapInput | SurveyorAssignmentCreateOrConnectWithoutWardMohallaMapInput[]
    createMany?: SurveyorAssignmentCreateManyWardMohallaMapInputEnvelope
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
  }

  export type SurveyorsCreateNestedManyWithoutWardMohallaMapInput = {
    create?: XOR<SurveyorsCreateWithoutWardMohallaMapInput, SurveyorsUncheckedCreateWithoutWardMohallaMapInput> | SurveyorsCreateWithoutWardMohallaMapInput[] | SurveyorsUncheckedCreateWithoutWardMohallaMapInput[]
    connectOrCreate?: SurveyorsCreateOrConnectWithoutWardMohallaMapInput | SurveyorsCreateOrConnectWithoutWardMohallaMapInput[]
    createMany?: SurveyorsCreateManyWardMohallaMapInputEnvelope
    connect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
  }

  export type SurveyorAssignmentUncheckedCreateNestedManyWithoutWardMohallaMapInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutWardMohallaMapInput, SurveyorAssignmentUncheckedCreateWithoutWardMohallaMapInput> | SurveyorAssignmentCreateWithoutWardMohallaMapInput[] | SurveyorAssignmentUncheckedCreateWithoutWardMohallaMapInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutWardMohallaMapInput | SurveyorAssignmentCreateOrConnectWithoutWardMohallaMapInput[]
    createMany?: SurveyorAssignmentCreateManyWardMohallaMapInputEnvelope
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
  }

  export type SurveyorsUncheckedCreateNestedManyWithoutWardMohallaMapInput = {
    create?: XOR<SurveyorsCreateWithoutWardMohallaMapInput, SurveyorsUncheckedCreateWithoutWardMohallaMapInput> | SurveyorsCreateWithoutWardMohallaMapInput[] | SurveyorsUncheckedCreateWithoutWardMohallaMapInput[]
    connectOrCreate?: SurveyorsCreateOrConnectWithoutWardMohallaMapInput | SurveyorsCreateOrConnectWithoutWardMohallaMapInput[]
    createMany?: SurveyorsCreateManyWardMohallaMapInputEnvelope
    connect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
  }

  export type WardMasterUpdateOneRequiredWithoutWardMohallaMapsNestedInput = {
    create?: XOR<WardMasterCreateWithoutWardMohallaMapsInput, WardMasterUncheckedCreateWithoutWardMohallaMapsInput>
    connectOrCreate?: WardMasterCreateOrConnectWithoutWardMohallaMapsInput
    upsert?: WardMasterUpsertWithoutWardMohallaMapsInput
    connect?: WardMasterWhereUniqueInput
    update?: XOR<XOR<WardMasterUpdateToOneWithWhereWithoutWardMohallaMapsInput, WardMasterUpdateWithoutWardMohallaMapsInput>, WardMasterUncheckedUpdateWithoutWardMohallaMapsInput>
  }

  export type MohallaMasterUpdateOneRequiredWithoutWardMohallaMapsNestedInput = {
    create?: XOR<MohallaMasterCreateWithoutWardMohallaMapsInput, MohallaMasterUncheckedCreateWithoutWardMohallaMapsInput>
    connectOrCreate?: MohallaMasterCreateOrConnectWithoutWardMohallaMapsInput
    upsert?: MohallaMasterUpsertWithoutWardMohallaMapsInput
    connect?: MohallaMasterWhereUniqueInput
    update?: XOR<XOR<MohallaMasterUpdateToOneWithWhereWithoutWardMohallaMapsInput, MohallaMasterUpdateWithoutWardMohallaMapsInput>, MohallaMasterUncheckedUpdateWithoutWardMohallaMapsInput>
  }

  export type SurveyorAssignmentUpdateManyWithoutWardMohallaMapNestedInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutWardMohallaMapInput, SurveyorAssignmentUncheckedCreateWithoutWardMohallaMapInput> | SurveyorAssignmentCreateWithoutWardMohallaMapInput[] | SurveyorAssignmentUncheckedCreateWithoutWardMohallaMapInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutWardMohallaMapInput | SurveyorAssignmentCreateOrConnectWithoutWardMohallaMapInput[]
    upsert?: SurveyorAssignmentUpsertWithWhereUniqueWithoutWardMohallaMapInput | SurveyorAssignmentUpsertWithWhereUniqueWithoutWardMohallaMapInput[]
    createMany?: SurveyorAssignmentCreateManyWardMohallaMapInputEnvelope
    set?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    disconnect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    delete?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    update?: SurveyorAssignmentUpdateWithWhereUniqueWithoutWardMohallaMapInput | SurveyorAssignmentUpdateWithWhereUniqueWithoutWardMohallaMapInput[]
    updateMany?: SurveyorAssignmentUpdateManyWithWhereWithoutWardMohallaMapInput | SurveyorAssignmentUpdateManyWithWhereWithoutWardMohallaMapInput[]
    deleteMany?: SurveyorAssignmentScalarWhereInput | SurveyorAssignmentScalarWhereInput[]
  }

  export type SurveyorsUpdateManyWithoutWardMohallaMapNestedInput = {
    create?: XOR<SurveyorsCreateWithoutWardMohallaMapInput, SurveyorsUncheckedCreateWithoutWardMohallaMapInput> | SurveyorsCreateWithoutWardMohallaMapInput[] | SurveyorsUncheckedCreateWithoutWardMohallaMapInput[]
    connectOrCreate?: SurveyorsCreateOrConnectWithoutWardMohallaMapInput | SurveyorsCreateOrConnectWithoutWardMohallaMapInput[]
    upsert?: SurveyorsUpsertWithWhereUniqueWithoutWardMohallaMapInput | SurveyorsUpsertWithWhereUniqueWithoutWardMohallaMapInput[]
    createMany?: SurveyorsCreateManyWardMohallaMapInputEnvelope
    set?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    disconnect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    delete?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    connect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    update?: SurveyorsUpdateWithWhereUniqueWithoutWardMohallaMapInput | SurveyorsUpdateWithWhereUniqueWithoutWardMohallaMapInput[]
    updateMany?: SurveyorsUpdateManyWithWhereWithoutWardMohallaMapInput | SurveyorsUpdateManyWithWhereWithoutWardMohallaMapInput[]
    deleteMany?: SurveyorsScalarWhereInput | SurveyorsScalarWhereInput[]
  }

  export type SurveyorAssignmentUncheckedUpdateManyWithoutWardMohallaMapNestedInput = {
    create?: XOR<SurveyorAssignmentCreateWithoutWardMohallaMapInput, SurveyorAssignmentUncheckedCreateWithoutWardMohallaMapInput> | SurveyorAssignmentCreateWithoutWardMohallaMapInput[] | SurveyorAssignmentUncheckedCreateWithoutWardMohallaMapInput[]
    connectOrCreate?: SurveyorAssignmentCreateOrConnectWithoutWardMohallaMapInput | SurveyorAssignmentCreateOrConnectWithoutWardMohallaMapInput[]
    upsert?: SurveyorAssignmentUpsertWithWhereUniqueWithoutWardMohallaMapInput | SurveyorAssignmentUpsertWithWhereUniqueWithoutWardMohallaMapInput[]
    createMany?: SurveyorAssignmentCreateManyWardMohallaMapInputEnvelope
    set?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    disconnect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    delete?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    connect?: SurveyorAssignmentWhereUniqueInput | SurveyorAssignmentWhereUniqueInput[]
    update?: SurveyorAssignmentUpdateWithWhereUniqueWithoutWardMohallaMapInput | SurveyorAssignmentUpdateWithWhereUniqueWithoutWardMohallaMapInput[]
    updateMany?: SurveyorAssignmentUpdateManyWithWhereWithoutWardMohallaMapInput | SurveyorAssignmentUpdateManyWithWhereWithoutWardMohallaMapInput[]
    deleteMany?: SurveyorAssignmentScalarWhereInput | SurveyorAssignmentScalarWhereInput[]
  }

  export type SurveyorsUncheckedUpdateManyWithoutWardMohallaMapNestedInput = {
    create?: XOR<SurveyorsCreateWithoutWardMohallaMapInput, SurveyorsUncheckedCreateWithoutWardMohallaMapInput> | SurveyorsCreateWithoutWardMohallaMapInput[] | SurveyorsUncheckedCreateWithoutWardMohallaMapInput[]
    connectOrCreate?: SurveyorsCreateOrConnectWithoutWardMohallaMapInput | SurveyorsCreateOrConnectWithoutWardMohallaMapInput[]
    upsert?: SurveyorsUpsertWithWhereUniqueWithoutWardMohallaMapInput | SurveyorsUpsertWithWhereUniqueWithoutWardMohallaMapInput[]
    createMany?: SurveyorsCreateManyWardMohallaMapInputEnvelope
    set?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    disconnect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    delete?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    connect?: SurveyorsWhereUniqueInput | SurveyorsWhereUniqueInput[]
    update?: SurveyorsUpdateWithWhereUniqueWithoutWardMohallaMapInput | SurveyorsUpdateWithWhereUniqueWithoutWardMohallaMapInput[]
    updateMany?: SurveyorsUpdateManyWithWhereWithoutWardMohallaMapInput | SurveyorsUpdateManyWithWhereWithoutWardMohallaMapInput[]
    deleteMany?: SurveyorsScalarWhereInput | SurveyorsScalarWhereInput[]
  }

  export type UsersMasterCreateNestedOneWithoutSurveyorAssignmentsInput = {
    create?: XOR<UsersMasterCreateWithoutSurveyorAssignmentsInput, UsersMasterUncheckedCreateWithoutSurveyorAssignmentsInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutSurveyorAssignmentsInput
    connect?: UsersMasterWhereUniqueInput
  }

  export type WardMasterCreateNestedOneWithoutSurveyorAssignmentsInput = {
    create?: XOR<WardMasterCreateWithoutSurveyorAssignmentsInput, WardMasterUncheckedCreateWithoutSurveyorAssignmentsInput>
    connectOrCreate?: WardMasterCreateOrConnectWithoutSurveyorAssignmentsInput
    connect?: WardMasterWhereUniqueInput
  }

  export type MohallaMasterCreateNestedOneWithoutSurveyorAssignmentsInput = {
    create?: XOR<MohallaMasterCreateWithoutSurveyorAssignmentsInput, MohallaMasterUncheckedCreateWithoutSurveyorAssignmentsInput>
    connectOrCreate?: MohallaMasterCreateOrConnectWithoutSurveyorAssignmentsInput
    connect?: MohallaMasterWhereUniqueInput
  }

  export type WardMohallaMappingCreateNestedOneWithoutSurveyorAssignmentsInput = {
    create?: XOR<WardMohallaMappingCreateWithoutSurveyorAssignmentsInput, WardMohallaMappingUncheckedCreateWithoutSurveyorAssignmentsInput>
    connectOrCreate?: WardMohallaMappingCreateOrConnectWithoutSurveyorAssignmentsInput
    connect?: WardMohallaMappingWhereUniqueInput
  }

  export type UsersMasterCreateNestedOneWithoutSurveyorAssignmentsAssignedByInput = {
    create?: XOR<UsersMasterCreateWithoutSurveyorAssignmentsAssignedByInput, UsersMasterUncheckedCreateWithoutSurveyorAssignmentsAssignedByInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutSurveyorAssignmentsAssignedByInput
    connect?: UsersMasterWhereUniqueInput
  }

  export type UsersMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput = {
    create?: XOR<UsersMasterCreateWithoutSurveyorAssignmentsInput, UsersMasterUncheckedCreateWithoutSurveyorAssignmentsInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutSurveyorAssignmentsInput
    upsert?: UsersMasterUpsertWithoutSurveyorAssignmentsInput
    connect?: UsersMasterWhereUniqueInput
    update?: XOR<XOR<UsersMasterUpdateToOneWithWhereWithoutSurveyorAssignmentsInput, UsersMasterUpdateWithoutSurveyorAssignmentsInput>, UsersMasterUncheckedUpdateWithoutSurveyorAssignmentsInput>
  }

  export type WardMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput = {
    create?: XOR<WardMasterCreateWithoutSurveyorAssignmentsInput, WardMasterUncheckedCreateWithoutSurveyorAssignmentsInput>
    connectOrCreate?: WardMasterCreateOrConnectWithoutSurveyorAssignmentsInput
    upsert?: WardMasterUpsertWithoutSurveyorAssignmentsInput
    connect?: WardMasterWhereUniqueInput
    update?: XOR<XOR<WardMasterUpdateToOneWithWhereWithoutSurveyorAssignmentsInput, WardMasterUpdateWithoutSurveyorAssignmentsInput>, WardMasterUncheckedUpdateWithoutSurveyorAssignmentsInput>
  }

  export type MohallaMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput = {
    create?: XOR<MohallaMasterCreateWithoutSurveyorAssignmentsInput, MohallaMasterUncheckedCreateWithoutSurveyorAssignmentsInput>
    connectOrCreate?: MohallaMasterCreateOrConnectWithoutSurveyorAssignmentsInput
    upsert?: MohallaMasterUpsertWithoutSurveyorAssignmentsInput
    connect?: MohallaMasterWhereUniqueInput
    update?: XOR<XOR<MohallaMasterUpdateToOneWithWhereWithoutSurveyorAssignmentsInput, MohallaMasterUpdateWithoutSurveyorAssignmentsInput>, MohallaMasterUncheckedUpdateWithoutSurveyorAssignmentsInput>
  }

  export type WardMohallaMappingUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput = {
    create?: XOR<WardMohallaMappingCreateWithoutSurveyorAssignmentsInput, WardMohallaMappingUncheckedCreateWithoutSurveyorAssignmentsInput>
    connectOrCreate?: WardMohallaMappingCreateOrConnectWithoutSurveyorAssignmentsInput
    upsert?: WardMohallaMappingUpsertWithoutSurveyorAssignmentsInput
    connect?: WardMohallaMappingWhereUniqueInput
    update?: XOR<XOR<WardMohallaMappingUpdateToOneWithWhereWithoutSurveyorAssignmentsInput, WardMohallaMappingUpdateWithoutSurveyorAssignmentsInput>, WardMohallaMappingUncheckedUpdateWithoutSurveyorAssignmentsInput>
  }

  export type UsersMasterUpdateOneRequiredWithoutSurveyorAssignmentsAssignedByNestedInput = {
    create?: XOR<UsersMasterCreateWithoutSurveyorAssignmentsAssignedByInput, UsersMasterUncheckedCreateWithoutSurveyorAssignmentsAssignedByInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutSurveyorAssignmentsAssignedByInput
    upsert?: UsersMasterUpsertWithoutSurveyorAssignmentsAssignedByInput
    connect?: UsersMasterWhereUniqueInput
    update?: XOR<XOR<UsersMasterUpdateToOneWithWhereWithoutSurveyorAssignmentsAssignedByInput, UsersMasterUpdateWithoutSurveyorAssignmentsAssignedByInput>, UsersMasterUncheckedUpdateWithoutSurveyorAssignmentsAssignedByInput>
  }

  export type WardMasterCreateNestedOneWithoutWardStatusMapsInput = {
    create?: XOR<WardMasterCreateWithoutWardStatusMapsInput, WardMasterUncheckedCreateWithoutWardStatusMapsInput>
    connectOrCreate?: WardMasterCreateOrConnectWithoutWardStatusMapsInput
    connect?: WardMasterWhereUniqueInput
  }

  export type WardStatusMasterCreateNestedOneWithoutWardStatusMapsInput = {
    create?: XOR<WardStatusMasterCreateWithoutWardStatusMapsInput, WardStatusMasterUncheckedCreateWithoutWardStatusMapsInput>
    connectOrCreate?: WardStatusMasterCreateOrConnectWithoutWardStatusMapsInput
    connect?: WardStatusMasterWhereUniqueInput
  }

  export type UsersMasterCreateNestedOneWithoutWardStatusMapsInput = {
    create?: XOR<UsersMasterCreateWithoutWardStatusMapsInput, UsersMasterUncheckedCreateWithoutWardStatusMapsInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutWardStatusMapsInput
    connect?: UsersMasterWhereUniqueInput
  }

  export type WardMasterUpdateOneRequiredWithoutWardStatusMapsNestedInput = {
    create?: XOR<WardMasterCreateWithoutWardStatusMapsInput, WardMasterUncheckedCreateWithoutWardStatusMapsInput>
    connectOrCreate?: WardMasterCreateOrConnectWithoutWardStatusMapsInput
    upsert?: WardMasterUpsertWithoutWardStatusMapsInput
    connect?: WardMasterWhereUniqueInput
    update?: XOR<XOR<WardMasterUpdateToOneWithWhereWithoutWardStatusMapsInput, WardMasterUpdateWithoutWardStatusMapsInput>, WardMasterUncheckedUpdateWithoutWardStatusMapsInput>
  }

  export type WardStatusMasterUpdateOneRequiredWithoutWardStatusMapsNestedInput = {
    create?: XOR<WardStatusMasterCreateWithoutWardStatusMapsInput, WardStatusMasterUncheckedCreateWithoutWardStatusMapsInput>
    connectOrCreate?: WardStatusMasterCreateOrConnectWithoutWardStatusMapsInput
    upsert?: WardStatusMasterUpsertWithoutWardStatusMapsInput
    connect?: WardStatusMasterWhereUniqueInput
    update?: XOR<XOR<WardStatusMasterUpdateToOneWithWhereWithoutWardStatusMapsInput, WardStatusMasterUpdateWithoutWardStatusMapsInput>, WardStatusMasterUncheckedUpdateWithoutWardStatusMapsInput>
  }

  export type UsersMasterUpdateOneRequiredWithoutWardStatusMapsNestedInput = {
    create?: XOR<UsersMasterCreateWithoutWardStatusMapsInput, UsersMasterUncheckedCreateWithoutWardStatusMapsInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutWardStatusMapsInput
    upsert?: UsersMasterUpsertWithoutWardStatusMapsInput
    connect?: UsersMasterWhereUniqueInput
    update?: XOR<XOR<UsersMasterUpdateToOneWithWhereWithoutWardStatusMapsInput, UsersMasterUpdateWithoutWardStatusMapsInput>, UsersMasterUncheckedUpdateWithoutWardStatusMapsInput>
  }

  export type SurveyDetailsCreateNestedOneWithoutSurveyStatusMapsInput = {
    create?: XOR<SurveyDetailsCreateWithoutSurveyStatusMapsInput, SurveyDetailsUncheckedCreateWithoutSurveyStatusMapsInput>
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutSurveyStatusMapsInput
    connect?: SurveyDetailsWhereUniqueInput
  }

  export type SurveyStatusMasterCreateNestedOneWithoutSurveyStatusMapsInput = {
    create?: XOR<SurveyStatusMasterCreateWithoutSurveyStatusMapsInput, SurveyStatusMasterUncheckedCreateWithoutSurveyStatusMapsInput>
    connectOrCreate?: SurveyStatusMasterCreateOrConnectWithoutSurveyStatusMapsInput
    connect?: SurveyStatusMasterWhereUniqueInput
  }

  export type SurveyStatusMasterCreateNestedOneWithoutSurveyStatusMapsRevertedInput = {
    create?: XOR<SurveyStatusMasterCreateWithoutSurveyStatusMapsRevertedInput, SurveyStatusMasterUncheckedCreateWithoutSurveyStatusMapsRevertedInput>
    connectOrCreate?: SurveyStatusMasterCreateOrConnectWithoutSurveyStatusMapsRevertedInput
    connect?: SurveyStatusMasterWhereUniqueInput
  }

  export type UsersMasterCreateNestedOneWithoutSurveyStatusMapsInput = {
    create?: XOR<UsersMasterCreateWithoutSurveyStatusMapsInput, UsersMasterUncheckedCreateWithoutSurveyStatusMapsInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutSurveyStatusMapsInput
    connect?: UsersMasterWhereUniqueInput
  }

  export type SurveyDetailsUpdateOneRequiredWithoutSurveyStatusMapsNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutSurveyStatusMapsInput, SurveyDetailsUncheckedCreateWithoutSurveyStatusMapsInput>
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutSurveyStatusMapsInput
    upsert?: SurveyDetailsUpsertWithoutSurveyStatusMapsInput
    connect?: SurveyDetailsWhereUniqueInput
    update?: XOR<XOR<SurveyDetailsUpdateToOneWithWhereWithoutSurveyStatusMapsInput, SurveyDetailsUpdateWithoutSurveyStatusMapsInput>, SurveyDetailsUncheckedUpdateWithoutSurveyStatusMapsInput>
  }

  export type SurveyStatusMasterUpdateOneRequiredWithoutSurveyStatusMapsNestedInput = {
    create?: XOR<SurveyStatusMasterCreateWithoutSurveyStatusMapsInput, SurveyStatusMasterUncheckedCreateWithoutSurveyStatusMapsInput>
    connectOrCreate?: SurveyStatusMasterCreateOrConnectWithoutSurveyStatusMapsInput
    upsert?: SurveyStatusMasterUpsertWithoutSurveyStatusMapsInput
    connect?: SurveyStatusMasterWhereUniqueInput
    update?: XOR<XOR<SurveyStatusMasterUpdateToOneWithWhereWithoutSurveyStatusMapsInput, SurveyStatusMasterUpdateWithoutSurveyStatusMapsInput>, SurveyStatusMasterUncheckedUpdateWithoutSurveyStatusMapsInput>
  }

  export type SurveyStatusMasterUpdateOneWithoutSurveyStatusMapsRevertedNestedInput = {
    create?: XOR<SurveyStatusMasterCreateWithoutSurveyStatusMapsRevertedInput, SurveyStatusMasterUncheckedCreateWithoutSurveyStatusMapsRevertedInput>
    connectOrCreate?: SurveyStatusMasterCreateOrConnectWithoutSurveyStatusMapsRevertedInput
    upsert?: SurveyStatusMasterUpsertWithoutSurveyStatusMapsRevertedInput
    disconnect?: SurveyStatusMasterWhereInput | boolean
    delete?: SurveyStatusMasterWhereInput | boolean
    connect?: SurveyStatusMasterWhereUniqueInput
    update?: XOR<XOR<SurveyStatusMasterUpdateToOneWithWhereWithoutSurveyStatusMapsRevertedInput, SurveyStatusMasterUpdateWithoutSurveyStatusMapsRevertedInput>, SurveyStatusMasterUncheckedUpdateWithoutSurveyStatusMapsRevertedInput>
  }

  export type UsersMasterUpdateOneRequiredWithoutSurveyStatusMapsNestedInput = {
    create?: XOR<UsersMasterCreateWithoutSurveyStatusMapsInput, UsersMasterUncheckedCreateWithoutSurveyStatusMapsInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutSurveyStatusMapsInput
    upsert?: UsersMasterUpsertWithoutSurveyStatusMapsInput
    connect?: UsersMasterWhereUniqueInput
    update?: XOR<XOR<UsersMasterUpdateToOneWithWhereWithoutSurveyStatusMapsInput, UsersMasterUpdateWithoutSurveyStatusMapsInput>, UsersMasterUncheckedUpdateWithoutSurveyStatusMapsInput>
  }

  export type UsersMasterCreateNestedOneWithoutUserRoleMapsInput = {
    create?: XOR<UsersMasterCreateWithoutUserRoleMapsInput, UsersMasterUncheckedCreateWithoutUserRoleMapsInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutUserRoleMapsInput
    connect?: UsersMasterWhereUniqueInput
  }

  export type RolePermissionMasterCreateNestedOneWithoutUserRoleMapsInput = {
    create?: XOR<RolePermissionMasterCreateWithoutUserRoleMapsInput, RolePermissionMasterUncheckedCreateWithoutUserRoleMapsInput>
    connectOrCreate?: RolePermissionMasterCreateOrConnectWithoutUserRoleMapsInput
    connect?: RolePermissionMasterWhereUniqueInput
  }

  export type UsersMasterUpdateOneRequiredWithoutUserRoleMapsNestedInput = {
    create?: XOR<UsersMasterCreateWithoutUserRoleMapsInput, UsersMasterUncheckedCreateWithoutUserRoleMapsInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutUserRoleMapsInput
    upsert?: UsersMasterUpsertWithoutUserRoleMapsInput
    connect?: UsersMasterWhereUniqueInput
    update?: XOR<XOR<UsersMasterUpdateToOneWithWhereWithoutUserRoleMapsInput, UsersMasterUpdateWithoutUserRoleMapsInput>, UsersMasterUncheckedUpdateWithoutUserRoleMapsInput>
  }

  export type RolePermissionMasterUpdateOneRequiredWithoutUserRoleMapsNestedInput = {
    create?: XOR<RolePermissionMasterCreateWithoutUserRoleMapsInput, RolePermissionMasterUncheckedCreateWithoutUserRoleMapsInput>
    connectOrCreate?: RolePermissionMasterCreateOrConnectWithoutUserRoleMapsInput
    upsert?: RolePermissionMasterUpsertWithoutUserRoleMapsInput
    connect?: RolePermissionMasterWhereUniqueInput
    update?: XOR<XOR<RolePermissionMasterUpdateToOneWithWhereWithoutUserRoleMapsInput, RolePermissionMasterUpdateWithoutUserRoleMapsInput>, RolePermissionMasterUncheckedUpdateWithoutUserRoleMapsInput>
  }

  export type UsersMasterCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UsersMasterCreateWithoutSessionsInput, UsersMasterUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutSessionsInput
    connect?: UsersMasterWhereUniqueInput
  }

  export type UsersMasterUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UsersMasterCreateWithoutSessionsInput, UsersMasterUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutSessionsInput
    upsert?: UsersMasterUpsertWithoutSessionsInput
    connect?: UsersMasterWhereUniqueInput
    update?: XOR<XOR<UsersMasterUpdateToOneWithWhereWithoutSessionsInput, UsersMasterUpdateWithoutSessionsInput>, UsersMasterUncheckedUpdateWithoutSessionsInput>
  }

  export type UsersMasterCreateNestedOneWithoutSurveyorsInput = {
    create?: XOR<UsersMasterCreateWithoutSurveyorsInput, UsersMasterUncheckedCreateWithoutSurveyorsInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutSurveyorsInput
    connect?: UsersMasterWhereUniqueInput
  }

  export type WardMohallaMappingCreateNestedOneWithoutSurveyorsInput = {
    create?: XOR<WardMohallaMappingCreateWithoutSurveyorsInput, WardMohallaMappingUncheckedCreateWithoutSurveyorsInput>
    connectOrCreate?: WardMohallaMappingCreateOrConnectWithoutSurveyorsInput
    connect?: WardMohallaMappingWhereUniqueInput
  }

  export type ZoneWardMappingCreateNestedOneWithoutSurveyorsInput = {
    create?: XOR<ZoneWardMappingCreateWithoutSurveyorsInput, ZoneWardMappingUncheckedCreateWithoutSurveyorsInput>
    connectOrCreate?: ZoneWardMappingCreateOrConnectWithoutSurveyorsInput
    connect?: ZoneWardMappingWhereUniqueInput
  }

  export type UlbZoneMappingCreateNestedOneWithoutSurveyorsInput = {
    create?: XOR<UlbZoneMappingCreateWithoutSurveyorsInput, UlbZoneMappingUncheckedCreateWithoutSurveyorsInput>
    connectOrCreate?: UlbZoneMappingCreateOrConnectWithoutSurveyorsInput
    connect?: UlbZoneMappingWhereUniqueInput
  }

  export type UsersMasterUpdateOneRequiredWithoutSurveyorsNestedInput = {
    create?: XOR<UsersMasterCreateWithoutSurveyorsInput, UsersMasterUncheckedCreateWithoutSurveyorsInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutSurveyorsInput
    upsert?: UsersMasterUpsertWithoutSurveyorsInput
    connect?: UsersMasterWhereUniqueInput
    update?: XOR<XOR<UsersMasterUpdateToOneWithWhereWithoutSurveyorsInput, UsersMasterUpdateWithoutSurveyorsInput>, UsersMasterUncheckedUpdateWithoutSurveyorsInput>
  }

  export type WardMohallaMappingUpdateOneRequiredWithoutSurveyorsNestedInput = {
    create?: XOR<WardMohallaMappingCreateWithoutSurveyorsInput, WardMohallaMappingUncheckedCreateWithoutSurveyorsInput>
    connectOrCreate?: WardMohallaMappingCreateOrConnectWithoutSurveyorsInput
    upsert?: WardMohallaMappingUpsertWithoutSurveyorsInput
    connect?: WardMohallaMappingWhereUniqueInput
    update?: XOR<XOR<WardMohallaMappingUpdateToOneWithWhereWithoutSurveyorsInput, WardMohallaMappingUpdateWithoutSurveyorsInput>, WardMohallaMappingUncheckedUpdateWithoutSurveyorsInput>
  }

  export type ZoneWardMappingUpdateOneRequiredWithoutSurveyorsNestedInput = {
    create?: XOR<ZoneWardMappingCreateWithoutSurveyorsInput, ZoneWardMappingUncheckedCreateWithoutSurveyorsInput>
    connectOrCreate?: ZoneWardMappingCreateOrConnectWithoutSurveyorsInput
    upsert?: ZoneWardMappingUpsertWithoutSurveyorsInput
    connect?: ZoneWardMappingWhereUniqueInput
    update?: XOR<XOR<ZoneWardMappingUpdateToOneWithWhereWithoutSurveyorsInput, ZoneWardMappingUpdateWithoutSurveyorsInput>, ZoneWardMappingUncheckedUpdateWithoutSurveyorsInput>
  }

  export type UlbZoneMappingUpdateOneRequiredWithoutSurveyorsNestedInput = {
    create?: XOR<UlbZoneMappingCreateWithoutSurveyorsInput, UlbZoneMappingUncheckedCreateWithoutSurveyorsInput>
    connectOrCreate?: UlbZoneMappingCreateOrConnectWithoutSurveyorsInput
    upsert?: UlbZoneMappingUpsertWithoutSurveyorsInput
    connect?: UlbZoneMappingWhereUniqueInput
    update?: XOR<XOR<UlbZoneMappingUpdateToOneWithWhereWithoutSurveyorsInput, UlbZoneMappingUpdateWithoutSurveyorsInput>, UlbZoneMappingUncheckedUpdateWithoutSurveyorsInput>
  }

  export type UsersMasterCreateNestedOneWithoutSupervisorsInput = {
    create?: XOR<UsersMasterCreateWithoutSupervisorsInput, UsersMasterUncheckedCreateWithoutSupervisorsInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutSupervisorsInput
    connect?: UsersMasterWhereUniqueInput
  }

  export type WardMasterCreateNestedOneWithoutSupervisorsInput = {
    create?: XOR<WardMasterCreateWithoutSupervisorsInput, WardMasterUncheckedCreateWithoutSupervisorsInput>
    connectOrCreate?: WardMasterCreateOrConnectWithoutSupervisorsInput
    connect?: WardMasterWhereUniqueInput
  }

  export type UsersMasterUpdateOneRequiredWithoutSupervisorsNestedInput = {
    create?: XOR<UsersMasterCreateWithoutSupervisorsInput, UsersMasterUncheckedCreateWithoutSupervisorsInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutSupervisorsInput
    upsert?: UsersMasterUpsertWithoutSupervisorsInput
    connect?: UsersMasterWhereUniqueInput
    update?: XOR<XOR<UsersMasterUpdateToOneWithWhereWithoutSupervisorsInput, UsersMasterUpdateWithoutSupervisorsInput>, UsersMasterUncheckedUpdateWithoutSupervisorsInput>
  }

  export type WardMasterUpdateOneRequiredWithoutSupervisorsNestedInput = {
    create?: XOR<WardMasterCreateWithoutSupervisorsInput, WardMasterUncheckedCreateWithoutSupervisorsInput>
    connectOrCreate?: WardMasterCreateOrConnectWithoutSupervisorsInput
    upsert?: WardMasterUpsertWithoutSupervisorsInput
    connect?: WardMasterWhereUniqueInput
    update?: XOR<XOR<WardMasterUpdateToOneWithWhereWithoutSupervisorsInput, WardMasterUpdateWithoutSupervisorsInput>, WardMasterUncheckedUpdateWithoutSupervisorsInput>
  }

  export type UsersMasterCreateNestedOneWithoutAdminsInput = {
    create?: XOR<UsersMasterCreateWithoutAdminsInput, UsersMasterUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutAdminsInput
    connect?: UsersMasterWhereUniqueInput
  }

  export type UsersMasterUpdateOneRequiredWithoutAdminsNestedInput = {
    create?: XOR<UsersMasterCreateWithoutAdminsInput, UsersMasterUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: UsersMasterCreateOrConnectWithoutAdminsInput
    upsert?: UsersMasterUpsertWithoutAdminsInput
    connect?: UsersMasterWhereUniqueInput
    update?: XOR<XOR<UsersMasterUpdateToOneWithWhereWithoutAdminsInput, UsersMasterUpdateWithoutAdminsInput>, UsersMasterUncheckedUpdateWithoutAdminsInput>
  }

  export type UlbMasterCreateNestedOneWithoutSurveyDetailsInput = {
    create?: XOR<UlbMasterCreateWithoutSurveyDetailsInput, UlbMasterUncheckedCreateWithoutSurveyDetailsInput>
    connectOrCreate?: UlbMasterCreateOrConnectWithoutSurveyDetailsInput
    connect?: UlbMasterWhereUniqueInput
  }

  export type ZoneMasterCreateNestedOneWithoutSurveyDetailsInput = {
    create?: XOR<ZoneMasterCreateWithoutSurveyDetailsInput, ZoneMasterUncheckedCreateWithoutSurveyDetailsInput>
    connectOrCreate?: ZoneMasterCreateOrConnectWithoutSurveyDetailsInput
    connect?: ZoneMasterWhereUniqueInput
  }

  export type WardMasterCreateNestedOneWithoutSurveyDetailsInput = {
    create?: XOR<WardMasterCreateWithoutSurveyDetailsInput, WardMasterUncheckedCreateWithoutSurveyDetailsInput>
    connectOrCreate?: WardMasterCreateOrConnectWithoutSurveyDetailsInput
    connect?: WardMasterWhereUniqueInput
  }

  export type MohallaMasterCreateNestedOneWithoutSurveyDetailsInput = {
    create?: XOR<MohallaMasterCreateWithoutSurveyDetailsInput, MohallaMasterUncheckedCreateWithoutSurveyDetailsInput>
    connectOrCreate?: MohallaMasterCreateOrConnectWithoutSurveyDetailsInput
    connect?: MohallaMasterWhereUniqueInput
  }

  export type SurveyTypeMasterCreateNestedOneWithoutSurveyDetailsInput = {
    create?: XOR<SurveyTypeMasterCreateWithoutSurveyDetailsInput, SurveyTypeMasterUncheckedCreateWithoutSurveyDetailsInput>
    connectOrCreate?: SurveyTypeMasterCreateOrConnectWithoutSurveyDetailsInput
    connect?: SurveyTypeMasterWhereUniqueInput
  }

  export type PropertyDetailsCreateNestedManyWithoutSurveyInput = {
    create?: XOR<PropertyDetailsCreateWithoutSurveyInput, PropertyDetailsUncheckedCreateWithoutSurveyInput> | PropertyDetailsCreateWithoutSurveyInput[] | PropertyDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutSurveyInput | PropertyDetailsCreateOrConnectWithoutSurveyInput[]
    createMany?: PropertyDetailsCreateManySurveyInputEnvelope
    connect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
  }

  export type OwnerDetailsCreateNestedManyWithoutSurveyInput = {
    create?: XOR<OwnerDetailsCreateWithoutSurveyInput, OwnerDetailsUncheckedCreateWithoutSurveyInput> | OwnerDetailsCreateWithoutSurveyInput[] | OwnerDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: OwnerDetailsCreateOrConnectWithoutSurveyInput | OwnerDetailsCreateOrConnectWithoutSurveyInput[]
    createMany?: OwnerDetailsCreateManySurveyInputEnvelope
    connect?: OwnerDetailsWhereUniqueInput | OwnerDetailsWhereUniqueInput[]
  }

  export type LocationDetailsCreateNestedManyWithoutSurveyInput = {
    create?: XOR<LocationDetailsCreateWithoutSurveyInput, LocationDetailsUncheckedCreateWithoutSurveyInput> | LocationDetailsCreateWithoutSurveyInput[] | LocationDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutSurveyInput | LocationDetailsCreateOrConnectWithoutSurveyInput[]
    createMany?: LocationDetailsCreateManySurveyInputEnvelope
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
  }

  export type OtherDetailsCreateNestedManyWithoutSurveyInput = {
    create?: XOR<OtherDetailsCreateWithoutSurveyInput, OtherDetailsUncheckedCreateWithoutSurveyInput> | OtherDetailsCreateWithoutSurveyInput[] | OtherDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: OtherDetailsCreateOrConnectWithoutSurveyInput | OtherDetailsCreateOrConnectWithoutSurveyInput[]
    createMany?: OtherDetailsCreateManySurveyInputEnvelope
    connect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
  }

  export type ResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput = {
    create?: XOR<ResidentialPropertyAssessmentCreateWithoutSurveyInput, ResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput> | ResidentialPropertyAssessmentCreateWithoutSurveyInput[] | ResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: ResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput | ResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput[]
    createMany?: ResidentialPropertyAssessmentCreateManySurveyInputEnvelope
    connect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
  }

  export type NonResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutSurveyInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput> | NonResidentialPropertyAssessmentCreateWithoutSurveyInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManySurveyInputEnvelope
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
  }

  export type PropertyAttachmentDetailsCreateNestedManyWithoutSurveyInput = {
    create?: XOR<PropertyAttachmentDetailsCreateWithoutSurveyInput, PropertyAttachmentDetailsUncheckedCreateWithoutSurveyInput> | PropertyAttachmentDetailsCreateWithoutSurveyInput[] | PropertyAttachmentDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: PropertyAttachmentDetailsCreateOrConnectWithoutSurveyInput | PropertyAttachmentDetailsCreateOrConnectWithoutSurveyInput[]
    createMany?: PropertyAttachmentDetailsCreateManySurveyInputEnvelope
    connect?: PropertyAttachmentDetailsWhereUniqueInput | PropertyAttachmentDetailsWhereUniqueInput[]
  }

  export type SurveyStatusMappingCreateNestedManyWithoutSurveyInput = {
    create?: XOR<SurveyStatusMappingCreateWithoutSurveyInput, SurveyStatusMappingUncheckedCreateWithoutSurveyInput> | SurveyStatusMappingCreateWithoutSurveyInput[] | SurveyStatusMappingUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: SurveyStatusMappingCreateOrConnectWithoutSurveyInput | SurveyStatusMappingCreateOrConnectWithoutSurveyInput[]
    createMany?: SurveyStatusMappingCreateManySurveyInputEnvelope
    connect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
  }

  export type PropertyDetailsUncheckedCreateNestedManyWithoutSurveyInput = {
    create?: XOR<PropertyDetailsCreateWithoutSurveyInput, PropertyDetailsUncheckedCreateWithoutSurveyInput> | PropertyDetailsCreateWithoutSurveyInput[] | PropertyDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutSurveyInput | PropertyDetailsCreateOrConnectWithoutSurveyInput[]
    createMany?: PropertyDetailsCreateManySurveyInputEnvelope
    connect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
  }

  export type OwnerDetailsUncheckedCreateNestedManyWithoutSurveyInput = {
    create?: XOR<OwnerDetailsCreateWithoutSurveyInput, OwnerDetailsUncheckedCreateWithoutSurveyInput> | OwnerDetailsCreateWithoutSurveyInput[] | OwnerDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: OwnerDetailsCreateOrConnectWithoutSurveyInput | OwnerDetailsCreateOrConnectWithoutSurveyInput[]
    createMany?: OwnerDetailsCreateManySurveyInputEnvelope
    connect?: OwnerDetailsWhereUniqueInput | OwnerDetailsWhereUniqueInput[]
  }

  export type LocationDetailsUncheckedCreateNestedManyWithoutSurveyInput = {
    create?: XOR<LocationDetailsCreateWithoutSurveyInput, LocationDetailsUncheckedCreateWithoutSurveyInput> | LocationDetailsCreateWithoutSurveyInput[] | LocationDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutSurveyInput | LocationDetailsCreateOrConnectWithoutSurveyInput[]
    createMany?: LocationDetailsCreateManySurveyInputEnvelope
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
  }

  export type OtherDetailsUncheckedCreateNestedManyWithoutSurveyInput = {
    create?: XOR<OtherDetailsCreateWithoutSurveyInput, OtherDetailsUncheckedCreateWithoutSurveyInput> | OtherDetailsCreateWithoutSurveyInput[] | OtherDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: OtherDetailsCreateOrConnectWithoutSurveyInput | OtherDetailsCreateOrConnectWithoutSurveyInput[]
    createMany?: OtherDetailsCreateManySurveyInputEnvelope
    connect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
  }

  export type ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput = {
    create?: XOR<ResidentialPropertyAssessmentCreateWithoutSurveyInput, ResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput> | ResidentialPropertyAssessmentCreateWithoutSurveyInput[] | ResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: ResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput | ResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput[]
    createMany?: ResidentialPropertyAssessmentCreateManySurveyInputEnvelope
    connect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
  }

  export type NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutSurveyInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput> | NonResidentialPropertyAssessmentCreateWithoutSurveyInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManySurveyInputEnvelope
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
  }

  export type PropertyAttachmentDetailsUncheckedCreateNestedManyWithoutSurveyInput = {
    create?: XOR<PropertyAttachmentDetailsCreateWithoutSurveyInput, PropertyAttachmentDetailsUncheckedCreateWithoutSurveyInput> | PropertyAttachmentDetailsCreateWithoutSurveyInput[] | PropertyAttachmentDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: PropertyAttachmentDetailsCreateOrConnectWithoutSurveyInput | PropertyAttachmentDetailsCreateOrConnectWithoutSurveyInput[]
    createMany?: PropertyAttachmentDetailsCreateManySurveyInputEnvelope
    connect?: PropertyAttachmentDetailsWhereUniqueInput | PropertyAttachmentDetailsWhereUniqueInput[]
  }

  export type SurveyStatusMappingUncheckedCreateNestedManyWithoutSurveyInput = {
    create?: XOR<SurveyStatusMappingCreateWithoutSurveyInput, SurveyStatusMappingUncheckedCreateWithoutSurveyInput> | SurveyStatusMappingCreateWithoutSurveyInput[] | SurveyStatusMappingUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: SurveyStatusMappingCreateOrConnectWithoutSurveyInput | SurveyStatusMappingCreateOrConnectWithoutSurveyInput[]
    createMany?: SurveyStatusMappingCreateManySurveyInputEnvelope
    connect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UlbMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput = {
    create?: XOR<UlbMasterCreateWithoutSurveyDetailsInput, UlbMasterUncheckedCreateWithoutSurveyDetailsInput>
    connectOrCreate?: UlbMasterCreateOrConnectWithoutSurveyDetailsInput
    upsert?: UlbMasterUpsertWithoutSurveyDetailsInput
    connect?: UlbMasterWhereUniqueInput
    update?: XOR<XOR<UlbMasterUpdateToOneWithWhereWithoutSurveyDetailsInput, UlbMasterUpdateWithoutSurveyDetailsInput>, UlbMasterUncheckedUpdateWithoutSurveyDetailsInput>
  }

  export type ZoneMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput = {
    create?: XOR<ZoneMasterCreateWithoutSurveyDetailsInput, ZoneMasterUncheckedCreateWithoutSurveyDetailsInput>
    connectOrCreate?: ZoneMasterCreateOrConnectWithoutSurveyDetailsInput
    upsert?: ZoneMasterUpsertWithoutSurveyDetailsInput
    connect?: ZoneMasterWhereUniqueInput
    update?: XOR<XOR<ZoneMasterUpdateToOneWithWhereWithoutSurveyDetailsInput, ZoneMasterUpdateWithoutSurveyDetailsInput>, ZoneMasterUncheckedUpdateWithoutSurveyDetailsInput>
  }

  export type WardMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput = {
    create?: XOR<WardMasterCreateWithoutSurveyDetailsInput, WardMasterUncheckedCreateWithoutSurveyDetailsInput>
    connectOrCreate?: WardMasterCreateOrConnectWithoutSurveyDetailsInput
    upsert?: WardMasterUpsertWithoutSurveyDetailsInput
    connect?: WardMasterWhereUniqueInput
    update?: XOR<XOR<WardMasterUpdateToOneWithWhereWithoutSurveyDetailsInput, WardMasterUpdateWithoutSurveyDetailsInput>, WardMasterUncheckedUpdateWithoutSurveyDetailsInput>
  }

  export type MohallaMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput = {
    create?: XOR<MohallaMasterCreateWithoutSurveyDetailsInput, MohallaMasterUncheckedCreateWithoutSurveyDetailsInput>
    connectOrCreate?: MohallaMasterCreateOrConnectWithoutSurveyDetailsInput
    upsert?: MohallaMasterUpsertWithoutSurveyDetailsInput
    connect?: MohallaMasterWhereUniqueInput
    update?: XOR<XOR<MohallaMasterUpdateToOneWithWhereWithoutSurveyDetailsInput, MohallaMasterUpdateWithoutSurveyDetailsInput>, MohallaMasterUncheckedUpdateWithoutSurveyDetailsInput>
  }

  export type SurveyTypeMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput = {
    create?: XOR<SurveyTypeMasterCreateWithoutSurveyDetailsInput, SurveyTypeMasterUncheckedCreateWithoutSurveyDetailsInput>
    connectOrCreate?: SurveyTypeMasterCreateOrConnectWithoutSurveyDetailsInput
    upsert?: SurveyTypeMasterUpsertWithoutSurveyDetailsInput
    connect?: SurveyTypeMasterWhereUniqueInput
    update?: XOR<XOR<SurveyTypeMasterUpdateToOneWithWhereWithoutSurveyDetailsInput, SurveyTypeMasterUpdateWithoutSurveyDetailsInput>, SurveyTypeMasterUncheckedUpdateWithoutSurveyDetailsInput>
  }

  export type PropertyDetailsUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<PropertyDetailsCreateWithoutSurveyInput, PropertyDetailsUncheckedCreateWithoutSurveyInput> | PropertyDetailsCreateWithoutSurveyInput[] | PropertyDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutSurveyInput | PropertyDetailsCreateOrConnectWithoutSurveyInput[]
    upsert?: PropertyDetailsUpsertWithWhereUniqueWithoutSurveyInput | PropertyDetailsUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: PropertyDetailsCreateManySurveyInputEnvelope
    set?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    disconnect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    delete?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    connect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    update?: PropertyDetailsUpdateWithWhereUniqueWithoutSurveyInput | PropertyDetailsUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: PropertyDetailsUpdateManyWithWhereWithoutSurveyInput | PropertyDetailsUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: PropertyDetailsScalarWhereInput | PropertyDetailsScalarWhereInput[]
  }

  export type OwnerDetailsUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<OwnerDetailsCreateWithoutSurveyInput, OwnerDetailsUncheckedCreateWithoutSurveyInput> | OwnerDetailsCreateWithoutSurveyInput[] | OwnerDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: OwnerDetailsCreateOrConnectWithoutSurveyInput | OwnerDetailsCreateOrConnectWithoutSurveyInput[]
    upsert?: OwnerDetailsUpsertWithWhereUniqueWithoutSurveyInput | OwnerDetailsUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: OwnerDetailsCreateManySurveyInputEnvelope
    set?: OwnerDetailsWhereUniqueInput | OwnerDetailsWhereUniqueInput[]
    disconnect?: OwnerDetailsWhereUniqueInput | OwnerDetailsWhereUniqueInput[]
    delete?: OwnerDetailsWhereUniqueInput | OwnerDetailsWhereUniqueInput[]
    connect?: OwnerDetailsWhereUniqueInput | OwnerDetailsWhereUniqueInput[]
    update?: OwnerDetailsUpdateWithWhereUniqueWithoutSurveyInput | OwnerDetailsUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: OwnerDetailsUpdateManyWithWhereWithoutSurveyInput | OwnerDetailsUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: OwnerDetailsScalarWhereInput | OwnerDetailsScalarWhereInput[]
  }

  export type LocationDetailsUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<LocationDetailsCreateWithoutSurveyInput, LocationDetailsUncheckedCreateWithoutSurveyInput> | LocationDetailsCreateWithoutSurveyInput[] | LocationDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutSurveyInput | LocationDetailsCreateOrConnectWithoutSurveyInput[]
    upsert?: LocationDetailsUpsertWithWhereUniqueWithoutSurveyInput | LocationDetailsUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: LocationDetailsCreateManySurveyInputEnvelope
    set?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    disconnect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    delete?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    update?: LocationDetailsUpdateWithWhereUniqueWithoutSurveyInput | LocationDetailsUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: LocationDetailsUpdateManyWithWhereWithoutSurveyInput | LocationDetailsUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: LocationDetailsScalarWhereInput | LocationDetailsScalarWhereInput[]
  }

  export type OtherDetailsUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<OtherDetailsCreateWithoutSurveyInput, OtherDetailsUncheckedCreateWithoutSurveyInput> | OtherDetailsCreateWithoutSurveyInput[] | OtherDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: OtherDetailsCreateOrConnectWithoutSurveyInput | OtherDetailsCreateOrConnectWithoutSurveyInput[]
    upsert?: OtherDetailsUpsertWithWhereUniqueWithoutSurveyInput | OtherDetailsUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: OtherDetailsCreateManySurveyInputEnvelope
    set?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    disconnect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    delete?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    connect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    update?: OtherDetailsUpdateWithWhereUniqueWithoutSurveyInput | OtherDetailsUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: OtherDetailsUpdateManyWithWhereWithoutSurveyInput | OtherDetailsUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: OtherDetailsScalarWhereInput | OtherDetailsScalarWhereInput[]
  }

  export type ResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<ResidentialPropertyAssessmentCreateWithoutSurveyInput, ResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput> | ResidentialPropertyAssessmentCreateWithoutSurveyInput[] | ResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: ResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput | ResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput[]
    upsert?: ResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutSurveyInput | ResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: ResidentialPropertyAssessmentCreateManySurveyInputEnvelope
    set?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    disconnect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    delete?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    connect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    update?: ResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutSurveyInput | ResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: ResidentialPropertyAssessmentUpdateManyWithWhereWithoutSurveyInput | ResidentialPropertyAssessmentUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: ResidentialPropertyAssessmentScalarWhereInput | ResidentialPropertyAssessmentScalarWhereInput[]
  }

  export type NonResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutSurveyInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput> | NonResidentialPropertyAssessmentCreateWithoutSurveyInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput[]
    upsert?: NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutSurveyInput | NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManySurveyInputEnvelope
    set?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    disconnect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    delete?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    update?: NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutSurveyInput | NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutSurveyInput | NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: NonResidentialPropertyAssessmentScalarWhereInput | NonResidentialPropertyAssessmentScalarWhereInput[]
  }

  export type PropertyAttachmentDetailsUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<PropertyAttachmentDetailsCreateWithoutSurveyInput, PropertyAttachmentDetailsUncheckedCreateWithoutSurveyInput> | PropertyAttachmentDetailsCreateWithoutSurveyInput[] | PropertyAttachmentDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: PropertyAttachmentDetailsCreateOrConnectWithoutSurveyInput | PropertyAttachmentDetailsCreateOrConnectWithoutSurveyInput[]
    upsert?: PropertyAttachmentDetailsUpsertWithWhereUniqueWithoutSurveyInput | PropertyAttachmentDetailsUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: PropertyAttachmentDetailsCreateManySurveyInputEnvelope
    set?: PropertyAttachmentDetailsWhereUniqueInput | PropertyAttachmentDetailsWhereUniqueInput[]
    disconnect?: PropertyAttachmentDetailsWhereUniqueInput | PropertyAttachmentDetailsWhereUniqueInput[]
    delete?: PropertyAttachmentDetailsWhereUniqueInput | PropertyAttachmentDetailsWhereUniqueInput[]
    connect?: PropertyAttachmentDetailsWhereUniqueInput | PropertyAttachmentDetailsWhereUniqueInput[]
    update?: PropertyAttachmentDetailsUpdateWithWhereUniqueWithoutSurveyInput | PropertyAttachmentDetailsUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: PropertyAttachmentDetailsUpdateManyWithWhereWithoutSurveyInput | PropertyAttachmentDetailsUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: PropertyAttachmentDetailsScalarWhereInput | PropertyAttachmentDetailsScalarWhereInput[]
  }

  export type SurveyStatusMappingUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<SurveyStatusMappingCreateWithoutSurveyInput, SurveyStatusMappingUncheckedCreateWithoutSurveyInput> | SurveyStatusMappingCreateWithoutSurveyInput[] | SurveyStatusMappingUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: SurveyStatusMappingCreateOrConnectWithoutSurveyInput | SurveyStatusMappingCreateOrConnectWithoutSurveyInput[]
    upsert?: SurveyStatusMappingUpsertWithWhereUniqueWithoutSurveyInput | SurveyStatusMappingUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: SurveyStatusMappingCreateManySurveyInputEnvelope
    set?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    disconnect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    delete?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    connect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    update?: SurveyStatusMappingUpdateWithWhereUniqueWithoutSurveyInput | SurveyStatusMappingUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: SurveyStatusMappingUpdateManyWithWhereWithoutSurveyInput | SurveyStatusMappingUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: SurveyStatusMappingScalarWhereInput | SurveyStatusMappingScalarWhereInput[]
  }

  export type PropertyDetailsUncheckedUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<PropertyDetailsCreateWithoutSurveyInput, PropertyDetailsUncheckedCreateWithoutSurveyInput> | PropertyDetailsCreateWithoutSurveyInput[] | PropertyDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutSurveyInput | PropertyDetailsCreateOrConnectWithoutSurveyInput[]
    upsert?: PropertyDetailsUpsertWithWhereUniqueWithoutSurveyInput | PropertyDetailsUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: PropertyDetailsCreateManySurveyInputEnvelope
    set?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    disconnect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    delete?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    connect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    update?: PropertyDetailsUpdateWithWhereUniqueWithoutSurveyInput | PropertyDetailsUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: PropertyDetailsUpdateManyWithWhereWithoutSurveyInput | PropertyDetailsUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: PropertyDetailsScalarWhereInput | PropertyDetailsScalarWhereInput[]
  }

  export type OwnerDetailsUncheckedUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<OwnerDetailsCreateWithoutSurveyInput, OwnerDetailsUncheckedCreateWithoutSurveyInput> | OwnerDetailsCreateWithoutSurveyInput[] | OwnerDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: OwnerDetailsCreateOrConnectWithoutSurveyInput | OwnerDetailsCreateOrConnectWithoutSurveyInput[]
    upsert?: OwnerDetailsUpsertWithWhereUniqueWithoutSurveyInput | OwnerDetailsUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: OwnerDetailsCreateManySurveyInputEnvelope
    set?: OwnerDetailsWhereUniqueInput | OwnerDetailsWhereUniqueInput[]
    disconnect?: OwnerDetailsWhereUniqueInput | OwnerDetailsWhereUniqueInput[]
    delete?: OwnerDetailsWhereUniqueInput | OwnerDetailsWhereUniqueInput[]
    connect?: OwnerDetailsWhereUniqueInput | OwnerDetailsWhereUniqueInput[]
    update?: OwnerDetailsUpdateWithWhereUniqueWithoutSurveyInput | OwnerDetailsUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: OwnerDetailsUpdateManyWithWhereWithoutSurveyInput | OwnerDetailsUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: OwnerDetailsScalarWhereInput | OwnerDetailsScalarWhereInput[]
  }

  export type LocationDetailsUncheckedUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<LocationDetailsCreateWithoutSurveyInput, LocationDetailsUncheckedCreateWithoutSurveyInput> | LocationDetailsCreateWithoutSurveyInput[] | LocationDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutSurveyInput | LocationDetailsCreateOrConnectWithoutSurveyInput[]
    upsert?: LocationDetailsUpsertWithWhereUniqueWithoutSurveyInput | LocationDetailsUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: LocationDetailsCreateManySurveyInputEnvelope
    set?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    disconnect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    delete?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    update?: LocationDetailsUpdateWithWhereUniqueWithoutSurveyInput | LocationDetailsUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: LocationDetailsUpdateManyWithWhereWithoutSurveyInput | LocationDetailsUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: LocationDetailsScalarWhereInput | LocationDetailsScalarWhereInput[]
  }

  export type OtherDetailsUncheckedUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<OtherDetailsCreateWithoutSurveyInput, OtherDetailsUncheckedCreateWithoutSurveyInput> | OtherDetailsCreateWithoutSurveyInput[] | OtherDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: OtherDetailsCreateOrConnectWithoutSurveyInput | OtherDetailsCreateOrConnectWithoutSurveyInput[]
    upsert?: OtherDetailsUpsertWithWhereUniqueWithoutSurveyInput | OtherDetailsUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: OtherDetailsCreateManySurveyInputEnvelope
    set?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    disconnect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    delete?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    connect?: OtherDetailsWhereUniqueInput | OtherDetailsWhereUniqueInput[]
    update?: OtherDetailsUpdateWithWhereUniqueWithoutSurveyInput | OtherDetailsUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: OtherDetailsUpdateManyWithWhereWithoutSurveyInput | OtherDetailsUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: OtherDetailsScalarWhereInput | OtherDetailsScalarWhereInput[]
  }

  export type ResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<ResidentialPropertyAssessmentCreateWithoutSurveyInput, ResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput> | ResidentialPropertyAssessmentCreateWithoutSurveyInput[] | ResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: ResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput | ResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput[]
    upsert?: ResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutSurveyInput | ResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: ResidentialPropertyAssessmentCreateManySurveyInputEnvelope
    set?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    disconnect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    delete?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    connect?: ResidentialPropertyAssessmentWhereUniqueInput | ResidentialPropertyAssessmentWhereUniqueInput[]
    update?: ResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutSurveyInput | ResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: ResidentialPropertyAssessmentUpdateManyWithWhereWithoutSurveyInput | ResidentialPropertyAssessmentUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: ResidentialPropertyAssessmentScalarWhereInput | ResidentialPropertyAssessmentScalarWhereInput[]
  }

  export type NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<NonResidentialPropertyAssessmentCreateWithoutSurveyInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput> | NonResidentialPropertyAssessmentCreateWithoutSurveyInput[] | NonResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: NonResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput | NonResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput[]
    upsert?: NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutSurveyInput | NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: NonResidentialPropertyAssessmentCreateManySurveyInputEnvelope
    set?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    disconnect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    delete?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    connect?: NonResidentialPropertyAssessmentWhereUniqueInput | NonResidentialPropertyAssessmentWhereUniqueInput[]
    update?: NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutSurveyInput | NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutSurveyInput | NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: NonResidentialPropertyAssessmentScalarWhereInput | NonResidentialPropertyAssessmentScalarWhereInput[]
  }

  export type PropertyAttachmentDetailsUncheckedUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<PropertyAttachmentDetailsCreateWithoutSurveyInput, PropertyAttachmentDetailsUncheckedCreateWithoutSurveyInput> | PropertyAttachmentDetailsCreateWithoutSurveyInput[] | PropertyAttachmentDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: PropertyAttachmentDetailsCreateOrConnectWithoutSurveyInput | PropertyAttachmentDetailsCreateOrConnectWithoutSurveyInput[]
    upsert?: PropertyAttachmentDetailsUpsertWithWhereUniqueWithoutSurveyInput | PropertyAttachmentDetailsUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: PropertyAttachmentDetailsCreateManySurveyInputEnvelope
    set?: PropertyAttachmentDetailsWhereUniqueInput | PropertyAttachmentDetailsWhereUniqueInput[]
    disconnect?: PropertyAttachmentDetailsWhereUniqueInput | PropertyAttachmentDetailsWhereUniqueInput[]
    delete?: PropertyAttachmentDetailsWhereUniqueInput | PropertyAttachmentDetailsWhereUniqueInput[]
    connect?: PropertyAttachmentDetailsWhereUniqueInput | PropertyAttachmentDetailsWhereUniqueInput[]
    update?: PropertyAttachmentDetailsUpdateWithWhereUniqueWithoutSurveyInput | PropertyAttachmentDetailsUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: PropertyAttachmentDetailsUpdateManyWithWhereWithoutSurveyInput | PropertyAttachmentDetailsUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: PropertyAttachmentDetailsScalarWhereInput | PropertyAttachmentDetailsScalarWhereInput[]
  }

  export type SurveyStatusMappingUncheckedUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<SurveyStatusMappingCreateWithoutSurveyInput, SurveyStatusMappingUncheckedCreateWithoutSurveyInput> | SurveyStatusMappingCreateWithoutSurveyInput[] | SurveyStatusMappingUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: SurveyStatusMappingCreateOrConnectWithoutSurveyInput | SurveyStatusMappingCreateOrConnectWithoutSurveyInput[]
    upsert?: SurveyStatusMappingUpsertWithWhereUniqueWithoutSurveyInput | SurveyStatusMappingUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: SurveyStatusMappingCreateManySurveyInputEnvelope
    set?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    disconnect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    delete?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    connect?: SurveyStatusMappingWhereUniqueInput | SurveyStatusMappingWhereUniqueInput[]
    update?: SurveyStatusMappingUpdateWithWhereUniqueWithoutSurveyInput | SurveyStatusMappingUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: SurveyStatusMappingUpdateManyWithWhereWithoutSurveyInput | SurveyStatusMappingUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: SurveyStatusMappingScalarWhereInput | SurveyStatusMappingScalarWhereInput[]
  }

  export type SurveyDetailsCreateNestedOneWithoutPropertyDetailsInput = {
    create?: XOR<SurveyDetailsCreateWithoutPropertyDetailsInput, SurveyDetailsUncheckedCreateWithoutPropertyDetailsInput>
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutPropertyDetailsInput
    connect?: SurveyDetailsWhereUniqueInput
  }

  export type ResponseTypeMasterCreateNestedOneWithoutPropertyDetailsInput = {
    create?: XOR<ResponseTypeMasterCreateWithoutPropertyDetailsInput, ResponseTypeMasterUncheckedCreateWithoutPropertyDetailsInput>
    connectOrCreate?: ResponseTypeMasterCreateOrConnectWithoutPropertyDetailsInput
    connect?: ResponseTypeMasterWhereUniqueInput
  }

  export type RespondentStatusMasterCreateNestedOneWithoutPropertyDetailsInput = {
    create?: XOR<RespondentStatusMasterCreateWithoutPropertyDetailsInput, RespondentStatusMasterUncheckedCreateWithoutPropertyDetailsInput>
    connectOrCreate?: RespondentStatusMasterCreateOrConnectWithoutPropertyDetailsInput
    connect?: RespondentStatusMasterWhereUniqueInput
  }

  export type SurveyDetailsUpdateOneRequiredWithoutPropertyDetailsNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutPropertyDetailsInput, SurveyDetailsUncheckedCreateWithoutPropertyDetailsInput>
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutPropertyDetailsInput
    upsert?: SurveyDetailsUpsertWithoutPropertyDetailsInput
    connect?: SurveyDetailsWhereUniqueInput
    update?: XOR<XOR<SurveyDetailsUpdateToOneWithWhereWithoutPropertyDetailsInput, SurveyDetailsUpdateWithoutPropertyDetailsInput>, SurveyDetailsUncheckedUpdateWithoutPropertyDetailsInput>
  }

  export type ResponseTypeMasterUpdateOneRequiredWithoutPropertyDetailsNestedInput = {
    create?: XOR<ResponseTypeMasterCreateWithoutPropertyDetailsInput, ResponseTypeMasterUncheckedCreateWithoutPropertyDetailsInput>
    connectOrCreate?: ResponseTypeMasterCreateOrConnectWithoutPropertyDetailsInput
    upsert?: ResponseTypeMasterUpsertWithoutPropertyDetailsInput
    connect?: ResponseTypeMasterWhereUniqueInput
    update?: XOR<XOR<ResponseTypeMasterUpdateToOneWithWhereWithoutPropertyDetailsInput, ResponseTypeMasterUpdateWithoutPropertyDetailsInput>, ResponseTypeMasterUncheckedUpdateWithoutPropertyDetailsInput>
  }

  export type RespondentStatusMasterUpdateOneRequiredWithoutPropertyDetailsNestedInput = {
    create?: XOR<RespondentStatusMasterCreateWithoutPropertyDetailsInput, RespondentStatusMasterUncheckedCreateWithoutPropertyDetailsInput>
    connectOrCreate?: RespondentStatusMasterCreateOrConnectWithoutPropertyDetailsInput
    upsert?: RespondentStatusMasterUpsertWithoutPropertyDetailsInput
    connect?: RespondentStatusMasterWhereUniqueInput
    update?: XOR<XOR<RespondentStatusMasterUpdateToOneWithWhereWithoutPropertyDetailsInput, RespondentStatusMasterUpdateWithoutPropertyDetailsInput>, RespondentStatusMasterUncheckedUpdateWithoutPropertyDetailsInput>
  }

  export type SurveyDetailsCreateNestedOneWithoutOwnerDetailsInput = {
    create?: XOR<SurveyDetailsCreateWithoutOwnerDetailsInput, SurveyDetailsUncheckedCreateWithoutOwnerDetailsInput>
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutOwnerDetailsInput
    connect?: SurveyDetailsWhereUniqueInput
  }

  export type SurveyDetailsUpdateOneRequiredWithoutOwnerDetailsNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutOwnerDetailsInput, SurveyDetailsUncheckedCreateWithoutOwnerDetailsInput>
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutOwnerDetailsInput
    upsert?: SurveyDetailsUpsertWithoutOwnerDetailsInput
    connect?: SurveyDetailsWhereUniqueInput
    update?: XOR<XOR<SurveyDetailsUpdateToOneWithWhereWithoutOwnerDetailsInput, SurveyDetailsUpdateWithoutOwnerDetailsInput>, SurveyDetailsUncheckedUpdateWithoutOwnerDetailsInput>
  }

  export type SurveyDetailsCreateNestedOneWithoutLocationDetailsInput = {
    create?: XOR<SurveyDetailsCreateWithoutLocationDetailsInput, SurveyDetailsUncheckedCreateWithoutLocationDetailsInput>
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutLocationDetailsInput
    connect?: SurveyDetailsWhereUniqueInput
  }

  export type PropertyTypeMasterCreateNestedOneWithoutLocationDetailsInput = {
    create?: XOR<PropertyTypeMasterCreateWithoutLocationDetailsInput, PropertyTypeMasterUncheckedCreateWithoutLocationDetailsInput>
    connectOrCreate?: PropertyTypeMasterCreateOrConnectWithoutLocationDetailsInput
    connect?: PropertyTypeMasterWhereUniqueInput
  }

  export type RoadTypeMasterCreateNestedOneWithoutLocationDetailsInput = {
    create?: XOR<RoadTypeMasterCreateWithoutLocationDetailsInput, RoadTypeMasterUncheckedCreateWithoutLocationDetailsInput>
    connectOrCreate?: RoadTypeMasterCreateOrConnectWithoutLocationDetailsInput
    connect?: RoadTypeMasterWhereUniqueInput
  }

  export type ConstructionTypeMasterCreateNestedOneWithoutLocationDetailsInput = {
    create?: XOR<ConstructionTypeMasterCreateWithoutLocationDetailsInput, ConstructionTypeMasterUncheckedCreateWithoutLocationDetailsInput>
    connectOrCreate?: ConstructionTypeMasterCreateOrConnectWithoutLocationDetailsInput
    connect?: ConstructionTypeMasterWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type SurveyDetailsUpdateOneRequiredWithoutLocationDetailsNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutLocationDetailsInput, SurveyDetailsUncheckedCreateWithoutLocationDetailsInput>
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutLocationDetailsInput
    upsert?: SurveyDetailsUpsertWithoutLocationDetailsInput
    connect?: SurveyDetailsWhereUniqueInput
    update?: XOR<XOR<SurveyDetailsUpdateToOneWithWhereWithoutLocationDetailsInput, SurveyDetailsUpdateWithoutLocationDetailsInput>, SurveyDetailsUncheckedUpdateWithoutLocationDetailsInput>
  }

  export type PropertyTypeMasterUpdateOneRequiredWithoutLocationDetailsNestedInput = {
    create?: XOR<PropertyTypeMasterCreateWithoutLocationDetailsInput, PropertyTypeMasterUncheckedCreateWithoutLocationDetailsInput>
    connectOrCreate?: PropertyTypeMasterCreateOrConnectWithoutLocationDetailsInput
    upsert?: PropertyTypeMasterUpsertWithoutLocationDetailsInput
    connect?: PropertyTypeMasterWhereUniqueInput
    update?: XOR<XOR<PropertyTypeMasterUpdateToOneWithWhereWithoutLocationDetailsInput, PropertyTypeMasterUpdateWithoutLocationDetailsInput>, PropertyTypeMasterUncheckedUpdateWithoutLocationDetailsInput>
  }

  export type RoadTypeMasterUpdateOneRequiredWithoutLocationDetailsNestedInput = {
    create?: XOR<RoadTypeMasterCreateWithoutLocationDetailsInput, RoadTypeMasterUncheckedCreateWithoutLocationDetailsInput>
    connectOrCreate?: RoadTypeMasterCreateOrConnectWithoutLocationDetailsInput
    upsert?: RoadTypeMasterUpsertWithoutLocationDetailsInput
    connect?: RoadTypeMasterWhereUniqueInput
    update?: XOR<XOR<RoadTypeMasterUpdateToOneWithWhereWithoutLocationDetailsInput, RoadTypeMasterUpdateWithoutLocationDetailsInput>, RoadTypeMasterUncheckedUpdateWithoutLocationDetailsInput>
  }

  export type ConstructionTypeMasterUpdateOneRequiredWithoutLocationDetailsNestedInput = {
    create?: XOR<ConstructionTypeMasterCreateWithoutLocationDetailsInput, ConstructionTypeMasterUncheckedCreateWithoutLocationDetailsInput>
    connectOrCreate?: ConstructionTypeMasterCreateOrConnectWithoutLocationDetailsInput
    upsert?: ConstructionTypeMasterUpsertWithoutLocationDetailsInput
    connect?: ConstructionTypeMasterWhereUniqueInput
    update?: XOR<XOR<ConstructionTypeMasterUpdateToOneWithWhereWithoutLocationDetailsInput, ConstructionTypeMasterUpdateWithoutLocationDetailsInput>, ConstructionTypeMasterUncheckedUpdateWithoutLocationDetailsInput>
  }

  export type SurveyDetailsCreateNestedOneWithoutOtherDetailsInput = {
    create?: XOR<SurveyDetailsCreateWithoutOtherDetailsInput, SurveyDetailsUncheckedCreateWithoutOtherDetailsInput>
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutOtherDetailsInput
    connect?: SurveyDetailsWhereUniqueInput
  }

  export type WaterSourceMasterCreateNestedOneWithoutOtherDetailsInput = {
    create?: XOR<WaterSourceMasterCreateWithoutOtherDetailsInput, WaterSourceMasterUncheckedCreateWithoutOtherDetailsInput>
    connectOrCreate?: WaterSourceMasterCreateOrConnectWithoutOtherDetailsInput
    connect?: WaterSourceMasterWhereUniqueInput
  }

  export type DisposalTypeMasterCreateNestedOneWithoutOtherDetailsInput = {
    create?: XOR<DisposalTypeMasterCreateWithoutOtherDetailsInput, DisposalTypeMasterUncheckedCreateWithoutOtherDetailsInput>
    connectOrCreate?: DisposalTypeMasterCreateOrConnectWithoutOtherDetailsInput
    connect?: DisposalTypeMasterWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SurveyDetailsUpdateOneRequiredWithoutOtherDetailsNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutOtherDetailsInput, SurveyDetailsUncheckedCreateWithoutOtherDetailsInput>
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutOtherDetailsInput
    upsert?: SurveyDetailsUpsertWithoutOtherDetailsInput
    connect?: SurveyDetailsWhereUniqueInput
    update?: XOR<XOR<SurveyDetailsUpdateToOneWithWhereWithoutOtherDetailsInput, SurveyDetailsUpdateWithoutOtherDetailsInput>, SurveyDetailsUncheckedUpdateWithoutOtherDetailsInput>
  }

  export type WaterSourceMasterUpdateOneRequiredWithoutOtherDetailsNestedInput = {
    create?: XOR<WaterSourceMasterCreateWithoutOtherDetailsInput, WaterSourceMasterUncheckedCreateWithoutOtherDetailsInput>
    connectOrCreate?: WaterSourceMasterCreateOrConnectWithoutOtherDetailsInput
    upsert?: WaterSourceMasterUpsertWithoutOtherDetailsInput
    connect?: WaterSourceMasterWhereUniqueInput
    update?: XOR<XOR<WaterSourceMasterUpdateToOneWithWhereWithoutOtherDetailsInput, WaterSourceMasterUpdateWithoutOtherDetailsInput>, WaterSourceMasterUncheckedUpdateWithoutOtherDetailsInput>
  }

  export type DisposalTypeMasterUpdateOneRequiredWithoutOtherDetailsNestedInput = {
    create?: XOR<DisposalTypeMasterCreateWithoutOtherDetailsInput, DisposalTypeMasterUncheckedCreateWithoutOtherDetailsInput>
    connectOrCreate?: DisposalTypeMasterCreateOrConnectWithoutOtherDetailsInput
    upsert?: DisposalTypeMasterUpsertWithoutOtherDetailsInput
    connect?: DisposalTypeMasterWhereUniqueInput
    update?: XOR<XOR<DisposalTypeMasterUpdateToOneWithWhereWithoutOtherDetailsInput, DisposalTypeMasterUpdateWithoutOtherDetailsInput>, DisposalTypeMasterUncheckedUpdateWithoutOtherDetailsInput>
  }

  export type SurveyDetailsCreateNestedOneWithoutResidentialPropertyAssessmentsInput = {
    create?: XOR<SurveyDetailsCreateWithoutResidentialPropertyAssessmentsInput, SurveyDetailsUncheckedCreateWithoutResidentialPropertyAssessmentsInput>
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutResidentialPropertyAssessmentsInput
    connect?: SurveyDetailsWhereUniqueInput
  }

  export type OccupancyStatusMasterCreateNestedOneWithoutResidentialPropertyAssessmentsInput = {
    create?: XOR<OccupancyStatusMasterCreateWithoutResidentialPropertyAssessmentsInput, OccupancyStatusMasterUncheckedCreateWithoutResidentialPropertyAssessmentsInput>
    connectOrCreate?: OccupancyStatusMasterCreateOrConnectWithoutResidentialPropertyAssessmentsInput
    connect?: OccupancyStatusMasterWhereUniqueInput
  }

  export type ConstructionNatureMasterCreateNestedOneWithoutResidentialPropertyAssessmentsInput = {
    create?: XOR<ConstructionNatureMasterCreateWithoutResidentialPropertyAssessmentsInput, ConstructionNatureMasterUncheckedCreateWithoutResidentialPropertyAssessmentsInput>
    connectOrCreate?: ConstructionNatureMasterCreateOrConnectWithoutResidentialPropertyAssessmentsInput
    connect?: ConstructionNatureMasterWhereUniqueInput
  }

  export type SurveyDetailsUpdateOneRequiredWithoutResidentialPropertyAssessmentsNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutResidentialPropertyAssessmentsInput, SurveyDetailsUncheckedCreateWithoutResidentialPropertyAssessmentsInput>
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutResidentialPropertyAssessmentsInput
    upsert?: SurveyDetailsUpsertWithoutResidentialPropertyAssessmentsInput
    connect?: SurveyDetailsWhereUniqueInput
    update?: XOR<XOR<SurveyDetailsUpdateToOneWithWhereWithoutResidentialPropertyAssessmentsInput, SurveyDetailsUpdateWithoutResidentialPropertyAssessmentsInput>, SurveyDetailsUncheckedUpdateWithoutResidentialPropertyAssessmentsInput>
  }

  export type OccupancyStatusMasterUpdateOneRequiredWithoutResidentialPropertyAssessmentsNestedInput = {
    create?: XOR<OccupancyStatusMasterCreateWithoutResidentialPropertyAssessmentsInput, OccupancyStatusMasterUncheckedCreateWithoutResidentialPropertyAssessmentsInput>
    connectOrCreate?: OccupancyStatusMasterCreateOrConnectWithoutResidentialPropertyAssessmentsInput
    upsert?: OccupancyStatusMasterUpsertWithoutResidentialPropertyAssessmentsInput
    connect?: OccupancyStatusMasterWhereUniqueInput
    update?: XOR<XOR<OccupancyStatusMasterUpdateToOneWithWhereWithoutResidentialPropertyAssessmentsInput, OccupancyStatusMasterUpdateWithoutResidentialPropertyAssessmentsInput>, OccupancyStatusMasterUncheckedUpdateWithoutResidentialPropertyAssessmentsInput>
  }

  export type ConstructionNatureMasterUpdateOneRequiredWithoutResidentialPropertyAssessmentsNestedInput = {
    create?: XOR<ConstructionNatureMasterCreateWithoutResidentialPropertyAssessmentsInput, ConstructionNatureMasterUncheckedCreateWithoutResidentialPropertyAssessmentsInput>
    connectOrCreate?: ConstructionNatureMasterCreateOrConnectWithoutResidentialPropertyAssessmentsInput
    upsert?: ConstructionNatureMasterUpsertWithoutResidentialPropertyAssessmentsInput
    connect?: ConstructionNatureMasterWhereUniqueInput
    update?: XOR<XOR<ConstructionNatureMasterUpdateToOneWithWhereWithoutResidentialPropertyAssessmentsInput, ConstructionNatureMasterUpdateWithoutResidentialPropertyAssessmentsInput>, ConstructionNatureMasterUncheckedUpdateWithoutResidentialPropertyAssessmentsInput>
  }

  export type NrPropertyCategoryMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput = {
    create?: XOR<NrPropertyCategoryMasterCreateWithoutNonResidentialPropertyAssessmentsInput, NrPropertyCategoryMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
    connectOrCreate?: NrPropertyCategoryMasterCreateOrConnectWithoutNonResidentialPropertyAssessmentsInput
    connect?: NrPropertyCategoryMasterWhereUniqueInput
  }

  export type NrPropertySubCategoryMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput = {
    create?: XOR<NrPropertySubCategoryMasterCreateWithoutNonResidentialPropertyAssessmentsInput, NrPropertySubCategoryMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
    connectOrCreate?: NrPropertySubCategoryMasterCreateOrConnectWithoutNonResidentialPropertyAssessmentsInput
    connect?: NrPropertySubCategoryMasterWhereUniqueInput
  }

  export type OccupancyStatusMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput = {
    create?: XOR<OccupancyStatusMasterCreateWithoutNonResidentialPropertyAssessmentsInput, OccupancyStatusMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
    connectOrCreate?: OccupancyStatusMasterCreateOrConnectWithoutNonResidentialPropertyAssessmentsInput
    connect?: OccupancyStatusMasterWhereUniqueInput
  }

  export type ConstructionNatureMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput = {
    create?: XOR<ConstructionNatureMasterCreateWithoutNonResidentialPropertyAssessmentsInput, ConstructionNatureMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
    connectOrCreate?: ConstructionNatureMasterCreateOrConnectWithoutNonResidentialPropertyAssessmentsInput
    connect?: ConstructionNatureMasterWhereUniqueInput
  }

  export type SurveyDetailsCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput = {
    create?: XOR<SurveyDetailsCreateWithoutNonResidentialPropertyAssessmentsInput, SurveyDetailsUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutNonResidentialPropertyAssessmentsInput
    connect?: SurveyDetailsWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NrPropertyCategoryMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput = {
    create?: XOR<NrPropertyCategoryMasterCreateWithoutNonResidentialPropertyAssessmentsInput, NrPropertyCategoryMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
    connectOrCreate?: NrPropertyCategoryMasterCreateOrConnectWithoutNonResidentialPropertyAssessmentsInput
    upsert?: NrPropertyCategoryMasterUpsertWithoutNonResidentialPropertyAssessmentsInput
    connect?: NrPropertyCategoryMasterWhereUniqueInput
    update?: XOR<XOR<NrPropertyCategoryMasterUpdateToOneWithWhereWithoutNonResidentialPropertyAssessmentsInput, NrPropertyCategoryMasterUpdateWithoutNonResidentialPropertyAssessmentsInput>, NrPropertyCategoryMasterUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput>
  }

  export type NrPropertySubCategoryMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput = {
    create?: XOR<NrPropertySubCategoryMasterCreateWithoutNonResidentialPropertyAssessmentsInput, NrPropertySubCategoryMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
    connectOrCreate?: NrPropertySubCategoryMasterCreateOrConnectWithoutNonResidentialPropertyAssessmentsInput
    upsert?: NrPropertySubCategoryMasterUpsertWithoutNonResidentialPropertyAssessmentsInput
    connect?: NrPropertySubCategoryMasterWhereUniqueInput
    update?: XOR<XOR<NrPropertySubCategoryMasterUpdateToOneWithWhereWithoutNonResidentialPropertyAssessmentsInput, NrPropertySubCategoryMasterUpdateWithoutNonResidentialPropertyAssessmentsInput>, NrPropertySubCategoryMasterUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput>
  }

  export type OccupancyStatusMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput = {
    create?: XOR<OccupancyStatusMasterCreateWithoutNonResidentialPropertyAssessmentsInput, OccupancyStatusMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
    connectOrCreate?: OccupancyStatusMasterCreateOrConnectWithoutNonResidentialPropertyAssessmentsInput
    upsert?: OccupancyStatusMasterUpsertWithoutNonResidentialPropertyAssessmentsInput
    connect?: OccupancyStatusMasterWhereUniqueInput
    update?: XOR<XOR<OccupancyStatusMasterUpdateToOneWithWhereWithoutNonResidentialPropertyAssessmentsInput, OccupancyStatusMasterUpdateWithoutNonResidentialPropertyAssessmentsInput>, OccupancyStatusMasterUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput>
  }

  export type ConstructionNatureMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput = {
    create?: XOR<ConstructionNatureMasterCreateWithoutNonResidentialPropertyAssessmentsInput, ConstructionNatureMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
    connectOrCreate?: ConstructionNatureMasterCreateOrConnectWithoutNonResidentialPropertyAssessmentsInput
    upsert?: ConstructionNatureMasterUpsertWithoutNonResidentialPropertyAssessmentsInput
    connect?: ConstructionNatureMasterWhereUniqueInput
    update?: XOR<XOR<ConstructionNatureMasterUpdateToOneWithWhereWithoutNonResidentialPropertyAssessmentsInput, ConstructionNatureMasterUpdateWithoutNonResidentialPropertyAssessmentsInput>, ConstructionNatureMasterUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput>
  }

  export type SurveyDetailsUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutNonResidentialPropertyAssessmentsInput, SurveyDetailsUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutNonResidentialPropertyAssessmentsInput
    upsert?: SurveyDetailsUpsertWithoutNonResidentialPropertyAssessmentsInput
    connect?: SurveyDetailsWhereUniqueInput
    update?: XOR<XOR<SurveyDetailsUpdateToOneWithWhereWithoutNonResidentialPropertyAssessmentsInput, SurveyDetailsUpdateWithoutNonResidentialPropertyAssessmentsInput>, SurveyDetailsUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput>
  }

  export type SurveyDetailsCreateNestedOneWithoutPropertyAttachmentsInput = {
    create?: XOR<SurveyDetailsCreateWithoutPropertyAttachmentsInput, SurveyDetailsUncheckedCreateWithoutPropertyAttachmentsInput>
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutPropertyAttachmentsInput
    connect?: SurveyDetailsWhereUniqueInput
  }

  export type SurveyDetailsUpdateOneRequiredWithoutPropertyAttachmentsNestedInput = {
    create?: XOR<SurveyDetailsCreateWithoutPropertyAttachmentsInput, SurveyDetailsUncheckedCreateWithoutPropertyAttachmentsInput>
    connectOrCreate?: SurveyDetailsCreateOrConnectWithoutPropertyAttachmentsInput
    upsert?: SurveyDetailsUpsertWithoutPropertyAttachmentsInput
    connect?: SurveyDetailsWhereUniqueInput
    update?: XOR<XOR<SurveyDetailsUpdateToOneWithWhereWithoutPropertyAttachmentsInput, SurveyDetailsUpdateWithoutPropertyAttachmentsInput>, SurveyDetailsUncheckedUpdateWithoutPropertyAttachmentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UlbZoneMappingCreateWithoutUlbInput = {
    ulbZoneMapId?: string
    isActive?: boolean
    zone: ZoneMasterCreateNestedOneWithoutUlbZoneMapsInput
    surveyors?: SurveyorsCreateNestedManyWithoutUlbZoneMapInput
  }

  export type UlbZoneMappingUncheckedCreateWithoutUlbInput = {
    ulbZoneMapId?: string
    zoneId: string
    isActive?: boolean
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutUlbZoneMapInput
  }

  export type UlbZoneMappingCreateOrConnectWithoutUlbInput = {
    where: UlbZoneMappingWhereUniqueInput
    create: XOR<UlbZoneMappingCreateWithoutUlbInput, UlbZoneMappingUncheckedCreateWithoutUlbInput>
  }

  export type UlbZoneMappingCreateManyUlbInputEnvelope = {
    data: UlbZoneMappingCreateManyUlbInput | UlbZoneMappingCreateManyUlbInput[]
    skipDuplicates?: boolean
  }

  export type SurveyDetailsCreateWithoutUlbInput = {
    surveyUniqueCode?: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    zone: ZoneMasterCreateNestedOneWithoutSurveyDetailsInput
    ward: WardMasterCreateNestedOneWithoutSurveyDetailsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyDetailsInput
    surveyType: SurveyTypeMasterCreateNestedOneWithoutSurveyDetailsInput
    propertyDetails?: PropertyDetailsCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsUncheckedCreateWithoutUlbInput = {
    surveyUniqueCode?: string
    zoneId: string
    wardId: string
    mohallaId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    propertyDetails?: PropertyDetailsUncheckedCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsUncheckedCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsUncheckedCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsUncheckedCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsCreateOrConnectWithoutUlbInput = {
    where: SurveyDetailsWhereUniqueInput
    create: XOR<SurveyDetailsCreateWithoutUlbInput, SurveyDetailsUncheckedCreateWithoutUlbInput>
  }

  export type SurveyDetailsCreateManyUlbInputEnvelope = {
    data: SurveyDetailsCreateManyUlbInput | SurveyDetailsCreateManyUlbInput[]
    skipDuplicates?: boolean
  }

  export type UlbZoneMappingUpsertWithWhereUniqueWithoutUlbInput = {
    where: UlbZoneMappingWhereUniqueInput
    update: XOR<UlbZoneMappingUpdateWithoutUlbInput, UlbZoneMappingUncheckedUpdateWithoutUlbInput>
    create: XOR<UlbZoneMappingCreateWithoutUlbInput, UlbZoneMappingUncheckedCreateWithoutUlbInput>
  }

  export type UlbZoneMappingUpdateWithWhereUniqueWithoutUlbInput = {
    where: UlbZoneMappingWhereUniqueInput
    data: XOR<UlbZoneMappingUpdateWithoutUlbInput, UlbZoneMappingUncheckedUpdateWithoutUlbInput>
  }

  export type UlbZoneMappingUpdateManyWithWhereWithoutUlbInput = {
    where: UlbZoneMappingScalarWhereInput
    data: XOR<UlbZoneMappingUpdateManyMutationInput, UlbZoneMappingUncheckedUpdateManyWithoutUlbInput>
  }

  export type UlbZoneMappingScalarWhereInput = {
    AND?: UlbZoneMappingScalarWhereInput | UlbZoneMappingScalarWhereInput[]
    OR?: UlbZoneMappingScalarWhereInput[]
    NOT?: UlbZoneMappingScalarWhereInput | UlbZoneMappingScalarWhereInput[]
    ulbZoneMapId?: StringFilter<"UlbZoneMapping"> | string
    ulbId?: StringFilter<"UlbZoneMapping"> | string
    zoneId?: StringFilter<"UlbZoneMapping"> | string
    isActive?: BoolFilter<"UlbZoneMapping"> | boolean
  }

  export type SurveyDetailsUpsertWithWhereUniqueWithoutUlbInput = {
    where: SurveyDetailsWhereUniqueInput
    update: XOR<SurveyDetailsUpdateWithoutUlbInput, SurveyDetailsUncheckedUpdateWithoutUlbInput>
    create: XOR<SurveyDetailsCreateWithoutUlbInput, SurveyDetailsUncheckedCreateWithoutUlbInput>
  }

  export type SurveyDetailsUpdateWithWhereUniqueWithoutUlbInput = {
    where: SurveyDetailsWhereUniqueInput
    data: XOR<SurveyDetailsUpdateWithoutUlbInput, SurveyDetailsUncheckedUpdateWithoutUlbInput>
  }

  export type SurveyDetailsUpdateManyWithWhereWithoutUlbInput = {
    where: SurveyDetailsScalarWhereInput
    data: XOR<SurveyDetailsUpdateManyMutationInput, SurveyDetailsUncheckedUpdateManyWithoutUlbInput>
  }

  export type SurveyDetailsScalarWhereInput = {
    AND?: SurveyDetailsScalarWhereInput | SurveyDetailsScalarWhereInput[]
    OR?: SurveyDetailsScalarWhereInput[]
    NOT?: SurveyDetailsScalarWhereInput | SurveyDetailsScalarWhereInput[]
    surveyUniqueCode?: StringFilter<"SurveyDetails"> | string
    ulbId?: StringFilter<"SurveyDetails"> | string
    zoneId?: StringFilter<"SurveyDetails"> | string
    wardId?: StringFilter<"SurveyDetails"> | string
    mohallaId?: StringFilter<"SurveyDetails"> | string
    surveyTypeId?: StringFilter<"SurveyDetails"> | string
    entryDate?: DateTimeFilter<"SurveyDetails"> | Date | string
    parcelId?: IntNullableFilter<"SurveyDetails"> | number | null
    mapId?: IntFilter<"SurveyDetails"> | number
    gisId?: StringFilter<"SurveyDetails"> | string
    subGisId?: StringNullableFilter<"SurveyDetails"> | string | null
  }

  export type UlbZoneMappingCreateWithoutZoneInput = {
    ulbZoneMapId?: string
    isActive?: boolean
    ulb: UlbMasterCreateNestedOneWithoutUlbZoneMapsInput
    surveyors?: SurveyorsCreateNestedManyWithoutUlbZoneMapInput
  }

  export type UlbZoneMappingUncheckedCreateWithoutZoneInput = {
    ulbZoneMapId?: string
    ulbId: string
    isActive?: boolean
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutUlbZoneMapInput
  }

  export type UlbZoneMappingCreateOrConnectWithoutZoneInput = {
    where: UlbZoneMappingWhereUniqueInput
    create: XOR<UlbZoneMappingCreateWithoutZoneInput, UlbZoneMappingUncheckedCreateWithoutZoneInput>
  }

  export type UlbZoneMappingCreateManyZoneInputEnvelope = {
    data: UlbZoneMappingCreateManyZoneInput | UlbZoneMappingCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type ZoneWardMappingCreateWithoutZoneInput = {
    zoneWardMapId?: string
    isActive?: boolean
    ward: WardMasterCreateNestedOneWithoutZoneWardMapsInput
    surveyors?: SurveyorsCreateNestedManyWithoutZoneWardMapInput
  }

  export type ZoneWardMappingUncheckedCreateWithoutZoneInput = {
    zoneWardMapId?: string
    wardId: string
    isActive?: boolean
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutZoneWardMapInput
  }

  export type ZoneWardMappingCreateOrConnectWithoutZoneInput = {
    where: ZoneWardMappingWhereUniqueInput
    create: XOR<ZoneWardMappingCreateWithoutZoneInput, ZoneWardMappingUncheckedCreateWithoutZoneInput>
  }

  export type ZoneWardMappingCreateManyZoneInputEnvelope = {
    data: ZoneWardMappingCreateManyZoneInput | ZoneWardMappingCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type SurveyDetailsCreateWithoutZoneInput = {
    surveyUniqueCode?: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    ulb: UlbMasterCreateNestedOneWithoutSurveyDetailsInput
    ward: WardMasterCreateNestedOneWithoutSurveyDetailsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyDetailsInput
    surveyType: SurveyTypeMasterCreateNestedOneWithoutSurveyDetailsInput
    propertyDetails?: PropertyDetailsCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsUncheckedCreateWithoutZoneInput = {
    surveyUniqueCode?: string
    ulbId: string
    wardId: string
    mohallaId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    propertyDetails?: PropertyDetailsUncheckedCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsUncheckedCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsUncheckedCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsUncheckedCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsCreateOrConnectWithoutZoneInput = {
    where: SurveyDetailsWhereUniqueInput
    create: XOR<SurveyDetailsCreateWithoutZoneInput, SurveyDetailsUncheckedCreateWithoutZoneInput>
  }

  export type SurveyDetailsCreateManyZoneInputEnvelope = {
    data: SurveyDetailsCreateManyZoneInput | SurveyDetailsCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type UlbZoneMappingUpsertWithWhereUniqueWithoutZoneInput = {
    where: UlbZoneMappingWhereUniqueInput
    update: XOR<UlbZoneMappingUpdateWithoutZoneInput, UlbZoneMappingUncheckedUpdateWithoutZoneInput>
    create: XOR<UlbZoneMappingCreateWithoutZoneInput, UlbZoneMappingUncheckedCreateWithoutZoneInput>
  }

  export type UlbZoneMappingUpdateWithWhereUniqueWithoutZoneInput = {
    where: UlbZoneMappingWhereUniqueInput
    data: XOR<UlbZoneMappingUpdateWithoutZoneInput, UlbZoneMappingUncheckedUpdateWithoutZoneInput>
  }

  export type UlbZoneMappingUpdateManyWithWhereWithoutZoneInput = {
    where: UlbZoneMappingScalarWhereInput
    data: XOR<UlbZoneMappingUpdateManyMutationInput, UlbZoneMappingUncheckedUpdateManyWithoutZoneInput>
  }

  export type ZoneWardMappingUpsertWithWhereUniqueWithoutZoneInput = {
    where: ZoneWardMappingWhereUniqueInput
    update: XOR<ZoneWardMappingUpdateWithoutZoneInput, ZoneWardMappingUncheckedUpdateWithoutZoneInput>
    create: XOR<ZoneWardMappingCreateWithoutZoneInput, ZoneWardMappingUncheckedCreateWithoutZoneInput>
  }

  export type ZoneWardMappingUpdateWithWhereUniqueWithoutZoneInput = {
    where: ZoneWardMappingWhereUniqueInput
    data: XOR<ZoneWardMappingUpdateWithoutZoneInput, ZoneWardMappingUncheckedUpdateWithoutZoneInput>
  }

  export type ZoneWardMappingUpdateManyWithWhereWithoutZoneInput = {
    where: ZoneWardMappingScalarWhereInput
    data: XOR<ZoneWardMappingUpdateManyMutationInput, ZoneWardMappingUncheckedUpdateManyWithoutZoneInput>
  }

  export type ZoneWardMappingScalarWhereInput = {
    AND?: ZoneWardMappingScalarWhereInput | ZoneWardMappingScalarWhereInput[]
    OR?: ZoneWardMappingScalarWhereInput[]
    NOT?: ZoneWardMappingScalarWhereInput | ZoneWardMappingScalarWhereInput[]
    zoneWardMapId?: StringFilter<"ZoneWardMapping"> | string
    zoneId?: StringFilter<"ZoneWardMapping"> | string
    wardId?: StringFilter<"ZoneWardMapping"> | string
    isActive?: BoolFilter<"ZoneWardMapping"> | boolean
  }

  export type SurveyDetailsUpsertWithWhereUniqueWithoutZoneInput = {
    where: SurveyDetailsWhereUniqueInput
    update: XOR<SurveyDetailsUpdateWithoutZoneInput, SurveyDetailsUncheckedUpdateWithoutZoneInput>
    create: XOR<SurveyDetailsCreateWithoutZoneInput, SurveyDetailsUncheckedCreateWithoutZoneInput>
  }

  export type SurveyDetailsUpdateWithWhereUniqueWithoutZoneInput = {
    where: SurveyDetailsWhereUniqueInput
    data: XOR<SurveyDetailsUpdateWithoutZoneInput, SurveyDetailsUncheckedUpdateWithoutZoneInput>
  }

  export type SurveyDetailsUpdateManyWithWhereWithoutZoneInput = {
    where: SurveyDetailsScalarWhereInput
    data: XOR<SurveyDetailsUpdateManyMutationInput, SurveyDetailsUncheckedUpdateManyWithoutZoneInput>
  }

  export type ZoneWardMappingCreateWithoutWardInput = {
    zoneWardMapId?: string
    isActive?: boolean
    zone: ZoneMasterCreateNestedOneWithoutZoneWardMapsInput
    surveyors?: SurveyorsCreateNestedManyWithoutZoneWardMapInput
  }

  export type ZoneWardMappingUncheckedCreateWithoutWardInput = {
    zoneWardMapId?: string
    zoneId: string
    isActive?: boolean
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutZoneWardMapInput
  }

  export type ZoneWardMappingCreateOrConnectWithoutWardInput = {
    where: ZoneWardMappingWhereUniqueInput
    create: XOR<ZoneWardMappingCreateWithoutWardInput, ZoneWardMappingUncheckedCreateWithoutWardInput>
  }

  export type ZoneWardMappingCreateManyWardInputEnvelope = {
    data: ZoneWardMappingCreateManyWardInput | ZoneWardMappingCreateManyWardInput[]
    skipDuplicates?: boolean
  }

  export type WardMohallaMappingCreateWithoutWardInput = {
    wardMohallaMapId?: string
    isActive?: boolean
    mohalla: MohallaMasterCreateNestedOneWithoutWardMohallaMapsInput
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutWardMohallaMapInput
    surveyors?: SurveyorsCreateNestedManyWithoutWardMohallaMapInput
  }

  export type WardMohallaMappingUncheckedCreateWithoutWardInput = {
    wardMohallaMapId?: string
    mohallaId: string
    isActive?: boolean
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutWardMohallaMapInput
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutWardMohallaMapInput
  }

  export type WardMohallaMappingCreateOrConnectWithoutWardInput = {
    where: WardMohallaMappingWhereUniqueInput
    create: XOR<WardMohallaMappingCreateWithoutWardInput, WardMohallaMappingUncheckedCreateWithoutWardInput>
  }

  export type WardMohallaMappingCreateManyWardInputEnvelope = {
    data: WardMohallaMappingCreateManyWardInput | WardMohallaMappingCreateManyWardInput[]
    skipDuplicates?: boolean
  }

  export type SurveyorAssignmentCreateWithoutWardInput = {
    assignmentId?: string
    assignmentType: string
    isActive?: boolean
    user: UsersMasterCreateNestedOneWithoutSurveyorAssignmentsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyorAssignmentsInput
    wardMohallaMap: WardMohallaMappingCreateNestedOneWithoutSurveyorAssignmentsInput
    assignedBy: UsersMasterCreateNestedOneWithoutSurveyorAssignmentsAssignedByInput
  }

  export type SurveyorAssignmentUncheckedCreateWithoutWardInput = {
    assignmentId?: string
    userId: string
    assignmentType: string
    mohallaId: string
    wardMohallaMapId: string
    assignedById: string
    isActive?: boolean
  }

  export type SurveyorAssignmentCreateOrConnectWithoutWardInput = {
    where: SurveyorAssignmentWhereUniqueInput
    create: XOR<SurveyorAssignmentCreateWithoutWardInput, SurveyorAssignmentUncheckedCreateWithoutWardInput>
  }

  export type SurveyorAssignmentCreateManyWardInputEnvelope = {
    data: SurveyorAssignmentCreateManyWardInput | SurveyorAssignmentCreateManyWardInput[]
    skipDuplicates?: boolean
  }

  export type WardStatusMappingCreateWithoutWardInput = {
    wardStatusId?: string
    isActive?: boolean
    status: WardStatusMasterCreateNestedOneWithoutWardStatusMapsInput
    changedBy: UsersMasterCreateNestedOneWithoutWardStatusMapsInput
  }

  export type WardStatusMappingUncheckedCreateWithoutWardInput = {
    wardStatusId?: string
    statusId: string
    changedById: string
    isActive?: boolean
  }

  export type WardStatusMappingCreateOrConnectWithoutWardInput = {
    where: WardStatusMappingWhereUniqueInput
    create: XOR<WardStatusMappingCreateWithoutWardInput, WardStatusMappingUncheckedCreateWithoutWardInput>
  }

  export type WardStatusMappingCreateManyWardInputEnvelope = {
    data: WardStatusMappingCreateManyWardInput | WardStatusMappingCreateManyWardInput[]
    skipDuplicates?: boolean
  }

  export type SurveyDetailsCreateWithoutWardInput = {
    surveyUniqueCode?: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    ulb: UlbMasterCreateNestedOneWithoutSurveyDetailsInput
    zone: ZoneMasterCreateNestedOneWithoutSurveyDetailsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyDetailsInput
    surveyType: SurveyTypeMasterCreateNestedOneWithoutSurveyDetailsInput
    propertyDetails?: PropertyDetailsCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsUncheckedCreateWithoutWardInput = {
    surveyUniqueCode?: string
    ulbId: string
    zoneId: string
    mohallaId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    propertyDetails?: PropertyDetailsUncheckedCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsUncheckedCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsUncheckedCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsUncheckedCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsCreateOrConnectWithoutWardInput = {
    where: SurveyDetailsWhereUniqueInput
    create: XOR<SurveyDetailsCreateWithoutWardInput, SurveyDetailsUncheckedCreateWithoutWardInput>
  }

  export type SurveyDetailsCreateManyWardInputEnvelope = {
    data: SurveyDetailsCreateManyWardInput | SurveyDetailsCreateManyWardInput[]
    skipDuplicates?: boolean
  }

  export type SupervisorsCreateWithoutWardInput = {
    supervisorName: string
    username: string
    password: string
    user: UsersMasterCreateNestedOneWithoutSupervisorsInput
  }

  export type SupervisorsUncheckedCreateWithoutWardInput = {
    userId: string
    supervisorName: string
    username: string
    password: string
  }

  export type SupervisorsCreateOrConnectWithoutWardInput = {
    where: SupervisorsWhereUniqueInput
    create: XOR<SupervisorsCreateWithoutWardInput, SupervisorsUncheckedCreateWithoutWardInput>
  }

  export type SupervisorsCreateManyWardInputEnvelope = {
    data: SupervisorsCreateManyWardInput | SupervisorsCreateManyWardInput[]
    skipDuplicates?: boolean
  }

  export type ZoneWardMappingUpsertWithWhereUniqueWithoutWardInput = {
    where: ZoneWardMappingWhereUniqueInput
    update: XOR<ZoneWardMappingUpdateWithoutWardInput, ZoneWardMappingUncheckedUpdateWithoutWardInput>
    create: XOR<ZoneWardMappingCreateWithoutWardInput, ZoneWardMappingUncheckedCreateWithoutWardInput>
  }

  export type ZoneWardMappingUpdateWithWhereUniqueWithoutWardInput = {
    where: ZoneWardMappingWhereUniqueInput
    data: XOR<ZoneWardMappingUpdateWithoutWardInput, ZoneWardMappingUncheckedUpdateWithoutWardInput>
  }

  export type ZoneWardMappingUpdateManyWithWhereWithoutWardInput = {
    where: ZoneWardMappingScalarWhereInput
    data: XOR<ZoneWardMappingUpdateManyMutationInput, ZoneWardMappingUncheckedUpdateManyWithoutWardInput>
  }

  export type WardMohallaMappingUpsertWithWhereUniqueWithoutWardInput = {
    where: WardMohallaMappingWhereUniqueInput
    update: XOR<WardMohallaMappingUpdateWithoutWardInput, WardMohallaMappingUncheckedUpdateWithoutWardInput>
    create: XOR<WardMohallaMappingCreateWithoutWardInput, WardMohallaMappingUncheckedCreateWithoutWardInput>
  }

  export type WardMohallaMappingUpdateWithWhereUniqueWithoutWardInput = {
    where: WardMohallaMappingWhereUniqueInput
    data: XOR<WardMohallaMappingUpdateWithoutWardInput, WardMohallaMappingUncheckedUpdateWithoutWardInput>
  }

  export type WardMohallaMappingUpdateManyWithWhereWithoutWardInput = {
    where: WardMohallaMappingScalarWhereInput
    data: XOR<WardMohallaMappingUpdateManyMutationInput, WardMohallaMappingUncheckedUpdateManyWithoutWardInput>
  }

  export type WardMohallaMappingScalarWhereInput = {
    AND?: WardMohallaMappingScalarWhereInput | WardMohallaMappingScalarWhereInput[]
    OR?: WardMohallaMappingScalarWhereInput[]
    NOT?: WardMohallaMappingScalarWhereInput | WardMohallaMappingScalarWhereInput[]
    wardMohallaMapId?: StringFilter<"WardMohallaMapping"> | string
    wardId?: StringFilter<"WardMohallaMapping"> | string
    mohallaId?: StringFilter<"WardMohallaMapping"> | string
    isActive?: BoolFilter<"WardMohallaMapping"> | boolean
  }

  export type SurveyorAssignmentUpsertWithWhereUniqueWithoutWardInput = {
    where: SurveyorAssignmentWhereUniqueInput
    update: XOR<SurveyorAssignmentUpdateWithoutWardInput, SurveyorAssignmentUncheckedUpdateWithoutWardInput>
    create: XOR<SurveyorAssignmentCreateWithoutWardInput, SurveyorAssignmentUncheckedCreateWithoutWardInput>
  }

  export type SurveyorAssignmentUpdateWithWhereUniqueWithoutWardInput = {
    where: SurveyorAssignmentWhereUniqueInput
    data: XOR<SurveyorAssignmentUpdateWithoutWardInput, SurveyorAssignmentUncheckedUpdateWithoutWardInput>
  }

  export type SurveyorAssignmentUpdateManyWithWhereWithoutWardInput = {
    where: SurveyorAssignmentScalarWhereInput
    data: XOR<SurveyorAssignmentUpdateManyMutationInput, SurveyorAssignmentUncheckedUpdateManyWithoutWardInput>
  }

  export type SurveyorAssignmentScalarWhereInput = {
    AND?: SurveyorAssignmentScalarWhereInput | SurveyorAssignmentScalarWhereInput[]
    OR?: SurveyorAssignmentScalarWhereInput[]
    NOT?: SurveyorAssignmentScalarWhereInput | SurveyorAssignmentScalarWhereInput[]
    assignmentId?: StringFilter<"SurveyorAssignment"> | string
    userId?: StringFilter<"SurveyorAssignment"> | string
    assignmentType?: StringFilter<"SurveyorAssignment"> | string
    wardId?: StringFilter<"SurveyorAssignment"> | string
    mohallaId?: StringFilter<"SurveyorAssignment"> | string
    wardMohallaMapId?: StringFilter<"SurveyorAssignment"> | string
    assignedById?: StringFilter<"SurveyorAssignment"> | string
    isActive?: BoolFilter<"SurveyorAssignment"> | boolean
  }

  export type WardStatusMappingUpsertWithWhereUniqueWithoutWardInput = {
    where: WardStatusMappingWhereUniqueInput
    update: XOR<WardStatusMappingUpdateWithoutWardInput, WardStatusMappingUncheckedUpdateWithoutWardInput>
    create: XOR<WardStatusMappingCreateWithoutWardInput, WardStatusMappingUncheckedCreateWithoutWardInput>
  }

  export type WardStatusMappingUpdateWithWhereUniqueWithoutWardInput = {
    where: WardStatusMappingWhereUniqueInput
    data: XOR<WardStatusMappingUpdateWithoutWardInput, WardStatusMappingUncheckedUpdateWithoutWardInput>
  }

  export type WardStatusMappingUpdateManyWithWhereWithoutWardInput = {
    where: WardStatusMappingScalarWhereInput
    data: XOR<WardStatusMappingUpdateManyMutationInput, WardStatusMappingUncheckedUpdateManyWithoutWardInput>
  }

  export type WardStatusMappingScalarWhereInput = {
    AND?: WardStatusMappingScalarWhereInput | WardStatusMappingScalarWhereInput[]
    OR?: WardStatusMappingScalarWhereInput[]
    NOT?: WardStatusMappingScalarWhereInput | WardStatusMappingScalarWhereInput[]
    wardStatusId?: StringFilter<"WardStatusMapping"> | string
    wardId?: StringFilter<"WardStatusMapping"> | string
    statusId?: StringFilter<"WardStatusMapping"> | string
    changedById?: StringFilter<"WardStatusMapping"> | string
    isActive?: BoolFilter<"WardStatusMapping"> | boolean
  }

  export type SurveyDetailsUpsertWithWhereUniqueWithoutWardInput = {
    where: SurveyDetailsWhereUniqueInput
    update: XOR<SurveyDetailsUpdateWithoutWardInput, SurveyDetailsUncheckedUpdateWithoutWardInput>
    create: XOR<SurveyDetailsCreateWithoutWardInput, SurveyDetailsUncheckedCreateWithoutWardInput>
  }

  export type SurveyDetailsUpdateWithWhereUniqueWithoutWardInput = {
    where: SurveyDetailsWhereUniqueInput
    data: XOR<SurveyDetailsUpdateWithoutWardInput, SurveyDetailsUncheckedUpdateWithoutWardInput>
  }

  export type SurveyDetailsUpdateManyWithWhereWithoutWardInput = {
    where: SurveyDetailsScalarWhereInput
    data: XOR<SurveyDetailsUpdateManyMutationInput, SurveyDetailsUncheckedUpdateManyWithoutWardInput>
  }

  export type SupervisorsUpsertWithWhereUniqueWithoutWardInput = {
    where: SupervisorsWhereUniqueInput
    update: XOR<SupervisorsUpdateWithoutWardInput, SupervisorsUncheckedUpdateWithoutWardInput>
    create: XOR<SupervisorsCreateWithoutWardInput, SupervisorsUncheckedCreateWithoutWardInput>
  }

  export type SupervisorsUpdateWithWhereUniqueWithoutWardInput = {
    where: SupervisorsWhereUniqueInput
    data: XOR<SupervisorsUpdateWithoutWardInput, SupervisorsUncheckedUpdateWithoutWardInput>
  }

  export type SupervisorsUpdateManyWithWhereWithoutWardInput = {
    where: SupervisorsScalarWhereInput
    data: XOR<SupervisorsUpdateManyMutationInput, SupervisorsUncheckedUpdateManyWithoutWardInput>
  }

  export type SupervisorsScalarWhereInput = {
    AND?: SupervisorsScalarWhereInput | SupervisorsScalarWhereInput[]
    OR?: SupervisorsScalarWhereInput[]
    NOT?: SupervisorsScalarWhereInput | SupervisorsScalarWhereInput[]
    userId?: StringFilter<"Supervisors"> | string
    supervisorName?: StringFilter<"Supervisors"> | string
    username?: StringFilter<"Supervisors"> | string
    password?: StringFilter<"Supervisors"> | string
    wardId?: StringFilter<"Supervisors"> | string
  }

  export type WardMohallaMappingCreateWithoutMohallaInput = {
    wardMohallaMapId?: string
    isActive?: boolean
    ward: WardMasterCreateNestedOneWithoutWardMohallaMapsInput
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutWardMohallaMapInput
    surveyors?: SurveyorsCreateNestedManyWithoutWardMohallaMapInput
  }

  export type WardMohallaMappingUncheckedCreateWithoutMohallaInput = {
    wardMohallaMapId?: string
    wardId: string
    isActive?: boolean
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutWardMohallaMapInput
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutWardMohallaMapInput
  }

  export type WardMohallaMappingCreateOrConnectWithoutMohallaInput = {
    where: WardMohallaMappingWhereUniqueInput
    create: XOR<WardMohallaMappingCreateWithoutMohallaInput, WardMohallaMappingUncheckedCreateWithoutMohallaInput>
  }

  export type WardMohallaMappingCreateManyMohallaInputEnvelope = {
    data: WardMohallaMappingCreateManyMohallaInput | WardMohallaMappingCreateManyMohallaInput[]
    skipDuplicates?: boolean
  }

  export type SurveyorAssignmentCreateWithoutMohallaInput = {
    assignmentId?: string
    assignmentType: string
    isActive?: boolean
    user: UsersMasterCreateNestedOneWithoutSurveyorAssignmentsInput
    ward: WardMasterCreateNestedOneWithoutSurveyorAssignmentsInput
    wardMohallaMap: WardMohallaMappingCreateNestedOneWithoutSurveyorAssignmentsInput
    assignedBy: UsersMasterCreateNestedOneWithoutSurveyorAssignmentsAssignedByInput
  }

  export type SurveyorAssignmentUncheckedCreateWithoutMohallaInput = {
    assignmentId?: string
    userId: string
    assignmentType: string
    wardId: string
    wardMohallaMapId: string
    assignedById: string
    isActive?: boolean
  }

  export type SurveyorAssignmentCreateOrConnectWithoutMohallaInput = {
    where: SurveyorAssignmentWhereUniqueInput
    create: XOR<SurveyorAssignmentCreateWithoutMohallaInput, SurveyorAssignmentUncheckedCreateWithoutMohallaInput>
  }

  export type SurveyorAssignmentCreateManyMohallaInputEnvelope = {
    data: SurveyorAssignmentCreateManyMohallaInput | SurveyorAssignmentCreateManyMohallaInput[]
    skipDuplicates?: boolean
  }

  export type SurveyDetailsCreateWithoutMohallaInput = {
    surveyUniqueCode?: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    ulb: UlbMasterCreateNestedOneWithoutSurveyDetailsInput
    zone: ZoneMasterCreateNestedOneWithoutSurveyDetailsInput
    ward: WardMasterCreateNestedOneWithoutSurveyDetailsInput
    surveyType: SurveyTypeMasterCreateNestedOneWithoutSurveyDetailsInput
    propertyDetails?: PropertyDetailsCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsUncheckedCreateWithoutMohallaInput = {
    surveyUniqueCode?: string
    ulbId: string
    zoneId: string
    wardId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    propertyDetails?: PropertyDetailsUncheckedCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsUncheckedCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsUncheckedCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsUncheckedCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsCreateOrConnectWithoutMohallaInput = {
    where: SurveyDetailsWhereUniqueInput
    create: XOR<SurveyDetailsCreateWithoutMohallaInput, SurveyDetailsUncheckedCreateWithoutMohallaInput>
  }

  export type SurveyDetailsCreateManyMohallaInputEnvelope = {
    data: SurveyDetailsCreateManyMohallaInput | SurveyDetailsCreateManyMohallaInput[]
    skipDuplicates?: boolean
  }

  export type WardMohallaMappingUpsertWithWhereUniqueWithoutMohallaInput = {
    where: WardMohallaMappingWhereUniqueInput
    update: XOR<WardMohallaMappingUpdateWithoutMohallaInput, WardMohallaMappingUncheckedUpdateWithoutMohallaInput>
    create: XOR<WardMohallaMappingCreateWithoutMohallaInput, WardMohallaMappingUncheckedCreateWithoutMohallaInput>
  }

  export type WardMohallaMappingUpdateWithWhereUniqueWithoutMohallaInput = {
    where: WardMohallaMappingWhereUniqueInput
    data: XOR<WardMohallaMappingUpdateWithoutMohallaInput, WardMohallaMappingUncheckedUpdateWithoutMohallaInput>
  }

  export type WardMohallaMappingUpdateManyWithWhereWithoutMohallaInput = {
    where: WardMohallaMappingScalarWhereInput
    data: XOR<WardMohallaMappingUpdateManyMutationInput, WardMohallaMappingUncheckedUpdateManyWithoutMohallaInput>
  }

  export type SurveyorAssignmentUpsertWithWhereUniqueWithoutMohallaInput = {
    where: SurveyorAssignmentWhereUniqueInput
    update: XOR<SurveyorAssignmentUpdateWithoutMohallaInput, SurveyorAssignmentUncheckedUpdateWithoutMohallaInput>
    create: XOR<SurveyorAssignmentCreateWithoutMohallaInput, SurveyorAssignmentUncheckedCreateWithoutMohallaInput>
  }

  export type SurveyorAssignmentUpdateWithWhereUniqueWithoutMohallaInput = {
    where: SurveyorAssignmentWhereUniqueInput
    data: XOR<SurveyorAssignmentUpdateWithoutMohallaInput, SurveyorAssignmentUncheckedUpdateWithoutMohallaInput>
  }

  export type SurveyorAssignmentUpdateManyWithWhereWithoutMohallaInput = {
    where: SurveyorAssignmentScalarWhereInput
    data: XOR<SurveyorAssignmentUpdateManyMutationInput, SurveyorAssignmentUncheckedUpdateManyWithoutMohallaInput>
  }

  export type SurveyDetailsUpsertWithWhereUniqueWithoutMohallaInput = {
    where: SurveyDetailsWhereUniqueInput
    update: XOR<SurveyDetailsUpdateWithoutMohallaInput, SurveyDetailsUncheckedUpdateWithoutMohallaInput>
    create: XOR<SurveyDetailsCreateWithoutMohallaInput, SurveyDetailsUncheckedCreateWithoutMohallaInput>
  }

  export type SurveyDetailsUpdateWithWhereUniqueWithoutMohallaInput = {
    where: SurveyDetailsWhereUniqueInput
    data: XOR<SurveyDetailsUpdateWithoutMohallaInput, SurveyDetailsUncheckedUpdateWithoutMohallaInput>
  }

  export type SurveyDetailsUpdateManyWithWhereWithoutMohallaInput = {
    where: SurveyDetailsScalarWhereInput
    data: XOR<SurveyDetailsUpdateManyMutationInput, SurveyDetailsUncheckedUpdateManyWithoutMohallaInput>
  }

  export type PropertyDetailsCreateWithoutResponseTypeInput = {
    oldHouseNumber?: string | null
    electricityConsumerName?: string | null
    waterSewerageConnectionNumber?: string | null
    respondentName: string
    survey: SurveyDetailsCreateNestedOneWithoutPropertyDetailsInput
    respondentStatus: RespondentStatusMasterCreateNestedOneWithoutPropertyDetailsInput
  }

  export type PropertyDetailsUncheckedCreateWithoutResponseTypeInput = {
    surveyUniqueCode: string
    oldHouseNumber?: string | null
    electricityConsumerName?: string | null
    waterSewerageConnectionNumber?: string | null
    respondentName: string
    respondentStatusId: string
  }

  export type PropertyDetailsCreateOrConnectWithoutResponseTypeInput = {
    where: PropertyDetailsWhereUniqueInput
    create: XOR<PropertyDetailsCreateWithoutResponseTypeInput, PropertyDetailsUncheckedCreateWithoutResponseTypeInput>
  }

  export type PropertyDetailsCreateManyResponseTypeInputEnvelope = {
    data: PropertyDetailsCreateManyResponseTypeInput | PropertyDetailsCreateManyResponseTypeInput[]
    skipDuplicates?: boolean
  }

  export type PropertyDetailsUpsertWithWhereUniqueWithoutResponseTypeInput = {
    where: PropertyDetailsWhereUniqueInput
    update: XOR<PropertyDetailsUpdateWithoutResponseTypeInput, PropertyDetailsUncheckedUpdateWithoutResponseTypeInput>
    create: XOR<PropertyDetailsCreateWithoutResponseTypeInput, PropertyDetailsUncheckedCreateWithoutResponseTypeInput>
  }

  export type PropertyDetailsUpdateWithWhereUniqueWithoutResponseTypeInput = {
    where: PropertyDetailsWhereUniqueInput
    data: XOR<PropertyDetailsUpdateWithoutResponseTypeInput, PropertyDetailsUncheckedUpdateWithoutResponseTypeInput>
  }

  export type PropertyDetailsUpdateManyWithWhereWithoutResponseTypeInput = {
    where: PropertyDetailsScalarWhereInput
    data: XOR<PropertyDetailsUpdateManyMutationInput, PropertyDetailsUncheckedUpdateManyWithoutResponseTypeInput>
  }

  export type PropertyDetailsScalarWhereInput = {
    AND?: PropertyDetailsScalarWhereInput | PropertyDetailsScalarWhereInput[]
    OR?: PropertyDetailsScalarWhereInput[]
    NOT?: PropertyDetailsScalarWhereInput | PropertyDetailsScalarWhereInput[]
    surveyUniqueCode?: StringFilter<"PropertyDetails"> | string
    responseTypeId?: StringFilter<"PropertyDetails"> | string
    oldHouseNumber?: StringNullableFilter<"PropertyDetails"> | string | null
    electricityConsumerName?: StringNullableFilter<"PropertyDetails"> | string | null
    waterSewerageConnectionNumber?: StringNullableFilter<"PropertyDetails"> | string | null
    respondentName?: StringFilter<"PropertyDetails"> | string
    respondentStatusId?: StringFilter<"PropertyDetails"> | string
  }

  export type LocationDetailsCreateWithoutPropertyTypeInput = {
    propertyLatitude: Decimal | DecimalJsLike | number | string
    propertyLongitude: Decimal | DecimalJsLike | number | string
    assessmentYear: string
    buildingName?: string | null
    constructionYear: string
    addressRoadName: string
    locality?: string | null
    pinCode: number
    landmark?: string | null
    fourWayEast?: string | null
    fourWayWest?: string | null
    fourWayNorth?: string | null
    fourWaySouth?: string | null
    newWard: string
    survey: SurveyDetailsCreateNestedOneWithoutLocationDetailsInput
    roadType: RoadTypeMasterCreateNestedOneWithoutLocationDetailsInput
    constructionType: ConstructionTypeMasterCreateNestedOneWithoutLocationDetailsInput
  }

  export type LocationDetailsUncheckedCreateWithoutPropertyTypeInput = {
    surveyUniqueCode: string
    propertyLatitude: Decimal | DecimalJsLike | number | string
    propertyLongitude: Decimal | DecimalJsLike | number | string
    assessmentYear: string
    buildingName?: string | null
    roadTypeId: string
    constructionYear: string
    constructionTypeId: string
    addressRoadName: string
    locality?: string | null
    pinCode: number
    landmark?: string | null
    fourWayEast?: string | null
    fourWayWest?: string | null
    fourWayNorth?: string | null
    fourWaySouth?: string | null
    newWard: string
  }

  export type LocationDetailsCreateOrConnectWithoutPropertyTypeInput = {
    where: LocationDetailsWhereUniqueInput
    create: XOR<LocationDetailsCreateWithoutPropertyTypeInput, LocationDetailsUncheckedCreateWithoutPropertyTypeInput>
  }

  export type LocationDetailsCreateManyPropertyTypeInputEnvelope = {
    data: LocationDetailsCreateManyPropertyTypeInput | LocationDetailsCreateManyPropertyTypeInput[]
    skipDuplicates?: boolean
  }

  export type LocationDetailsUpsertWithWhereUniqueWithoutPropertyTypeInput = {
    where: LocationDetailsWhereUniqueInput
    update: XOR<LocationDetailsUpdateWithoutPropertyTypeInput, LocationDetailsUncheckedUpdateWithoutPropertyTypeInput>
    create: XOR<LocationDetailsCreateWithoutPropertyTypeInput, LocationDetailsUncheckedCreateWithoutPropertyTypeInput>
  }

  export type LocationDetailsUpdateWithWhereUniqueWithoutPropertyTypeInput = {
    where: LocationDetailsWhereUniqueInput
    data: XOR<LocationDetailsUpdateWithoutPropertyTypeInput, LocationDetailsUncheckedUpdateWithoutPropertyTypeInput>
  }

  export type LocationDetailsUpdateManyWithWhereWithoutPropertyTypeInput = {
    where: LocationDetailsScalarWhereInput
    data: XOR<LocationDetailsUpdateManyMutationInput, LocationDetailsUncheckedUpdateManyWithoutPropertyTypeInput>
  }

  export type LocationDetailsScalarWhereInput = {
    AND?: LocationDetailsScalarWhereInput | LocationDetailsScalarWhereInput[]
    OR?: LocationDetailsScalarWhereInput[]
    NOT?: LocationDetailsScalarWhereInput | LocationDetailsScalarWhereInput[]
    surveyUniqueCode?: StringFilter<"LocationDetails"> | string
    propertyLatitude?: DecimalFilter<"LocationDetails"> | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFilter<"LocationDetails"> | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFilter<"LocationDetails"> | string
    propertyTypeId?: StringFilter<"LocationDetails"> | string
    buildingName?: StringNullableFilter<"LocationDetails"> | string | null
    roadTypeId?: StringFilter<"LocationDetails"> | string
    constructionYear?: StringFilter<"LocationDetails"> | string
    constructionTypeId?: StringFilter<"LocationDetails"> | string
    addressRoadName?: StringFilter<"LocationDetails"> | string
    locality?: StringNullableFilter<"LocationDetails"> | string | null
    pinCode?: IntFilter<"LocationDetails"> | number
    landmark?: StringNullableFilter<"LocationDetails"> | string | null
    fourWayEast?: StringNullableFilter<"LocationDetails"> | string | null
    fourWayWest?: StringNullableFilter<"LocationDetails"> | string | null
    fourWayNorth?: StringNullableFilter<"LocationDetails"> | string | null
    fourWaySouth?: StringNullableFilter<"LocationDetails"> | string | null
    newWard?: StringFilter<"LocationDetails"> | string
  }

  export type PropertyDetailsCreateWithoutRespondentStatusInput = {
    oldHouseNumber?: string | null
    electricityConsumerName?: string | null
    waterSewerageConnectionNumber?: string | null
    respondentName: string
    survey: SurveyDetailsCreateNestedOneWithoutPropertyDetailsInput
    responseType: ResponseTypeMasterCreateNestedOneWithoutPropertyDetailsInput
  }

  export type PropertyDetailsUncheckedCreateWithoutRespondentStatusInput = {
    surveyUniqueCode: string
    responseTypeId: string
    oldHouseNumber?: string | null
    electricityConsumerName?: string | null
    waterSewerageConnectionNumber?: string | null
    respondentName: string
  }

  export type PropertyDetailsCreateOrConnectWithoutRespondentStatusInput = {
    where: PropertyDetailsWhereUniqueInput
    create: XOR<PropertyDetailsCreateWithoutRespondentStatusInput, PropertyDetailsUncheckedCreateWithoutRespondentStatusInput>
  }

  export type PropertyDetailsCreateManyRespondentStatusInputEnvelope = {
    data: PropertyDetailsCreateManyRespondentStatusInput | PropertyDetailsCreateManyRespondentStatusInput[]
    skipDuplicates?: boolean
  }

  export type PropertyDetailsUpsertWithWhereUniqueWithoutRespondentStatusInput = {
    where: PropertyDetailsWhereUniqueInput
    update: XOR<PropertyDetailsUpdateWithoutRespondentStatusInput, PropertyDetailsUncheckedUpdateWithoutRespondentStatusInput>
    create: XOR<PropertyDetailsCreateWithoutRespondentStatusInput, PropertyDetailsUncheckedCreateWithoutRespondentStatusInput>
  }

  export type PropertyDetailsUpdateWithWhereUniqueWithoutRespondentStatusInput = {
    where: PropertyDetailsWhereUniqueInput
    data: XOR<PropertyDetailsUpdateWithoutRespondentStatusInput, PropertyDetailsUncheckedUpdateWithoutRespondentStatusInput>
  }

  export type PropertyDetailsUpdateManyWithWhereWithoutRespondentStatusInput = {
    where: PropertyDetailsScalarWhereInput
    data: XOR<PropertyDetailsUpdateManyMutationInput, PropertyDetailsUncheckedUpdateManyWithoutRespondentStatusInput>
  }

  export type LocationDetailsCreateWithoutRoadTypeInput = {
    propertyLatitude: Decimal | DecimalJsLike | number | string
    propertyLongitude: Decimal | DecimalJsLike | number | string
    assessmentYear: string
    buildingName?: string | null
    constructionYear: string
    addressRoadName: string
    locality?: string | null
    pinCode: number
    landmark?: string | null
    fourWayEast?: string | null
    fourWayWest?: string | null
    fourWayNorth?: string | null
    fourWaySouth?: string | null
    newWard: string
    survey: SurveyDetailsCreateNestedOneWithoutLocationDetailsInput
    propertyType: PropertyTypeMasterCreateNestedOneWithoutLocationDetailsInput
    constructionType: ConstructionTypeMasterCreateNestedOneWithoutLocationDetailsInput
  }

  export type LocationDetailsUncheckedCreateWithoutRoadTypeInput = {
    surveyUniqueCode: string
    propertyLatitude: Decimal | DecimalJsLike | number | string
    propertyLongitude: Decimal | DecimalJsLike | number | string
    assessmentYear: string
    propertyTypeId: string
    buildingName?: string | null
    constructionYear: string
    constructionTypeId: string
    addressRoadName: string
    locality?: string | null
    pinCode: number
    landmark?: string | null
    fourWayEast?: string | null
    fourWayWest?: string | null
    fourWayNorth?: string | null
    fourWaySouth?: string | null
    newWard: string
  }

  export type LocationDetailsCreateOrConnectWithoutRoadTypeInput = {
    where: LocationDetailsWhereUniqueInput
    create: XOR<LocationDetailsCreateWithoutRoadTypeInput, LocationDetailsUncheckedCreateWithoutRoadTypeInput>
  }

  export type LocationDetailsCreateManyRoadTypeInputEnvelope = {
    data: LocationDetailsCreateManyRoadTypeInput | LocationDetailsCreateManyRoadTypeInput[]
    skipDuplicates?: boolean
  }

  export type LocationDetailsUpsertWithWhereUniqueWithoutRoadTypeInput = {
    where: LocationDetailsWhereUniqueInput
    update: XOR<LocationDetailsUpdateWithoutRoadTypeInput, LocationDetailsUncheckedUpdateWithoutRoadTypeInput>
    create: XOR<LocationDetailsCreateWithoutRoadTypeInput, LocationDetailsUncheckedCreateWithoutRoadTypeInput>
  }

  export type LocationDetailsUpdateWithWhereUniqueWithoutRoadTypeInput = {
    where: LocationDetailsWhereUniqueInput
    data: XOR<LocationDetailsUpdateWithoutRoadTypeInput, LocationDetailsUncheckedUpdateWithoutRoadTypeInput>
  }

  export type LocationDetailsUpdateManyWithWhereWithoutRoadTypeInput = {
    where: LocationDetailsScalarWhereInput
    data: XOR<LocationDetailsUpdateManyMutationInput, LocationDetailsUncheckedUpdateManyWithoutRoadTypeInput>
  }

  export type LocationDetailsCreateWithoutConstructionTypeInput = {
    propertyLatitude: Decimal | DecimalJsLike | number | string
    propertyLongitude: Decimal | DecimalJsLike | number | string
    assessmentYear: string
    buildingName?: string | null
    constructionYear: string
    addressRoadName: string
    locality?: string | null
    pinCode: number
    landmark?: string | null
    fourWayEast?: string | null
    fourWayWest?: string | null
    fourWayNorth?: string | null
    fourWaySouth?: string | null
    newWard: string
    survey: SurveyDetailsCreateNestedOneWithoutLocationDetailsInput
    propertyType: PropertyTypeMasterCreateNestedOneWithoutLocationDetailsInput
    roadType: RoadTypeMasterCreateNestedOneWithoutLocationDetailsInput
  }

  export type LocationDetailsUncheckedCreateWithoutConstructionTypeInput = {
    surveyUniqueCode: string
    propertyLatitude: Decimal | DecimalJsLike | number | string
    propertyLongitude: Decimal | DecimalJsLike | number | string
    assessmentYear: string
    propertyTypeId: string
    buildingName?: string | null
    roadTypeId: string
    constructionYear: string
    addressRoadName: string
    locality?: string | null
    pinCode: number
    landmark?: string | null
    fourWayEast?: string | null
    fourWayWest?: string | null
    fourWayNorth?: string | null
    fourWaySouth?: string | null
    newWard: string
  }

  export type LocationDetailsCreateOrConnectWithoutConstructionTypeInput = {
    where: LocationDetailsWhereUniqueInput
    create: XOR<LocationDetailsCreateWithoutConstructionTypeInput, LocationDetailsUncheckedCreateWithoutConstructionTypeInput>
  }

  export type LocationDetailsCreateManyConstructionTypeInputEnvelope = {
    data: LocationDetailsCreateManyConstructionTypeInput | LocationDetailsCreateManyConstructionTypeInput[]
    skipDuplicates?: boolean
  }

  export type LocationDetailsUpsertWithWhereUniqueWithoutConstructionTypeInput = {
    where: LocationDetailsWhereUniqueInput
    update: XOR<LocationDetailsUpdateWithoutConstructionTypeInput, LocationDetailsUncheckedUpdateWithoutConstructionTypeInput>
    create: XOR<LocationDetailsCreateWithoutConstructionTypeInput, LocationDetailsUncheckedCreateWithoutConstructionTypeInput>
  }

  export type LocationDetailsUpdateWithWhereUniqueWithoutConstructionTypeInput = {
    where: LocationDetailsWhereUniqueInput
    data: XOR<LocationDetailsUpdateWithoutConstructionTypeInput, LocationDetailsUncheckedUpdateWithoutConstructionTypeInput>
  }

  export type LocationDetailsUpdateManyWithWhereWithoutConstructionTypeInput = {
    where: LocationDetailsScalarWhereInput
    data: XOR<LocationDetailsUpdateManyMutationInput, LocationDetailsUncheckedUpdateManyWithoutConstructionTypeInput>
  }

  export type OtherDetailsCreateWithoutWaterSourceInput = {
    rainWaterHarvestingSystem?: string | null
    plantation?: string | null
    parking?: string | null
    pollution?: string | null
    pollutionMeasurementTaken?: string | null
    waterSupplyWithin200Meters?: string | null
    sewerageLineWithin100Meters?: string | null
    totalPlotArea: number
    builtupAreaOfGroundFloor: number
    remarks?: string | null
    survey: SurveyDetailsCreateNestedOneWithoutOtherDetailsInput
    disposalType: DisposalTypeMasterCreateNestedOneWithoutOtherDetailsInput
  }

  export type OtherDetailsUncheckedCreateWithoutWaterSourceInput = {
    surveyUniqueCode: string
    rainWaterHarvestingSystem?: string | null
    plantation?: string | null
    parking?: string | null
    pollution?: string | null
    pollutionMeasurementTaken?: string | null
    waterSupplyWithin200Meters?: string | null
    sewerageLineWithin100Meters?: string | null
    disposalTypeId: string
    totalPlotArea: number
    builtupAreaOfGroundFloor: number
    remarks?: string | null
  }

  export type OtherDetailsCreateOrConnectWithoutWaterSourceInput = {
    where: OtherDetailsWhereUniqueInput
    create: XOR<OtherDetailsCreateWithoutWaterSourceInput, OtherDetailsUncheckedCreateWithoutWaterSourceInput>
  }

  export type OtherDetailsCreateManyWaterSourceInputEnvelope = {
    data: OtherDetailsCreateManyWaterSourceInput | OtherDetailsCreateManyWaterSourceInput[]
    skipDuplicates?: boolean
  }

  export type OtherDetailsUpsertWithWhereUniqueWithoutWaterSourceInput = {
    where: OtherDetailsWhereUniqueInput
    update: XOR<OtherDetailsUpdateWithoutWaterSourceInput, OtherDetailsUncheckedUpdateWithoutWaterSourceInput>
    create: XOR<OtherDetailsCreateWithoutWaterSourceInput, OtherDetailsUncheckedCreateWithoutWaterSourceInput>
  }

  export type OtherDetailsUpdateWithWhereUniqueWithoutWaterSourceInput = {
    where: OtherDetailsWhereUniqueInput
    data: XOR<OtherDetailsUpdateWithoutWaterSourceInput, OtherDetailsUncheckedUpdateWithoutWaterSourceInput>
  }

  export type OtherDetailsUpdateManyWithWhereWithoutWaterSourceInput = {
    where: OtherDetailsScalarWhereInput
    data: XOR<OtherDetailsUpdateManyMutationInput, OtherDetailsUncheckedUpdateManyWithoutWaterSourceInput>
  }

  export type OtherDetailsScalarWhereInput = {
    AND?: OtherDetailsScalarWhereInput | OtherDetailsScalarWhereInput[]
    OR?: OtherDetailsScalarWhereInput[]
    NOT?: OtherDetailsScalarWhereInput | OtherDetailsScalarWhereInput[]
    surveyUniqueCode?: StringFilter<"OtherDetails"> | string
    waterSourceId?: StringFilter<"OtherDetails"> | string
    rainWaterHarvestingSystem?: StringNullableFilter<"OtherDetails"> | string | null
    plantation?: StringNullableFilter<"OtherDetails"> | string | null
    parking?: StringNullableFilter<"OtherDetails"> | string | null
    pollution?: StringNullableFilter<"OtherDetails"> | string | null
    pollutionMeasurementTaken?: StringNullableFilter<"OtherDetails"> | string | null
    waterSupplyWithin200Meters?: StringNullableFilter<"OtherDetails"> | string | null
    sewerageLineWithin100Meters?: StringNullableFilter<"OtherDetails"> | string | null
    disposalTypeId?: StringFilter<"OtherDetails"> | string
    totalPlotArea?: FloatFilter<"OtherDetails"> | number
    builtupAreaOfGroundFloor?: FloatFilter<"OtherDetails"> | number
    remarks?: StringNullableFilter<"OtherDetails"> | string | null
  }

  export type OtherDetailsCreateWithoutDisposalTypeInput = {
    rainWaterHarvestingSystem?: string | null
    plantation?: string | null
    parking?: string | null
    pollution?: string | null
    pollutionMeasurementTaken?: string | null
    waterSupplyWithin200Meters?: string | null
    sewerageLineWithin100Meters?: string | null
    totalPlotArea: number
    builtupAreaOfGroundFloor: number
    remarks?: string | null
    survey: SurveyDetailsCreateNestedOneWithoutOtherDetailsInput
    waterSource: WaterSourceMasterCreateNestedOneWithoutOtherDetailsInput
  }

  export type OtherDetailsUncheckedCreateWithoutDisposalTypeInput = {
    surveyUniqueCode: string
    waterSourceId: string
    rainWaterHarvestingSystem?: string | null
    plantation?: string | null
    parking?: string | null
    pollution?: string | null
    pollutionMeasurementTaken?: string | null
    waterSupplyWithin200Meters?: string | null
    sewerageLineWithin100Meters?: string | null
    totalPlotArea: number
    builtupAreaOfGroundFloor: number
    remarks?: string | null
  }

  export type OtherDetailsCreateOrConnectWithoutDisposalTypeInput = {
    where: OtherDetailsWhereUniqueInput
    create: XOR<OtherDetailsCreateWithoutDisposalTypeInput, OtherDetailsUncheckedCreateWithoutDisposalTypeInput>
  }

  export type OtherDetailsCreateManyDisposalTypeInputEnvelope = {
    data: OtherDetailsCreateManyDisposalTypeInput | OtherDetailsCreateManyDisposalTypeInput[]
    skipDuplicates?: boolean
  }

  export type OtherDetailsUpsertWithWhereUniqueWithoutDisposalTypeInput = {
    where: OtherDetailsWhereUniqueInput
    update: XOR<OtherDetailsUpdateWithoutDisposalTypeInput, OtherDetailsUncheckedUpdateWithoutDisposalTypeInput>
    create: XOR<OtherDetailsCreateWithoutDisposalTypeInput, OtherDetailsUncheckedCreateWithoutDisposalTypeInput>
  }

  export type OtherDetailsUpdateWithWhereUniqueWithoutDisposalTypeInput = {
    where: OtherDetailsWhereUniqueInput
    data: XOR<OtherDetailsUpdateWithoutDisposalTypeInput, OtherDetailsUncheckedUpdateWithoutDisposalTypeInput>
  }

  export type OtherDetailsUpdateManyWithWhereWithoutDisposalTypeInput = {
    where: OtherDetailsScalarWhereInput
    data: XOR<OtherDetailsUpdateManyMutationInput, OtherDetailsUncheckedUpdateManyWithoutDisposalTypeInput>
  }

  export type NrPropertySubCategoryMasterCreateWithoutPropertyCategoryInput = {
    subCategoryId?: string
    subCategoryNumber: number
    subCategoryName: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutNrSubCategoryInput
  }

  export type NrPropertySubCategoryMasterUncheckedCreateWithoutPropertyCategoryInput = {
    subCategoryId?: string
    subCategoryNumber: number
    subCategoryName: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutNrSubCategoryInput
  }

  export type NrPropertySubCategoryMasterCreateOrConnectWithoutPropertyCategoryInput = {
    where: NrPropertySubCategoryMasterWhereUniqueInput
    create: XOR<NrPropertySubCategoryMasterCreateWithoutPropertyCategoryInput, NrPropertySubCategoryMasterUncheckedCreateWithoutPropertyCategoryInput>
  }

  export type NrPropertySubCategoryMasterCreateManyPropertyCategoryInputEnvelope = {
    data: NrPropertySubCategoryMasterCreateManyPropertyCategoryInput | NrPropertySubCategoryMasterCreateManyPropertyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type NonResidentialPropertyAssessmentCreateWithoutNrPropertyCategoryInput = {
    floorAssessmentId?: string
    floorNumber: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    builtupArea: Decimal | DecimalJsLike | number | string
    nrSubCategory: NrPropertySubCategoryMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    occupancyStatus: OccupancyStatusMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    constructionNature: ConstructionNatureMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    survey: SurveyDetailsCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
  }

  export type NonResidentialPropertyAssessmentUncheckedCreateWithoutNrPropertyCategoryInput = {
    floorAssessmentId?: string
    surveyUniqueCode: string
    floorNumber: string
    nrSubCategoryId: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    occupancyStatusId: string
    constructionNatureId: string
    builtupArea: Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentCreateOrConnectWithoutNrPropertyCategoryInput = {
    where: NonResidentialPropertyAssessmentWhereUniqueInput
    create: XOR<NonResidentialPropertyAssessmentCreateWithoutNrPropertyCategoryInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutNrPropertyCategoryInput>
  }

  export type NonResidentialPropertyAssessmentCreateManyNrPropertyCategoryInputEnvelope = {
    data: NonResidentialPropertyAssessmentCreateManyNrPropertyCategoryInput | NonResidentialPropertyAssessmentCreateManyNrPropertyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type NrPropertySubCategoryMasterUpsertWithWhereUniqueWithoutPropertyCategoryInput = {
    where: NrPropertySubCategoryMasterWhereUniqueInput
    update: XOR<NrPropertySubCategoryMasterUpdateWithoutPropertyCategoryInput, NrPropertySubCategoryMasterUncheckedUpdateWithoutPropertyCategoryInput>
    create: XOR<NrPropertySubCategoryMasterCreateWithoutPropertyCategoryInput, NrPropertySubCategoryMasterUncheckedCreateWithoutPropertyCategoryInput>
  }

  export type NrPropertySubCategoryMasterUpdateWithWhereUniqueWithoutPropertyCategoryInput = {
    where: NrPropertySubCategoryMasterWhereUniqueInput
    data: XOR<NrPropertySubCategoryMasterUpdateWithoutPropertyCategoryInput, NrPropertySubCategoryMasterUncheckedUpdateWithoutPropertyCategoryInput>
  }

  export type NrPropertySubCategoryMasterUpdateManyWithWhereWithoutPropertyCategoryInput = {
    where: NrPropertySubCategoryMasterScalarWhereInput
    data: XOR<NrPropertySubCategoryMasterUpdateManyMutationInput, NrPropertySubCategoryMasterUncheckedUpdateManyWithoutPropertyCategoryInput>
  }

  export type NrPropertySubCategoryMasterScalarWhereInput = {
    AND?: NrPropertySubCategoryMasterScalarWhereInput | NrPropertySubCategoryMasterScalarWhereInput[]
    OR?: NrPropertySubCategoryMasterScalarWhereInput[]
    NOT?: NrPropertySubCategoryMasterScalarWhereInput | NrPropertySubCategoryMasterScalarWhereInput[]
    subCategoryId?: StringFilter<"NrPropertySubCategoryMaster"> | string
    subCategoryNumber?: IntFilter<"NrPropertySubCategoryMaster"> | number
    subCategoryName?: StringFilter<"NrPropertySubCategoryMaster"> | string
    isActive?: BoolFilter<"NrPropertySubCategoryMaster"> | boolean
    description?: StringNullableFilter<"NrPropertySubCategoryMaster"> | string | null
    createdAt?: DateTimeFilter<"NrPropertySubCategoryMaster"> | Date | string
    propertyCategoryId?: StringFilter<"NrPropertySubCategoryMaster"> | string
  }

  export type NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutNrPropertyCategoryInput = {
    where: NonResidentialPropertyAssessmentWhereUniqueInput
    update: XOR<NonResidentialPropertyAssessmentUpdateWithoutNrPropertyCategoryInput, NonResidentialPropertyAssessmentUncheckedUpdateWithoutNrPropertyCategoryInput>
    create: XOR<NonResidentialPropertyAssessmentCreateWithoutNrPropertyCategoryInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutNrPropertyCategoryInput>
  }

  export type NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutNrPropertyCategoryInput = {
    where: NonResidentialPropertyAssessmentWhereUniqueInput
    data: XOR<NonResidentialPropertyAssessmentUpdateWithoutNrPropertyCategoryInput, NonResidentialPropertyAssessmentUncheckedUpdateWithoutNrPropertyCategoryInput>
  }

  export type NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutNrPropertyCategoryInput = {
    where: NonResidentialPropertyAssessmentScalarWhereInput
    data: XOR<NonResidentialPropertyAssessmentUpdateManyMutationInput, NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutNrPropertyCategoryInput>
  }

  export type NonResidentialPropertyAssessmentScalarWhereInput = {
    AND?: NonResidentialPropertyAssessmentScalarWhereInput | NonResidentialPropertyAssessmentScalarWhereInput[]
    OR?: NonResidentialPropertyAssessmentScalarWhereInput[]
    NOT?: NonResidentialPropertyAssessmentScalarWhereInput | NonResidentialPropertyAssessmentScalarWhereInput[]
    floorAssessmentId?: StringFilter<"NonResidentialPropertyAssessment"> | string
    surveyUniqueCode?: StringFilter<"NonResidentialPropertyAssessment"> | string
    floorNumber?: StringFilter<"NonResidentialPropertyAssessment"> | string
    nrPropertyCategoryId?: StringFilter<"NonResidentialPropertyAssessment"> | string
    nrSubCategoryId?: StringFilter<"NonResidentialPropertyAssessment"> | string
    establishmentName?: StringFilter<"NonResidentialPropertyAssessment"> | string
    licenseNo?: StringNullableFilter<"NonResidentialPropertyAssessment"> | string | null
    licenseExpiryDate?: DateTimeNullableFilter<"NonResidentialPropertyAssessment"> | Date | string | null
    occupancyStatusId?: StringFilter<"NonResidentialPropertyAssessment"> | string
    constructionNatureId?: StringFilter<"NonResidentialPropertyAssessment"> | string
    builtupArea?: DecimalFilter<"NonResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
  }

  export type NrPropertyCategoryMasterCreateWithoutSubCategoriesInput = {
    propertyCategoryId?: string
    propertyCategoryNumber: number
    propertyCategoryName: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutNrPropertyCategoryInput
  }

  export type NrPropertyCategoryMasterUncheckedCreateWithoutSubCategoriesInput = {
    propertyCategoryId?: string
    propertyCategoryNumber: number
    propertyCategoryName: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutNrPropertyCategoryInput
  }

  export type NrPropertyCategoryMasterCreateOrConnectWithoutSubCategoriesInput = {
    where: NrPropertyCategoryMasterWhereUniqueInput
    create: XOR<NrPropertyCategoryMasterCreateWithoutSubCategoriesInput, NrPropertyCategoryMasterUncheckedCreateWithoutSubCategoriesInput>
  }

  export type NonResidentialPropertyAssessmentCreateWithoutNrSubCategoryInput = {
    floorAssessmentId?: string
    floorNumber: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    builtupArea: Decimal | DecimalJsLike | number | string
    nrPropertyCategory: NrPropertyCategoryMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    occupancyStatus: OccupancyStatusMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    constructionNature: ConstructionNatureMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    survey: SurveyDetailsCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
  }

  export type NonResidentialPropertyAssessmentUncheckedCreateWithoutNrSubCategoryInput = {
    floorAssessmentId?: string
    surveyUniqueCode: string
    floorNumber: string
    nrPropertyCategoryId: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    occupancyStatusId: string
    constructionNatureId: string
    builtupArea: Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentCreateOrConnectWithoutNrSubCategoryInput = {
    where: NonResidentialPropertyAssessmentWhereUniqueInput
    create: XOR<NonResidentialPropertyAssessmentCreateWithoutNrSubCategoryInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutNrSubCategoryInput>
  }

  export type NonResidentialPropertyAssessmentCreateManyNrSubCategoryInputEnvelope = {
    data: NonResidentialPropertyAssessmentCreateManyNrSubCategoryInput | NonResidentialPropertyAssessmentCreateManyNrSubCategoryInput[]
    skipDuplicates?: boolean
  }

  export type NrPropertyCategoryMasterUpsertWithoutSubCategoriesInput = {
    update: XOR<NrPropertyCategoryMasterUpdateWithoutSubCategoriesInput, NrPropertyCategoryMasterUncheckedUpdateWithoutSubCategoriesInput>
    create: XOR<NrPropertyCategoryMasterCreateWithoutSubCategoriesInput, NrPropertyCategoryMasterUncheckedCreateWithoutSubCategoriesInput>
    where?: NrPropertyCategoryMasterWhereInput
  }

  export type NrPropertyCategoryMasterUpdateToOneWithWhereWithoutSubCategoriesInput = {
    where?: NrPropertyCategoryMasterWhereInput
    data: XOR<NrPropertyCategoryMasterUpdateWithoutSubCategoriesInput, NrPropertyCategoryMasterUncheckedUpdateWithoutSubCategoriesInput>
  }

  export type NrPropertyCategoryMasterUpdateWithoutSubCategoriesInput = {
    propertyCategoryId?: StringFieldUpdateOperationsInput | string
    propertyCategoryNumber?: IntFieldUpdateOperationsInput | number
    propertyCategoryName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutNrPropertyCategoryNestedInput
  }

  export type NrPropertyCategoryMasterUncheckedUpdateWithoutSubCategoriesInput = {
    propertyCategoryId?: StringFieldUpdateOperationsInput | string
    propertyCategoryNumber?: IntFieldUpdateOperationsInput | number
    propertyCategoryName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutNrPropertyCategoryNestedInput
  }

  export type NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutNrSubCategoryInput = {
    where: NonResidentialPropertyAssessmentWhereUniqueInput
    update: XOR<NonResidentialPropertyAssessmentUpdateWithoutNrSubCategoryInput, NonResidentialPropertyAssessmentUncheckedUpdateWithoutNrSubCategoryInput>
    create: XOR<NonResidentialPropertyAssessmentCreateWithoutNrSubCategoryInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutNrSubCategoryInput>
  }

  export type NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutNrSubCategoryInput = {
    where: NonResidentialPropertyAssessmentWhereUniqueInput
    data: XOR<NonResidentialPropertyAssessmentUpdateWithoutNrSubCategoryInput, NonResidentialPropertyAssessmentUncheckedUpdateWithoutNrSubCategoryInput>
  }

  export type NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutNrSubCategoryInput = {
    where: NonResidentialPropertyAssessmentScalarWhereInput
    data: XOR<NonResidentialPropertyAssessmentUpdateManyMutationInput, NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutNrSubCategoryInput>
  }

  export type ResidentialPropertyAssessmentCreateWithoutConstructionNatureInput = {
    floorAssessmentId?: string
    floorNumber: string
    coveredArea: Decimal | DecimalJsLike | number | string
    allRoomVerandaArea: Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea: Decimal | DecimalJsLike | number | string
    allGarageArea: Decimal | DecimalJsLike | number | string
    carpetArea: Decimal | DecimalJsLike | number | string
    survey: SurveyDetailsCreateNestedOneWithoutResidentialPropertyAssessmentsInput
    occupancyStatus: OccupancyStatusMasterCreateNestedOneWithoutResidentialPropertyAssessmentsInput
  }

  export type ResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput = {
    floorAssessmentId?: string
    surveyUniqueCode: string
    floorNumber: string
    occupancyStatusId: string
    coveredArea: Decimal | DecimalJsLike | number | string
    allRoomVerandaArea: Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea: Decimal | DecimalJsLike | number | string
    allGarageArea: Decimal | DecimalJsLike | number | string
    carpetArea: Decimal | DecimalJsLike | number | string
  }

  export type ResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput = {
    where: ResidentialPropertyAssessmentWhereUniqueInput
    create: XOR<ResidentialPropertyAssessmentCreateWithoutConstructionNatureInput, ResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput>
  }

  export type ResidentialPropertyAssessmentCreateManyConstructionNatureInputEnvelope = {
    data: ResidentialPropertyAssessmentCreateManyConstructionNatureInput | ResidentialPropertyAssessmentCreateManyConstructionNatureInput[]
    skipDuplicates?: boolean
  }

  export type NonResidentialPropertyAssessmentCreateWithoutConstructionNatureInput = {
    floorAssessmentId?: string
    floorNumber: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    builtupArea: Decimal | DecimalJsLike | number | string
    nrPropertyCategory: NrPropertyCategoryMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    nrSubCategory: NrPropertySubCategoryMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    occupancyStatus: OccupancyStatusMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    survey: SurveyDetailsCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
  }

  export type NonResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput = {
    floorAssessmentId?: string
    surveyUniqueCode: string
    floorNumber: string
    nrPropertyCategoryId: string
    nrSubCategoryId: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    occupancyStatusId: string
    builtupArea: Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentCreateOrConnectWithoutConstructionNatureInput = {
    where: NonResidentialPropertyAssessmentWhereUniqueInput
    create: XOR<NonResidentialPropertyAssessmentCreateWithoutConstructionNatureInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput>
  }

  export type NonResidentialPropertyAssessmentCreateManyConstructionNatureInputEnvelope = {
    data: NonResidentialPropertyAssessmentCreateManyConstructionNatureInput | NonResidentialPropertyAssessmentCreateManyConstructionNatureInput[]
    skipDuplicates?: boolean
  }

  export type ResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutConstructionNatureInput = {
    where: ResidentialPropertyAssessmentWhereUniqueInput
    update: XOR<ResidentialPropertyAssessmentUpdateWithoutConstructionNatureInput, ResidentialPropertyAssessmentUncheckedUpdateWithoutConstructionNatureInput>
    create: XOR<ResidentialPropertyAssessmentCreateWithoutConstructionNatureInput, ResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput>
  }

  export type ResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutConstructionNatureInput = {
    where: ResidentialPropertyAssessmentWhereUniqueInput
    data: XOR<ResidentialPropertyAssessmentUpdateWithoutConstructionNatureInput, ResidentialPropertyAssessmentUncheckedUpdateWithoutConstructionNatureInput>
  }

  export type ResidentialPropertyAssessmentUpdateManyWithWhereWithoutConstructionNatureInput = {
    where: ResidentialPropertyAssessmentScalarWhereInput
    data: XOR<ResidentialPropertyAssessmentUpdateManyMutationInput, ResidentialPropertyAssessmentUncheckedUpdateManyWithoutConstructionNatureInput>
  }

  export type ResidentialPropertyAssessmentScalarWhereInput = {
    AND?: ResidentialPropertyAssessmentScalarWhereInput | ResidentialPropertyAssessmentScalarWhereInput[]
    OR?: ResidentialPropertyAssessmentScalarWhereInput[]
    NOT?: ResidentialPropertyAssessmentScalarWhereInput | ResidentialPropertyAssessmentScalarWhereInput[]
    floorAssessmentId?: StringFilter<"ResidentialPropertyAssessment"> | string
    surveyUniqueCode?: StringFilter<"ResidentialPropertyAssessment"> | string
    floorNumber?: StringFilter<"ResidentialPropertyAssessment"> | string
    occupancyStatusId?: StringFilter<"ResidentialPropertyAssessment"> | string
    constructionNatureId?: StringFilter<"ResidentialPropertyAssessment"> | string
    coveredArea?: DecimalFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    allRoomVerandaArea?: DecimalFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea?: DecimalFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    allGarageArea?: DecimalFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
    carpetArea?: DecimalFilter<"ResidentialPropertyAssessment"> | Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutConstructionNatureInput = {
    where: NonResidentialPropertyAssessmentWhereUniqueInput
    update: XOR<NonResidentialPropertyAssessmentUpdateWithoutConstructionNatureInput, NonResidentialPropertyAssessmentUncheckedUpdateWithoutConstructionNatureInput>
    create: XOR<NonResidentialPropertyAssessmentCreateWithoutConstructionNatureInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutConstructionNatureInput>
  }

  export type NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutConstructionNatureInput = {
    where: NonResidentialPropertyAssessmentWhereUniqueInput
    data: XOR<NonResidentialPropertyAssessmentUpdateWithoutConstructionNatureInput, NonResidentialPropertyAssessmentUncheckedUpdateWithoutConstructionNatureInput>
  }

  export type NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutConstructionNatureInput = {
    where: NonResidentialPropertyAssessmentScalarWhereInput
    data: XOR<NonResidentialPropertyAssessmentUpdateManyMutationInput, NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutConstructionNatureInput>
  }

  export type SurveyDetailsCreateWithoutSurveyTypeInput = {
    surveyUniqueCode?: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    ulb: UlbMasterCreateNestedOneWithoutSurveyDetailsInput
    zone: ZoneMasterCreateNestedOneWithoutSurveyDetailsInput
    ward: WardMasterCreateNestedOneWithoutSurveyDetailsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyDetailsInput
    propertyDetails?: PropertyDetailsCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsUncheckedCreateWithoutSurveyTypeInput = {
    surveyUniqueCode?: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    propertyDetails?: PropertyDetailsUncheckedCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsUncheckedCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsUncheckedCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsUncheckedCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsCreateOrConnectWithoutSurveyTypeInput = {
    where: SurveyDetailsWhereUniqueInput
    create: XOR<SurveyDetailsCreateWithoutSurveyTypeInput, SurveyDetailsUncheckedCreateWithoutSurveyTypeInput>
  }

  export type SurveyDetailsCreateManySurveyTypeInputEnvelope = {
    data: SurveyDetailsCreateManySurveyTypeInput | SurveyDetailsCreateManySurveyTypeInput[]
    skipDuplicates?: boolean
  }

  export type SurveyDetailsUpsertWithWhereUniqueWithoutSurveyTypeInput = {
    where: SurveyDetailsWhereUniqueInput
    update: XOR<SurveyDetailsUpdateWithoutSurveyTypeInput, SurveyDetailsUncheckedUpdateWithoutSurveyTypeInput>
    create: XOR<SurveyDetailsCreateWithoutSurveyTypeInput, SurveyDetailsUncheckedCreateWithoutSurveyTypeInput>
  }

  export type SurveyDetailsUpdateWithWhereUniqueWithoutSurveyTypeInput = {
    where: SurveyDetailsWhereUniqueInput
    data: XOR<SurveyDetailsUpdateWithoutSurveyTypeInput, SurveyDetailsUncheckedUpdateWithoutSurveyTypeInput>
  }

  export type SurveyDetailsUpdateManyWithWhereWithoutSurveyTypeInput = {
    where: SurveyDetailsScalarWhereInput
    data: XOR<SurveyDetailsUpdateManyMutationInput, SurveyDetailsUncheckedUpdateManyWithoutSurveyTypeInput>
  }

  export type ResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput = {
    floorAssessmentId?: string
    floorNumber: string
    coveredArea: Decimal | DecimalJsLike | number | string
    allRoomVerandaArea: Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea: Decimal | DecimalJsLike | number | string
    allGarageArea: Decimal | DecimalJsLike | number | string
    carpetArea: Decimal | DecimalJsLike | number | string
    survey: SurveyDetailsCreateNestedOneWithoutResidentialPropertyAssessmentsInput
    constructionNature: ConstructionNatureMasterCreateNestedOneWithoutResidentialPropertyAssessmentsInput
  }

  export type ResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput = {
    floorAssessmentId?: string
    surveyUniqueCode: string
    floorNumber: string
    constructionNatureId: string
    coveredArea: Decimal | DecimalJsLike | number | string
    allRoomVerandaArea: Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea: Decimal | DecimalJsLike | number | string
    allGarageArea: Decimal | DecimalJsLike | number | string
    carpetArea: Decimal | DecimalJsLike | number | string
  }

  export type ResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput = {
    where: ResidentialPropertyAssessmentWhereUniqueInput
    create: XOR<ResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput, ResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput>
  }

  export type ResidentialPropertyAssessmentCreateManyOccupancyStatusInputEnvelope = {
    data: ResidentialPropertyAssessmentCreateManyOccupancyStatusInput | ResidentialPropertyAssessmentCreateManyOccupancyStatusInput[]
    skipDuplicates?: boolean
  }

  export type NonResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput = {
    floorAssessmentId?: string
    floorNumber: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    builtupArea: Decimal | DecimalJsLike | number | string
    nrPropertyCategory: NrPropertyCategoryMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    nrSubCategory: NrPropertySubCategoryMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    constructionNature: ConstructionNatureMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    survey: SurveyDetailsCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
  }

  export type NonResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput = {
    floorAssessmentId?: string
    surveyUniqueCode: string
    floorNumber: string
    nrPropertyCategoryId: string
    nrSubCategoryId: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    constructionNatureId: string
    builtupArea: Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentCreateOrConnectWithoutOccupancyStatusInput = {
    where: NonResidentialPropertyAssessmentWhereUniqueInput
    create: XOR<NonResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput>
  }

  export type NonResidentialPropertyAssessmentCreateManyOccupancyStatusInputEnvelope = {
    data: NonResidentialPropertyAssessmentCreateManyOccupancyStatusInput | NonResidentialPropertyAssessmentCreateManyOccupancyStatusInput[]
    skipDuplicates?: boolean
  }

  export type ResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutOccupancyStatusInput = {
    where: ResidentialPropertyAssessmentWhereUniqueInput
    update: XOR<ResidentialPropertyAssessmentUpdateWithoutOccupancyStatusInput, ResidentialPropertyAssessmentUncheckedUpdateWithoutOccupancyStatusInput>
    create: XOR<ResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput, ResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput>
  }

  export type ResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutOccupancyStatusInput = {
    where: ResidentialPropertyAssessmentWhereUniqueInput
    data: XOR<ResidentialPropertyAssessmentUpdateWithoutOccupancyStatusInput, ResidentialPropertyAssessmentUncheckedUpdateWithoutOccupancyStatusInput>
  }

  export type ResidentialPropertyAssessmentUpdateManyWithWhereWithoutOccupancyStatusInput = {
    where: ResidentialPropertyAssessmentScalarWhereInput
    data: XOR<ResidentialPropertyAssessmentUpdateManyMutationInput, ResidentialPropertyAssessmentUncheckedUpdateManyWithoutOccupancyStatusInput>
  }

  export type NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutOccupancyStatusInput = {
    where: NonResidentialPropertyAssessmentWhereUniqueInput
    update: XOR<NonResidentialPropertyAssessmentUpdateWithoutOccupancyStatusInput, NonResidentialPropertyAssessmentUncheckedUpdateWithoutOccupancyStatusInput>
    create: XOR<NonResidentialPropertyAssessmentCreateWithoutOccupancyStatusInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutOccupancyStatusInput>
  }

  export type NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutOccupancyStatusInput = {
    where: NonResidentialPropertyAssessmentWhereUniqueInput
    data: XOR<NonResidentialPropertyAssessmentUpdateWithoutOccupancyStatusInput, NonResidentialPropertyAssessmentUncheckedUpdateWithoutOccupancyStatusInput>
  }

  export type NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutOccupancyStatusInput = {
    where: NonResidentialPropertyAssessmentScalarWhereInput
    data: XOR<NonResidentialPropertyAssessmentUpdateManyMutationInput, NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutOccupancyStatusInput>
  }

  export type SurveyStatusMappingCreateWithoutStatusInput = {
    statusMappingId?: string
    isActive?: boolean
    survey: SurveyDetailsCreateNestedOneWithoutSurveyStatusMapsInput
    revertedFrom?: SurveyStatusMasterCreateNestedOneWithoutSurveyStatusMapsRevertedInput
    changedBy: UsersMasterCreateNestedOneWithoutSurveyStatusMapsInput
  }

  export type SurveyStatusMappingUncheckedCreateWithoutStatusInput = {
    statusMappingId?: string
    surveyUniqueCode: string
    revertedFromId?: string | null
    changedById: string
    isActive?: boolean
  }

  export type SurveyStatusMappingCreateOrConnectWithoutStatusInput = {
    where: SurveyStatusMappingWhereUniqueInput
    create: XOR<SurveyStatusMappingCreateWithoutStatusInput, SurveyStatusMappingUncheckedCreateWithoutStatusInput>
  }

  export type SurveyStatusMappingCreateManyStatusInputEnvelope = {
    data: SurveyStatusMappingCreateManyStatusInput | SurveyStatusMappingCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type SurveyStatusMappingCreateWithoutRevertedFromInput = {
    statusMappingId?: string
    isActive?: boolean
    survey: SurveyDetailsCreateNestedOneWithoutSurveyStatusMapsInput
    status: SurveyStatusMasterCreateNestedOneWithoutSurveyStatusMapsInput
    changedBy: UsersMasterCreateNestedOneWithoutSurveyStatusMapsInput
  }

  export type SurveyStatusMappingUncheckedCreateWithoutRevertedFromInput = {
    statusMappingId?: string
    surveyUniqueCode: string
    statusId: string
    changedById: string
    isActive?: boolean
  }

  export type SurveyStatusMappingCreateOrConnectWithoutRevertedFromInput = {
    where: SurveyStatusMappingWhereUniqueInput
    create: XOR<SurveyStatusMappingCreateWithoutRevertedFromInput, SurveyStatusMappingUncheckedCreateWithoutRevertedFromInput>
  }

  export type SurveyStatusMappingCreateManyRevertedFromInputEnvelope = {
    data: SurveyStatusMappingCreateManyRevertedFromInput | SurveyStatusMappingCreateManyRevertedFromInput[]
    skipDuplicates?: boolean
  }

  export type SurveyStatusMappingUpsertWithWhereUniqueWithoutStatusInput = {
    where: SurveyStatusMappingWhereUniqueInput
    update: XOR<SurveyStatusMappingUpdateWithoutStatusInput, SurveyStatusMappingUncheckedUpdateWithoutStatusInput>
    create: XOR<SurveyStatusMappingCreateWithoutStatusInput, SurveyStatusMappingUncheckedCreateWithoutStatusInput>
  }

  export type SurveyStatusMappingUpdateWithWhereUniqueWithoutStatusInput = {
    where: SurveyStatusMappingWhereUniqueInput
    data: XOR<SurveyStatusMappingUpdateWithoutStatusInput, SurveyStatusMappingUncheckedUpdateWithoutStatusInput>
  }

  export type SurveyStatusMappingUpdateManyWithWhereWithoutStatusInput = {
    where: SurveyStatusMappingScalarWhereInput
    data: XOR<SurveyStatusMappingUpdateManyMutationInput, SurveyStatusMappingUncheckedUpdateManyWithoutStatusInput>
  }

  export type SurveyStatusMappingScalarWhereInput = {
    AND?: SurveyStatusMappingScalarWhereInput | SurveyStatusMappingScalarWhereInput[]
    OR?: SurveyStatusMappingScalarWhereInput[]
    NOT?: SurveyStatusMappingScalarWhereInput | SurveyStatusMappingScalarWhereInput[]
    statusMappingId?: StringFilter<"SurveyStatusMapping"> | string
    surveyUniqueCode?: StringFilter<"SurveyStatusMapping"> | string
    statusId?: StringFilter<"SurveyStatusMapping"> | string
    revertedFromId?: StringNullableFilter<"SurveyStatusMapping"> | string | null
    changedById?: StringFilter<"SurveyStatusMapping"> | string
    isActive?: BoolFilter<"SurveyStatusMapping"> | boolean
  }

  export type SurveyStatusMappingUpsertWithWhereUniqueWithoutRevertedFromInput = {
    where: SurveyStatusMappingWhereUniqueInput
    update: XOR<SurveyStatusMappingUpdateWithoutRevertedFromInput, SurveyStatusMappingUncheckedUpdateWithoutRevertedFromInput>
    create: XOR<SurveyStatusMappingCreateWithoutRevertedFromInput, SurveyStatusMappingUncheckedCreateWithoutRevertedFromInput>
  }

  export type SurveyStatusMappingUpdateWithWhereUniqueWithoutRevertedFromInput = {
    where: SurveyStatusMappingWhereUniqueInput
    data: XOR<SurveyStatusMappingUpdateWithoutRevertedFromInput, SurveyStatusMappingUncheckedUpdateWithoutRevertedFromInput>
  }

  export type SurveyStatusMappingUpdateManyWithWhereWithoutRevertedFromInput = {
    where: SurveyStatusMappingScalarWhereInput
    data: XOR<SurveyStatusMappingUpdateManyMutationInput, SurveyStatusMappingUncheckedUpdateManyWithoutRevertedFromInput>
  }

  export type WardStatusMappingCreateWithoutStatusInput = {
    wardStatusId?: string
    isActive?: boolean
    ward: WardMasterCreateNestedOneWithoutWardStatusMapsInput
    changedBy: UsersMasterCreateNestedOneWithoutWardStatusMapsInput
  }

  export type WardStatusMappingUncheckedCreateWithoutStatusInput = {
    wardStatusId?: string
    wardId: string
    changedById: string
    isActive?: boolean
  }

  export type WardStatusMappingCreateOrConnectWithoutStatusInput = {
    where: WardStatusMappingWhereUniqueInput
    create: XOR<WardStatusMappingCreateWithoutStatusInput, WardStatusMappingUncheckedCreateWithoutStatusInput>
  }

  export type WardStatusMappingCreateManyStatusInputEnvelope = {
    data: WardStatusMappingCreateManyStatusInput | WardStatusMappingCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type WardStatusMappingUpsertWithWhereUniqueWithoutStatusInput = {
    where: WardStatusMappingWhereUniqueInput
    update: XOR<WardStatusMappingUpdateWithoutStatusInput, WardStatusMappingUncheckedUpdateWithoutStatusInput>
    create: XOR<WardStatusMappingCreateWithoutStatusInput, WardStatusMappingUncheckedCreateWithoutStatusInput>
  }

  export type WardStatusMappingUpdateWithWhereUniqueWithoutStatusInput = {
    where: WardStatusMappingWhereUniqueInput
    data: XOR<WardStatusMappingUpdateWithoutStatusInput, WardStatusMappingUncheckedUpdateWithoutStatusInput>
  }

  export type WardStatusMappingUpdateManyWithWhereWithoutStatusInput = {
    where: WardStatusMappingScalarWhereInput
    data: XOR<WardStatusMappingUpdateManyMutationInput, WardStatusMappingUncheckedUpdateManyWithoutStatusInput>
  }

  export type SurveyorAssignmentCreateWithoutUserInput = {
    assignmentId?: string
    assignmentType: string
    isActive?: boolean
    ward: WardMasterCreateNestedOneWithoutSurveyorAssignmentsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyorAssignmentsInput
    wardMohallaMap: WardMohallaMappingCreateNestedOneWithoutSurveyorAssignmentsInput
    assignedBy: UsersMasterCreateNestedOneWithoutSurveyorAssignmentsAssignedByInput
  }

  export type SurveyorAssignmentUncheckedCreateWithoutUserInput = {
    assignmentId?: string
    assignmentType: string
    wardId: string
    mohallaId: string
    wardMohallaMapId: string
    assignedById: string
    isActive?: boolean
  }

  export type SurveyorAssignmentCreateOrConnectWithoutUserInput = {
    where: SurveyorAssignmentWhereUniqueInput
    create: XOR<SurveyorAssignmentCreateWithoutUserInput, SurveyorAssignmentUncheckedCreateWithoutUserInput>
  }

  export type SurveyorAssignmentCreateManyUserInputEnvelope = {
    data: SurveyorAssignmentCreateManyUserInput | SurveyorAssignmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SurveyorAssignmentCreateWithoutAssignedByInput = {
    assignmentId?: string
    assignmentType: string
    isActive?: boolean
    user: UsersMasterCreateNestedOneWithoutSurveyorAssignmentsInput
    ward: WardMasterCreateNestedOneWithoutSurveyorAssignmentsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyorAssignmentsInput
    wardMohallaMap: WardMohallaMappingCreateNestedOneWithoutSurveyorAssignmentsInput
  }

  export type SurveyorAssignmentUncheckedCreateWithoutAssignedByInput = {
    assignmentId?: string
    userId: string
    assignmentType: string
    wardId: string
    mohallaId: string
    wardMohallaMapId: string
    isActive?: boolean
  }

  export type SurveyorAssignmentCreateOrConnectWithoutAssignedByInput = {
    where: SurveyorAssignmentWhereUniqueInput
    create: XOR<SurveyorAssignmentCreateWithoutAssignedByInput, SurveyorAssignmentUncheckedCreateWithoutAssignedByInput>
  }

  export type SurveyorAssignmentCreateManyAssignedByInputEnvelope = {
    data: SurveyorAssignmentCreateManyAssignedByInput | SurveyorAssignmentCreateManyAssignedByInput[]
    skipDuplicates?: boolean
  }

  export type WardStatusMappingCreateWithoutChangedByInput = {
    wardStatusId?: string
    isActive?: boolean
    ward: WardMasterCreateNestedOneWithoutWardStatusMapsInput
    status: WardStatusMasterCreateNestedOneWithoutWardStatusMapsInput
  }

  export type WardStatusMappingUncheckedCreateWithoutChangedByInput = {
    wardStatusId?: string
    wardId: string
    statusId: string
    isActive?: boolean
  }

  export type WardStatusMappingCreateOrConnectWithoutChangedByInput = {
    where: WardStatusMappingWhereUniqueInput
    create: XOR<WardStatusMappingCreateWithoutChangedByInput, WardStatusMappingUncheckedCreateWithoutChangedByInput>
  }

  export type WardStatusMappingCreateManyChangedByInputEnvelope = {
    data: WardStatusMappingCreateManyChangedByInput | WardStatusMappingCreateManyChangedByInput[]
    skipDuplicates?: boolean
  }

  export type SurveyStatusMappingCreateWithoutChangedByInput = {
    statusMappingId?: string
    isActive?: boolean
    survey: SurveyDetailsCreateNestedOneWithoutSurveyStatusMapsInput
    status: SurveyStatusMasterCreateNestedOneWithoutSurveyStatusMapsInput
    revertedFrom?: SurveyStatusMasterCreateNestedOneWithoutSurveyStatusMapsRevertedInput
  }

  export type SurveyStatusMappingUncheckedCreateWithoutChangedByInput = {
    statusMappingId?: string
    surveyUniqueCode: string
    statusId: string
    revertedFromId?: string | null
    isActive?: boolean
  }

  export type SurveyStatusMappingCreateOrConnectWithoutChangedByInput = {
    where: SurveyStatusMappingWhereUniqueInput
    create: XOR<SurveyStatusMappingCreateWithoutChangedByInput, SurveyStatusMappingUncheckedCreateWithoutChangedByInput>
  }

  export type SurveyStatusMappingCreateManyChangedByInputEnvelope = {
    data: SurveyStatusMappingCreateManyChangedByInput | SurveyStatusMappingCreateManyChangedByInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleMappingCreateWithoutUserInput = {
    userRoleMapId?: string
    isActive?: boolean
    role: RolePermissionMasterCreateNestedOneWithoutUserRoleMapsInput
  }

  export type UserRoleMappingUncheckedCreateWithoutUserInput = {
    userRoleMapId?: string
    roleId: string
    isActive?: boolean
  }

  export type UserRoleMappingCreateOrConnectWithoutUserInput = {
    where: UserRoleMappingWhereUniqueInput
    create: XOR<UserRoleMappingCreateWithoutUserInput, UserRoleMappingUncheckedCreateWithoutUserInput>
  }

  export type UserRoleMappingCreateManyUserInputEnvelope = {
    data: UserRoleMappingCreateManyUserInput | UserRoleMappingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    sessionId?: string
    loginTime: Date | string
    logoutTime: Date | string
    isActive?: boolean
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    sessionId?: string
    loginTime: Date | string
    logoutTime: Date | string
    isActive?: boolean
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SurveyorsCreateWithoutUserInput = {
    surveyorName: string
    username: string
    password: string
    wardNumber: string
    wardMohallaMap: WardMohallaMappingCreateNestedOneWithoutSurveyorsInput
    zoneWardMap: ZoneWardMappingCreateNestedOneWithoutSurveyorsInput
    ulbZoneMap: UlbZoneMappingCreateNestedOneWithoutSurveyorsInput
  }

  export type SurveyorsUncheckedCreateWithoutUserInput = {
    surveyorName: string
    username: string
    password: string
    wardNumber: string
    wardMohallaMapId: string
    zoneWardMapId: string
    ulbZoneMapId: string
  }

  export type SurveyorsCreateOrConnectWithoutUserInput = {
    where: SurveyorsWhereUniqueInput
    create: XOR<SurveyorsCreateWithoutUserInput, SurveyorsUncheckedCreateWithoutUserInput>
  }

  export type SurveyorsCreateManyUserInputEnvelope = {
    data: SurveyorsCreateManyUserInput | SurveyorsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SupervisorsCreateWithoutUserInput = {
    supervisorName: string
    username: string
    password: string
    ward: WardMasterCreateNestedOneWithoutSupervisorsInput
  }

  export type SupervisorsUncheckedCreateWithoutUserInput = {
    supervisorName: string
    username: string
    password: string
    wardId: string
  }

  export type SupervisorsCreateOrConnectWithoutUserInput = {
    where: SupervisorsWhereUniqueInput
    create: XOR<SupervisorsCreateWithoutUserInput, SupervisorsUncheckedCreateWithoutUserInput>
  }

  export type SupervisorsCreateManyUserInputEnvelope = {
    data: SupervisorsCreateManyUserInput | SupervisorsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminsCreateWithoutUserInput = {
    adminName: string
    username: string
    password: string
  }

  export type AdminsUncheckedCreateWithoutUserInput = {
    adminName: string
    username: string
    password: string
  }

  export type AdminsCreateOrConnectWithoutUserInput = {
    where: AdminsWhereUniqueInput
    create: XOR<AdminsCreateWithoutUserInput, AdminsUncheckedCreateWithoutUserInput>
  }

  export type AdminsCreateManyUserInputEnvelope = {
    data: AdminsCreateManyUserInput | AdminsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SurveyorAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: SurveyorAssignmentWhereUniqueInput
    update: XOR<SurveyorAssignmentUpdateWithoutUserInput, SurveyorAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<SurveyorAssignmentCreateWithoutUserInput, SurveyorAssignmentUncheckedCreateWithoutUserInput>
  }

  export type SurveyorAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: SurveyorAssignmentWhereUniqueInput
    data: XOR<SurveyorAssignmentUpdateWithoutUserInput, SurveyorAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type SurveyorAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: SurveyorAssignmentScalarWhereInput
    data: XOR<SurveyorAssignmentUpdateManyMutationInput, SurveyorAssignmentUncheckedUpdateManyWithoutUserInput>
  }

  export type SurveyorAssignmentUpsertWithWhereUniqueWithoutAssignedByInput = {
    where: SurveyorAssignmentWhereUniqueInput
    update: XOR<SurveyorAssignmentUpdateWithoutAssignedByInput, SurveyorAssignmentUncheckedUpdateWithoutAssignedByInput>
    create: XOR<SurveyorAssignmentCreateWithoutAssignedByInput, SurveyorAssignmentUncheckedCreateWithoutAssignedByInput>
  }

  export type SurveyorAssignmentUpdateWithWhereUniqueWithoutAssignedByInput = {
    where: SurveyorAssignmentWhereUniqueInput
    data: XOR<SurveyorAssignmentUpdateWithoutAssignedByInput, SurveyorAssignmentUncheckedUpdateWithoutAssignedByInput>
  }

  export type SurveyorAssignmentUpdateManyWithWhereWithoutAssignedByInput = {
    where: SurveyorAssignmentScalarWhereInput
    data: XOR<SurveyorAssignmentUpdateManyMutationInput, SurveyorAssignmentUncheckedUpdateManyWithoutAssignedByInput>
  }

  export type WardStatusMappingUpsertWithWhereUniqueWithoutChangedByInput = {
    where: WardStatusMappingWhereUniqueInput
    update: XOR<WardStatusMappingUpdateWithoutChangedByInput, WardStatusMappingUncheckedUpdateWithoutChangedByInput>
    create: XOR<WardStatusMappingCreateWithoutChangedByInput, WardStatusMappingUncheckedCreateWithoutChangedByInput>
  }

  export type WardStatusMappingUpdateWithWhereUniqueWithoutChangedByInput = {
    where: WardStatusMappingWhereUniqueInput
    data: XOR<WardStatusMappingUpdateWithoutChangedByInput, WardStatusMappingUncheckedUpdateWithoutChangedByInput>
  }

  export type WardStatusMappingUpdateManyWithWhereWithoutChangedByInput = {
    where: WardStatusMappingScalarWhereInput
    data: XOR<WardStatusMappingUpdateManyMutationInput, WardStatusMappingUncheckedUpdateManyWithoutChangedByInput>
  }

  export type SurveyStatusMappingUpsertWithWhereUniqueWithoutChangedByInput = {
    where: SurveyStatusMappingWhereUniqueInput
    update: XOR<SurveyStatusMappingUpdateWithoutChangedByInput, SurveyStatusMappingUncheckedUpdateWithoutChangedByInput>
    create: XOR<SurveyStatusMappingCreateWithoutChangedByInput, SurveyStatusMappingUncheckedCreateWithoutChangedByInput>
  }

  export type SurveyStatusMappingUpdateWithWhereUniqueWithoutChangedByInput = {
    where: SurveyStatusMappingWhereUniqueInput
    data: XOR<SurveyStatusMappingUpdateWithoutChangedByInput, SurveyStatusMappingUncheckedUpdateWithoutChangedByInput>
  }

  export type SurveyStatusMappingUpdateManyWithWhereWithoutChangedByInput = {
    where: SurveyStatusMappingScalarWhereInput
    data: XOR<SurveyStatusMappingUpdateManyMutationInput, SurveyStatusMappingUncheckedUpdateManyWithoutChangedByInput>
  }

  export type UserRoleMappingUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleMappingWhereUniqueInput
    update: XOR<UserRoleMappingUpdateWithoutUserInput, UserRoleMappingUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleMappingCreateWithoutUserInput, UserRoleMappingUncheckedCreateWithoutUserInput>
  }

  export type UserRoleMappingUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleMappingWhereUniqueInput
    data: XOR<UserRoleMappingUpdateWithoutUserInput, UserRoleMappingUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleMappingUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleMappingScalarWhereInput
    data: XOR<UserRoleMappingUpdateManyMutationInput, UserRoleMappingUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleMappingScalarWhereInput = {
    AND?: UserRoleMappingScalarWhereInput | UserRoleMappingScalarWhereInput[]
    OR?: UserRoleMappingScalarWhereInput[]
    NOT?: UserRoleMappingScalarWhereInput | UserRoleMappingScalarWhereInput[]
    userRoleMapId?: StringFilter<"UserRoleMapping"> | string
    userId?: StringFilter<"UserRoleMapping"> | string
    roleId?: StringFilter<"UserRoleMapping"> | string
    isActive?: BoolFilter<"UserRoleMapping"> | boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    sessionId?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    loginTime?: DateTimeFilter<"Session"> | Date | string
    logoutTime?: DateTimeFilter<"Session"> | Date | string
    isActive?: BoolFilter<"Session"> | boolean
  }

  export type SurveyorsUpsertWithWhereUniqueWithoutUserInput = {
    where: SurveyorsWhereUniqueInput
    update: XOR<SurveyorsUpdateWithoutUserInput, SurveyorsUncheckedUpdateWithoutUserInput>
    create: XOR<SurveyorsCreateWithoutUserInput, SurveyorsUncheckedCreateWithoutUserInput>
  }

  export type SurveyorsUpdateWithWhereUniqueWithoutUserInput = {
    where: SurveyorsWhereUniqueInput
    data: XOR<SurveyorsUpdateWithoutUserInput, SurveyorsUncheckedUpdateWithoutUserInput>
  }

  export type SurveyorsUpdateManyWithWhereWithoutUserInput = {
    where: SurveyorsScalarWhereInput
    data: XOR<SurveyorsUpdateManyMutationInput, SurveyorsUncheckedUpdateManyWithoutUserInput>
  }

  export type SurveyorsScalarWhereInput = {
    AND?: SurveyorsScalarWhereInput | SurveyorsScalarWhereInput[]
    OR?: SurveyorsScalarWhereInput[]
    NOT?: SurveyorsScalarWhereInput | SurveyorsScalarWhereInput[]
    userId?: StringFilter<"Surveyors"> | string
    surveyorName?: StringFilter<"Surveyors"> | string
    username?: StringFilter<"Surveyors"> | string
    password?: StringFilter<"Surveyors"> | string
    wardNumber?: StringFilter<"Surveyors"> | string
    wardMohallaMapId?: StringFilter<"Surveyors"> | string
    zoneWardMapId?: StringFilter<"Surveyors"> | string
    ulbZoneMapId?: StringFilter<"Surveyors"> | string
  }

  export type SupervisorsUpsertWithWhereUniqueWithoutUserInput = {
    where: SupervisorsWhereUniqueInput
    update: XOR<SupervisorsUpdateWithoutUserInput, SupervisorsUncheckedUpdateWithoutUserInput>
    create: XOR<SupervisorsCreateWithoutUserInput, SupervisorsUncheckedCreateWithoutUserInput>
  }

  export type SupervisorsUpdateWithWhereUniqueWithoutUserInput = {
    where: SupervisorsWhereUniqueInput
    data: XOR<SupervisorsUpdateWithoutUserInput, SupervisorsUncheckedUpdateWithoutUserInput>
  }

  export type SupervisorsUpdateManyWithWhereWithoutUserInput = {
    where: SupervisorsScalarWhereInput
    data: XOR<SupervisorsUpdateManyMutationInput, SupervisorsUncheckedUpdateManyWithoutUserInput>
  }

  export type AdminsUpsertWithWhereUniqueWithoutUserInput = {
    where: AdminsWhereUniqueInput
    update: XOR<AdminsUpdateWithoutUserInput, AdminsUncheckedUpdateWithoutUserInput>
    create: XOR<AdminsCreateWithoutUserInput, AdminsUncheckedCreateWithoutUserInput>
  }

  export type AdminsUpdateWithWhereUniqueWithoutUserInput = {
    where: AdminsWhereUniqueInput
    data: XOR<AdminsUpdateWithoutUserInput, AdminsUncheckedUpdateWithoutUserInput>
  }

  export type AdminsUpdateManyWithWhereWithoutUserInput = {
    where: AdminsScalarWhereInput
    data: XOR<AdminsUpdateManyMutationInput, AdminsUncheckedUpdateManyWithoutUserInput>
  }

  export type AdminsScalarWhereInput = {
    AND?: AdminsScalarWhereInput | AdminsScalarWhereInput[]
    OR?: AdminsScalarWhereInput[]
    NOT?: AdminsScalarWhereInput | AdminsScalarWhereInput[]
    userId?: StringFilter<"Admins"> | string
    adminName?: StringFilter<"Admins"> | string
    username?: StringFilter<"Admins"> | string
    password?: StringFilter<"Admins"> | string
  }

  export type UserRoleMappingCreateWithoutRoleInput = {
    userRoleMapId?: string
    isActive?: boolean
    user: UsersMasterCreateNestedOneWithoutUserRoleMapsInput
  }

  export type UserRoleMappingUncheckedCreateWithoutRoleInput = {
    userRoleMapId?: string
    userId: string
    isActive?: boolean
  }

  export type UserRoleMappingCreateOrConnectWithoutRoleInput = {
    where: UserRoleMappingWhereUniqueInput
    create: XOR<UserRoleMappingCreateWithoutRoleInput, UserRoleMappingUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleMappingCreateManyRoleInputEnvelope = {
    data: UserRoleMappingCreateManyRoleInput | UserRoleMappingCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleMappingUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleMappingWhereUniqueInput
    update: XOR<UserRoleMappingUpdateWithoutRoleInput, UserRoleMappingUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleMappingCreateWithoutRoleInput, UserRoleMappingUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleMappingUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleMappingWhereUniqueInput
    data: XOR<UserRoleMappingUpdateWithoutRoleInput, UserRoleMappingUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleMappingUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleMappingScalarWhereInput
    data: XOR<UserRoleMappingUpdateManyMutationInput, UserRoleMappingUncheckedUpdateManyWithoutRoleInput>
  }

  export type UlbMasterCreateWithoutUlbZoneMapsInput = {
    ulbId?: string
    ulbName: string
    isActive?: boolean
    description?: string | null
    surveyDetails?: SurveyDetailsCreateNestedManyWithoutUlbInput
  }

  export type UlbMasterUncheckedCreateWithoutUlbZoneMapsInput = {
    ulbId?: string
    ulbName: string
    isActive?: boolean
    description?: string | null
    surveyDetails?: SurveyDetailsUncheckedCreateNestedManyWithoutUlbInput
  }

  export type UlbMasterCreateOrConnectWithoutUlbZoneMapsInput = {
    where: UlbMasterWhereUniqueInput
    create: XOR<UlbMasterCreateWithoutUlbZoneMapsInput, UlbMasterUncheckedCreateWithoutUlbZoneMapsInput>
  }

  export type ZoneMasterCreateWithoutUlbZoneMapsInput = {
    zoneId?: string
    zoneNumber: string
    isActive?: boolean
    description?: string | null
    zoneWardMaps?: ZoneWardMappingCreateNestedManyWithoutZoneInput
    surveyDetails?: SurveyDetailsCreateNestedManyWithoutZoneInput
  }

  export type ZoneMasterUncheckedCreateWithoutUlbZoneMapsInput = {
    zoneId?: string
    zoneNumber: string
    isActive?: boolean
    description?: string | null
    zoneWardMaps?: ZoneWardMappingUncheckedCreateNestedManyWithoutZoneInput
    surveyDetails?: SurveyDetailsUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneMasterCreateOrConnectWithoutUlbZoneMapsInput = {
    where: ZoneMasterWhereUniqueInput
    create: XOR<ZoneMasterCreateWithoutUlbZoneMapsInput, ZoneMasterUncheckedCreateWithoutUlbZoneMapsInput>
  }

  export type SurveyorsCreateWithoutUlbZoneMapInput = {
    surveyorName: string
    username: string
    password: string
    wardNumber: string
    user: UsersMasterCreateNestedOneWithoutSurveyorsInput
    wardMohallaMap: WardMohallaMappingCreateNestedOneWithoutSurveyorsInput
    zoneWardMap: ZoneWardMappingCreateNestedOneWithoutSurveyorsInput
  }

  export type SurveyorsUncheckedCreateWithoutUlbZoneMapInput = {
    userId: string
    surveyorName: string
    username: string
    password: string
    wardNumber: string
    wardMohallaMapId: string
    zoneWardMapId: string
  }

  export type SurveyorsCreateOrConnectWithoutUlbZoneMapInput = {
    where: SurveyorsWhereUniqueInput
    create: XOR<SurveyorsCreateWithoutUlbZoneMapInput, SurveyorsUncheckedCreateWithoutUlbZoneMapInput>
  }

  export type SurveyorsCreateManyUlbZoneMapInputEnvelope = {
    data: SurveyorsCreateManyUlbZoneMapInput | SurveyorsCreateManyUlbZoneMapInput[]
    skipDuplicates?: boolean
  }

  export type UlbMasterUpsertWithoutUlbZoneMapsInput = {
    update: XOR<UlbMasterUpdateWithoutUlbZoneMapsInput, UlbMasterUncheckedUpdateWithoutUlbZoneMapsInput>
    create: XOR<UlbMasterCreateWithoutUlbZoneMapsInput, UlbMasterUncheckedCreateWithoutUlbZoneMapsInput>
    where?: UlbMasterWhereInput
  }

  export type UlbMasterUpdateToOneWithWhereWithoutUlbZoneMapsInput = {
    where?: UlbMasterWhereInput
    data: XOR<UlbMasterUpdateWithoutUlbZoneMapsInput, UlbMasterUncheckedUpdateWithoutUlbZoneMapsInput>
  }

  export type UlbMasterUpdateWithoutUlbZoneMapsInput = {
    ulbId?: StringFieldUpdateOperationsInput | string
    ulbName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyDetails?: SurveyDetailsUpdateManyWithoutUlbNestedInput
  }

  export type UlbMasterUncheckedUpdateWithoutUlbZoneMapsInput = {
    ulbId?: StringFieldUpdateOperationsInput | string
    ulbName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyDetails?: SurveyDetailsUncheckedUpdateManyWithoutUlbNestedInput
  }

  export type ZoneMasterUpsertWithoutUlbZoneMapsInput = {
    update: XOR<ZoneMasterUpdateWithoutUlbZoneMapsInput, ZoneMasterUncheckedUpdateWithoutUlbZoneMapsInput>
    create: XOR<ZoneMasterCreateWithoutUlbZoneMapsInput, ZoneMasterUncheckedCreateWithoutUlbZoneMapsInput>
    where?: ZoneMasterWhereInput
  }

  export type ZoneMasterUpdateToOneWithWhereWithoutUlbZoneMapsInput = {
    where?: ZoneMasterWhereInput
    data: XOR<ZoneMasterUpdateWithoutUlbZoneMapsInput, ZoneMasterUncheckedUpdateWithoutUlbZoneMapsInput>
  }

  export type ZoneMasterUpdateWithoutUlbZoneMapsInput = {
    zoneId?: StringFieldUpdateOperationsInput | string
    zoneNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    zoneWardMaps?: ZoneWardMappingUpdateManyWithoutZoneNestedInput
    surveyDetails?: SurveyDetailsUpdateManyWithoutZoneNestedInput
  }

  export type ZoneMasterUncheckedUpdateWithoutUlbZoneMapsInput = {
    zoneId?: StringFieldUpdateOperationsInput | string
    zoneNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    zoneWardMaps?: ZoneWardMappingUncheckedUpdateManyWithoutZoneNestedInput
    surveyDetails?: SurveyDetailsUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type SurveyorsUpsertWithWhereUniqueWithoutUlbZoneMapInput = {
    where: SurveyorsWhereUniqueInput
    update: XOR<SurveyorsUpdateWithoutUlbZoneMapInput, SurveyorsUncheckedUpdateWithoutUlbZoneMapInput>
    create: XOR<SurveyorsCreateWithoutUlbZoneMapInput, SurveyorsUncheckedCreateWithoutUlbZoneMapInput>
  }

  export type SurveyorsUpdateWithWhereUniqueWithoutUlbZoneMapInput = {
    where: SurveyorsWhereUniqueInput
    data: XOR<SurveyorsUpdateWithoutUlbZoneMapInput, SurveyorsUncheckedUpdateWithoutUlbZoneMapInput>
  }

  export type SurveyorsUpdateManyWithWhereWithoutUlbZoneMapInput = {
    where: SurveyorsScalarWhereInput
    data: XOR<SurveyorsUpdateManyMutationInput, SurveyorsUncheckedUpdateManyWithoutUlbZoneMapInput>
  }

  export type ZoneMasterCreateWithoutZoneWardMapsInput = {
    zoneId?: string
    zoneNumber: string
    isActive?: boolean
    description?: string | null
    ulbZoneMaps?: UlbZoneMappingCreateNestedManyWithoutZoneInput
    surveyDetails?: SurveyDetailsCreateNestedManyWithoutZoneInput
  }

  export type ZoneMasterUncheckedCreateWithoutZoneWardMapsInput = {
    zoneId?: string
    zoneNumber: string
    isActive?: boolean
    description?: string | null
    ulbZoneMaps?: UlbZoneMappingUncheckedCreateNestedManyWithoutZoneInput
    surveyDetails?: SurveyDetailsUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneMasterCreateOrConnectWithoutZoneWardMapsInput = {
    where: ZoneMasterWhereUniqueInput
    create: XOR<ZoneMasterCreateWithoutZoneWardMapsInput, ZoneMasterUncheckedCreateWithoutZoneWardMapsInput>
  }

  export type WardMasterCreateWithoutZoneWardMapsInput = {
    wardId?: string
    wardNumber: string
    isActive?: boolean
    wardName: string
    description?: string | null
    wardMohallaMaps?: WardMohallaMappingCreateNestedManyWithoutWardInput
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutWardInput
    wardStatusMaps?: WardStatusMappingCreateNestedManyWithoutWardInput
    surveyDetails?: SurveyDetailsCreateNestedManyWithoutWardInput
    supervisors?: SupervisorsCreateNestedManyWithoutWardInput
  }

  export type WardMasterUncheckedCreateWithoutZoneWardMapsInput = {
    wardId?: string
    wardNumber: string
    isActive?: boolean
    wardName: string
    description?: string | null
    wardMohallaMaps?: WardMohallaMappingUncheckedCreateNestedManyWithoutWardInput
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutWardInput
    wardStatusMaps?: WardStatusMappingUncheckedCreateNestedManyWithoutWardInput
    surveyDetails?: SurveyDetailsUncheckedCreateNestedManyWithoutWardInput
    supervisors?: SupervisorsUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardMasterCreateOrConnectWithoutZoneWardMapsInput = {
    where: WardMasterWhereUniqueInput
    create: XOR<WardMasterCreateWithoutZoneWardMapsInput, WardMasterUncheckedCreateWithoutZoneWardMapsInput>
  }

  export type SurveyorsCreateWithoutZoneWardMapInput = {
    surveyorName: string
    username: string
    password: string
    wardNumber: string
    user: UsersMasterCreateNestedOneWithoutSurveyorsInput
    wardMohallaMap: WardMohallaMappingCreateNestedOneWithoutSurveyorsInput
    ulbZoneMap: UlbZoneMappingCreateNestedOneWithoutSurveyorsInput
  }

  export type SurveyorsUncheckedCreateWithoutZoneWardMapInput = {
    userId: string
    surveyorName: string
    username: string
    password: string
    wardNumber: string
    wardMohallaMapId: string
    ulbZoneMapId: string
  }

  export type SurveyorsCreateOrConnectWithoutZoneWardMapInput = {
    where: SurveyorsWhereUniqueInput
    create: XOR<SurveyorsCreateWithoutZoneWardMapInput, SurveyorsUncheckedCreateWithoutZoneWardMapInput>
  }

  export type SurveyorsCreateManyZoneWardMapInputEnvelope = {
    data: SurveyorsCreateManyZoneWardMapInput | SurveyorsCreateManyZoneWardMapInput[]
    skipDuplicates?: boolean
  }

  export type ZoneMasterUpsertWithoutZoneWardMapsInput = {
    update: XOR<ZoneMasterUpdateWithoutZoneWardMapsInput, ZoneMasterUncheckedUpdateWithoutZoneWardMapsInput>
    create: XOR<ZoneMasterCreateWithoutZoneWardMapsInput, ZoneMasterUncheckedCreateWithoutZoneWardMapsInput>
    where?: ZoneMasterWhereInput
  }

  export type ZoneMasterUpdateToOneWithWhereWithoutZoneWardMapsInput = {
    where?: ZoneMasterWhereInput
    data: XOR<ZoneMasterUpdateWithoutZoneWardMapsInput, ZoneMasterUncheckedUpdateWithoutZoneWardMapsInput>
  }

  export type ZoneMasterUpdateWithoutZoneWardMapsInput = {
    zoneId?: StringFieldUpdateOperationsInput | string
    zoneNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ulbZoneMaps?: UlbZoneMappingUpdateManyWithoutZoneNestedInput
    surveyDetails?: SurveyDetailsUpdateManyWithoutZoneNestedInput
  }

  export type ZoneMasterUncheckedUpdateWithoutZoneWardMapsInput = {
    zoneId?: StringFieldUpdateOperationsInput | string
    zoneNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ulbZoneMaps?: UlbZoneMappingUncheckedUpdateManyWithoutZoneNestedInput
    surveyDetails?: SurveyDetailsUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type WardMasterUpsertWithoutZoneWardMapsInput = {
    update: XOR<WardMasterUpdateWithoutZoneWardMapsInput, WardMasterUncheckedUpdateWithoutZoneWardMapsInput>
    create: XOR<WardMasterCreateWithoutZoneWardMapsInput, WardMasterUncheckedCreateWithoutZoneWardMapsInput>
    where?: WardMasterWhereInput
  }

  export type WardMasterUpdateToOneWithWhereWithoutZoneWardMapsInput = {
    where?: WardMasterWhereInput
    data: XOR<WardMasterUpdateWithoutZoneWardMapsInput, WardMasterUncheckedUpdateWithoutZoneWardMapsInput>
  }

  export type WardMasterUpdateWithoutZoneWardMapsInput = {
    wardId?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    wardName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    wardMohallaMaps?: WardMohallaMappingUpdateManyWithoutWardNestedInput
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutWardNestedInput
    wardStatusMaps?: WardStatusMappingUpdateManyWithoutWardNestedInput
    surveyDetails?: SurveyDetailsUpdateManyWithoutWardNestedInput
    supervisors?: SupervisorsUpdateManyWithoutWardNestedInput
  }

  export type WardMasterUncheckedUpdateWithoutZoneWardMapsInput = {
    wardId?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    wardName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    wardMohallaMaps?: WardMohallaMappingUncheckedUpdateManyWithoutWardNestedInput
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutWardNestedInput
    wardStatusMaps?: WardStatusMappingUncheckedUpdateManyWithoutWardNestedInput
    surveyDetails?: SurveyDetailsUncheckedUpdateManyWithoutWardNestedInput
    supervisors?: SupervisorsUncheckedUpdateManyWithoutWardNestedInput
  }

  export type SurveyorsUpsertWithWhereUniqueWithoutZoneWardMapInput = {
    where: SurveyorsWhereUniqueInput
    update: XOR<SurveyorsUpdateWithoutZoneWardMapInput, SurveyorsUncheckedUpdateWithoutZoneWardMapInput>
    create: XOR<SurveyorsCreateWithoutZoneWardMapInput, SurveyorsUncheckedCreateWithoutZoneWardMapInput>
  }

  export type SurveyorsUpdateWithWhereUniqueWithoutZoneWardMapInput = {
    where: SurveyorsWhereUniqueInput
    data: XOR<SurveyorsUpdateWithoutZoneWardMapInput, SurveyorsUncheckedUpdateWithoutZoneWardMapInput>
  }

  export type SurveyorsUpdateManyWithWhereWithoutZoneWardMapInput = {
    where: SurveyorsScalarWhereInput
    data: XOR<SurveyorsUpdateManyMutationInput, SurveyorsUncheckedUpdateManyWithoutZoneWardMapInput>
  }

  export type WardMasterCreateWithoutWardMohallaMapsInput = {
    wardId?: string
    wardNumber: string
    isActive?: boolean
    wardName: string
    description?: string | null
    zoneWardMaps?: ZoneWardMappingCreateNestedManyWithoutWardInput
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutWardInput
    wardStatusMaps?: WardStatusMappingCreateNestedManyWithoutWardInput
    surveyDetails?: SurveyDetailsCreateNestedManyWithoutWardInput
    supervisors?: SupervisorsCreateNestedManyWithoutWardInput
  }

  export type WardMasterUncheckedCreateWithoutWardMohallaMapsInput = {
    wardId?: string
    wardNumber: string
    isActive?: boolean
    wardName: string
    description?: string | null
    zoneWardMaps?: ZoneWardMappingUncheckedCreateNestedManyWithoutWardInput
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutWardInput
    wardStatusMaps?: WardStatusMappingUncheckedCreateNestedManyWithoutWardInput
    surveyDetails?: SurveyDetailsUncheckedCreateNestedManyWithoutWardInput
    supervisors?: SupervisorsUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardMasterCreateOrConnectWithoutWardMohallaMapsInput = {
    where: WardMasterWhereUniqueInput
    create: XOR<WardMasterCreateWithoutWardMohallaMapsInput, WardMasterUncheckedCreateWithoutWardMohallaMapsInput>
  }

  export type MohallaMasterCreateWithoutWardMohallaMapsInput = {
    mohallaId?: string
    mohallaName: string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutMohallaInput
    surveyDetails?: SurveyDetailsCreateNestedManyWithoutMohallaInput
  }

  export type MohallaMasterUncheckedCreateWithoutWardMohallaMapsInput = {
    mohallaId?: string
    mohallaName: string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutMohallaInput
    surveyDetails?: SurveyDetailsUncheckedCreateNestedManyWithoutMohallaInput
  }

  export type MohallaMasterCreateOrConnectWithoutWardMohallaMapsInput = {
    where: MohallaMasterWhereUniqueInput
    create: XOR<MohallaMasterCreateWithoutWardMohallaMapsInput, MohallaMasterUncheckedCreateWithoutWardMohallaMapsInput>
  }

  export type SurveyorAssignmentCreateWithoutWardMohallaMapInput = {
    assignmentId?: string
    assignmentType: string
    isActive?: boolean
    user: UsersMasterCreateNestedOneWithoutSurveyorAssignmentsInput
    ward: WardMasterCreateNestedOneWithoutSurveyorAssignmentsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyorAssignmentsInput
    assignedBy: UsersMasterCreateNestedOneWithoutSurveyorAssignmentsAssignedByInput
  }

  export type SurveyorAssignmentUncheckedCreateWithoutWardMohallaMapInput = {
    assignmentId?: string
    userId: string
    assignmentType: string
    wardId: string
    mohallaId: string
    assignedById: string
    isActive?: boolean
  }

  export type SurveyorAssignmentCreateOrConnectWithoutWardMohallaMapInput = {
    where: SurveyorAssignmentWhereUniqueInput
    create: XOR<SurveyorAssignmentCreateWithoutWardMohallaMapInput, SurveyorAssignmentUncheckedCreateWithoutWardMohallaMapInput>
  }

  export type SurveyorAssignmentCreateManyWardMohallaMapInputEnvelope = {
    data: SurveyorAssignmentCreateManyWardMohallaMapInput | SurveyorAssignmentCreateManyWardMohallaMapInput[]
    skipDuplicates?: boolean
  }

  export type SurveyorsCreateWithoutWardMohallaMapInput = {
    surveyorName: string
    username: string
    password: string
    wardNumber: string
    user: UsersMasterCreateNestedOneWithoutSurveyorsInput
    zoneWardMap: ZoneWardMappingCreateNestedOneWithoutSurveyorsInput
    ulbZoneMap: UlbZoneMappingCreateNestedOneWithoutSurveyorsInput
  }

  export type SurveyorsUncheckedCreateWithoutWardMohallaMapInput = {
    userId: string
    surveyorName: string
    username: string
    password: string
    wardNumber: string
    zoneWardMapId: string
    ulbZoneMapId: string
  }

  export type SurveyorsCreateOrConnectWithoutWardMohallaMapInput = {
    where: SurveyorsWhereUniqueInput
    create: XOR<SurveyorsCreateWithoutWardMohallaMapInput, SurveyorsUncheckedCreateWithoutWardMohallaMapInput>
  }

  export type SurveyorsCreateManyWardMohallaMapInputEnvelope = {
    data: SurveyorsCreateManyWardMohallaMapInput | SurveyorsCreateManyWardMohallaMapInput[]
    skipDuplicates?: boolean
  }

  export type WardMasterUpsertWithoutWardMohallaMapsInput = {
    update: XOR<WardMasterUpdateWithoutWardMohallaMapsInput, WardMasterUncheckedUpdateWithoutWardMohallaMapsInput>
    create: XOR<WardMasterCreateWithoutWardMohallaMapsInput, WardMasterUncheckedCreateWithoutWardMohallaMapsInput>
    where?: WardMasterWhereInput
  }

  export type WardMasterUpdateToOneWithWhereWithoutWardMohallaMapsInput = {
    where?: WardMasterWhereInput
    data: XOR<WardMasterUpdateWithoutWardMohallaMapsInput, WardMasterUncheckedUpdateWithoutWardMohallaMapsInput>
  }

  export type WardMasterUpdateWithoutWardMohallaMapsInput = {
    wardId?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    wardName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    zoneWardMaps?: ZoneWardMappingUpdateManyWithoutWardNestedInput
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutWardNestedInput
    wardStatusMaps?: WardStatusMappingUpdateManyWithoutWardNestedInput
    surveyDetails?: SurveyDetailsUpdateManyWithoutWardNestedInput
    supervisors?: SupervisorsUpdateManyWithoutWardNestedInput
  }

  export type WardMasterUncheckedUpdateWithoutWardMohallaMapsInput = {
    wardId?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    wardName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    zoneWardMaps?: ZoneWardMappingUncheckedUpdateManyWithoutWardNestedInput
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutWardNestedInput
    wardStatusMaps?: WardStatusMappingUncheckedUpdateManyWithoutWardNestedInput
    surveyDetails?: SurveyDetailsUncheckedUpdateManyWithoutWardNestedInput
    supervisors?: SupervisorsUncheckedUpdateManyWithoutWardNestedInput
  }

  export type MohallaMasterUpsertWithoutWardMohallaMapsInput = {
    update: XOR<MohallaMasterUpdateWithoutWardMohallaMapsInput, MohallaMasterUncheckedUpdateWithoutWardMohallaMapsInput>
    create: XOR<MohallaMasterCreateWithoutWardMohallaMapsInput, MohallaMasterUncheckedCreateWithoutWardMohallaMapsInput>
    where?: MohallaMasterWhereInput
  }

  export type MohallaMasterUpdateToOneWithWhereWithoutWardMohallaMapsInput = {
    where?: MohallaMasterWhereInput
    data: XOR<MohallaMasterUpdateWithoutWardMohallaMapsInput, MohallaMasterUncheckedUpdateWithoutWardMohallaMapsInput>
  }

  export type MohallaMasterUpdateWithoutWardMohallaMapsInput = {
    mohallaId?: StringFieldUpdateOperationsInput | string
    mohallaName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutMohallaNestedInput
    surveyDetails?: SurveyDetailsUpdateManyWithoutMohallaNestedInput
  }

  export type MohallaMasterUncheckedUpdateWithoutWardMohallaMapsInput = {
    mohallaId?: StringFieldUpdateOperationsInput | string
    mohallaName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutMohallaNestedInput
    surveyDetails?: SurveyDetailsUncheckedUpdateManyWithoutMohallaNestedInput
  }

  export type SurveyorAssignmentUpsertWithWhereUniqueWithoutWardMohallaMapInput = {
    where: SurveyorAssignmentWhereUniqueInput
    update: XOR<SurveyorAssignmentUpdateWithoutWardMohallaMapInput, SurveyorAssignmentUncheckedUpdateWithoutWardMohallaMapInput>
    create: XOR<SurveyorAssignmentCreateWithoutWardMohallaMapInput, SurveyorAssignmentUncheckedCreateWithoutWardMohallaMapInput>
  }

  export type SurveyorAssignmentUpdateWithWhereUniqueWithoutWardMohallaMapInput = {
    where: SurveyorAssignmentWhereUniqueInput
    data: XOR<SurveyorAssignmentUpdateWithoutWardMohallaMapInput, SurveyorAssignmentUncheckedUpdateWithoutWardMohallaMapInput>
  }

  export type SurveyorAssignmentUpdateManyWithWhereWithoutWardMohallaMapInput = {
    where: SurveyorAssignmentScalarWhereInput
    data: XOR<SurveyorAssignmentUpdateManyMutationInput, SurveyorAssignmentUncheckedUpdateManyWithoutWardMohallaMapInput>
  }

  export type SurveyorsUpsertWithWhereUniqueWithoutWardMohallaMapInput = {
    where: SurveyorsWhereUniqueInput
    update: XOR<SurveyorsUpdateWithoutWardMohallaMapInput, SurveyorsUncheckedUpdateWithoutWardMohallaMapInput>
    create: XOR<SurveyorsCreateWithoutWardMohallaMapInput, SurveyorsUncheckedCreateWithoutWardMohallaMapInput>
  }

  export type SurveyorsUpdateWithWhereUniqueWithoutWardMohallaMapInput = {
    where: SurveyorsWhereUniqueInput
    data: XOR<SurveyorsUpdateWithoutWardMohallaMapInput, SurveyorsUncheckedUpdateWithoutWardMohallaMapInput>
  }

  export type SurveyorsUpdateManyWithWhereWithoutWardMohallaMapInput = {
    where: SurveyorsScalarWhereInput
    data: XOR<SurveyorsUpdateManyMutationInput, SurveyorsUncheckedUpdateManyWithoutWardMohallaMapInput>
  }

  export type UsersMasterCreateWithoutSurveyorAssignmentsInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentCreateNestedManyWithoutAssignedByInput
    wardStatusMaps?: WardStatusMappingCreateNestedManyWithoutChangedByInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsCreateNestedManyWithoutUserInput
    admins?: AdminsCreateNestedManyWithoutUserInput
  }

  export type UsersMasterUncheckedCreateWithoutSurveyorAssignmentsInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    wardStatusMaps?: WardStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsUncheckedCreateNestedManyWithoutUserInput
    admins?: AdminsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersMasterCreateOrConnectWithoutSurveyorAssignmentsInput = {
    where: UsersMasterWhereUniqueInput
    create: XOR<UsersMasterCreateWithoutSurveyorAssignmentsInput, UsersMasterUncheckedCreateWithoutSurveyorAssignmentsInput>
  }

  export type WardMasterCreateWithoutSurveyorAssignmentsInput = {
    wardId?: string
    wardNumber: string
    isActive?: boolean
    wardName: string
    description?: string | null
    zoneWardMaps?: ZoneWardMappingCreateNestedManyWithoutWardInput
    wardMohallaMaps?: WardMohallaMappingCreateNestedManyWithoutWardInput
    wardStatusMaps?: WardStatusMappingCreateNestedManyWithoutWardInput
    surveyDetails?: SurveyDetailsCreateNestedManyWithoutWardInput
    supervisors?: SupervisorsCreateNestedManyWithoutWardInput
  }

  export type WardMasterUncheckedCreateWithoutSurveyorAssignmentsInput = {
    wardId?: string
    wardNumber: string
    isActive?: boolean
    wardName: string
    description?: string | null
    zoneWardMaps?: ZoneWardMappingUncheckedCreateNestedManyWithoutWardInput
    wardMohallaMaps?: WardMohallaMappingUncheckedCreateNestedManyWithoutWardInput
    wardStatusMaps?: WardStatusMappingUncheckedCreateNestedManyWithoutWardInput
    surveyDetails?: SurveyDetailsUncheckedCreateNestedManyWithoutWardInput
    supervisors?: SupervisorsUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardMasterCreateOrConnectWithoutSurveyorAssignmentsInput = {
    where: WardMasterWhereUniqueInput
    create: XOR<WardMasterCreateWithoutSurveyorAssignmentsInput, WardMasterUncheckedCreateWithoutSurveyorAssignmentsInput>
  }

  export type MohallaMasterCreateWithoutSurveyorAssignmentsInput = {
    mohallaId?: string
    mohallaName: string
    isActive?: boolean
    description?: string | null
    wardMohallaMaps?: WardMohallaMappingCreateNestedManyWithoutMohallaInput
    surveyDetails?: SurveyDetailsCreateNestedManyWithoutMohallaInput
  }

  export type MohallaMasterUncheckedCreateWithoutSurveyorAssignmentsInput = {
    mohallaId?: string
    mohallaName: string
    isActive?: boolean
    description?: string | null
    wardMohallaMaps?: WardMohallaMappingUncheckedCreateNestedManyWithoutMohallaInput
    surveyDetails?: SurveyDetailsUncheckedCreateNestedManyWithoutMohallaInput
  }

  export type MohallaMasterCreateOrConnectWithoutSurveyorAssignmentsInput = {
    where: MohallaMasterWhereUniqueInput
    create: XOR<MohallaMasterCreateWithoutSurveyorAssignmentsInput, MohallaMasterUncheckedCreateWithoutSurveyorAssignmentsInput>
  }

  export type WardMohallaMappingCreateWithoutSurveyorAssignmentsInput = {
    wardMohallaMapId?: string
    isActive?: boolean
    ward: WardMasterCreateNestedOneWithoutWardMohallaMapsInput
    mohalla: MohallaMasterCreateNestedOneWithoutWardMohallaMapsInput
    surveyors?: SurveyorsCreateNestedManyWithoutWardMohallaMapInput
  }

  export type WardMohallaMappingUncheckedCreateWithoutSurveyorAssignmentsInput = {
    wardMohallaMapId?: string
    wardId: string
    mohallaId: string
    isActive?: boolean
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutWardMohallaMapInput
  }

  export type WardMohallaMappingCreateOrConnectWithoutSurveyorAssignmentsInput = {
    where: WardMohallaMappingWhereUniqueInput
    create: XOR<WardMohallaMappingCreateWithoutSurveyorAssignmentsInput, WardMohallaMappingUncheckedCreateWithoutSurveyorAssignmentsInput>
  }

  export type UsersMasterCreateWithoutSurveyorAssignmentsAssignedByInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutUserInput
    wardStatusMaps?: WardStatusMappingCreateNestedManyWithoutChangedByInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsCreateNestedManyWithoutUserInput
    admins?: AdminsCreateNestedManyWithoutUserInput
  }

  export type UsersMasterUncheckedCreateWithoutSurveyorAssignmentsAssignedByInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutUserInput
    wardStatusMaps?: WardStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsUncheckedCreateNestedManyWithoutUserInput
    admins?: AdminsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersMasterCreateOrConnectWithoutSurveyorAssignmentsAssignedByInput = {
    where: UsersMasterWhereUniqueInput
    create: XOR<UsersMasterCreateWithoutSurveyorAssignmentsAssignedByInput, UsersMasterUncheckedCreateWithoutSurveyorAssignmentsAssignedByInput>
  }

  export type UsersMasterUpsertWithoutSurveyorAssignmentsInput = {
    update: XOR<UsersMasterUpdateWithoutSurveyorAssignmentsInput, UsersMasterUncheckedUpdateWithoutSurveyorAssignmentsInput>
    create: XOR<UsersMasterCreateWithoutSurveyorAssignmentsInput, UsersMasterUncheckedCreateWithoutSurveyorAssignmentsInput>
    where?: UsersMasterWhereInput
  }

  export type UsersMasterUpdateToOneWithWhereWithoutSurveyorAssignmentsInput = {
    where?: UsersMasterWhereInput
    data: XOR<UsersMasterUpdateWithoutSurveyorAssignmentsInput, UsersMasterUncheckedUpdateWithoutSurveyorAssignmentsInput>
  }

  export type UsersMasterUpdateWithoutSurveyorAssignmentsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUpdateManyWithoutAssignedByNestedInput
    wardStatusMaps?: WardStatusMappingUpdateManyWithoutChangedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUpdateManyWithoutUserNestedInput
    admins?: AdminsUpdateManyWithoutUserNestedInput
  }

  export type UsersMasterUncheckedUpdateWithoutSurveyorAssignmentsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    wardStatusMaps?: WardStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUncheckedUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUncheckedUpdateManyWithoutUserNestedInput
    admins?: AdminsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WardMasterUpsertWithoutSurveyorAssignmentsInput = {
    update: XOR<WardMasterUpdateWithoutSurveyorAssignmentsInput, WardMasterUncheckedUpdateWithoutSurveyorAssignmentsInput>
    create: XOR<WardMasterCreateWithoutSurveyorAssignmentsInput, WardMasterUncheckedCreateWithoutSurveyorAssignmentsInput>
    where?: WardMasterWhereInput
  }

  export type WardMasterUpdateToOneWithWhereWithoutSurveyorAssignmentsInput = {
    where?: WardMasterWhereInput
    data: XOR<WardMasterUpdateWithoutSurveyorAssignmentsInput, WardMasterUncheckedUpdateWithoutSurveyorAssignmentsInput>
  }

  export type WardMasterUpdateWithoutSurveyorAssignmentsInput = {
    wardId?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    wardName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    zoneWardMaps?: ZoneWardMappingUpdateManyWithoutWardNestedInput
    wardMohallaMaps?: WardMohallaMappingUpdateManyWithoutWardNestedInput
    wardStatusMaps?: WardStatusMappingUpdateManyWithoutWardNestedInput
    surveyDetails?: SurveyDetailsUpdateManyWithoutWardNestedInput
    supervisors?: SupervisorsUpdateManyWithoutWardNestedInput
  }

  export type WardMasterUncheckedUpdateWithoutSurveyorAssignmentsInput = {
    wardId?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    wardName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    zoneWardMaps?: ZoneWardMappingUncheckedUpdateManyWithoutWardNestedInput
    wardMohallaMaps?: WardMohallaMappingUncheckedUpdateManyWithoutWardNestedInput
    wardStatusMaps?: WardStatusMappingUncheckedUpdateManyWithoutWardNestedInput
    surveyDetails?: SurveyDetailsUncheckedUpdateManyWithoutWardNestedInput
    supervisors?: SupervisorsUncheckedUpdateManyWithoutWardNestedInput
  }

  export type MohallaMasterUpsertWithoutSurveyorAssignmentsInput = {
    update: XOR<MohallaMasterUpdateWithoutSurveyorAssignmentsInput, MohallaMasterUncheckedUpdateWithoutSurveyorAssignmentsInput>
    create: XOR<MohallaMasterCreateWithoutSurveyorAssignmentsInput, MohallaMasterUncheckedCreateWithoutSurveyorAssignmentsInput>
    where?: MohallaMasterWhereInput
  }

  export type MohallaMasterUpdateToOneWithWhereWithoutSurveyorAssignmentsInput = {
    where?: MohallaMasterWhereInput
    data: XOR<MohallaMasterUpdateWithoutSurveyorAssignmentsInput, MohallaMasterUncheckedUpdateWithoutSurveyorAssignmentsInput>
  }

  export type MohallaMasterUpdateWithoutSurveyorAssignmentsInput = {
    mohallaId?: StringFieldUpdateOperationsInput | string
    mohallaName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    wardMohallaMaps?: WardMohallaMappingUpdateManyWithoutMohallaNestedInput
    surveyDetails?: SurveyDetailsUpdateManyWithoutMohallaNestedInput
  }

  export type MohallaMasterUncheckedUpdateWithoutSurveyorAssignmentsInput = {
    mohallaId?: StringFieldUpdateOperationsInput | string
    mohallaName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    wardMohallaMaps?: WardMohallaMappingUncheckedUpdateManyWithoutMohallaNestedInput
    surveyDetails?: SurveyDetailsUncheckedUpdateManyWithoutMohallaNestedInput
  }

  export type WardMohallaMappingUpsertWithoutSurveyorAssignmentsInput = {
    update: XOR<WardMohallaMappingUpdateWithoutSurveyorAssignmentsInput, WardMohallaMappingUncheckedUpdateWithoutSurveyorAssignmentsInput>
    create: XOR<WardMohallaMappingCreateWithoutSurveyorAssignmentsInput, WardMohallaMappingUncheckedCreateWithoutSurveyorAssignmentsInput>
    where?: WardMohallaMappingWhereInput
  }

  export type WardMohallaMappingUpdateToOneWithWhereWithoutSurveyorAssignmentsInput = {
    where?: WardMohallaMappingWhereInput
    data: XOR<WardMohallaMappingUpdateWithoutSurveyorAssignmentsInput, WardMohallaMappingUncheckedUpdateWithoutSurveyorAssignmentsInput>
  }

  export type WardMohallaMappingUpdateWithoutSurveyorAssignmentsInput = {
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ward?: WardMasterUpdateOneRequiredWithoutWardMohallaMapsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutWardMohallaMapsNestedInput
    surveyors?: SurveyorsUpdateManyWithoutWardMohallaMapNestedInput
  }

  export type WardMohallaMappingUncheckedUpdateWithoutSurveyorAssignmentsInput = {
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    surveyors?: SurveyorsUncheckedUpdateManyWithoutWardMohallaMapNestedInput
  }

  export type UsersMasterUpsertWithoutSurveyorAssignmentsAssignedByInput = {
    update: XOR<UsersMasterUpdateWithoutSurveyorAssignmentsAssignedByInput, UsersMasterUncheckedUpdateWithoutSurveyorAssignmentsAssignedByInput>
    create: XOR<UsersMasterCreateWithoutSurveyorAssignmentsAssignedByInput, UsersMasterUncheckedCreateWithoutSurveyorAssignmentsAssignedByInput>
    where?: UsersMasterWhereInput
  }

  export type UsersMasterUpdateToOneWithWhereWithoutSurveyorAssignmentsAssignedByInput = {
    where?: UsersMasterWhereInput
    data: XOR<UsersMasterUpdateWithoutSurveyorAssignmentsAssignedByInput, UsersMasterUncheckedUpdateWithoutSurveyorAssignmentsAssignedByInput>
  }

  export type UsersMasterUpdateWithoutSurveyorAssignmentsAssignedByInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutUserNestedInput
    wardStatusMaps?: WardStatusMappingUpdateManyWithoutChangedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUpdateManyWithoutUserNestedInput
    admins?: AdminsUpdateManyWithoutUserNestedInput
  }

  export type UsersMasterUncheckedUpdateWithoutSurveyorAssignmentsAssignedByInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutUserNestedInput
    wardStatusMaps?: WardStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUncheckedUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUncheckedUpdateManyWithoutUserNestedInput
    admins?: AdminsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WardMasterCreateWithoutWardStatusMapsInput = {
    wardId?: string
    wardNumber: string
    isActive?: boolean
    wardName: string
    description?: string | null
    zoneWardMaps?: ZoneWardMappingCreateNestedManyWithoutWardInput
    wardMohallaMaps?: WardMohallaMappingCreateNestedManyWithoutWardInput
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutWardInput
    surveyDetails?: SurveyDetailsCreateNestedManyWithoutWardInput
    supervisors?: SupervisorsCreateNestedManyWithoutWardInput
  }

  export type WardMasterUncheckedCreateWithoutWardStatusMapsInput = {
    wardId?: string
    wardNumber: string
    isActive?: boolean
    wardName: string
    description?: string | null
    zoneWardMaps?: ZoneWardMappingUncheckedCreateNestedManyWithoutWardInput
    wardMohallaMaps?: WardMohallaMappingUncheckedCreateNestedManyWithoutWardInput
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutWardInput
    surveyDetails?: SurveyDetailsUncheckedCreateNestedManyWithoutWardInput
    supervisors?: SupervisorsUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardMasterCreateOrConnectWithoutWardStatusMapsInput = {
    where: WardMasterWhereUniqueInput
    create: XOR<WardMasterCreateWithoutWardStatusMapsInput, WardMasterUncheckedCreateWithoutWardStatusMapsInput>
  }

  export type WardStatusMasterCreateWithoutWardStatusMapsInput = {
    statusId?: string
    statusName: string
    isActive?: boolean
    description?: string | null
  }

  export type WardStatusMasterUncheckedCreateWithoutWardStatusMapsInput = {
    statusId?: string
    statusName: string
    isActive?: boolean
    description?: string | null
  }

  export type WardStatusMasterCreateOrConnectWithoutWardStatusMapsInput = {
    where: WardStatusMasterWhereUniqueInput
    create: XOR<WardStatusMasterCreateWithoutWardStatusMapsInput, WardStatusMasterUncheckedCreateWithoutWardStatusMapsInput>
  }

  export type UsersMasterCreateWithoutWardStatusMapsInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutUserInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentCreateNestedManyWithoutAssignedByInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsCreateNestedManyWithoutUserInput
    admins?: AdminsCreateNestedManyWithoutUserInput
  }

  export type UsersMasterUncheckedCreateWithoutWardStatusMapsInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutUserInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsUncheckedCreateNestedManyWithoutUserInput
    admins?: AdminsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersMasterCreateOrConnectWithoutWardStatusMapsInput = {
    where: UsersMasterWhereUniqueInput
    create: XOR<UsersMasterCreateWithoutWardStatusMapsInput, UsersMasterUncheckedCreateWithoutWardStatusMapsInput>
  }

  export type WardMasterUpsertWithoutWardStatusMapsInput = {
    update: XOR<WardMasterUpdateWithoutWardStatusMapsInput, WardMasterUncheckedUpdateWithoutWardStatusMapsInput>
    create: XOR<WardMasterCreateWithoutWardStatusMapsInput, WardMasterUncheckedCreateWithoutWardStatusMapsInput>
    where?: WardMasterWhereInput
  }

  export type WardMasterUpdateToOneWithWhereWithoutWardStatusMapsInput = {
    where?: WardMasterWhereInput
    data: XOR<WardMasterUpdateWithoutWardStatusMapsInput, WardMasterUncheckedUpdateWithoutWardStatusMapsInput>
  }

  export type WardMasterUpdateWithoutWardStatusMapsInput = {
    wardId?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    wardName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    zoneWardMaps?: ZoneWardMappingUpdateManyWithoutWardNestedInput
    wardMohallaMaps?: WardMohallaMappingUpdateManyWithoutWardNestedInput
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutWardNestedInput
    surveyDetails?: SurveyDetailsUpdateManyWithoutWardNestedInput
    supervisors?: SupervisorsUpdateManyWithoutWardNestedInput
  }

  export type WardMasterUncheckedUpdateWithoutWardStatusMapsInput = {
    wardId?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    wardName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    zoneWardMaps?: ZoneWardMappingUncheckedUpdateManyWithoutWardNestedInput
    wardMohallaMaps?: WardMohallaMappingUncheckedUpdateManyWithoutWardNestedInput
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutWardNestedInput
    surveyDetails?: SurveyDetailsUncheckedUpdateManyWithoutWardNestedInput
    supervisors?: SupervisorsUncheckedUpdateManyWithoutWardNestedInput
  }

  export type WardStatusMasterUpsertWithoutWardStatusMapsInput = {
    update: XOR<WardStatusMasterUpdateWithoutWardStatusMapsInput, WardStatusMasterUncheckedUpdateWithoutWardStatusMapsInput>
    create: XOR<WardStatusMasterCreateWithoutWardStatusMapsInput, WardStatusMasterUncheckedCreateWithoutWardStatusMapsInput>
    where?: WardStatusMasterWhereInput
  }

  export type WardStatusMasterUpdateToOneWithWhereWithoutWardStatusMapsInput = {
    where?: WardStatusMasterWhereInput
    data: XOR<WardStatusMasterUpdateWithoutWardStatusMapsInput, WardStatusMasterUncheckedUpdateWithoutWardStatusMapsInput>
  }

  export type WardStatusMasterUpdateWithoutWardStatusMapsInput = {
    statusId?: StringFieldUpdateOperationsInput | string
    statusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WardStatusMasterUncheckedUpdateWithoutWardStatusMapsInput = {
    statusId?: StringFieldUpdateOperationsInput | string
    statusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersMasterUpsertWithoutWardStatusMapsInput = {
    update: XOR<UsersMasterUpdateWithoutWardStatusMapsInput, UsersMasterUncheckedUpdateWithoutWardStatusMapsInput>
    create: XOR<UsersMasterCreateWithoutWardStatusMapsInput, UsersMasterUncheckedCreateWithoutWardStatusMapsInput>
    where?: UsersMasterWhereInput
  }

  export type UsersMasterUpdateToOneWithWhereWithoutWardStatusMapsInput = {
    where?: UsersMasterWhereInput
    data: XOR<UsersMasterUpdateWithoutWardStatusMapsInput, UsersMasterUncheckedUpdateWithoutWardStatusMapsInput>
  }

  export type UsersMasterUpdateWithoutWardStatusMapsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutUserNestedInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUpdateManyWithoutAssignedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUpdateManyWithoutUserNestedInput
    admins?: AdminsUpdateManyWithoutUserNestedInput
  }

  export type UsersMasterUncheckedUpdateWithoutWardStatusMapsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutUserNestedInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUncheckedUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUncheckedUpdateManyWithoutUserNestedInput
    admins?: AdminsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SurveyDetailsCreateWithoutSurveyStatusMapsInput = {
    surveyUniqueCode?: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    ulb: UlbMasterCreateNestedOneWithoutSurveyDetailsInput
    zone: ZoneMasterCreateNestedOneWithoutSurveyDetailsInput
    ward: WardMasterCreateNestedOneWithoutSurveyDetailsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyDetailsInput
    surveyType: SurveyTypeMasterCreateNestedOneWithoutSurveyDetailsInput
    propertyDetails?: PropertyDetailsCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsUncheckedCreateWithoutSurveyStatusMapsInput = {
    surveyUniqueCode?: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    propertyDetails?: PropertyDetailsUncheckedCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsUncheckedCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsUncheckedCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsUncheckedCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsCreateOrConnectWithoutSurveyStatusMapsInput = {
    where: SurveyDetailsWhereUniqueInput
    create: XOR<SurveyDetailsCreateWithoutSurveyStatusMapsInput, SurveyDetailsUncheckedCreateWithoutSurveyStatusMapsInput>
  }

  export type SurveyStatusMasterCreateWithoutSurveyStatusMapsInput = {
    statusId?: string
    statusName: string
    isActive?: boolean
    description?: string | null
    surveyStatusMapsReverted?: SurveyStatusMappingCreateNestedManyWithoutRevertedFromInput
  }

  export type SurveyStatusMasterUncheckedCreateWithoutSurveyStatusMapsInput = {
    statusId?: string
    statusName: string
    isActive?: boolean
    description?: string | null
    surveyStatusMapsReverted?: SurveyStatusMappingUncheckedCreateNestedManyWithoutRevertedFromInput
  }

  export type SurveyStatusMasterCreateOrConnectWithoutSurveyStatusMapsInput = {
    where: SurveyStatusMasterWhereUniqueInput
    create: XOR<SurveyStatusMasterCreateWithoutSurveyStatusMapsInput, SurveyStatusMasterUncheckedCreateWithoutSurveyStatusMapsInput>
  }

  export type SurveyStatusMasterCreateWithoutSurveyStatusMapsRevertedInput = {
    statusId?: string
    statusName: string
    isActive?: boolean
    description?: string | null
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutStatusInput
  }

  export type SurveyStatusMasterUncheckedCreateWithoutSurveyStatusMapsRevertedInput = {
    statusId?: string
    statusName: string
    isActive?: boolean
    description?: string | null
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutStatusInput
  }

  export type SurveyStatusMasterCreateOrConnectWithoutSurveyStatusMapsRevertedInput = {
    where: SurveyStatusMasterWhereUniqueInput
    create: XOR<SurveyStatusMasterCreateWithoutSurveyStatusMapsRevertedInput, SurveyStatusMasterUncheckedCreateWithoutSurveyStatusMapsRevertedInput>
  }

  export type UsersMasterCreateWithoutSurveyStatusMapsInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutUserInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentCreateNestedManyWithoutAssignedByInput
    wardStatusMaps?: WardStatusMappingCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsCreateNestedManyWithoutUserInput
    admins?: AdminsCreateNestedManyWithoutUserInput
  }

  export type UsersMasterUncheckedCreateWithoutSurveyStatusMapsInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutUserInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    wardStatusMaps?: WardStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsUncheckedCreateNestedManyWithoutUserInput
    admins?: AdminsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersMasterCreateOrConnectWithoutSurveyStatusMapsInput = {
    where: UsersMasterWhereUniqueInput
    create: XOR<UsersMasterCreateWithoutSurveyStatusMapsInput, UsersMasterUncheckedCreateWithoutSurveyStatusMapsInput>
  }

  export type SurveyDetailsUpsertWithoutSurveyStatusMapsInput = {
    update: XOR<SurveyDetailsUpdateWithoutSurveyStatusMapsInput, SurveyDetailsUncheckedUpdateWithoutSurveyStatusMapsInput>
    create: XOR<SurveyDetailsCreateWithoutSurveyStatusMapsInput, SurveyDetailsUncheckedCreateWithoutSurveyStatusMapsInput>
    where?: SurveyDetailsWhereInput
  }

  export type SurveyDetailsUpdateToOneWithWhereWithoutSurveyStatusMapsInput = {
    where?: SurveyDetailsWhereInput
    data: XOR<SurveyDetailsUpdateWithoutSurveyStatusMapsInput, SurveyDetailsUncheckedUpdateWithoutSurveyStatusMapsInput>
  }

  export type SurveyDetailsUpdateWithoutSurveyStatusMapsInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    ulb?: UlbMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    zone?: ZoneMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    surveyType?: SurveyTypeMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    propertyDetails?: PropertyDetailsUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateWithoutSurveyStatusMapsInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDetails?: PropertyDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyStatusMasterUpsertWithoutSurveyStatusMapsInput = {
    update: XOR<SurveyStatusMasterUpdateWithoutSurveyStatusMapsInput, SurveyStatusMasterUncheckedUpdateWithoutSurveyStatusMapsInput>
    create: XOR<SurveyStatusMasterCreateWithoutSurveyStatusMapsInput, SurveyStatusMasterUncheckedCreateWithoutSurveyStatusMapsInput>
    where?: SurveyStatusMasterWhereInput
  }

  export type SurveyStatusMasterUpdateToOneWithWhereWithoutSurveyStatusMapsInput = {
    where?: SurveyStatusMasterWhereInput
    data: XOR<SurveyStatusMasterUpdateWithoutSurveyStatusMapsInput, SurveyStatusMasterUncheckedUpdateWithoutSurveyStatusMapsInput>
  }

  export type SurveyStatusMasterUpdateWithoutSurveyStatusMapsInput = {
    statusId?: StringFieldUpdateOperationsInput | string
    statusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyStatusMapsReverted?: SurveyStatusMappingUpdateManyWithoutRevertedFromNestedInput
  }

  export type SurveyStatusMasterUncheckedUpdateWithoutSurveyStatusMapsInput = {
    statusId?: StringFieldUpdateOperationsInput | string
    statusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyStatusMapsReverted?: SurveyStatusMappingUncheckedUpdateManyWithoutRevertedFromNestedInput
  }

  export type SurveyStatusMasterUpsertWithoutSurveyStatusMapsRevertedInput = {
    update: XOR<SurveyStatusMasterUpdateWithoutSurveyStatusMapsRevertedInput, SurveyStatusMasterUncheckedUpdateWithoutSurveyStatusMapsRevertedInput>
    create: XOR<SurveyStatusMasterCreateWithoutSurveyStatusMapsRevertedInput, SurveyStatusMasterUncheckedCreateWithoutSurveyStatusMapsRevertedInput>
    where?: SurveyStatusMasterWhereInput
  }

  export type SurveyStatusMasterUpdateToOneWithWhereWithoutSurveyStatusMapsRevertedInput = {
    where?: SurveyStatusMasterWhereInput
    data: XOR<SurveyStatusMasterUpdateWithoutSurveyStatusMapsRevertedInput, SurveyStatusMasterUncheckedUpdateWithoutSurveyStatusMapsRevertedInput>
  }

  export type SurveyStatusMasterUpdateWithoutSurveyStatusMapsRevertedInput = {
    statusId?: StringFieldUpdateOperationsInput | string
    statusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutStatusNestedInput
  }

  export type SurveyStatusMasterUncheckedUpdateWithoutSurveyStatusMapsRevertedInput = {
    statusId?: StringFieldUpdateOperationsInput | string
    statusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type UsersMasterUpsertWithoutSurveyStatusMapsInput = {
    update: XOR<UsersMasterUpdateWithoutSurveyStatusMapsInput, UsersMasterUncheckedUpdateWithoutSurveyStatusMapsInput>
    create: XOR<UsersMasterCreateWithoutSurveyStatusMapsInput, UsersMasterUncheckedCreateWithoutSurveyStatusMapsInput>
    where?: UsersMasterWhereInput
  }

  export type UsersMasterUpdateToOneWithWhereWithoutSurveyStatusMapsInput = {
    where?: UsersMasterWhereInput
    data: XOR<UsersMasterUpdateWithoutSurveyStatusMapsInput, UsersMasterUncheckedUpdateWithoutSurveyStatusMapsInput>
  }

  export type UsersMasterUpdateWithoutSurveyStatusMapsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutUserNestedInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUpdateManyWithoutAssignedByNestedInput
    wardStatusMaps?: WardStatusMappingUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUpdateManyWithoutUserNestedInput
    admins?: AdminsUpdateManyWithoutUserNestedInput
  }

  export type UsersMasterUncheckedUpdateWithoutSurveyStatusMapsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutUserNestedInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    wardStatusMaps?: WardStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUncheckedUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUncheckedUpdateManyWithoutUserNestedInput
    admins?: AdminsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersMasterCreateWithoutUserRoleMapsInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutUserInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentCreateNestedManyWithoutAssignedByInput
    wardStatusMaps?: WardStatusMappingCreateNestedManyWithoutChangedByInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutChangedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsCreateNestedManyWithoutUserInput
    admins?: AdminsCreateNestedManyWithoutUserInput
  }

  export type UsersMasterUncheckedCreateWithoutUserRoleMapsInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutUserInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    wardStatusMaps?: WardStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsUncheckedCreateNestedManyWithoutUserInput
    admins?: AdminsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersMasterCreateOrConnectWithoutUserRoleMapsInput = {
    where: UsersMasterWhereUniqueInput
    create: XOR<UsersMasterCreateWithoutUserRoleMapsInput, UsersMasterUncheckedCreateWithoutUserRoleMapsInput>
  }

  export type RolePermissionMasterCreateWithoutUserRoleMapsInput = {
    roleId?: string
    roleName: string
    isActive?: boolean
    description?: string | null
  }

  export type RolePermissionMasterUncheckedCreateWithoutUserRoleMapsInput = {
    roleId?: string
    roleName: string
    isActive?: boolean
    description?: string | null
  }

  export type RolePermissionMasterCreateOrConnectWithoutUserRoleMapsInput = {
    where: RolePermissionMasterWhereUniqueInput
    create: XOR<RolePermissionMasterCreateWithoutUserRoleMapsInput, RolePermissionMasterUncheckedCreateWithoutUserRoleMapsInput>
  }

  export type UsersMasterUpsertWithoutUserRoleMapsInput = {
    update: XOR<UsersMasterUpdateWithoutUserRoleMapsInput, UsersMasterUncheckedUpdateWithoutUserRoleMapsInput>
    create: XOR<UsersMasterCreateWithoutUserRoleMapsInput, UsersMasterUncheckedCreateWithoutUserRoleMapsInput>
    where?: UsersMasterWhereInput
  }

  export type UsersMasterUpdateToOneWithWhereWithoutUserRoleMapsInput = {
    where?: UsersMasterWhereInput
    data: XOR<UsersMasterUpdateWithoutUserRoleMapsInput, UsersMasterUncheckedUpdateWithoutUserRoleMapsInput>
  }

  export type UsersMasterUpdateWithoutUserRoleMapsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutUserNestedInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUpdateManyWithoutAssignedByNestedInput
    wardStatusMaps?: WardStatusMappingUpdateManyWithoutChangedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutChangedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUpdateManyWithoutUserNestedInput
    admins?: AdminsUpdateManyWithoutUserNestedInput
  }

  export type UsersMasterUncheckedUpdateWithoutUserRoleMapsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutUserNestedInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    wardStatusMaps?: WardStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUncheckedUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUncheckedUpdateManyWithoutUserNestedInput
    admins?: AdminsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RolePermissionMasterUpsertWithoutUserRoleMapsInput = {
    update: XOR<RolePermissionMasterUpdateWithoutUserRoleMapsInput, RolePermissionMasterUncheckedUpdateWithoutUserRoleMapsInput>
    create: XOR<RolePermissionMasterCreateWithoutUserRoleMapsInput, RolePermissionMasterUncheckedCreateWithoutUserRoleMapsInput>
    where?: RolePermissionMasterWhereInput
  }

  export type RolePermissionMasterUpdateToOneWithWhereWithoutUserRoleMapsInput = {
    where?: RolePermissionMasterWhereInput
    data: XOR<RolePermissionMasterUpdateWithoutUserRoleMapsInput, RolePermissionMasterUncheckedUpdateWithoutUserRoleMapsInput>
  }

  export type RolePermissionMasterUpdateWithoutUserRoleMapsInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionMasterUncheckedUpdateWithoutUserRoleMapsInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersMasterCreateWithoutSessionsInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutUserInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentCreateNestedManyWithoutAssignedByInput
    wardStatusMaps?: WardStatusMappingCreateNestedManyWithoutChangedByInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsCreateNestedManyWithoutUserInput
    admins?: AdminsCreateNestedManyWithoutUserInput
  }

  export type UsersMasterUncheckedCreateWithoutSessionsInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutUserInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    wardStatusMaps?: WardStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingUncheckedCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsUncheckedCreateNestedManyWithoutUserInput
    admins?: AdminsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersMasterCreateOrConnectWithoutSessionsInput = {
    where: UsersMasterWhereUniqueInput
    create: XOR<UsersMasterCreateWithoutSessionsInput, UsersMasterUncheckedCreateWithoutSessionsInput>
  }

  export type UsersMasterUpsertWithoutSessionsInput = {
    update: XOR<UsersMasterUpdateWithoutSessionsInput, UsersMasterUncheckedUpdateWithoutSessionsInput>
    create: XOR<UsersMasterCreateWithoutSessionsInput, UsersMasterUncheckedCreateWithoutSessionsInput>
    where?: UsersMasterWhereInput
  }

  export type UsersMasterUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UsersMasterWhereInput
    data: XOR<UsersMasterUpdateWithoutSessionsInput, UsersMasterUncheckedUpdateWithoutSessionsInput>
  }

  export type UsersMasterUpdateWithoutSessionsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutUserNestedInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUpdateManyWithoutAssignedByNestedInput
    wardStatusMaps?: WardStatusMappingUpdateManyWithoutChangedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUpdateManyWithoutUserNestedInput
    admins?: AdminsUpdateManyWithoutUserNestedInput
  }

  export type UsersMasterUncheckedUpdateWithoutSessionsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutUserNestedInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    wardStatusMaps?: WardStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUncheckedUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUncheckedUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUncheckedUpdateManyWithoutUserNestedInput
    admins?: AdminsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersMasterCreateWithoutSurveyorsInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutUserInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentCreateNestedManyWithoutAssignedByInput
    wardStatusMaps?: WardStatusMappingCreateNestedManyWithoutChangedByInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsCreateNestedManyWithoutUserInput
    admins?: AdminsCreateNestedManyWithoutUserInput
  }

  export type UsersMasterUncheckedCreateWithoutSurveyorsInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutUserInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    wardStatusMaps?: WardStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsUncheckedCreateNestedManyWithoutUserInput
    admins?: AdminsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersMasterCreateOrConnectWithoutSurveyorsInput = {
    where: UsersMasterWhereUniqueInput
    create: XOR<UsersMasterCreateWithoutSurveyorsInput, UsersMasterUncheckedCreateWithoutSurveyorsInput>
  }

  export type WardMohallaMappingCreateWithoutSurveyorsInput = {
    wardMohallaMapId?: string
    isActive?: boolean
    ward: WardMasterCreateNestedOneWithoutWardMohallaMapsInput
    mohalla: MohallaMasterCreateNestedOneWithoutWardMohallaMapsInput
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutWardMohallaMapInput
  }

  export type WardMohallaMappingUncheckedCreateWithoutSurveyorsInput = {
    wardMohallaMapId?: string
    wardId: string
    mohallaId: string
    isActive?: boolean
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutWardMohallaMapInput
  }

  export type WardMohallaMappingCreateOrConnectWithoutSurveyorsInput = {
    where: WardMohallaMappingWhereUniqueInput
    create: XOR<WardMohallaMappingCreateWithoutSurveyorsInput, WardMohallaMappingUncheckedCreateWithoutSurveyorsInput>
  }

  export type ZoneWardMappingCreateWithoutSurveyorsInput = {
    zoneWardMapId?: string
    isActive?: boolean
    zone: ZoneMasterCreateNestedOneWithoutZoneWardMapsInput
    ward: WardMasterCreateNestedOneWithoutZoneWardMapsInput
  }

  export type ZoneWardMappingUncheckedCreateWithoutSurveyorsInput = {
    zoneWardMapId?: string
    zoneId: string
    wardId: string
    isActive?: boolean
  }

  export type ZoneWardMappingCreateOrConnectWithoutSurveyorsInput = {
    where: ZoneWardMappingWhereUniqueInput
    create: XOR<ZoneWardMappingCreateWithoutSurveyorsInput, ZoneWardMappingUncheckedCreateWithoutSurveyorsInput>
  }

  export type UlbZoneMappingCreateWithoutSurveyorsInput = {
    ulbZoneMapId?: string
    isActive?: boolean
    ulb: UlbMasterCreateNestedOneWithoutUlbZoneMapsInput
    zone: ZoneMasterCreateNestedOneWithoutUlbZoneMapsInput
  }

  export type UlbZoneMappingUncheckedCreateWithoutSurveyorsInput = {
    ulbZoneMapId?: string
    ulbId: string
    zoneId: string
    isActive?: boolean
  }

  export type UlbZoneMappingCreateOrConnectWithoutSurveyorsInput = {
    where: UlbZoneMappingWhereUniqueInput
    create: XOR<UlbZoneMappingCreateWithoutSurveyorsInput, UlbZoneMappingUncheckedCreateWithoutSurveyorsInput>
  }

  export type UsersMasterUpsertWithoutSurveyorsInput = {
    update: XOR<UsersMasterUpdateWithoutSurveyorsInput, UsersMasterUncheckedUpdateWithoutSurveyorsInput>
    create: XOR<UsersMasterCreateWithoutSurveyorsInput, UsersMasterUncheckedCreateWithoutSurveyorsInput>
    where?: UsersMasterWhereInput
  }

  export type UsersMasterUpdateToOneWithWhereWithoutSurveyorsInput = {
    where?: UsersMasterWhereInput
    data: XOR<UsersMasterUpdateWithoutSurveyorsInput, UsersMasterUncheckedUpdateWithoutSurveyorsInput>
  }

  export type UsersMasterUpdateWithoutSurveyorsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutUserNestedInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUpdateManyWithoutAssignedByNestedInput
    wardStatusMaps?: WardStatusMappingUpdateManyWithoutChangedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUpdateManyWithoutUserNestedInput
    admins?: AdminsUpdateManyWithoutUserNestedInput
  }

  export type UsersMasterUncheckedUpdateWithoutSurveyorsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutUserNestedInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    wardStatusMaps?: WardStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUncheckedUpdateManyWithoutUserNestedInput
    admins?: AdminsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WardMohallaMappingUpsertWithoutSurveyorsInput = {
    update: XOR<WardMohallaMappingUpdateWithoutSurveyorsInput, WardMohallaMappingUncheckedUpdateWithoutSurveyorsInput>
    create: XOR<WardMohallaMappingCreateWithoutSurveyorsInput, WardMohallaMappingUncheckedCreateWithoutSurveyorsInput>
    where?: WardMohallaMappingWhereInput
  }

  export type WardMohallaMappingUpdateToOneWithWhereWithoutSurveyorsInput = {
    where?: WardMohallaMappingWhereInput
    data: XOR<WardMohallaMappingUpdateWithoutSurveyorsInput, WardMohallaMappingUncheckedUpdateWithoutSurveyorsInput>
  }

  export type WardMohallaMappingUpdateWithoutSurveyorsInput = {
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ward?: WardMasterUpdateOneRequiredWithoutWardMohallaMapsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutWardMohallaMapsNestedInput
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutWardMohallaMapNestedInput
  }

  export type WardMohallaMappingUncheckedUpdateWithoutSurveyorsInput = {
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutWardMohallaMapNestedInput
  }

  export type ZoneWardMappingUpsertWithoutSurveyorsInput = {
    update: XOR<ZoneWardMappingUpdateWithoutSurveyorsInput, ZoneWardMappingUncheckedUpdateWithoutSurveyorsInput>
    create: XOR<ZoneWardMappingCreateWithoutSurveyorsInput, ZoneWardMappingUncheckedCreateWithoutSurveyorsInput>
    where?: ZoneWardMappingWhereInput
  }

  export type ZoneWardMappingUpdateToOneWithWhereWithoutSurveyorsInput = {
    where?: ZoneWardMappingWhereInput
    data: XOR<ZoneWardMappingUpdateWithoutSurveyorsInput, ZoneWardMappingUncheckedUpdateWithoutSurveyorsInput>
  }

  export type ZoneWardMappingUpdateWithoutSurveyorsInput = {
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    zone?: ZoneMasterUpdateOneRequiredWithoutZoneWardMapsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutZoneWardMapsNestedInput
  }

  export type ZoneWardMappingUncheckedUpdateWithoutSurveyorsInput = {
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UlbZoneMappingUpsertWithoutSurveyorsInput = {
    update: XOR<UlbZoneMappingUpdateWithoutSurveyorsInput, UlbZoneMappingUncheckedUpdateWithoutSurveyorsInput>
    create: XOR<UlbZoneMappingCreateWithoutSurveyorsInput, UlbZoneMappingUncheckedCreateWithoutSurveyorsInput>
    where?: UlbZoneMappingWhereInput
  }

  export type UlbZoneMappingUpdateToOneWithWhereWithoutSurveyorsInput = {
    where?: UlbZoneMappingWhereInput
    data: XOR<UlbZoneMappingUpdateWithoutSurveyorsInput, UlbZoneMappingUncheckedUpdateWithoutSurveyorsInput>
  }

  export type UlbZoneMappingUpdateWithoutSurveyorsInput = {
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ulb?: UlbMasterUpdateOneRequiredWithoutUlbZoneMapsNestedInput
    zone?: ZoneMasterUpdateOneRequiredWithoutUlbZoneMapsNestedInput
  }

  export type UlbZoneMappingUncheckedUpdateWithoutSurveyorsInput = {
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsersMasterCreateWithoutSupervisorsInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutUserInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentCreateNestedManyWithoutAssignedByInput
    wardStatusMaps?: WardStatusMappingCreateNestedManyWithoutChangedByInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsCreateNestedManyWithoutUserInput
    admins?: AdminsCreateNestedManyWithoutUserInput
  }

  export type UsersMasterUncheckedCreateWithoutSupervisorsInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutUserInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    wardStatusMaps?: WardStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutUserInput
    admins?: AdminsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersMasterCreateOrConnectWithoutSupervisorsInput = {
    where: UsersMasterWhereUniqueInput
    create: XOR<UsersMasterCreateWithoutSupervisorsInput, UsersMasterUncheckedCreateWithoutSupervisorsInput>
  }

  export type WardMasterCreateWithoutSupervisorsInput = {
    wardId?: string
    wardNumber: string
    isActive?: boolean
    wardName: string
    description?: string | null
    zoneWardMaps?: ZoneWardMappingCreateNestedManyWithoutWardInput
    wardMohallaMaps?: WardMohallaMappingCreateNestedManyWithoutWardInput
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutWardInput
    wardStatusMaps?: WardStatusMappingCreateNestedManyWithoutWardInput
    surveyDetails?: SurveyDetailsCreateNestedManyWithoutWardInput
  }

  export type WardMasterUncheckedCreateWithoutSupervisorsInput = {
    wardId?: string
    wardNumber: string
    isActive?: boolean
    wardName: string
    description?: string | null
    zoneWardMaps?: ZoneWardMappingUncheckedCreateNestedManyWithoutWardInput
    wardMohallaMaps?: WardMohallaMappingUncheckedCreateNestedManyWithoutWardInput
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutWardInput
    wardStatusMaps?: WardStatusMappingUncheckedCreateNestedManyWithoutWardInput
    surveyDetails?: SurveyDetailsUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardMasterCreateOrConnectWithoutSupervisorsInput = {
    where: WardMasterWhereUniqueInput
    create: XOR<WardMasterCreateWithoutSupervisorsInput, WardMasterUncheckedCreateWithoutSupervisorsInput>
  }

  export type UsersMasterUpsertWithoutSupervisorsInput = {
    update: XOR<UsersMasterUpdateWithoutSupervisorsInput, UsersMasterUncheckedUpdateWithoutSupervisorsInput>
    create: XOR<UsersMasterCreateWithoutSupervisorsInput, UsersMasterUncheckedCreateWithoutSupervisorsInput>
    where?: UsersMasterWhereInput
  }

  export type UsersMasterUpdateToOneWithWhereWithoutSupervisorsInput = {
    where?: UsersMasterWhereInput
    data: XOR<UsersMasterUpdateWithoutSupervisorsInput, UsersMasterUncheckedUpdateWithoutSupervisorsInput>
  }

  export type UsersMasterUpdateWithoutSupervisorsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutUserNestedInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUpdateManyWithoutAssignedByNestedInput
    wardStatusMaps?: WardStatusMappingUpdateManyWithoutChangedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUpdateManyWithoutUserNestedInput
    admins?: AdminsUpdateManyWithoutUserNestedInput
  }

  export type UsersMasterUncheckedUpdateWithoutSupervisorsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutUserNestedInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    wardStatusMaps?: WardStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUncheckedUpdateManyWithoutUserNestedInput
    admins?: AdminsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WardMasterUpsertWithoutSupervisorsInput = {
    update: XOR<WardMasterUpdateWithoutSupervisorsInput, WardMasterUncheckedUpdateWithoutSupervisorsInput>
    create: XOR<WardMasterCreateWithoutSupervisorsInput, WardMasterUncheckedCreateWithoutSupervisorsInput>
    where?: WardMasterWhereInput
  }

  export type WardMasterUpdateToOneWithWhereWithoutSupervisorsInput = {
    where?: WardMasterWhereInput
    data: XOR<WardMasterUpdateWithoutSupervisorsInput, WardMasterUncheckedUpdateWithoutSupervisorsInput>
  }

  export type WardMasterUpdateWithoutSupervisorsInput = {
    wardId?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    wardName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    zoneWardMaps?: ZoneWardMappingUpdateManyWithoutWardNestedInput
    wardMohallaMaps?: WardMohallaMappingUpdateManyWithoutWardNestedInput
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutWardNestedInput
    wardStatusMaps?: WardStatusMappingUpdateManyWithoutWardNestedInput
    surveyDetails?: SurveyDetailsUpdateManyWithoutWardNestedInput
  }

  export type WardMasterUncheckedUpdateWithoutSupervisorsInput = {
    wardId?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    wardName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    zoneWardMaps?: ZoneWardMappingUncheckedUpdateManyWithoutWardNestedInput
    wardMohallaMaps?: WardMohallaMappingUncheckedUpdateManyWithoutWardNestedInput
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutWardNestedInput
    wardStatusMaps?: WardStatusMappingUncheckedUpdateManyWithoutWardNestedInput
    surveyDetails?: SurveyDetailsUncheckedUpdateManyWithoutWardNestedInput
  }

  export type UsersMasterCreateWithoutAdminsInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutUserInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentCreateNestedManyWithoutAssignedByInput
    wardStatusMaps?: WardStatusMappingCreateNestedManyWithoutChangedByInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsCreateNestedManyWithoutUserInput
  }

  export type UsersMasterUncheckedCreateWithoutAdminsInput = {
    userId?: string
    username: string
    password: string
    mobileNumber?: string | null
    isCreatedAt?: Date | string
    isActive?: boolean
    description?: string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutUserInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    wardStatusMaps?: WardStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutChangedByInput
    userRoleMaps?: UserRoleMappingUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    surveyors?: SurveyorsUncheckedCreateNestedManyWithoutUserInput
    supervisors?: SupervisorsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersMasterCreateOrConnectWithoutAdminsInput = {
    where: UsersMasterWhereUniqueInput
    create: XOR<UsersMasterCreateWithoutAdminsInput, UsersMasterUncheckedCreateWithoutAdminsInput>
  }

  export type UsersMasterUpsertWithoutAdminsInput = {
    update: XOR<UsersMasterUpdateWithoutAdminsInput, UsersMasterUncheckedUpdateWithoutAdminsInput>
    create: XOR<UsersMasterCreateWithoutAdminsInput, UsersMasterUncheckedCreateWithoutAdminsInput>
    where?: UsersMasterWhereInput
  }

  export type UsersMasterUpdateToOneWithWhereWithoutAdminsInput = {
    where?: UsersMasterWhereInput
    data: XOR<UsersMasterUpdateWithoutAdminsInput, UsersMasterUncheckedUpdateWithoutAdminsInput>
  }

  export type UsersMasterUpdateWithoutAdminsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutUserNestedInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUpdateManyWithoutAssignedByNestedInput
    wardStatusMaps?: WardStatusMappingUpdateManyWithoutChangedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUpdateManyWithoutUserNestedInput
  }

  export type UsersMasterUncheckedUpdateWithoutAdminsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutUserNestedInput
    surveyorAssignmentsAssignedBy?: SurveyorAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    wardStatusMaps?: WardStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutChangedByNestedInput
    userRoleMaps?: UserRoleMappingUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    surveyors?: SurveyorsUncheckedUpdateManyWithoutUserNestedInput
    supervisors?: SupervisorsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UlbMasterCreateWithoutSurveyDetailsInput = {
    ulbId?: string
    ulbName: string
    isActive?: boolean
    description?: string | null
    ulbZoneMaps?: UlbZoneMappingCreateNestedManyWithoutUlbInput
  }

  export type UlbMasterUncheckedCreateWithoutSurveyDetailsInput = {
    ulbId?: string
    ulbName: string
    isActive?: boolean
    description?: string | null
    ulbZoneMaps?: UlbZoneMappingUncheckedCreateNestedManyWithoutUlbInput
  }

  export type UlbMasterCreateOrConnectWithoutSurveyDetailsInput = {
    where: UlbMasterWhereUniqueInput
    create: XOR<UlbMasterCreateWithoutSurveyDetailsInput, UlbMasterUncheckedCreateWithoutSurveyDetailsInput>
  }

  export type ZoneMasterCreateWithoutSurveyDetailsInput = {
    zoneId?: string
    zoneNumber: string
    isActive?: boolean
    description?: string | null
    ulbZoneMaps?: UlbZoneMappingCreateNestedManyWithoutZoneInput
    zoneWardMaps?: ZoneWardMappingCreateNestedManyWithoutZoneInput
  }

  export type ZoneMasterUncheckedCreateWithoutSurveyDetailsInput = {
    zoneId?: string
    zoneNumber: string
    isActive?: boolean
    description?: string | null
    ulbZoneMaps?: UlbZoneMappingUncheckedCreateNestedManyWithoutZoneInput
    zoneWardMaps?: ZoneWardMappingUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneMasterCreateOrConnectWithoutSurveyDetailsInput = {
    where: ZoneMasterWhereUniqueInput
    create: XOR<ZoneMasterCreateWithoutSurveyDetailsInput, ZoneMasterUncheckedCreateWithoutSurveyDetailsInput>
  }

  export type WardMasterCreateWithoutSurveyDetailsInput = {
    wardId?: string
    wardNumber: string
    isActive?: boolean
    wardName: string
    description?: string | null
    zoneWardMaps?: ZoneWardMappingCreateNestedManyWithoutWardInput
    wardMohallaMaps?: WardMohallaMappingCreateNestedManyWithoutWardInput
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutWardInput
    wardStatusMaps?: WardStatusMappingCreateNestedManyWithoutWardInput
    supervisors?: SupervisorsCreateNestedManyWithoutWardInput
  }

  export type WardMasterUncheckedCreateWithoutSurveyDetailsInput = {
    wardId?: string
    wardNumber: string
    isActive?: boolean
    wardName: string
    description?: string | null
    zoneWardMaps?: ZoneWardMappingUncheckedCreateNestedManyWithoutWardInput
    wardMohallaMaps?: WardMohallaMappingUncheckedCreateNestedManyWithoutWardInput
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutWardInput
    wardStatusMaps?: WardStatusMappingUncheckedCreateNestedManyWithoutWardInput
    supervisors?: SupervisorsUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardMasterCreateOrConnectWithoutSurveyDetailsInput = {
    where: WardMasterWhereUniqueInput
    create: XOR<WardMasterCreateWithoutSurveyDetailsInput, WardMasterUncheckedCreateWithoutSurveyDetailsInput>
  }

  export type MohallaMasterCreateWithoutSurveyDetailsInput = {
    mohallaId?: string
    mohallaName: string
    isActive?: boolean
    description?: string | null
    wardMohallaMaps?: WardMohallaMappingCreateNestedManyWithoutMohallaInput
    surveyorAssignments?: SurveyorAssignmentCreateNestedManyWithoutMohallaInput
  }

  export type MohallaMasterUncheckedCreateWithoutSurveyDetailsInput = {
    mohallaId?: string
    mohallaName: string
    isActive?: boolean
    description?: string | null
    wardMohallaMaps?: WardMohallaMappingUncheckedCreateNestedManyWithoutMohallaInput
    surveyorAssignments?: SurveyorAssignmentUncheckedCreateNestedManyWithoutMohallaInput
  }

  export type MohallaMasterCreateOrConnectWithoutSurveyDetailsInput = {
    where: MohallaMasterWhereUniqueInput
    create: XOR<MohallaMasterCreateWithoutSurveyDetailsInput, MohallaMasterUncheckedCreateWithoutSurveyDetailsInput>
  }

  export type SurveyTypeMasterCreateWithoutSurveyDetailsInput = {
    surveyTypeId?: string
    surveyTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type SurveyTypeMasterUncheckedCreateWithoutSurveyDetailsInput = {
    surveyTypeId?: string
    surveyTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type SurveyTypeMasterCreateOrConnectWithoutSurveyDetailsInput = {
    where: SurveyTypeMasterWhereUniqueInput
    create: XOR<SurveyTypeMasterCreateWithoutSurveyDetailsInput, SurveyTypeMasterUncheckedCreateWithoutSurveyDetailsInput>
  }

  export type PropertyDetailsCreateWithoutSurveyInput = {
    oldHouseNumber?: string | null
    electricityConsumerName?: string | null
    waterSewerageConnectionNumber?: string | null
    respondentName: string
    responseType: ResponseTypeMasterCreateNestedOneWithoutPropertyDetailsInput
    respondentStatus: RespondentStatusMasterCreateNestedOneWithoutPropertyDetailsInput
  }

  export type PropertyDetailsUncheckedCreateWithoutSurveyInput = {
    responseTypeId: string
    oldHouseNumber?: string | null
    electricityConsumerName?: string | null
    waterSewerageConnectionNumber?: string | null
    respondentName: string
    respondentStatusId: string
  }

  export type PropertyDetailsCreateOrConnectWithoutSurveyInput = {
    where: PropertyDetailsWhereUniqueInput
    create: XOR<PropertyDetailsCreateWithoutSurveyInput, PropertyDetailsUncheckedCreateWithoutSurveyInput>
  }

  export type PropertyDetailsCreateManySurveyInputEnvelope = {
    data: PropertyDetailsCreateManySurveyInput | PropertyDetailsCreateManySurveyInput[]
    skipDuplicates?: boolean
  }

  export type OwnerDetailsCreateWithoutSurveyInput = {
    ownerName: string
    fatherHusbandName: string
    mobileNumber?: string | null
    aadharNumber?: string | null
  }

  export type OwnerDetailsUncheckedCreateWithoutSurveyInput = {
    ownerName: string
    fatherHusbandName: string
    mobileNumber?: string | null
    aadharNumber?: string | null
  }

  export type OwnerDetailsCreateOrConnectWithoutSurveyInput = {
    where: OwnerDetailsWhereUniqueInput
    create: XOR<OwnerDetailsCreateWithoutSurveyInput, OwnerDetailsUncheckedCreateWithoutSurveyInput>
  }

  export type OwnerDetailsCreateManySurveyInputEnvelope = {
    data: OwnerDetailsCreateManySurveyInput | OwnerDetailsCreateManySurveyInput[]
    skipDuplicates?: boolean
  }

  export type LocationDetailsCreateWithoutSurveyInput = {
    propertyLatitude: Decimal | DecimalJsLike | number | string
    propertyLongitude: Decimal | DecimalJsLike | number | string
    assessmentYear: string
    buildingName?: string | null
    constructionYear: string
    addressRoadName: string
    locality?: string | null
    pinCode: number
    landmark?: string | null
    fourWayEast?: string | null
    fourWayWest?: string | null
    fourWayNorth?: string | null
    fourWaySouth?: string | null
    newWard: string
    propertyType: PropertyTypeMasterCreateNestedOneWithoutLocationDetailsInput
    roadType: RoadTypeMasterCreateNestedOneWithoutLocationDetailsInput
    constructionType: ConstructionTypeMasterCreateNestedOneWithoutLocationDetailsInput
  }

  export type LocationDetailsUncheckedCreateWithoutSurveyInput = {
    propertyLatitude: Decimal | DecimalJsLike | number | string
    propertyLongitude: Decimal | DecimalJsLike | number | string
    assessmentYear: string
    propertyTypeId: string
    buildingName?: string | null
    roadTypeId: string
    constructionYear: string
    constructionTypeId: string
    addressRoadName: string
    locality?: string | null
    pinCode: number
    landmark?: string | null
    fourWayEast?: string | null
    fourWayWest?: string | null
    fourWayNorth?: string | null
    fourWaySouth?: string | null
    newWard: string
  }

  export type LocationDetailsCreateOrConnectWithoutSurveyInput = {
    where: LocationDetailsWhereUniqueInput
    create: XOR<LocationDetailsCreateWithoutSurveyInput, LocationDetailsUncheckedCreateWithoutSurveyInput>
  }

  export type LocationDetailsCreateManySurveyInputEnvelope = {
    data: LocationDetailsCreateManySurveyInput | LocationDetailsCreateManySurveyInput[]
    skipDuplicates?: boolean
  }

  export type OtherDetailsCreateWithoutSurveyInput = {
    rainWaterHarvestingSystem?: string | null
    plantation?: string | null
    parking?: string | null
    pollution?: string | null
    pollutionMeasurementTaken?: string | null
    waterSupplyWithin200Meters?: string | null
    sewerageLineWithin100Meters?: string | null
    totalPlotArea: number
    builtupAreaOfGroundFloor: number
    remarks?: string | null
    waterSource: WaterSourceMasterCreateNestedOneWithoutOtherDetailsInput
    disposalType: DisposalTypeMasterCreateNestedOneWithoutOtherDetailsInput
  }

  export type OtherDetailsUncheckedCreateWithoutSurveyInput = {
    waterSourceId: string
    rainWaterHarvestingSystem?: string | null
    plantation?: string | null
    parking?: string | null
    pollution?: string | null
    pollutionMeasurementTaken?: string | null
    waterSupplyWithin200Meters?: string | null
    sewerageLineWithin100Meters?: string | null
    disposalTypeId: string
    totalPlotArea: number
    builtupAreaOfGroundFloor: number
    remarks?: string | null
  }

  export type OtherDetailsCreateOrConnectWithoutSurveyInput = {
    where: OtherDetailsWhereUniqueInput
    create: XOR<OtherDetailsCreateWithoutSurveyInput, OtherDetailsUncheckedCreateWithoutSurveyInput>
  }

  export type OtherDetailsCreateManySurveyInputEnvelope = {
    data: OtherDetailsCreateManySurveyInput | OtherDetailsCreateManySurveyInput[]
    skipDuplicates?: boolean
  }

  export type ResidentialPropertyAssessmentCreateWithoutSurveyInput = {
    floorAssessmentId?: string
    floorNumber: string
    coveredArea: Decimal | DecimalJsLike | number | string
    allRoomVerandaArea: Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea: Decimal | DecimalJsLike | number | string
    allGarageArea: Decimal | DecimalJsLike | number | string
    carpetArea: Decimal | DecimalJsLike | number | string
    occupancyStatus: OccupancyStatusMasterCreateNestedOneWithoutResidentialPropertyAssessmentsInput
    constructionNature: ConstructionNatureMasterCreateNestedOneWithoutResidentialPropertyAssessmentsInput
  }

  export type ResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput = {
    floorAssessmentId?: string
    floorNumber: string
    occupancyStatusId: string
    constructionNatureId: string
    coveredArea: Decimal | DecimalJsLike | number | string
    allRoomVerandaArea: Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea: Decimal | DecimalJsLike | number | string
    allGarageArea: Decimal | DecimalJsLike | number | string
    carpetArea: Decimal | DecimalJsLike | number | string
  }

  export type ResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput = {
    where: ResidentialPropertyAssessmentWhereUniqueInput
    create: XOR<ResidentialPropertyAssessmentCreateWithoutSurveyInput, ResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput>
  }

  export type ResidentialPropertyAssessmentCreateManySurveyInputEnvelope = {
    data: ResidentialPropertyAssessmentCreateManySurveyInput | ResidentialPropertyAssessmentCreateManySurveyInput[]
    skipDuplicates?: boolean
  }

  export type NonResidentialPropertyAssessmentCreateWithoutSurveyInput = {
    floorAssessmentId?: string
    floorNumber: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    builtupArea: Decimal | DecimalJsLike | number | string
    nrPropertyCategory: NrPropertyCategoryMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    nrSubCategory: NrPropertySubCategoryMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    occupancyStatus: OccupancyStatusMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
    constructionNature: ConstructionNatureMasterCreateNestedOneWithoutNonResidentialPropertyAssessmentsInput
  }

  export type NonResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput = {
    floorAssessmentId?: string
    floorNumber: string
    nrPropertyCategoryId: string
    nrSubCategoryId: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    occupancyStatusId: string
    constructionNatureId: string
    builtupArea: Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentCreateOrConnectWithoutSurveyInput = {
    where: NonResidentialPropertyAssessmentWhereUniqueInput
    create: XOR<NonResidentialPropertyAssessmentCreateWithoutSurveyInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput>
  }

  export type NonResidentialPropertyAssessmentCreateManySurveyInputEnvelope = {
    data: NonResidentialPropertyAssessmentCreateManySurveyInput | NonResidentialPropertyAssessmentCreateManySurveyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyAttachmentDetailsCreateWithoutSurveyInput = {
    image1Url?: string | null
    image2Url?: string | null
    image3Url?: string | null
    image4Url?: string | null
    image5Url?: string | null
    image6Url?: string | null
    image7Url?: string | null
    image8Url?: string | null
    image9Url?: string | null
    image10Url?: string | null
  }

  export type PropertyAttachmentDetailsUncheckedCreateWithoutSurveyInput = {
    image1Url?: string | null
    image2Url?: string | null
    image3Url?: string | null
    image4Url?: string | null
    image5Url?: string | null
    image6Url?: string | null
    image7Url?: string | null
    image8Url?: string | null
    image9Url?: string | null
    image10Url?: string | null
  }

  export type PropertyAttachmentDetailsCreateOrConnectWithoutSurveyInput = {
    where: PropertyAttachmentDetailsWhereUniqueInput
    create: XOR<PropertyAttachmentDetailsCreateWithoutSurveyInput, PropertyAttachmentDetailsUncheckedCreateWithoutSurveyInput>
  }

  export type PropertyAttachmentDetailsCreateManySurveyInputEnvelope = {
    data: PropertyAttachmentDetailsCreateManySurveyInput | PropertyAttachmentDetailsCreateManySurveyInput[]
    skipDuplicates?: boolean
  }

  export type SurveyStatusMappingCreateWithoutSurveyInput = {
    statusMappingId?: string
    isActive?: boolean
    status: SurveyStatusMasterCreateNestedOneWithoutSurveyStatusMapsInput
    revertedFrom?: SurveyStatusMasterCreateNestedOneWithoutSurveyStatusMapsRevertedInput
    changedBy: UsersMasterCreateNestedOneWithoutSurveyStatusMapsInput
  }

  export type SurveyStatusMappingUncheckedCreateWithoutSurveyInput = {
    statusMappingId?: string
    statusId: string
    revertedFromId?: string | null
    changedById: string
    isActive?: boolean
  }

  export type SurveyStatusMappingCreateOrConnectWithoutSurveyInput = {
    where: SurveyStatusMappingWhereUniqueInput
    create: XOR<SurveyStatusMappingCreateWithoutSurveyInput, SurveyStatusMappingUncheckedCreateWithoutSurveyInput>
  }

  export type SurveyStatusMappingCreateManySurveyInputEnvelope = {
    data: SurveyStatusMappingCreateManySurveyInput | SurveyStatusMappingCreateManySurveyInput[]
    skipDuplicates?: boolean
  }

  export type UlbMasterUpsertWithoutSurveyDetailsInput = {
    update: XOR<UlbMasterUpdateWithoutSurveyDetailsInput, UlbMasterUncheckedUpdateWithoutSurveyDetailsInput>
    create: XOR<UlbMasterCreateWithoutSurveyDetailsInput, UlbMasterUncheckedCreateWithoutSurveyDetailsInput>
    where?: UlbMasterWhereInput
  }

  export type UlbMasterUpdateToOneWithWhereWithoutSurveyDetailsInput = {
    where?: UlbMasterWhereInput
    data: XOR<UlbMasterUpdateWithoutSurveyDetailsInput, UlbMasterUncheckedUpdateWithoutSurveyDetailsInput>
  }

  export type UlbMasterUpdateWithoutSurveyDetailsInput = {
    ulbId?: StringFieldUpdateOperationsInput | string
    ulbName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ulbZoneMaps?: UlbZoneMappingUpdateManyWithoutUlbNestedInput
  }

  export type UlbMasterUncheckedUpdateWithoutSurveyDetailsInput = {
    ulbId?: StringFieldUpdateOperationsInput | string
    ulbName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ulbZoneMaps?: UlbZoneMappingUncheckedUpdateManyWithoutUlbNestedInput
  }

  export type ZoneMasterUpsertWithoutSurveyDetailsInput = {
    update: XOR<ZoneMasterUpdateWithoutSurveyDetailsInput, ZoneMasterUncheckedUpdateWithoutSurveyDetailsInput>
    create: XOR<ZoneMasterCreateWithoutSurveyDetailsInput, ZoneMasterUncheckedCreateWithoutSurveyDetailsInput>
    where?: ZoneMasterWhereInput
  }

  export type ZoneMasterUpdateToOneWithWhereWithoutSurveyDetailsInput = {
    where?: ZoneMasterWhereInput
    data: XOR<ZoneMasterUpdateWithoutSurveyDetailsInput, ZoneMasterUncheckedUpdateWithoutSurveyDetailsInput>
  }

  export type ZoneMasterUpdateWithoutSurveyDetailsInput = {
    zoneId?: StringFieldUpdateOperationsInput | string
    zoneNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ulbZoneMaps?: UlbZoneMappingUpdateManyWithoutZoneNestedInput
    zoneWardMaps?: ZoneWardMappingUpdateManyWithoutZoneNestedInput
  }

  export type ZoneMasterUncheckedUpdateWithoutSurveyDetailsInput = {
    zoneId?: StringFieldUpdateOperationsInput | string
    zoneNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ulbZoneMaps?: UlbZoneMappingUncheckedUpdateManyWithoutZoneNestedInput
    zoneWardMaps?: ZoneWardMappingUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type WardMasterUpsertWithoutSurveyDetailsInput = {
    update: XOR<WardMasterUpdateWithoutSurveyDetailsInput, WardMasterUncheckedUpdateWithoutSurveyDetailsInput>
    create: XOR<WardMasterCreateWithoutSurveyDetailsInput, WardMasterUncheckedCreateWithoutSurveyDetailsInput>
    where?: WardMasterWhereInput
  }

  export type WardMasterUpdateToOneWithWhereWithoutSurveyDetailsInput = {
    where?: WardMasterWhereInput
    data: XOR<WardMasterUpdateWithoutSurveyDetailsInput, WardMasterUncheckedUpdateWithoutSurveyDetailsInput>
  }

  export type WardMasterUpdateWithoutSurveyDetailsInput = {
    wardId?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    wardName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    zoneWardMaps?: ZoneWardMappingUpdateManyWithoutWardNestedInput
    wardMohallaMaps?: WardMohallaMappingUpdateManyWithoutWardNestedInput
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutWardNestedInput
    wardStatusMaps?: WardStatusMappingUpdateManyWithoutWardNestedInput
    supervisors?: SupervisorsUpdateManyWithoutWardNestedInput
  }

  export type WardMasterUncheckedUpdateWithoutSurveyDetailsInput = {
    wardId?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    wardName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    zoneWardMaps?: ZoneWardMappingUncheckedUpdateManyWithoutWardNestedInput
    wardMohallaMaps?: WardMohallaMappingUncheckedUpdateManyWithoutWardNestedInput
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutWardNestedInput
    wardStatusMaps?: WardStatusMappingUncheckedUpdateManyWithoutWardNestedInput
    supervisors?: SupervisorsUncheckedUpdateManyWithoutWardNestedInput
  }

  export type MohallaMasterUpsertWithoutSurveyDetailsInput = {
    update: XOR<MohallaMasterUpdateWithoutSurveyDetailsInput, MohallaMasterUncheckedUpdateWithoutSurveyDetailsInput>
    create: XOR<MohallaMasterCreateWithoutSurveyDetailsInput, MohallaMasterUncheckedCreateWithoutSurveyDetailsInput>
    where?: MohallaMasterWhereInput
  }

  export type MohallaMasterUpdateToOneWithWhereWithoutSurveyDetailsInput = {
    where?: MohallaMasterWhereInput
    data: XOR<MohallaMasterUpdateWithoutSurveyDetailsInput, MohallaMasterUncheckedUpdateWithoutSurveyDetailsInput>
  }

  export type MohallaMasterUpdateWithoutSurveyDetailsInput = {
    mohallaId?: StringFieldUpdateOperationsInput | string
    mohallaName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    wardMohallaMaps?: WardMohallaMappingUpdateManyWithoutMohallaNestedInput
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutMohallaNestedInput
  }

  export type MohallaMasterUncheckedUpdateWithoutSurveyDetailsInput = {
    mohallaId?: StringFieldUpdateOperationsInput | string
    mohallaName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    wardMohallaMaps?: WardMohallaMappingUncheckedUpdateManyWithoutMohallaNestedInput
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutMohallaNestedInput
  }

  export type SurveyTypeMasterUpsertWithoutSurveyDetailsInput = {
    update: XOR<SurveyTypeMasterUpdateWithoutSurveyDetailsInput, SurveyTypeMasterUncheckedUpdateWithoutSurveyDetailsInput>
    create: XOR<SurveyTypeMasterCreateWithoutSurveyDetailsInput, SurveyTypeMasterUncheckedCreateWithoutSurveyDetailsInput>
    where?: SurveyTypeMasterWhereInput
  }

  export type SurveyTypeMasterUpdateToOneWithWhereWithoutSurveyDetailsInput = {
    where?: SurveyTypeMasterWhereInput
    data: XOR<SurveyTypeMasterUpdateWithoutSurveyDetailsInput, SurveyTypeMasterUncheckedUpdateWithoutSurveyDetailsInput>
  }

  export type SurveyTypeMasterUpdateWithoutSurveyDetailsInput = {
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    surveyTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SurveyTypeMasterUncheckedUpdateWithoutSurveyDetailsInput = {
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    surveyTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyDetailsUpsertWithWhereUniqueWithoutSurveyInput = {
    where: PropertyDetailsWhereUniqueInput
    update: XOR<PropertyDetailsUpdateWithoutSurveyInput, PropertyDetailsUncheckedUpdateWithoutSurveyInput>
    create: XOR<PropertyDetailsCreateWithoutSurveyInput, PropertyDetailsUncheckedCreateWithoutSurveyInput>
  }

  export type PropertyDetailsUpdateWithWhereUniqueWithoutSurveyInput = {
    where: PropertyDetailsWhereUniqueInput
    data: XOR<PropertyDetailsUpdateWithoutSurveyInput, PropertyDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type PropertyDetailsUpdateManyWithWhereWithoutSurveyInput = {
    where: PropertyDetailsScalarWhereInput
    data: XOR<PropertyDetailsUpdateManyMutationInput, PropertyDetailsUncheckedUpdateManyWithoutSurveyInput>
  }

  export type OwnerDetailsUpsertWithWhereUniqueWithoutSurveyInput = {
    where: OwnerDetailsWhereUniqueInput
    update: XOR<OwnerDetailsUpdateWithoutSurveyInput, OwnerDetailsUncheckedUpdateWithoutSurveyInput>
    create: XOR<OwnerDetailsCreateWithoutSurveyInput, OwnerDetailsUncheckedCreateWithoutSurveyInput>
  }

  export type OwnerDetailsUpdateWithWhereUniqueWithoutSurveyInput = {
    where: OwnerDetailsWhereUniqueInput
    data: XOR<OwnerDetailsUpdateWithoutSurveyInput, OwnerDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type OwnerDetailsUpdateManyWithWhereWithoutSurveyInput = {
    where: OwnerDetailsScalarWhereInput
    data: XOR<OwnerDetailsUpdateManyMutationInput, OwnerDetailsUncheckedUpdateManyWithoutSurveyInput>
  }

  export type OwnerDetailsScalarWhereInput = {
    AND?: OwnerDetailsScalarWhereInput | OwnerDetailsScalarWhereInput[]
    OR?: OwnerDetailsScalarWhereInput[]
    NOT?: OwnerDetailsScalarWhereInput | OwnerDetailsScalarWhereInput[]
    surveyUniqueCode?: StringFilter<"OwnerDetails"> | string
    ownerName?: StringFilter<"OwnerDetails"> | string
    fatherHusbandName?: StringFilter<"OwnerDetails"> | string
    mobileNumber?: StringNullableFilter<"OwnerDetails"> | string | null
    aadharNumber?: StringNullableFilter<"OwnerDetails"> | string | null
  }

  export type LocationDetailsUpsertWithWhereUniqueWithoutSurveyInput = {
    where: LocationDetailsWhereUniqueInput
    update: XOR<LocationDetailsUpdateWithoutSurveyInput, LocationDetailsUncheckedUpdateWithoutSurveyInput>
    create: XOR<LocationDetailsCreateWithoutSurveyInput, LocationDetailsUncheckedCreateWithoutSurveyInput>
  }

  export type LocationDetailsUpdateWithWhereUniqueWithoutSurveyInput = {
    where: LocationDetailsWhereUniqueInput
    data: XOR<LocationDetailsUpdateWithoutSurveyInput, LocationDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type LocationDetailsUpdateManyWithWhereWithoutSurveyInput = {
    where: LocationDetailsScalarWhereInput
    data: XOR<LocationDetailsUpdateManyMutationInput, LocationDetailsUncheckedUpdateManyWithoutSurveyInput>
  }

  export type OtherDetailsUpsertWithWhereUniqueWithoutSurveyInput = {
    where: OtherDetailsWhereUniqueInput
    update: XOR<OtherDetailsUpdateWithoutSurveyInput, OtherDetailsUncheckedUpdateWithoutSurveyInput>
    create: XOR<OtherDetailsCreateWithoutSurveyInput, OtherDetailsUncheckedCreateWithoutSurveyInput>
  }

  export type OtherDetailsUpdateWithWhereUniqueWithoutSurveyInput = {
    where: OtherDetailsWhereUniqueInput
    data: XOR<OtherDetailsUpdateWithoutSurveyInput, OtherDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type OtherDetailsUpdateManyWithWhereWithoutSurveyInput = {
    where: OtherDetailsScalarWhereInput
    data: XOR<OtherDetailsUpdateManyMutationInput, OtherDetailsUncheckedUpdateManyWithoutSurveyInput>
  }

  export type ResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutSurveyInput = {
    where: ResidentialPropertyAssessmentWhereUniqueInput
    update: XOR<ResidentialPropertyAssessmentUpdateWithoutSurveyInput, ResidentialPropertyAssessmentUncheckedUpdateWithoutSurveyInput>
    create: XOR<ResidentialPropertyAssessmentCreateWithoutSurveyInput, ResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput>
  }

  export type ResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutSurveyInput = {
    where: ResidentialPropertyAssessmentWhereUniqueInput
    data: XOR<ResidentialPropertyAssessmentUpdateWithoutSurveyInput, ResidentialPropertyAssessmentUncheckedUpdateWithoutSurveyInput>
  }

  export type ResidentialPropertyAssessmentUpdateManyWithWhereWithoutSurveyInput = {
    where: ResidentialPropertyAssessmentScalarWhereInput
    data: XOR<ResidentialPropertyAssessmentUpdateManyMutationInput, ResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyInput>
  }

  export type NonResidentialPropertyAssessmentUpsertWithWhereUniqueWithoutSurveyInput = {
    where: NonResidentialPropertyAssessmentWhereUniqueInput
    update: XOR<NonResidentialPropertyAssessmentUpdateWithoutSurveyInput, NonResidentialPropertyAssessmentUncheckedUpdateWithoutSurveyInput>
    create: XOR<NonResidentialPropertyAssessmentCreateWithoutSurveyInput, NonResidentialPropertyAssessmentUncheckedCreateWithoutSurveyInput>
  }

  export type NonResidentialPropertyAssessmentUpdateWithWhereUniqueWithoutSurveyInput = {
    where: NonResidentialPropertyAssessmentWhereUniqueInput
    data: XOR<NonResidentialPropertyAssessmentUpdateWithoutSurveyInput, NonResidentialPropertyAssessmentUncheckedUpdateWithoutSurveyInput>
  }

  export type NonResidentialPropertyAssessmentUpdateManyWithWhereWithoutSurveyInput = {
    where: NonResidentialPropertyAssessmentScalarWhereInput
    data: XOR<NonResidentialPropertyAssessmentUpdateManyMutationInput, NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyInput>
  }

  export type PropertyAttachmentDetailsUpsertWithWhereUniqueWithoutSurveyInput = {
    where: PropertyAttachmentDetailsWhereUniqueInput
    update: XOR<PropertyAttachmentDetailsUpdateWithoutSurveyInput, PropertyAttachmentDetailsUncheckedUpdateWithoutSurveyInput>
    create: XOR<PropertyAttachmentDetailsCreateWithoutSurveyInput, PropertyAttachmentDetailsUncheckedCreateWithoutSurveyInput>
  }

  export type PropertyAttachmentDetailsUpdateWithWhereUniqueWithoutSurveyInput = {
    where: PropertyAttachmentDetailsWhereUniqueInput
    data: XOR<PropertyAttachmentDetailsUpdateWithoutSurveyInput, PropertyAttachmentDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type PropertyAttachmentDetailsUpdateManyWithWhereWithoutSurveyInput = {
    where: PropertyAttachmentDetailsScalarWhereInput
    data: XOR<PropertyAttachmentDetailsUpdateManyMutationInput, PropertyAttachmentDetailsUncheckedUpdateManyWithoutSurveyInput>
  }

  export type PropertyAttachmentDetailsScalarWhereInput = {
    AND?: PropertyAttachmentDetailsScalarWhereInput | PropertyAttachmentDetailsScalarWhereInput[]
    OR?: PropertyAttachmentDetailsScalarWhereInput[]
    NOT?: PropertyAttachmentDetailsScalarWhereInput | PropertyAttachmentDetailsScalarWhereInput[]
    surveyUniqueCode?: StringFilter<"PropertyAttachmentDetails"> | string
    image1Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image2Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image3Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image4Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image5Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image6Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image7Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image8Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image9Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
    image10Url?: StringNullableFilter<"PropertyAttachmentDetails"> | string | null
  }

  export type SurveyStatusMappingUpsertWithWhereUniqueWithoutSurveyInput = {
    where: SurveyStatusMappingWhereUniqueInput
    update: XOR<SurveyStatusMappingUpdateWithoutSurveyInput, SurveyStatusMappingUncheckedUpdateWithoutSurveyInput>
    create: XOR<SurveyStatusMappingCreateWithoutSurveyInput, SurveyStatusMappingUncheckedCreateWithoutSurveyInput>
  }

  export type SurveyStatusMappingUpdateWithWhereUniqueWithoutSurveyInput = {
    where: SurveyStatusMappingWhereUniqueInput
    data: XOR<SurveyStatusMappingUpdateWithoutSurveyInput, SurveyStatusMappingUncheckedUpdateWithoutSurveyInput>
  }

  export type SurveyStatusMappingUpdateManyWithWhereWithoutSurveyInput = {
    where: SurveyStatusMappingScalarWhereInput
    data: XOR<SurveyStatusMappingUpdateManyMutationInput, SurveyStatusMappingUncheckedUpdateManyWithoutSurveyInput>
  }

  export type SurveyDetailsCreateWithoutPropertyDetailsInput = {
    surveyUniqueCode?: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    ulb: UlbMasterCreateNestedOneWithoutSurveyDetailsInput
    zone: ZoneMasterCreateNestedOneWithoutSurveyDetailsInput
    ward: WardMasterCreateNestedOneWithoutSurveyDetailsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyDetailsInput
    surveyType: SurveyTypeMasterCreateNestedOneWithoutSurveyDetailsInput
    ownerDetails?: OwnerDetailsCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsUncheckedCreateWithoutPropertyDetailsInput = {
    surveyUniqueCode?: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    ownerDetails?: OwnerDetailsUncheckedCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsUncheckedCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsUncheckedCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsCreateOrConnectWithoutPropertyDetailsInput = {
    where: SurveyDetailsWhereUniqueInput
    create: XOR<SurveyDetailsCreateWithoutPropertyDetailsInput, SurveyDetailsUncheckedCreateWithoutPropertyDetailsInput>
  }

  export type ResponseTypeMasterCreateWithoutPropertyDetailsInput = {
    responseTypeId?: string
    responseTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type ResponseTypeMasterUncheckedCreateWithoutPropertyDetailsInput = {
    responseTypeId?: string
    responseTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type ResponseTypeMasterCreateOrConnectWithoutPropertyDetailsInput = {
    where: ResponseTypeMasterWhereUniqueInput
    create: XOR<ResponseTypeMasterCreateWithoutPropertyDetailsInput, ResponseTypeMasterUncheckedCreateWithoutPropertyDetailsInput>
  }

  export type RespondentStatusMasterCreateWithoutPropertyDetailsInput = {
    respondentStatusId?: string
    respondentStatusName: string
    isActive?: boolean
    description?: string | null
  }

  export type RespondentStatusMasterUncheckedCreateWithoutPropertyDetailsInput = {
    respondentStatusId?: string
    respondentStatusName: string
    isActive?: boolean
    description?: string | null
  }

  export type RespondentStatusMasterCreateOrConnectWithoutPropertyDetailsInput = {
    where: RespondentStatusMasterWhereUniqueInput
    create: XOR<RespondentStatusMasterCreateWithoutPropertyDetailsInput, RespondentStatusMasterUncheckedCreateWithoutPropertyDetailsInput>
  }

  export type SurveyDetailsUpsertWithoutPropertyDetailsInput = {
    update: XOR<SurveyDetailsUpdateWithoutPropertyDetailsInput, SurveyDetailsUncheckedUpdateWithoutPropertyDetailsInput>
    create: XOR<SurveyDetailsCreateWithoutPropertyDetailsInput, SurveyDetailsUncheckedCreateWithoutPropertyDetailsInput>
    where?: SurveyDetailsWhereInput
  }

  export type SurveyDetailsUpdateToOneWithWhereWithoutPropertyDetailsInput = {
    where?: SurveyDetailsWhereInput
    data: XOR<SurveyDetailsUpdateWithoutPropertyDetailsInput, SurveyDetailsUncheckedUpdateWithoutPropertyDetailsInput>
  }

  export type SurveyDetailsUpdateWithoutPropertyDetailsInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    ulb?: UlbMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    zone?: ZoneMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    surveyType?: SurveyTypeMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    ownerDetails?: OwnerDetailsUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateWithoutPropertyDetailsInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerDetails?: OwnerDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type ResponseTypeMasterUpsertWithoutPropertyDetailsInput = {
    update: XOR<ResponseTypeMasterUpdateWithoutPropertyDetailsInput, ResponseTypeMasterUncheckedUpdateWithoutPropertyDetailsInput>
    create: XOR<ResponseTypeMasterCreateWithoutPropertyDetailsInput, ResponseTypeMasterUncheckedCreateWithoutPropertyDetailsInput>
    where?: ResponseTypeMasterWhereInput
  }

  export type ResponseTypeMasterUpdateToOneWithWhereWithoutPropertyDetailsInput = {
    where?: ResponseTypeMasterWhereInput
    data: XOR<ResponseTypeMasterUpdateWithoutPropertyDetailsInput, ResponseTypeMasterUncheckedUpdateWithoutPropertyDetailsInput>
  }

  export type ResponseTypeMasterUpdateWithoutPropertyDetailsInput = {
    responseTypeId?: StringFieldUpdateOperationsInput | string
    responseTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponseTypeMasterUncheckedUpdateWithoutPropertyDetailsInput = {
    responseTypeId?: StringFieldUpdateOperationsInput | string
    responseTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RespondentStatusMasterUpsertWithoutPropertyDetailsInput = {
    update: XOR<RespondentStatusMasterUpdateWithoutPropertyDetailsInput, RespondentStatusMasterUncheckedUpdateWithoutPropertyDetailsInput>
    create: XOR<RespondentStatusMasterCreateWithoutPropertyDetailsInput, RespondentStatusMasterUncheckedCreateWithoutPropertyDetailsInput>
    where?: RespondentStatusMasterWhereInput
  }

  export type RespondentStatusMasterUpdateToOneWithWhereWithoutPropertyDetailsInput = {
    where?: RespondentStatusMasterWhereInput
    data: XOR<RespondentStatusMasterUpdateWithoutPropertyDetailsInput, RespondentStatusMasterUncheckedUpdateWithoutPropertyDetailsInput>
  }

  export type RespondentStatusMasterUpdateWithoutPropertyDetailsInput = {
    respondentStatusId?: StringFieldUpdateOperationsInput | string
    respondentStatusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RespondentStatusMasterUncheckedUpdateWithoutPropertyDetailsInput = {
    respondentStatusId?: StringFieldUpdateOperationsInput | string
    respondentStatusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SurveyDetailsCreateWithoutOwnerDetailsInput = {
    surveyUniqueCode?: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    ulb: UlbMasterCreateNestedOneWithoutSurveyDetailsInput
    zone: ZoneMasterCreateNestedOneWithoutSurveyDetailsInput
    ward: WardMasterCreateNestedOneWithoutSurveyDetailsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyDetailsInput
    surveyType: SurveyTypeMasterCreateNestedOneWithoutSurveyDetailsInput
    propertyDetails?: PropertyDetailsCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsUncheckedCreateWithoutOwnerDetailsInput = {
    surveyUniqueCode?: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    propertyDetails?: PropertyDetailsUncheckedCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsUncheckedCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsUncheckedCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsCreateOrConnectWithoutOwnerDetailsInput = {
    where: SurveyDetailsWhereUniqueInput
    create: XOR<SurveyDetailsCreateWithoutOwnerDetailsInput, SurveyDetailsUncheckedCreateWithoutOwnerDetailsInput>
  }

  export type SurveyDetailsUpsertWithoutOwnerDetailsInput = {
    update: XOR<SurveyDetailsUpdateWithoutOwnerDetailsInput, SurveyDetailsUncheckedUpdateWithoutOwnerDetailsInput>
    create: XOR<SurveyDetailsCreateWithoutOwnerDetailsInput, SurveyDetailsUncheckedCreateWithoutOwnerDetailsInput>
    where?: SurveyDetailsWhereInput
  }

  export type SurveyDetailsUpdateToOneWithWhereWithoutOwnerDetailsInput = {
    where?: SurveyDetailsWhereInput
    data: XOR<SurveyDetailsUpdateWithoutOwnerDetailsInput, SurveyDetailsUncheckedUpdateWithoutOwnerDetailsInput>
  }

  export type SurveyDetailsUpdateWithoutOwnerDetailsInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    ulb?: UlbMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    zone?: ZoneMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    surveyType?: SurveyTypeMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    propertyDetails?: PropertyDetailsUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateWithoutOwnerDetailsInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDetails?: PropertyDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsCreateWithoutLocationDetailsInput = {
    surveyUniqueCode?: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    ulb: UlbMasterCreateNestedOneWithoutSurveyDetailsInput
    zone: ZoneMasterCreateNestedOneWithoutSurveyDetailsInput
    ward: WardMasterCreateNestedOneWithoutSurveyDetailsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyDetailsInput
    surveyType: SurveyTypeMasterCreateNestedOneWithoutSurveyDetailsInput
    propertyDetails?: PropertyDetailsCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsUncheckedCreateWithoutLocationDetailsInput = {
    surveyUniqueCode?: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    propertyDetails?: PropertyDetailsUncheckedCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsUncheckedCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsUncheckedCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsCreateOrConnectWithoutLocationDetailsInput = {
    where: SurveyDetailsWhereUniqueInput
    create: XOR<SurveyDetailsCreateWithoutLocationDetailsInput, SurveyDetailsUncheckedCreateWithoutLocationDetailsInput>
  }

  export type PropertyTypeMasterCreateWithoutLocationDetailsInput = {
    propertyTypeId?: string
    propertyTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type PropertyTypeMasterUncheckedCreateWithoutLocationDetailsInput = {
    propertyTypeId?: string
    propertyTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type PropertyTypeMasterCreateOrConnectWithoutLocationDetailsInput = {
    where: PropertyTypeMasterWhereUniqueInput
    create: XOR<PropertyTypeMasterCreateWithoutLocationDetailsInput, PropertyTypeMasterUncheckedCreateWithoutLocationDetailsInput>
  }

  export type RoadTypeMasterCreateWithoutLocationDetailsInput = {
    roadTypeId?: string
    roadTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type RoadTypeMasterUncheckedCreateWithoutLocationDetailsInput = {
    roadTypeId?: string
    roadTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type RoadTypeMasterCreateOrConnectWithoutLocationDetailsInput = {
    where: RoadTypeMasterWhereUniqueInput
    create: XOR<RoadTypeMasterCreateWithoutLocationDetailsInput, RoadTypeMasterUncheckedCreateWithoutLocationDetailsInput>
  }

  export type ConstructionTypeMasterCreateWithoutLocationDetailsInput = {
    constructionTypeId?: string
    constructionTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type ConstructionTypeMasterUncheckedCreateWithoutLocationDetailsInput = {
    constructionTypeId?: string
    constructionTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type ConstructionTypeMasterCreateOrConnectWithoutLocationDetailsInput = {
    where: ConstructionTypeMasterWhereUniqueInput
    create: XOR<ConstructionTypeMasterCreateWithoutLocationDetailsInput, ConstructionTypeMasterUncheckedCreateWithoutLocationDetailsInput>
  }

  export type SurveyDetailsUpsertWithoutLocationDetailsInput = {
    update: XOR<SurveyDetailsUpdateWithoutLocationDetailsInput, SurveyDetailsUncheckedUpdateWithoutLocationDetailsInput>
    create: XOR<SurveyDetailsCreateWithoutLocationDetailsInput, SurveyDetailsUncheckedCreateWithoutLocationDetailsInput>
    where?: SurveyDetailsWhereInput
  }

  export type SurveyDetailsUpdateToOneWithWhereWithoutLocationDetailsInput = {
    where?: SurveyDetailsWhereInput
    data: XOR<SurveyDetailsUpdateWithoutLocationDetailsInput, SurveyDetailsUncheckedUpdateWithoutLocationDetailsInput>
  }

  export type SurveyDetailsUpdateWithoutLocationDetailsInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    ulb?: UlbMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    zone?: ZoneMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    surveyType?: SurveyTypeMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    propertyDetails?: PropertyDetailsUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateWithoutLocationDetailsInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDetails?: PropertyDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type PropertyTypeMasterUpsertWithoutLocationDetailsInput = {
    update: XOR<PropertyTypeMasterUpdateWithoutLocationDetailsInput, PropertyTypeMasterUncheckedUpdateWithoutLocationDetailsInput>
    create: XOR<PropertyTypeMasterCreateWithoutLocationDetailsInput, PropertyTypeMasterUncheckedCreateWithoutLocationDetailsInput>
    where?: PropertyTypeMasterWhereInput
  }

  export type PropertyTypeMasterUpdateToOneWithWhereWithoutLocationDetailsInput = {
    where?: PropertyTypeMasterWhereInput
    data: XOR<PropertyTypeMasterUpdateWithoutLocationDetailsInput, PropertyTypeMasterUncheckedUpdateWithoutLocationDetailsInput>
  }

  export type PropertyTypeMasterUpdateWithoutLocationDetailsInput = {
    propertyTypeId?: StringFieldUpdateOperationsInput | string
    propertyTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyTypeMasterUncheckedUpdateWithoutLocationDetailsInput = {
    propertyTypeId?: StringFieldUpdateOperationsInput | string
    propertyTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoadTypeMasterUpsertWithoutLocationDetailsInput = {
    update: XOR<RoadTypeMasterUpdateWithoutLocationDetailsInput, RoadTypeMasterUncheckedUpdateWithoutLocationDetailsInput>
    create: XOR<RoadTypeMasterCreateWithoutLocationDetailsInput, RoadTypeMasterUncheckedCreateWithoutLocationDetailsInput>
    where?: RoadTypeMasterWhereInput
  }

  export type RoadTypeMasterUpdateToOneWithWhereWithoutLocationDetailsInput = {
    where?: RoadTypeMasterWhereInput
    data: XOR<RoadTypeMasterUpdateWithoutLocationDetailsInput, RoadTypeMasterUncheckedUpdateWithoutLocationDetailsInput>
  }

  export type RoadTypeMasterUpdateWithoutLocationDetailsInput = {
    roadTypeId?: StringFieldUpdateOperationsInput | string
    roadTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoadTypeMasterUncheckedUpdateWithoutLocationDetailsInput = {
    roadTypeId?: StringFieldUpdateOperationsInput | string
    roadTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConstructionTypeMasterUpsertWithoutLocationDetailsInput = {
    update: XOR<ConstructionTypeMasterUpdateWithoutLocationDetailsInput, ConstructionTypeMasterUncheckedUpdateWithoutLocationDetailsInput>
    create: XOR<ConstructionTypeMasterCreateWithoutLocationDetailsInput, ConstructionTypeMasterUncheckedCreateWithoutLocationDetailsInput>
    where?: ConstructionTypeMasterWhereInput
  }

  export type ConstructionTypeMasterUpdateToOneWithWhereWithoutLocationDetailsInput = {
    where?: ConstructionTypeMasterWhereInput
    data: XOR<ConstructionTypeMasterUpdateWithoutLocationDetailsInput, ConstructionTypeMasterUncheckedUpdateWithoutLocationDetailsInput>
  }

  export type ConstructionTypeMasterUpdateWithoutLocationDetailsInput = {
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    constructionTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConstructionTypeMasterUncheckedUpdateWithoutLocationDetailsInput = {
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    constructionTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SurveyDetailsCreateWithoutOtherDetailsInput = {
    surveyUniqueCode?: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    ulb: UlbMasterCreateNestedOneWithoutSurveyDetailsInput
    zone: ZoneMasterCreateNestedOneWithoutSurveyDetailsInput
    ward: WardMasterCreateNestedOneWithoutSurveyDetailsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyDetailsInput
    surveyType: SurveyTypeMasterCreateNestedOneWithoutSurveyDetailsInput
    propertyDetails?: PropertyDetailsCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsUncheckedCreateWithoutOtherDetailsInput = {
    surveyUniqueCode?: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    propertyDetails?: PropertyDetailsUncheckedCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsUncheckedCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsUncheckedCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsCreateOrConnectWithoutOtherDetailsInput = {
    where: SurveyDetailsWhereUniqueInput
    create: XOR<SurveyDetailsCreateWithoutOtherDetailsInput, SurveyDetailsUncheckedCreateWithoutOtherDetailsInput>
  }

  export type WaterSourceMasterCreateWithoutOtherDetailsInput = {
    waterSourceId?: string
    waterSourceName: string
    isActive?: boolean
    description?: string | null
  }

  export type WaterSourceMasterUncheckedCreateWithoutOtherDetailsInput = {
    waterSourceId?: string
    waterSourceName: string
    isActive?: boolean
    description?: string | null
  }

  export type WaterSourceMasterCreateOrConnectWithoutOtherDetailsInput = {
    where: WaterSourceMasterWhereUniqueInput
    create: XOR<WaterSourceMasterCreateWithoutOtherDetailsInput, WaterSourceMasterUncheckedCreateWithoutOtherDetailsInput>
  }

  export type DisposalTypeMasterCreateWithoutOtherDetailsInput = {
    disposalTypeId?: string
    disposalTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type DisposalTypeMasterUncheckedCreateWithoutOtherDetailsInput = {
    disposalTypeId?: string
    disposalTypeName: string
    isActive?: boolean
    description?: string | null
  }

  export type DisposalTypeMasterCreateOrConnectWithoutOtherDetailsInput = {
    where: DisposalTypeMasterWhereUniqueInput
    create: XOR<DisposalTypeMasterCreateWithoutOtherDetailsInput, DisposalTypeMasterUncheckedCreateWithoutOtherDetailsInput>
  }

  export type SurveyDetailsUpsertWithoutOtherDetailsInput = {
    update: XOR<SurveyDetailsUpdateWithoutOtherDetailsInput, SurveyDetailsUncheckedUpdateWithoutOtherDetailsInput>
    create: XOR<SurveyDetailsCreateWithoutOtherDetailsInput, SurveyDetailsUncheckedCreateWithoutOtherDetailsInput>
    where?: SurveyDetailsWhereInput
  }

  export type SurveyDetailsUpdateToOneWithWhereWithoutOtherDetailsInput = {
    where?: SurveyDetailsWhereInput
    data: XOR<SurveyDetailsUpdateWithoutOtherDetailsInput, SurveyDetailsUncheckedUpdateWithoutOtherDetailsInput>
  }

  export type SurveyDetailsUpdateWithoutOtherDetailsInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    ulb?: UlbMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    zone?: ZoneMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    surveyType?: SurveyTypeMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    propertyDetails?: PropertyDetailsUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateWithoutOtherDetailsInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDetails?: PropertyDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type WaterSourceMasterUpsertWithoutOtherDetailsInput = {
    update: XOR<WaterSourceMasterUpdateWithoutOtherDetailsInput, WaterSourceMasterUncheckedUpdateWithoutOtherDetailsInput>
    create: XOR<WaterSourceMasterCreateWithoutOtherDetailsInput, WaterSourceMasterUncheckedCreateWithoutOtherDetailsInput>
    where?: WaterSourceMasterWhereInput
  }

  export type WaterSourceMasterUpdateToOneWithWhereWithoutOtherDetailsInput = {
    where?: WaterSourceMasterWhereInput
    data: XOR<WaterSourceMasterUpdateWithoutOtherDetailsInput, WaterSourceMasterUncheckedUpdateWithoutOtherDetailsInput>
  }

  export type WaterSourceMasterUpdateWithoutOtherDetailsInput = {
    waterSourceId?: StringFieldUpdateOperationsInput | string
    waterSourceName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WaterSourceMasterUncheckedUpdateWithoutOtherDetailsInput = {
    waterSourceId?: StringFieldUpdateOperationsInput | string
    waterSourceName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DisposalTypeMasterUpsertWithoutOtherDetailsInput = {
    update: XOR<DisposalTypeMasterUpdateWithoutOtherDetailsInput, DisposalTypeMasterUncheckedUpdateWithoutOtherDetailsInput>
    create: XOR<DisposalTypeMasterCreateWithoutOtherDetailsInput, DisposalTypeMasterUncheckedCreateWithoutOtherDetailsInput>
    where?: DisposalTypeMasterWhereInput
  }

  export type DisposalTypeMasterUpdateToOneWithWhereWithoutOtherDetailsInput = {
    where?: DisposalTypeMasterWhereInput
    data: XOR<DisposalTypeMasterUpdateWithoutOtherDetailsInput, DisposalTypeMasterUncheckedUpdateWithoutOtherDetailsInput>
  }

  export type DisposalTypeMasterUpdateWithoutOtherDetailsInput = {
    disposalTypeId?: StringFieldUpdateOperationsInput | string
    disposalTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DisposalTypeMasterUncheckedUpdateWithoutOtherDetailsInput = {
    disposalTypeId?: StringFieldUpdateOperationsInput | string
    disposalTypeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SurveyDetailsCreateWithoutResidentialPropertyAssessmentsInput = {
    surveyUniqueCode?: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    ulb: UlbMasterCreateNestedOneWithoutSurveyDetailsInput
    zone: ZoneMasterCreateNestedOneWithoutSurveyDetailsInput
    ward: WardMasterCreateNestedOneWithoutSurveyDetailsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyDetailsInput
    surveyType: SurveyTypeMasterCreateNestedOneWithoutSurveyDetailsInput
    propertyDetails?: PropertyDetailsCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsUncheckedCreateWithoutResidentialPropertyAssessmentsInput = {
    surveyUniqueCode?: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    propertyDetails?: PropertyDetailsUncheckedCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsUncheckedCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsUncheckedCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsUncheckedCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsCreateOrConnectWithoutResidentialPropertyAssessmentsInput = {
    where: SurveyDetailsWhereUniqueInput
    create: XOR<SurveyDetailsCreateWithoutResidentialPropertyAssessmentsInput, SurveyDetailsUncheckedCreateWithoutResidentialPropertyAssessmentsInput>
  }

  export type OccupancyStatusMasterCreateWithoutResidentialPropertyAssessmentsInput = {
    occupancyStatusId?: string
    occupancyStatusName: string
    isActive?: boolean
    description?: string | null
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutOccupancyStatusInput
  }

  export type OccupancyStatusMasterUncheckedCreateWithoutResidentialPropertyAssessmentsInput = {
    occupancyStatusId?: string
    occupancyStatusName: string
    isActive?: boolean
    description?: string | null
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutOccupancyStatusInput
  }

  export type OccupancyStatusMasterCreateOrConnectWithoutResidentialPropertyAssessmentsInput = {
    where: OccupancyStatusMasterWhereUniqueInput
    create: XOR<OccupancyStatusMasterCreateWithoutResidentialPropertyAssessmentsInput, OccupancyStatusMasterUncheckedCreateWithoutResidentialPropertyAssessmentsInput>
  }

  export type ConstructionNatureMasterCreateWithoutResidentialPropertyAssessmentsInput = {
    constructionNatureId?: string
    constructionNatureName: string
    isActive?: boolean
    description?: string | null
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutConstructionNatureInput
  }

  export type ConstructionNatureMasterUncheckedCreateWithoutResidentialPropertyAssessmentsInput = {
    constructionNatureId?: string
    constructionNatureName: string
    isActive?: boolean
    description?: string | null
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutConstructionNatureInput
  }

  export type ConstructionNatureMasterCreateOrConnectWithoutResidentialPropertyAssessmentsInput = {
    where: ConstructionNatureMasterWhereUniqueInput
    create: XOR<ConstructionNatureMasterCreateWithoutResidentialPropertyAssessmentsInput, ConstructionNatureMasterUncheckedCreateWithoutResidentialPropertyAssessmentsInput>
  }

  export type SurveyDetailsUpsertWithoutResidentialPropertyAssessmentsInput = {
    update: XOR<SurveyDetailsUpdateWithoutResidentialPropertyAssessmentsInput, SurveyDetailsUncheckedUpdateWithoutResidentialPropertyAssessmentsInput>
    create: XOR<SurveyDetailsCreateWithoutResidentialPropertyAssessmentsInput, SurveyDetailsUncheckedCreateWithoutResidentialPropertyAssessmentsInput>
    where?: SurveyDetailsWhereInput
  }

  export type SurveyDetailsUpdateToOneWithWhereWithoutResidentialPropertyAssessmentsInput = {
    where?: SurveyDetailsWhereInput
    data: XOR<SurveyDetailsUpdateWithoutResidentialPropertyAssessmentsInput, SurveyDetailsUncheckedUpdateWithoutResidentialPropertyAssessmentsInput>
  }

  export type SurveyDetailsUpdateWithoutResidentialPropertyAssessmentsInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    ulb?: UlbMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    zone?: ZoneMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    surveyType?: SurveyTypeMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    propertyDetails?: PropertyDetailsUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateWithoutResidentialPropertyAssessmentsInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDetails?: PropertyDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type OccupancyStatusMasterUpsertWithoutResidentialPropertyAssessmentsInput = {
    update: XOR<OccupancyStatusMasterUpdateWithoutResidentialPropertyAssessmentsInput, OccupancyStatusMasterUncheckedUpdateWithoutResidentialPropertyAssessmentsInput>
    create: XOR<OccupancyStatusMasterCreateWithoutResidentialPropertyAssessmentsInput, OccupancyStatusMasterUncheckedCreateWithoutResidentialPropertyAssessmentsInput>
    where?: OccupancyStatusMasterWhereInput
  }

  export type OccupancyStatusMasterUpdateToOneWithWhereWithoutResidentialPropertyAssessmentsInput = {
    where?: OccupancyStatusMasterWhereInput
    data: XOR<OccupancyStatusMasterUpdateWithoutResidentialPropertyAssessmentsInput, OccupancyStatusMasterUncheckedUpdateWithoutResidentialPropertyAssessmentsInput>
  }

  export type OccupancyStatusMasterUpdateWithoutResidentialPropertyAssessmentsInput = {
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    occupancyStatusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutOccupancyStatusNestedInput
  }

  export type OccupancyStatusMasterUncheckedUpdateWithoutResidentialPropertyAssessmentsInput = {
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    occupancyStatusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutOccupancyStatusNestedInput
  }

  export type ConstructionNatureMasterUpsertWithoutResidentialPropertyAssessmentsInput = {
    update: XOR<ConstructionNatureMasterUpdateWithoutResidentialPropertyAssessmentsInput, ConstructionNatureMasterUncheckedUpdateWithoutResidentialPropertyAssessmentsInput>
    create: XOR<ConstructionNatureMasterCreateWithoutResidentialPropertyAssessmentsInput, ConstructionNatureMasterUncheckedCreateWithoutResidentialPropertyAssessmentsInput>
    where?: ConstructionNatureMasterWhereInput
  }

  export type ConstructionNatureMasterUpdateToOneWithWhereWithoutResidentialPropertyAssessmentsInput = {
    where?: ConstructionNatureMasterWhereInput
    data: XOR<ConstructionNatureMasterUpdateWithoutResidentialPropertyAssessmentsInput, ConstructionNatureMasterUncheckedUpdateWithoutResidentialPropertyAssessmentsInput>
  }

  export type ConstructionNatureMasterUpdateWithoutResidentialPropertyAssessmentsInput = {
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    constructionNatureName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutConstructionNatureNestedInput
  }

  export type ConstructionNatureMasterUncheckedUpdateWithoutResidentialPropertyAssessmentsInput = {
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    constructionNatureName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutConstructionNatureNestedInput
  }

  export type NrPropertyCategoryMasterCreateWithoutNonResidentialPropertyAssessmentsInput = {
    propertyCategoryId?: string
    propertyCategoryNumber: number
    propertyCategoryName: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    subCategories?: NrPropertySubCategoryMasterCreateNestedManyWithoutPropertyCategoryInput
  }

  export type NrPropertyCategoryMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput = {
    propertyCategoryId?: string
    propertyCategoryNumber: number
    propertyCategoryName: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    subCategories?: NrPropertySubCategoryMasterUncheckedCreateNestedManyWithoutPropertyCategoryInput
  }

  export type NrPropertyCategoryMasterCreateOrConnectWithoutNonResidentialPropertyAssessmentsInput = {
    where: NrPropertyCategoryMasterWhereUniqueInput
    create: XOR<NrPropertyCategoryMasterCreateWithoutNonResidentialPropertyAssessmentsInput, NrPropertyCategoryMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
  }

  export type NrPropertySubCategoryMasterCreateWithoutNonResidentialPropertyAssessmentsInput = {
    subCategoryId?: string
    subCategoryNumber: number
    subCategoryName: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    propertyCategory: NrPropertyCategoryMasterCreateNestedOneWithoutSubCategoriesInput
  }

  export type NrPropertySubCategoryMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput = {
    subCategoryId?: string
    subCategoryNumber: number
    subCategoryName: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    propertyCategoryId: string
  }

  export type NrPropertySubCategoryMasterCreateOrConnectWithoutNonResidentialPropertyAssessmentsInput = {
    where: NrPropertySubCategoryMasterWhereUniqueInput
    create: XOR<NrPropertySubCategoryMasterCreateWithoutNonResidentialPropertyAssessmentsInput, NrPropertySubCategoryMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
  }

  export type OccupancyStatusMasterCreateWithoutNonResidentialPropertyAssessmentsInput = {
    occupancyStatusId?: string
    occupancyStatusName: string
    isActive?: boolean
    description?: string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentCreateNestedManyWithoutOccupancyStatusInput
  }

  export type OccupancyStatusMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput = {
    occupancyStatusId?: string
    occupancyStatusName: string
    isActive?: boolean
    description?: string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutOccupancyStatusInput
  }

  export type OccupancyStatusMasterCreateOrConnectWithoutNonResidentialPropertyAssessmentsInput = {
    where: OccupancyStatusMasterWhereUniqueInput
    create: XOR<OccupancyStatusMasterCreateWithoutNonResidentialPropertyAssessmentsInput, OccupancyStatusMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
  }

  export type ConstructionNatureMasterCreateWithoutNonResidentialPropertyAssessmentsInput = {
    constructionNatureId?: string
    constructionNatureName: string
    isActive?: boolean
    description?: string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentCreateNestedManyWithoutConstructionNatureInput
  }

  export type ConstructionNatureMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput = {
    constructionNatureId?: string
    constructionNatureName: string
    isActive?: boolean
    description?: string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutConstructionNatureInput
  }

  export type ConstructionNatureMasterCreateOrConnectWithoutNonResidentialPropertyAssessmentsInput = {
    where: ConstructionNatureMasterWhereUniqueInput
    create: XOR<ConstructionNatureMasterCreateWithoutNonResidentialPropertyAssessmentsInput, ConstructionNatureMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
  }

  export type SurveyDetailsCreateWithoutNonResidentialPropertyAssessmentsInput = {
    surveyUniqueCode?: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    ulb: UlbMasterCreateNestedOneWithoutSurveyDetailsInput
    zone: ZoneMasterCreateNestedOneWithoutSurveyDetailsInput
    ward: WardMasterCreateNestedOneWithoutSurveyDetailsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyDetailsInput
    surveyType: SurveyTypeMasterCreateNestedOneWithoutSurveyDetailsInput
    propertyDetails?: PropertyDetailsCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput = {
    surveyUniqueCode?: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    propertyDetails?: PropertyDetailsUncheckedCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsUncheckedCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsUncheckedCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsUncheckedCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsCreateOrConnectWithoutNonResidentialPropertyAssessmentsInput = {
    where: SurveyDetailsWhereUniqueInput
    create: XOR<SurveyDetailsCreateWithoutNonResidentialPropertyAssessmentsInput, SurveyDetailsUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
  }

  export type NrPropertyCategoryMasterUpsertWithoutNonResidentialPropertyAssessmentsInput = {
    update: XOR<NrPropertyCategoryMasterUpdateWithoutNonResidentialPropertyAssessmentsInput, NrPropertyCategoryMasterUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput>
    create: XOR<NrPropertyCategoryMasterCreateWithoutNonResidentialPropertyAssessmentsInput, NrPropertyCategoryMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
    where?: NrPropertyCategoryMasterWhereInput
  }

  export type NrPropertyCategoryMasterUpdateToOneWithWhereWithoutNonResidentialPropertyAssessmentsInput = {
    where?: NrPropertyCategoryMasterWhereInput
    data: XOR<NrPropertyCategoryMasterUpdateWithoutNonResidentialPropertyAssessmentsInput, NrPropertyCategoryMasterUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput>
  }

  export type NrPropertyCategoryMasterUpdateWithoutNonResidentialPropertyAssessmentsInput = {
    propertyCategoryId?: StringFieldUpdateOperationsInput | string
    propertyCategoryNumber?: IntFieldUpdateOperationsInput | number
    propertyCategoryName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCategories?: NrPropertySubCategoryMasterUpdateManyWithoutPropertyCategoryNestedInput
  }

  export type NrPropertyCategoryMasterUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput = {
    propertyCategoryId?: StringFieldUpdateOperationsInput | string
    propertyCategoryNumber?: IntFieldUpdateOperationsInput | number
    propertyCategoryName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCategories?: NrPropertySubCategoryMasterUncheckedUpdateManyWithoutPropertyCategoryNestedInput
  }

  export type NrPropertySubCategoryMasterUpsertWithoutNonResidentialPropertyAssessmentsInput = {
    update: XOR<NrPropertySubCategoryMasterUpdateWithoutNonResidentialPropertyAssessmentsInput, NrPropertySubCategoryMasterUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput>
    create: XOR<NrPropertySubCategoryMasterCreateWithoutNonResidentialPropertyAssessmentsInput, NrPropertySubCategoryMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
    where?: NrPropertySubCategoryMasterWhereInput
  }

  export type NrPropertySubCategoryMasterUpdateToOneWithWhereWithoutNonResidentialPropertyAssessmentsInput = {
    where?: NrPropertySubCategoryMasterWhereInput
    data: XOR<NrPropertySubCategoryMasterUpdateWithoutNonResidentialPropertyAssessmentsInput, NrPropertySubCategoryMasterUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput>
  }

  export type NrPropertySubCategoryMasterUpdateWithoutNonResidentialPropertyAssessmentsInput = {
    subCategoryId?: StringFieldUpdateOperationsInput | string
    subCategoryNumber?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyCategory?: NrPropertyCategoryMasterUpdateOneRequiredWithoutSubCategoriesNestedInput
  }

  export type NrPropertySubCategoryMasterUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput = {
    subCategoryId?: StringFieldUpdateOperationsInput | string
    subCategoryNumber?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyCategoryId?: StringFieldUpdateOperationsInput | string
  }

  export type OccupancyStatusMasterUpsertWithoutNonResidentialPropertyAssessmentsInput = {
    update: XOR<OccupancyStatusMasterUpdateWithoutNonResidentialPropertyAssessmentsInput, OccupancyStatusMasterUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput>
    create: XOR<OccupancyStatusMasterCreateWithoutNonResidentialPropertyAssessmentsInput, OccupancyStatusMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
    where?: OccupancyStatusMasterWhereInput
  }

  export type OccupancyStatusMasterUpdateToOneWithWhereWithoutNonResidentialPropertyAssessmentsInput = {
    where?: OccupancyStatusMasterWhereInput
    data: XOR<OccupancyStatusMasterUpdateWithoutNonResidentialPropertyAssessmentsInput, OccupancyStatusMasterUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput>
  }

  export type OccupancyStatusMasterUpdateWithoutNonResidentialPropertyAssessmentsInput = {
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    occupancyStatusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUpdateManyWithoutOccupancyStatusNestedInput
  }

  export type OccupancyStatusMasterUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput = {
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    occupancyStatusName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedUpdateManyWithoutOccupancyStatusNestedInput
  }

  export type ConstructionNatureMasterUpsertWithoutNonResidentialPropertyAssessmentsInput = {
    update: XOR<ConstructionNatureMasterUpdateWithoutNonResidentialPropertyAssessmentsInput, ConstructionNatureMasterUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput>
    create: XOR<ConstructionNatureMasterCreateWithoutNonResidentialPropertyAssessmentsInput, ConstructionNatureMasterUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
    where?: ConstructionNatureMasterWhereInput
  }

  export type ConstructionNatureMasterUpdateToOneWithWhereWithoutNonResidentialPropertyAssessmentsInput = {
    where?: ConstructionNatureMasterWhereInput
    data: XOR<ConstructionNatureMasterUpdateWithoutNonResidentialPropertyAssessmentsInput, ConstructionNatureMasterUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput>
  }

  export type ConstructionNatureMasterUpdateWithoutNonResidentialPropertyAssessmentsInput = {
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    constructionNatureName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUpdateManyWithoutConstructionNatureNestedInput
  }

  export type ConstructionNatureMasterUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput = {
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    constructionNatureName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedUpdateManyWithoutConstructionNatureNestedInput
  }

  export type SurveyDetailsUpsertWithoutNonResidentialPropertyAssessmentsInput = {
    update: XOR<SurveyDetailsUpdateWithoutNonResidentialPropertyAssessmentsInput, SurveyDetailsUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput>
    create: XOR<SurveyDetailsCreateWithoutNonResidentialPropertyAssessmentsInput, SurveyDetailsUncheckedCreateWithoutNonResidentialPropertyAssessmentsInput>
    where?: SurveyDetailsWhereInput
  }

  export type SurveyDetailsUpdateToOneWithWhereWithoutNonResidentialPropertyAssessmentsInput = {
    where?: SurveyDetailsWhereInput
    data: XOR<SurveyDetailsUpdateWithoutNonResidentialPropertyAssessmentsInput, SurveyDetailsUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput>
  }

  export type SurveyDetailsUpdateWithoutNonResidentialPropertyAssessmentsInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    ulb?: UlbMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    zone?: ZoneMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    surveyType?: SurveyTypeMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    propertyDetails?: PropertyDetailsUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateWithoutNonResidentialPropertyAssessmentsInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDetails?: PropertyDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsCreateWithoutPropertyAttachmentsInput = {
    surveyUniqueCode?: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    ulb: UlbMasterCreateNestedOneWithoutSurveyDetailsInput
    zone: ZoneMasterCreateNestedOneWithoutSurveyDetailsInput
    ward: WardMasterCreateNestedOneWithoutSurveyDetailsInput
    mohalla: MohallaMasterCreateNestedOneWithoutSurveyDetailsInput
    surveyType: SurveyTypeMasterCreateNestedOneWithoutSurveyDetailsInput
    propertyDetails?: PropertyDetailsCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsUncheckedCreateWithoutPropertyAttachmentsInput = {
    surveyUniqueCode?: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
    propertyDetails?: PropertyDetailsUncheckedCreateNestedManyWithoutSurveyInput
    ownerDetails?: OwnerDetailsUncheckedCreateNestedManyWithoutSurveyInput
    locationDetails?: LocationDetailsUncheckedCreateNestedManyWithoutSurveyInput
    otherDetails?: OtherDetailsUncheckedCreateNestedManyWithoutSurveyInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedCreateNestedManyWithoutSurveyInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyDetailsCreateOrConnectWithoutPropertyAttachmentsInput = {
    where: SurveyDetailsWhereUniqueInput
    create: XOR<SurveyDetailsCreateWithoutPropertyAttachmentsInput, SurveyDetailsUncheckedCreateWithoutPropertyAttachmentsInput>
  }

  export type SurveyDetailsUpsertWithoutPropertyAttachmentsInput = {
    update: XOR<SurveyDetailsUpdateWithoutPropertyAttachmentsInput, SurveyDetailsUncheckedUpdateWithoutPropertyAttachmentsInput>
    create: XOR<SurveyDetailsCreateWithoutPropertyAttachmentsInput, SurveyDetailsUncheckedCreateWithoutPropertyAttachmentsInput>
    where?: SurveyDetailsWhereInput
  }

  export type SurveyDetailsUpdateToOneWithWhereWithoutPropertyAttachmentsInput = {
    where?: SurveyDetailsWhereInput
    data: XOR<SurveyDetailsUpdateWithoutPropertyAttachmentsInput, SurveyDetailsUncheckedUpdateWithoutPropertyAttachmentsInput>
  }

  export type SurveyDetailsUpdateWithoutPropertyAttachmentsInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    ulb?: UlbMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    zone?: ZoneMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    surveyType?: SurveyTypeMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    propertyDetails?: PropertyDetailsUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateWithoutPropertyAttachmentsInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDetails?: PropertyDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type UlbZoneMappingCreateManyUlbInput = {
    ulbZoneMapId?: string
    zoneId: string
    isActive?: boolean
  }

  export type SurveyDetailsCreateManyUlbInput = {
    surveyUniqueCode?: string
    zoneId: string
    wardId: string
    mohallaId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
  }

  export type UlbZoneMappingUpdateWithoutUlbInput = {
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    zone?: ZoneMasterUpdateOneRequiredWithoutUlbZoneMapsNestedInput
    surveyors?: SurveyorsUpdateManyWithoutUlbZoneMapNestedInput
  }

  export type UlbZoneMappingUncheckedUpdateWithoutUlbInput = {
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    surveyors?: SurveyorsUncheckedUpdateManyWithoutUlbZoneMapNestedInput
  }

  export type UlbZoneMappingUncheckedUpdateManyWithoutUlbInput = {
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyDetailsUpdateWithoutUlbInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    zone?: ZoneMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    surveyType?: SurveyTypeMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    propertyDetails?: PropertyDetailsUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateWithoutUlbInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDetails?: PropertyDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateManyWithoutUlbInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UlbZoneMappingCreateManyZoneInput = {
    ulbZoneMapId?: string
    ulbId: string
    isActive?: boolean
  }

  export type ZoneWardMappingCreateManyZoneInput = {
    zoneWardMapId?: string
    wardId: string
    isActive?: boolean
  }

  export type SurveyDetailsCreateManyZoneInput = {
    surveyUniqueCode?: string
    ulbId: string
    wardId: string
    mohallaId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
  }

  export type UlbZoneMappingUpdateWithoutZoneInput = {
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ulb?: UlbMasterUpdateOneRequiredWithoutUlbZoneMapsNestedInput
    surveyors?: SurveyorsUpdateManyWithoutUlbZoneMapNestedInput
  }

  export type UlbZoneMappingUncheckedUpdateWithoutZoneInput = {
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    surveyors?: SurveyorsUncheckedUpdateManyWithoutUlbZoneMapNestedInput
  }

  export type UlbZoneMappingUncheckedUpdateManyWithoutZoneInput = {
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ZoneWardMappingUpdateWithoutZoneInput = {
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ward?: WardMasterUpdateOneRequiredWithoutZoneWardMapsNestedInput
    surveyors?: SurveyorsUpdateManyWithoutZoneWardMapNestedInput
  }

  export type ZoneWardMappingUncheckedUpdateWithoutZoneInput = {
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    surveyors?: SurveyorsUncheckedUpdateManyWithoutZoneWardMapNestedInput
  }

  export type ZoneWardMappingUncheckedUpdateManyWithoutZoneInput = {
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyDetailsUpdateWithoutZoneInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    ulb?: UlbMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    surveyType?: SurveyTypeMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    propertyDetails?: PropertyDetailsUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateWithoutZoneInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDetails?: PropertyDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateManyWithoutZoneInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ZoneWardMappingCreateManyWardInput = {
    zoneWardMapId?: string
    zoneId: string
    isActive?: boolean
  }

  export type WardMohallaMappingCreateManyWardInput = {
    wardMohallaMapId?: string
    mohallaId: string
    isActive?: boolean
  }

  export type SurveyorAssignmentCreateManyWardInput = {
    assignmentId?: string
    userId: string
    assignmentType: string
    mohallaId: string
    wardMohallaMapId: string
    assignedById: string
    isActive?: boolean
  }

  export type WardStatusMappingCreateManyWardInput = {
    wardStatusId?: string
    statusId: string
    changedById: string
    isActive?: boolean
  }

  export type SurveyDetailsCreateManyWardInput = {
    surveyUniqueCode?: string
    ulbId: string
    zoneId: string
    mohallaId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
  }

  export type SupervisorsCreateManyWardInput = {
    userId: string
    supervisorName: string
    username: string
    password: string
  }

  export type ZoneWardMappingUpdateWithoutWardInput = {
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    zone?: ZoneMasterUpdateOneRequiredWithoutZoneWardMapsNestedInput
    surveyors?: SurveyorsUpdateManyWithoutZoneWardMapNestedInput
  }

  export type ZoneWardMappingUncheckedUpdateWithoutWardInput = {
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    surveyors?: SurveyorsUncheckedUpdateManyWithoutZoneWardMapNestedInput
  }

  export type ZoneWardMappingUncheckedUpdateManyWithoutWardInput = {
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WardMohallaMappingUpdateWithoutWardInput = {
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mohalla?: MohallaMasterUpdateOneRequiredWithoutWardMohallaMapsNestedInput
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutWardMohallaMapNestedInput
    surveyors?: SurveyorsUpdateManyWithoutWardMohallaMapNestedInput
  }

  export type WardMohallaMappingUncheckedUpdateWithoutWardInput = {
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutWardMohallaMapNestedInput
    surveyors?: SurveyorsUncheckedUpdateManyWithoutWardMohallaMapNestedInput
  }

  export type WardMohallaMappingUncheckedUpdateManyWithoutWardInput = {
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyorAssignmentUpdateWithoutWardInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UsersMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    wardMohallaMap?: WardMohallaMappingUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    assignedBy?: UsersMasterUpdateOneRequiredWithoutSurveyorAssignmentsAssignedByNestedInput
  }

  export type SurveyorAssignmentUncheckedUpdateWithoutWardInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyorAssignmentUncheckedUpdateManyWithoutWardInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WardStatusMappingUpdateWithoutWardInput = {
    wardStatusId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: WardStatusMasterUpdateOneRequiredWithoutWardStatusMapsNestedInput
    changedBy?: UsersMasterUpdateOneRequiredWithoutWardStatusMapsNestedInput
  }

  export type WardStatusMappingUncheckedUpdateWithoutWardInput = {
    wardStatusId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    changedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WardStatusMappingUncheckedUpdateManyWithoutWardInput = {
    wardStatusId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    changedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyDetailsUpdateWithoutWardInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    ulb?: UlbMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    zone?: ZoneMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    surveyType?: SurveyTypeMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    propertyDetails?: PropertyDetailsUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateWithoutWardInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDetails?: PropertyDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateManyWithoutWardInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupervisorsUpdateWithoutWardInput = {
    supervisorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user?: UsersMasterUpdateOneRequiredWithoutSupervisorsNestedInput
  }

  export type SupervisorsUncheckedUpdateWithoutWardInput = {
    userId?: StringFieldUpdateOperationsInput | string
    supervisorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type SupervisorsUncheckedUpdateManyWithoutWardInput = {
    userId?: StringFieldUpdateOperationsInput | string
    supervisorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type WardMohallaMappingCreateManyMohallaInput = {
    wardMohallaMapId?: string
    wardId: string
    isActive?: boolean
  }

  export type SurveyorAssignmentCreateManyMohallaInput = {
    assignmentId?: string
    userId: string
    assignmentType: string
    wardId: string
    wardMohallaMapId: string
    assignedById: string
    isActive?: boolean
  }

  export type SurveyDetailsCreateManyMohallaInput = {
    surveyUniqueCode?: string
    ulbId: string
    zoneId: string
    wardId: string
    surveyTypeId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
  }

  export type WardMohallaMappingUpdateWithoutMohallaInput = {
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ward?: WardMasterUpdateOneRequiredWithoutWardMohallaMapsNestedInput
    surveyorAssignments?: SurveyorAssignmentUpdateManyWithoutWardMohallaMapNestedInput
    surveyors?: SurveyorsUpdateManyWithoutWardMohallaMapNestedInput
  }

  export type WardMohallaMappingUncheckedUpdateWithoutMohallaInput = {
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    surveyorAssignments?: SurveyorAssignmentUncheckedUpdateManyWithoutWardMohallaMapNestedInput
    surveyors?: SurveyorsUncheckedUpdateManyWithoutWardMohallaMapNestedInput
  }

  export type WardMohallaMappingUncheckedUpdateManyWithoutMohallaInput = {
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyorAssignmentUpdateWithoutMohallaInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UsersMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    wardMohallaMap?: WardMohallaMappingUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    assignedBy?: UsersMasterUpdateOneRequiredWithoutSurveyorAssignmentsAssignedByNestedInput
  }

  export type SurveyorAssignmentUncheckedUpdateWithoutMohallaInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyorAssignmentUncheckedUpdateManyWithoutMohallaInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyDetailsUpdateWithoutMohallaInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    ulb?: UlbMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    zone?: ZoneMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    surveyType?: SurveyTypeMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    propertyDetails?: PropertyDetailsUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateWithoutMohallaInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDetails?: PropertyDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateManyWithoutMohallaInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    surveyTypeId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyDetailsCreateManyResponseTypeInput = {
    surveyUniqueCode: string
    oldHouseNumber?: string | null
    electricityConsumerName?: string | null
    waterSewerageConnectionNumber?: string | null
    respondentName: string
    respondentStatusId: string
  }

  export type PropertyDetailsUpdateWithoutResponseTypeInput = {
    oldHouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    electricityConsumerName?: NullableStringFieldUpdateOperationsInput | string | null
    waterSewerageConnectionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    respondentName?: StringFieldUpdateOperationsInput | string
    survey?: SurveyDetailsUpdateOneRequiredWithoutPropertyDetailsNestedInput
    respondentStatus?: RespondentStatusMasterUpdateOneRequiredWithoutPropertyDetailsNestedInput
  }

  export type PropertyDetailsUncheckedUpdateWithoutResponseTypeInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    oldHouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    electricityConsumerName?: NullableStringFieldUpdateOperationsInput | string | null
    waterSewerageConnectionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    respondentName?: StringFieldUpdateOperationsInput | string
    respondentStatusId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyDetailsUncheckedUpdateManyWithoutResponseTypeInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    oldHouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    electricityConsumerName?: NullableStringFieldUpdateOperationsInput | string | null
    waterSewerageConnectionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    respondentName?: StringFieldUpdateOperationsInput | string
    respondentStatusId?: StringFieldUpdateOperationsInput | string
  }

  export type LocationDetailsCreateManyPropertyTypeInput = {
    surveyUniqueCode: string
    propertyLatitude: Decimal | DecimalJsLike | number | string
    propertyLongitude: Decimal | DecimalJsLike | number | string
    assessmentYear: string
    buildingName?: string | null
    roadTypeId: string
    constructionYear: string
    constructionTypeId: string
    addressRoadName: string
    locality?: string | null
    pinCode: number
    landmark?: string | null
    fourWayEast?: string | null
    fourWayWest?: string | null
    fourWayNorth?: string | null
    fourWaySouth?: string | null
    newWard: string
  }

  export type LocationDetailsUpdateWithoutPropertyTypeInput = {
    propertyLatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    constructionYear?: StringFieldUpdateOperationsInput | string
    addressRoadName?: StringFieldUpdateOperationsInput | string
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: IntFieldUpdateOperationsInput | number
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayEast?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayWest?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayNorth?: NullableStringFieldUpdateOperationsInput | string | null
    fourWaySouth?: NullableStringFieldUpdateOperationsInput | string | null
    newWard?: StringFieldUpdateOperationsInput | string
    survey?: SurveyDetailsUpdateOneRequiredWithoutLocationDetailsNestedInput
    roadType?: RoadTypeMasterUpdateOneRequiredWithoutLocationDetailsNestedInput
    constructionType?: ConstructionTypeMasterUpdateOneRequiredWithoutLocationDetailsNestedInput
  }

  export type LocationDetailsUncheckedUpdateWithoutPropertyTypeInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    propertyLatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    roadTypeId?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    addressRoadName?: StringFieldUpdateOperationsInput | string
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: IntFieldUpdateOperationsInput | number
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayEast?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayWest?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayNorth?: NullableStringFieldUpdateOperationsInput | string | null
    fourWaySouth?: NullableStringFieldUpdateOperationsInput | string | null
    newWard?: StringFieldUpdateOperationsInput | string
  }

  export type LocationDetailsUncheckedUpdateManyWithoutPropertyTypeInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    propertyLatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    roadTypeId?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    addressRoadName?: StringFieldUpdateOperationsInput | string
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: IntFieldUpdateOperationsInput | number
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayEast?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayWest?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayNorth?: NullableStringFieldUpdateOperationsInput | string | null
    fourWaySouth?: NullableStringFieldUpdateOperationsInput | string | null
    newWard?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyDetailsCreateManyRespondentStatusInput = {
    surveyUniqueCode: string
    responseTypeId: string
    oldHouseNumber?: string | null
    electricityConsumerName?: string | null
    waterSewerageConnectionNumber?: string | null
    respondentName: string
  }

  export type PropertyDetailsUpdateWithoutRespondentStatusInput = {
    oldHouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    electricityConsumerName?: NullableStringFieldUpdateOperationsInput | string | null
    waterSewerageConnectionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    respondentName?: StringFieldUpdateOperationsInput | string
    survey?: SurveyDetailsUpdateOneRequiredWithoutPropertyDetailsNestedInput
    responseType?: ResponseTypeMasterUpdateOneRequiredWithoutPropertyDetailsNestedInput
  }

  export type PropertyDetailsUncheckedUpdateWithoutRespondentStatusInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    responseTypeId?: StringFieldUpdateOperationsInput | string
    oldHouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    electricityConsumerName?: NullableStringFieldUpdateOperationsInput | string | null
    waterSewerageConnectionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    respondentName?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyDetailsUncheckedUpdateManyWithoutRespondentStatusInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    responseTypeId?: StringFieldUpdateOperationsInput | string
    oldHouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    electricityConsumerName?: NullableStringFieldUpdateOperationsInput | string | null
    waterSewerageConnectionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    respondentName?: StringFieldUpdateOperationsInput | string
  }

  export type LocationDetailsCreateManyRoadTypeInput = {
    surveyUniqueCode: string
    propertyLatitude: Decimal | DecimalJsLike | number | string
    propertyLongitude: Decimal | DecimalJsLike | number | string
    assessmentYear: string
    propertyTypeId: string
    buildingName?: string | null
    constructionYear: string
    constructionTypeId: string
    addressRoadName: string
    locality?: string | null
    pinCode: number
    landmark?: string | null
    fourWayEast?: string | null
    fourWayWest?: string | null
    fourWayNorth?: string | null
    fourWaySouth?: string | null
    newWard: string
  }

  export type LocationDetailsUpdateWithoutRoadTypeInput = {
    propertyLatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    constructionYear?: StringFieldUpdateOperationsInput | string
    addressRoadName?: StringFieldUpdateOperationsInput | string
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: IntFieldUpdateOperationsInput | number
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayEast?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayWest?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayNorth?: NullableStringFieldUpdateOperationsInput | string | null
    fourWaySouth?: NullableStringFieldUpdateOperationsInput | string | null
    newWard?: StringFieldUpdateOperationsInput | string
    survey?: SurveyDetailsUpdateOneRequiredWithoutLocationDetailsNestedInput
    propertyType?: PropertyTypeMasterUpdateOneRequiredWithoutLocationDetailsNestedInput
    constructionType?: ConstructionTypeMasterUpdateOneRequiredWithoutLocationDetailsNestedInput
  }

  export type LocationDetailsUncheckedUpdateWithoutRoadTypeInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    propertyLatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFieldUpdateOperationsInput | string
    propertyTypeId?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    constructionYear?: StringFieldUpdateOperationsInput | string
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    addressRoadName?: StringFieldUpdateOperationsInput | string
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: IntFieldUpdateOperationsInput | number
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayEast?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayWest?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayNorth?: NullableStringFieldUpdateOperationsInput | string | null
    fourWaySouth?: NullableStringFieldUpdateOperationsInput | string | null
    newWard?: StringFieldUpdateOperationsInput | string
  }

  export type LocationDetailsUncheckedUpdateManyWithoutRoadTypeInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    propertyLatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFieldUpdateOperationsInput | string
    propertyTypeId?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    constructionYear?: StringFieldUpdateOperationsInput | string
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    addressRoadName?: StringFieldUpdateOperationsInput | string
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: IntFieldUpdateOperationsInput | number
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayEast?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayWest?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayNorth?: NullableStringFieldUpdateOperationsInput | string | null
    fourWaySouth?: NullableStringFieldUpdateOperationsInput | string | null
    newWard?: StringFieldUpdateOperationsInput | string
  }

  export type LocationDetailsCreateManyConstructionTypeInput = {
    surveyUniqueCode: string
    propertyLatitude: Decimal | DecimalJsLike | number | string
    propertyLongitude: Decimal | DecimalJsLike | number | string
    assessmentYear: string
    propertyTypeId: string
    buildingName?: string | null
    roadTypeId: string
    constructionYear: string
    addressRoadName: string
    locality?: string | null
    pinCode: number
    landmark?: string | null
    fourWayEast?: string | null
    fourWayWest?: string | null
    fourWayNorth?: string | null
    fourWaySouth?: string | null
    newWard: string
  }

  export type LocationDetailsUpdateWithoutConstructionTypeInput = {
    propertyLatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    constructionYear?: StringFieldUpdateOperationsInput | string
    addressRoadName?: StringFieldUpdateOperationsInput | string
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: IntFieldUpdateOperationsInput | number
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayEast?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayWest?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayNorth?: NullableStringFieldUpdateOperationsInput | string | null
    fourWaySouth?: NullableStringFieldUpdateOperationsInput | string | null
    newWard?: StringFieldUpdateOperationsInput | string
    survey?: SurveyDetailsUpdateOneRequiredWithoutLocationDetailsNestedInput
    propertyType?: PropertyTypeMasterUpdateOneRequiredWithoutLocationDetailsNestedInput
    roadType?: RoadTypeMasterUpdateOneRequiredWithoutLocationDetailsNestedInput
  }

  export type LocationDetailsUncheckedUpdateWithoutConstructionTypeInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    propertyLatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFieldUpdateOperationsInput | string
    propertyTypeId?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    roadTypeId?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    addressRoadName?: StringFieldUpdateOperationsInput | string
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: IntFieldUpdateOperationsInput | number
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayEast?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayWest?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayNorth?: NullableStringFieldUpdateOperationsInput | string | null
    fourWaySouth?: NullableStringFieldUpdateOperationsInput | string | null
    newWard?: StringFieldUpdateOperationsInput | string
  }

  export type LocationDetailsUncheckedUpdateManyWithoutConstructionTypeInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    propertyLatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFieldUpdateOperationsInput | string
    propertyTypeId?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    roadTypeId?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    addressRoadName?: StringFieldUpdateOperationsInput | string
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: IntFieldUpdateOperationsInput | number
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayEast?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayWest?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayNorth?: NullableStringFieldUpdateOperationsInput | string | null
    fourWaySouth?: NullableStringFieldUpdateOperationsInput | string | null
    newWard?: StringFieldUpdateOperationsInput | string
  }

  export type OtherDetailsCreateManyWaterSourceInput = {
    surveyUniqueCode: string
    rainWaterHarvestingSystem?: string | null
    plantation?: string | null
    parking?: string | null
    pollution?: string | null
    pollutionMeasurementTaken?: string | null
    waterSupplyWithin200Meters?: string | null
    sewerageLineWithin100Meters?: string | null
    disposalTypeId: string
    totalPlotArea: number
    builtupAreaOfGroundFloor: number
    remarks?: string | null
  }

  export type OtherDetailsUpdateWithoutWaterSourceInput = {
    rainWaterHarvestingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    plantation?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: NullableStringFieldUpdateOperationsInput | string | null
    pollution?: NullableStringFieldUpdateOperationsInput | string | null
    pollutionMeasurementTaken?: NullableStringFieldUpdateOperationsInput | string | null
    waterSupplyWithin200Meters?: NullableStringFieldUpdateOperationsInput | string | null
    sewerageLineWithin100Meters?: NullableStringFieldUpdateOperationsInput | string | null
    totalPlotArea?: FloatFieldUpdateOperationsInput | number
    builtupAreaOfGroundFloor?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    survey?: SurveyDetailsUpdateOneRequiredWithoutOtherDetailsNestedInput
    disposalType?: DisposalTypeMasterUpdateOneRequiredWithoutOtherDetailsNestedInput
  }

  export type OtherDetailsUncheckedUpdateWithoutWaterSourceInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    rainWaterHarvestingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    plantation?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: NullableStringFieldUpdateOperationsInput | string | null
    pollution?: NullableStringFieldUpdateOperationsInput | string | null
    pollutionMeasurementTaken?: NullableStringFieldUpdateOperationsInput | string | null
    waterSupplyWithin200Meters?: NullableStringFieldUpdateOperationsInput | string | null
    sewerageLineWithin100Meters?: NullableStringFieldUpdateOperationsInput | string | null
    disposalTypeId?: StringFieldUpdateOperationsInput | string
    totalPlotArea?: FloatFieldUpdateOperationsInput | number
    builtupAreaOfGroundFloor?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OtherDetailsUncheckedUpdateManyWithoutWaterSourceInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    rainWaterHarvestingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    plantation?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: NullableStringFieldUpdateOperationsInput | string | null
    pollution?: NullableStringFieldUpdateOperationsInput | string | null
    pollutionMeasurementTaken?: NullableStringFieldUpdateOperationsInput | string | null
    waterSupplyWithin200Meters?: NullableStringFieldUpdateOperationsInput | string | null
    sewerageLineWithin100Meters?: NullableStringFieldUpdateOperationsInput | string | null
    disposalTypeId?: StringFieldUpdateOperationsInput | string
    totalPlotArea?: FloatFieldUpdateOperationsInput | number
    builtupAreaOfGroundFloor?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OtherDetailsCreateManyDisposalTypeInput = {
    surveyUniqueCode: string
    waterSourceId: string
    rainWaterHarvestingSystem?: string | null
    plantation?: string | null
    parking?: string | null
    pollution?: string | null
    pollutionMeasurementTaken?: string | null
    waterSupplyWithin200Meters?: string | null
    sewerageLineWithin100Meters?: string | null
    totalPlotArea: number
    builtupAreaOfGroundFloor: number
    remarks?: string | null
  }

  export type OtherDetailsUpdateWithoutDisposalTypeInput = {
    rainWaterHarvestingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    plantation?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: NullableStringFieldUpdateOperationsInput | string | null
    pollution?: NullableStringFieldUpdateOperationsInput | string | null
    pollutionMeasurementTaken?: NullableStringFieldUpdateOperationsInput | string | null
    waterSupplyWithin200Meters?: NullableStringFieldUpdateOperationsInput | string | null
    sewerageLineWithin100Meters?: NullableStringFieldUpdateOperationsInput | string | null
    totalPlotArea?: FloatFieldUpdateOperationsInput | number
    builtupAreaOfGroundFloor?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    survey?: SurveyDetailsUpdateOneRequiredWithoutOtherDetailsNestedInput
    waterSource?: WaterSourceMasterUpdateOneRequiredWithoutOtherDetailsNestedInput
  }

  export type OtherDetailsUncheckedUpdateWithoutDisposalTypeInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    waterSourceId?: StringFieldUpdateOperationsInput | string
    rainWaterHarvestingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    plantation?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: NullableStringFieldUpdateOperationsInput | string | null
    pollution?: NullableStringFieldUpdateOperationsInput | string | null
    pollutionMeasurementTaken?: NullableStringFieldUpdateOperationsInput | string | null
    waterSupplyWithin200Meters?: NullableStringFieldUpdateOperationsInput | string | null
    sewerageLineWithin100Meters?: NullableStringFieldUpdateOperationsInput | string | null
    totalPlotArea?: FloatFieldUpdateOperationsInput | number
    builtupAreaOfGroundFloor?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OtherDetailsUncheckedUpdateManyWithoutDisposalTypeInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    waterSourceId?: StringFieldUpdateOperationsInput | string
    rainWaterHarvestingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    plantation?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: NullableStringFieldUpdateOperationsInput | string | null
    pollution?: NullableStringFieldUpdateOperationsInput | string | null
    pollutionMeasurementTaken?: NullableStringFieldUpdateOperationsInput | string | null
    waterSupplyWithin200Meters?: NullableStringFieldUpdateOperationsInput | string | null
    sewerageLineWithin100Meters?: NullableStringFieldUpdateOperationsInput | string | null
    totalPlotArea?: FloatFieldUpdateOperationsInput | number
    builtupAreaOfGroundFloor?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NrPropertySubCategoryMasterCreateManyPropertyCategoryInput = {
    subCategoryId?: string
    subCategoryNumber: number
    subCategoryName: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
  }

  export type NonResidentialPropertyAssessmentCreateManyNrPropertyCategoryInput = {
    floorAssessmentId?: string
    surveyUniqueCode: string
    floorNumber: string
    nrSubCategoryId: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    occupancyStatusId: string
    constructionNatureId: string
    builtupArea: Decimal | DecimalJsLike | number | string
  }

  export type NrPropertySubCategoryMasterUpdateWithoutPropertyCategoryInput = {
    subCategoryId?: StringFieldUpdateOperationsInput | string
    subCategoryNumber?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutNrSubCategoryNestedInput
  }

  export type NrPropertySubCategoryMasterUncheckedUpdateWithoutPropertyCategoryInput = {
    subCategoryId?: StringFieldUpdateOperationsInput | string
    subCategoryNumber?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutNrSubCategoryNestedInput
  }

  export type NrPropertySubCategoryMasterUncheckedUpdateManyWithoutPropertyCategoryInput = {
    subCategoryId?: StringFieldUpdateOperationsInput | string
    subCategoryNumber?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NonResidentialPropertyAssessmentUpdateWithoutNrPropertyCategoryInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nrSubCategory?: NrPropertySubCategoryMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    occupancyStatus?: OccupancyStatusMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    constructionNature?: ConstructionNatureMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    survey?: SurveyDetailsUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
  }

  export type NonResidentialPropertyAssessmentUncheckedUpdateWithoutNrPropertyCategoryInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    nrSubCategoryId?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutNrPropertyCategoryInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    nrSubCategoryId?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentCreateManyNrSubCategoryInput = {
    floorAssessmentId?: string
    surveyUniqueCode: string
    floorNumber: string
    nrPropertyCategoryId: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    occupancyStatusId: string
    constructionNatureId: string
    builtupArea: Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentUpdateWithoutNrSubCategoryInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nrPropertyCategory?: NrPropertyCategoryMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    occupancyStatus?: OccupancyStatusMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    constructionNature?: ConstructionNatureMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    survey?: SurveyDetailsUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
  }

  export type NonResidentialPropertyAssessmentUncheckedUpdateWithoutNrSubCategoryInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    nrPropertyCategoryId?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutNrSubCategoryInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    nrPropertyCategoryId?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ResidentialPropertyAssessmentCreateManyConstructionNatureInput = {
    floorAssessmentId?: string
    surveyUniqueCode: string
    floorNumber: string
    occupancyStatusId: string
    coveredArea: Decimal | DecimalJsLike | number | string
    allRoomVerandaArea: Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea: Decimal | DecimalJsLike | number | string
    allGarageArea: Decimal | DecimalJsLike | number | string
    carpetArea: Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentCreateManyConstructionNatureInput = {
    floorAssessmentId?: string
    surveyUniqueCode: string
    floorNumber: string
    nrPropertyCategoryId: string
    nrSubCategoryId: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    occupancyStatusId: string
    builtupArea: Decimal | DecimalJsLike | number | string
  }

  export type ResidentialPropertyAssessmentUpdateWithoutConstructionNatureInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    coveredArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allRoomVerandaArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allGarageArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carpetArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    survey?: SurveyDetailsUpdateOneRequiredWithoutResidentialPropertyAssessmentsNestedInput
    occupancyStatus?: OccupancyStatusMasterUpdateOneRequiredWithoutResidentialPropertyAssessmentsNestedInput
  }

  export type ResidentialPropertyAssessmentUncheckedUpdateWithoutConstructionNatureInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    coveredArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allRoomVerandaArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allGarageArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carpetArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ResidentialPropertyAssessmentUncheckedUpdateManyWithoutConstructionNatureInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    coveredArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allRoomVerandaArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allGarageArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carpetArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentUpdateWithoutConstructionNatureInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nrPropertyCategory?: NrPropertyCategoryMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    nrSubCategory?: NrPropertySubCategoryMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    occupancyStatus?: OccupancyStatusMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    survey?: SurveyDetailsUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
  }

  export type NonResidentialPropertyAssessmentUncheckedUpdateWithoutConstructionNatureInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    nrPropertyCategoryId?: StringFieldUpdateOperationsInput | string
    nrSubCategoryId?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutConstructionNatureInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    nrPropertyCategoryId?: StringFieldUpdateOperationsInput | string
    nrSubCategoryId?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SurveyDetailsCreateManySurveyTypeInput = {
    surveyUniqueCode?: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    entryDate: Date | string
    parcelId?: number | null
    mapId: number
    gisId: string
    subGisId?: string | null
  }

  export type SurveyDetailsUpdateWithoutSurveyTypeInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    ulb?: UlbMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    zone?: ZoneMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyDetailsNestedInput
    propertyDetails?: PropertyDetailsUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateWithoutSurveyTypeInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDetails?: PropertyDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    ownerDetails?: OwnerDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    locationDetails?: LocationDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    otherDetails?: OtherDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    residentialPropertyAssessments?: ResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    nonResidentialPropertyAssessments?: NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyNestedInput
    propertyAttachments?: PropertyAttachmentDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    surveyStatusMaps?: SurveyStatusMappingUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyDetailsUncheckedUpdateManyWithoutSurveyTypeInput = {
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    parcelId?: NullableIntFieldUpdateOperationsInput | number | null
    mapId?: IntFieldUpdateOperationsInput | number
    gisId?: StringFieldUpdateOperationsInput | string
    subGisId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResidentialPropertyAssessmentCreateManyOccupancyStatusInput = {
    floorAssessmentId?: string
    surveyUniqueCode: string
    floorNumber: string
    constructionNatureId: string
    coveredArea: Decimal | DecimalJsLike | number | string
    allRoomVerandaArea: Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea: Decimal | DecimalJsLike | number | string
    allGarageArea: Decimal | DecimalJsLike | number | string
    carpetArea: Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentCreateManyOccupancyStatusInput = {
    floorAssessmentId?: string
    surveyUniqueCode: string
    floorNumber: string
    nrPropertyCategoryId: string
    nrSubCategoryId: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    constructionNatureId: string
    builtupArea: Decimal | DecimalJsLike | number | string
  }

  export type ResidentialPropertyAssessmentUpdateWithoutOccupancyStatusInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    coveredArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allRoomVerandaArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allGarageArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carpetArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    survey?: SurveyDetailsUpdateOneRequiredWithoutResidentialPropertyAssessmentsNestedInput
    constructionNature?: ConstructionNatureMasterUpdateOneRequiredWithoutResidentialPropertyAssessmentsNestedInput
  }

  export type ResidentialPropertyAssessmentUncheckedUpdateWithoutOccupancyStatusInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    coveredArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allRoomVerandaArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allGarageArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carpetArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ResidentialPropertyAssessmentUncheckedUpdateManyWithoutOccupancyStatusInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    coveredArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allRoomVerandaArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allGarageArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carpetArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentUpdateWithoutOccupancyStatusInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nrPropertyCategory?: NrPropertyCategoryMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    nrSubCategory?: NrPropertySubCategoryMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    constructionNature?: ConstructionNatureMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    survey?: SurveyDetailsUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
  }

  export type NonResidentialPropertyAssessmentUncheckedUpdateWithoutOccupancyStatusInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    nrPropertyCategoryId?: StringFieldUpdateOperationsInput | string
    nrSubCategoryId?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutOccupancyStatusInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    nrPropertyCategoryId?: StringFieldUpdateOperationsInput | string
    nrSubCategoryId?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SurveyStatusMappingCreateManyStatusInput = {
    statusMappingId?: string
    surveyUniqueCode: string
    revertedFromId?: string | null
    changedById: string
    isActive?: boolean
  }

  export type SurveyStatusMappingCreateManyRevertedFromInput = {
    statusMappingId?: string
    surveyUniqueCode: string
    statusId: string
    changedById: string
    isActive?: boolean
  }

  export type SurveyStatusMappingUpdateWithoutStatusInput = {
    statusMappingId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    survey?: SurveyDetailsUpdateOneRequiredWithoutSurveyStatusMapsNestedInput
    revertedFrom?: SurveyStatusMasterUpdateOneWithoutSurveyStatusMapsRevertedNestedInput
    changedBy?: UsersMasterUpdateOneRequiredWithoutSurveyStatusMapsNestedInput
  }

  export type SurveyStatusMappingUncheckedUpdateWithoutStatusInput = {
    statusMappingId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    revertedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyStatusMappingUncheckedUpdateManyWithoutStatusInput = {
    statusMappingId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    revertedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyStatusMappingUpdateWithoutRevertedFromInput = {
    statusMappingId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    survey?: SurveyDetailsUpdateOneRequiredWithoutSurveyStatusMapsNestedInput
    status?: SurveyStatusMasterUpdateOneRequiredWithoutSurveyStatusMapsNestedInput
    changedBy?: UsersMasterUpdateOneRequiredWithoutSurveyStatusMapsNestedInput
  }

  export type SurveyStatusMappingUncheckedUpdateWithoutRevertedFromInput = {
    statusMappingId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    changedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyStatusMappingUncheckedUpdateManyWithoutRevertedFromInput = {
    statusMappingId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    changedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WardStatusMappingCreateManyStatusInput = {
    wardStatusId?: string
    wardId: string
    changedById: string
    isActive?: boolean
  }

  export type WardStatusMappingUpdateWithoutStatusInput = {
    wardStatusId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ward?: WardMasterUpdateOneRequiredWithoutWardStatusMapsNestedInput
    changedBy?: UsersMasterUpdateOneRequiredWithoutWardStatusMapsNestedInput
  }

  export type WardStatusMappingUncheckedUpdateWithoutStatusInput = {
    wardStatusId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    changedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WardStatusMappingUncheckedUpdateManyWithoutStatusInput = {
    wardStatusId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    changedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyorAssignmentCreateManyUserInput = {
    assignmentId?: string
    assignmentType: string
    wardId: string
    mohallaId: string
    wardMohallaMapId: string
    assignedById: string
    isActive?: boolean
  }

  export type SurveyorAssignmentCreateManyAssignedByInput = {
    assignmentId?: string
    userId: string
    assignmentType: string
    wardId: string
    mohallaId: string
    wardMohallaMapId: string
    isActive?: boolean
  }

  export type WardStatusMappingCreateManyChangedByInput = {
    wardStatusId?: string
    wardId: string
    statusId: string
    isActive?: boolean
  }

  export type SurveyStatusMappingCreateManyChangedByInput = {
    statusMappingId?: string
    surveyUniqueCode: string
    statusId: string
    revertedFromId?: string | null
    isActive?: boolean
  }

  export type UserRoleMappingCreateManyUserInput = {
    userRoleMapId?: string
    roleId: string
    isActive?: boolean
  }

  export type SessionCreateManyUserInput = {
    sessionId?: string
    loginTime: Date | string
    logoutTime: Date | string
    isActive?: boolean
  }

  export type SurveyorsCreateManyUserInput = {
    surveyorName: string
    username: string
    password: string
    wardNumber: string
    wardMohallaMapId: string
    zoneWardMapId: string
    ulbZoneMapId: string
  }

  export type SupervisorsCreateManyUserInput = {
    supervisorName: string
    username: string
    password: string
    wardId: string
  }

  export type AdminsCreateManyUserInput = {
    adminName: string
    username: string
    password: string
  }

  export type SurveyorAssignmentUpdateWithoutUserInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ward?: WardMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    wardMohallaMap?: WardMohallaMappingUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    assignedBy?: UsersMasterUpdateOneRequiredWithoutSurveyorAssignmentsAssignedByNestedInput
  }

  export type SurveyorAssignmentUncheckedUpdateWithoutUserInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyorAssignmentUncheckedUpdateManyWithoutUserInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyorAssignmentUpdateWithoutAssignedByInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UsersMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    wardMohallaMap?: WardMohallaMappingUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
  }

  export type SurveyorAssignmentUncheckedUpdateWithoutAssignedByInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyorAssignmentUncheckedUpdateManyWithoutAssignedByInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WardStatusMappingUpdateWithoutChangedByInput = {
    wardStatusId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ward?: WardMasterUpdateOneRequiredWithoutWardStatusMapsNestedInput
    status?: WardStatusMasterUpdateOneRequiredWithoutWardStatusMapsNestedInput
  }

  export type WardStatusMappingUncheckedUpdateWithoutChangedByInput = {
    wardStatusId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WardStatusMappingUncheckedUpdateManyWithoutChangedByInput = {
    wardStatusId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyStatusMappingUpdateWithoutChangedByInput = {
    statusMappingId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    survey?: SurveyDetailsUpdateOneRequiredWithoutSurveyStatusMapsNestedInput
    status?: SurveyStatusMasterUpdateOneRequiredWithoutSurveyStatusMapsNestedInput
    revertedFrom?: SurveyStatusMasterUpdateOneWithoutSurveyStatusMapsRevertedNestedInput
  }

  export type SurveyStatusMappingUncheckedUpdateWithoutChangedByInput = {
    statusMappingId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    revertedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyStatusMappingUncheckedUpdateManyWithoutChangedByInput = {
    statusMappingId?: StringFieldUpdateOperationsInput | string
    surveyUniqueCode?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    revertedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserRoleMappingUpdateWithoutUserInput = {
    userRoleMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: RolePermissionMasterUpdateOneRequiredWithoutUserRoleMapsNestedInput
  }

  export type UserRoleMappingUncheckedUpdateWithoutUserInput = {
    userRoleMapId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserRoleMappingUncheckedUpdateManyWithoutUserInput = {
    userRoleMapId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUpdateWithoutUserInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyorsUpdateWithoutUserInput = {
    surveyorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    wardMohallaMap?: WardMohallaMappingUpdateOneRequiredWithoutSurveyorsNestedInput
    zoneWardMap?: ZoneWardMappingUpdateOneRequiredWithoutSurveyorsNestedInput
    ulbZoneMap?: UlbZoneMappingUpdateOneRequiredWithoutSurveyorsNestedInput
  }

  export type SurveyorsUncheckedUpdateWithoutUserInput = {
    surveyorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyorsUncheckedUpdateManyWithoutUserInput = {
    surveyorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
  }

  export type SupervisorsUpdateWithoutUserInput = {
    supervisorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ward?: WardMasterUpdateOneRequiredWithoutSupervisorsNestedInput
  }

  export type SupervisorsUncheckedUpdateWithoutUserInput = {
    supervisorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
  }

  export type SupervisorsUncheckedUpdateManyWithoutUserInput = {
    supervisorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminsUpdateWithoutUserInput = {
    adminName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type AdminsUncheckedUpdateWithoutUserInput = {
    adminName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type AdminsUncheckedUpdateManyWithoutUserInput = {
    adminName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleMappingCreateManyRoleInput = {
    userRoleMapId?: string
    userId: string
    isActive?: boolean
  }

  export type UserRoleMappingUpdateWithoutRoleInput = {
    userRoleMapId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UsersMasterUpdateOneRequiredWithoutUserRoleMapsNestedInput
  }

  export type UserRoleMappingUncheckedUpdateWithoutRoleInput = {
    userRoleMapId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserRoleMappingUncheckedUpdateManyWithoutRoleInput = {
    userRoleMapId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyorsCreateManyUlbZoneMapInput = {
    userId: string
    surveyorName: string
    username: string
    password: string
    wardNumber: string
    wardMohallaMapId: string
    zoneWardMapId: string
  }

  export type SurveyorsUpdateWithoutUlbZoneMapInput = {
    surveyorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    user?: UsersMasterUpdateOneRequiredWithoutSurveyorsNestedInput
    wardMohallaMap?: WardMohallaMappingUpdateOneRequiredWithoutSurveyorsNestedInput
    zoneWardMap?: ZoneWardMappingUpdateOneRequiredWithoutSurveyorsNestedInput
  }

  export type SurveyorsUncheckedUpdateWithoutUlbZoneMapInput = {
    userId?: StringFieldUpdateOperationsInput | string
    surveyorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyorsUncheckedUpdateManyWithoutUlbZoneMapInput = {
    userId?: StringFieldUpdateOperationsInput | string
    surveyorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyorsCreateManyZoneWardMapInput = {
    userId: string
    surveyorName: string
    username: string
    password: string
    wardNumber: string
    wardMohallaMapId: string
    ulbZoneMapId: string
  }

  export type SurveyorsUpdateWithoutZoneWardMapInput = {
    surveyorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    user?: UsersMasterUpdateOneRequiredWithoutSurveyorsNestedInput
    wardMohallaMap?: WardMohallaMappingUpdateOneRequiredWithoutSurveyorsNestedInput
    ulbZoneMap?: UlbZoneMappingUpdateOneRequiredWithoutSurveyorsNestedInput
  }

  export type SurveyorsUncheckedUpdateWithoutZoneWardMapInput = {
    userId?: StringFieldUpdateOperationsInput | string
    surveyorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyorsUncheckedUpdateManyWithoutZoneWardMapInput = {
    userId?: StringFieldUpdateOperationsInput | string
    surveyorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    wardMohallaMapId?: StringFieldUpdateOperationsInput | string
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyorAssignmentCreateManyWardMohallaMapInput = {
    assignmentId?: string
    userId: string
    assignmentType: string
    wardId: string
    mohallaId: string
    assignedById: string
    isActive?: boolean
  }

  export type SurveyorsCreateManyWardMohallaMapInput = {
    userId: string
    surveyorName: string
    username: string
    password: string
    wardNumber: string
    zoneWardMapId: string
    ulbZoneMapId: string
  }

  export type SurveyorAssignmentUpdateWithoutWardMohallaMapInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UsersMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    ward?: WardMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    mohalla?: MohallaMasterUpdateOneRequiredWithoutSurveyorAssignmentsNestedInput
    assignedBy?: UsersMasterUpdateOneRequiredWithoutSurveyorAssignmentsAssignedByNestedInput
  }

  export type SurveyorAssignmentUncheckedUpdateWithoutWardMohallaMapInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyorAssignmentUncheckedUpdateManyWithoutWardMohallaMapInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignmentType?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyorsUpdateWithoutWardMohallaMapInput = {
    surveyorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    user?: UsersMasterUpdateOneRequiredWithoutSurveyorsNestedInput
    zoneWardMap?: ZoneWardMappingUpdateOneRequiredWithoutSurveyorsNestedInput
    ulbZoneMap?: UlbZoneMappingUpdateOneRequiredWithoutSurveyorsNestedInput
  }

  export type SurveyorsUncheckedUpdateWithoutWardMohallaMapInput = {
    userId?: StringFieldUpdateOperationsInput | string
    surveyorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyorsUncheckedUpdateManyWithoutWardMohallaMapInput = {
    userId?: StringFieldUpdateOperationsInput | string
    surveyorName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    wardNumber?: StringFieldUpdateOperationsInput | string
    zoneWardMapId?: StringFieldUpdateOperationsInput | string
    ulbZoneMapId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyDetailsCreateManySurveyInput = {
    responseTypeId: string
    oldHouseNumber?: string | null
    electricityConsumerName?: string | null
    waterSewerageConnectionNumber?: string | null
    respondentName: string
    respondentStatusId: string
  }

  export type OwnerDetailsCreateManySurveyInput = {
    ownerName: string
    fatherHusbandName: string
    mobileNumber?: string | null
    aadharNumber?: string | null
  }

  export type LocationDetailsCreateManySurveyInput = {
    propertyLatitude: Decimal | DecimalJsLike | number | string
    propertyLongitude: Decimal | DecimalJsLike | number | string
    assessmentYear: string
    propertyTypeId: string
    buildingName?: string | null
    roadTypeId: string
    constructionYear: string
    constructionTypeId: string
    addressRoadName: string
    locality?: string | null
    pinCode: number
    landmark?: string | null
    fourWayEast?: string | null
    fourWayWest?: string | null
    fourWayNorth?: string | null
    fourWaySouth?: string | null
    newWard: string
  }

  export type OtherDetailsCreateManySurveyInput = {
    waterSourceId: string
    rainWaterHarvestingSystem?: string | null
    plantation?: string | null
    parking?: string | null
    pollution?: string | null
    pollutionMeasurementTaken?: string | null
    waterSupplyWithin200Meters?: string | null
    sewerageLineWithin100Meters?: string | null
    disposalTypeId: string
    totalPlotArea: number
    builtupAreaOfGroundFloor: number
    remarks?: string | null
  }

  export type ResidentialPropertyAssessmentCreateManySurveyInput = {
    floorAssessmentId?: string
    floorNumber: string
    occupancyStatusId: string
    constructionNatureId: string
    coveredArea: Decimal | DecimalJsLike | number | string
    allRoomVerandaArea: Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea: Decimal | DecimalJsLike | number | string
    allGarageArea: Decimal | DecimalJsLike | number | string
    carpetArea: Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentCreateManySurveyInput = {
    floorAssessmentId?: string
    floorNumber: string
    nrPropertyCategoryId: string
    nrSubCategoryId: string
    establishmentName: string
    licenseNo?: string | null
    licenseExpiryDate?: Date | string | null
    occupancyStatusId: string
    constructionNatureId: string
    builtupArea: Decimal | DecimalJsLike | number | string
  }

  export type PropertyAttachmentDetailsCreateManySurveyInput = {
    image1Url?: string | null
    image2Url?: string | null
    image3Url?: string | null
    image4Url?: string | null
    image5Url?: string | null
    image6Url?: string | null
    image7Url?: string | null
    image8Url?: string | null
    image9Url?: string | null
    image10Url?: string | null
  }

  export type SurveyStatusMappingCreateManySurveyInput = {
    statusMappingId?: string
    statusId: string
    revertedFromId?: string | null
    changedById: string
    isActive?: boolean
  }

  export type PropertyDetailsUpdateWithoutSurveyInput = {
    oldHouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    electricityConsumerName?: NullableStringFieldUpdateOperationsInput | string | null
    waterSewerageConnectionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    respondentName?: StringFieldUpdateOperationsInput | string
    responseType?: ResponseTypeMasterUpdateOneRequiredWithoutPropertyDetailsNestedInput
    respondentStatus?: RespondentStatusMasterUpdateOneRequiredWithoutPropertyDetailsNestedInput
  }

  export type PropertyDetailsUncheckedUpdateWithoutSurveyInput = {
    responseTypeId?: StringFieldUpdateOperationsInput | string
    oldHouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    electricityConsumerName?: NullableStringFieldUpdateOperationsInput | string | null
    waterSewerageConnectionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    respondentName?: StringFieldUpdateOperationsInput | string
    respondentStatusId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyDetailsUncheckedUpdateManyWithoutSurveyInput = {
    responseTypeId?: StringFieldUpdateOperationsInput | string
    oldHouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    electricityConsumerName?: NullableStringFieldUpdateOperationsInput | string | null
    waterSewerageConnectionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    respondentName?: StringFieldUpdateOperationsInput | string
    respondentStatusId?: StringFieldUpdateOperationsInput | string
  }

  export type OwnerDetailsUpdateWithoutSurveyInput = {
    ownerName?: StringFieldUpdateOperationsInput | string
    fatherHusbandName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OwnerDetailsUncheckedUpdateWithoutSurveyInput = {
    ownerName?: StringFieldUpdateOperationsInput | string
    fatherHusbandName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OwnerDetailsUncheckedUpdateManyWithoutSurveyInput = {
    ownerName?: StringFieldUpdateOperationsInput | string
    fatherHusbandName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationDetailsUpdateWithoutSurveyInput = {
    propertyLatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    constructionYear?: StringFieldUpdateOperationsInput | string
    addressRoadName?: StringFieldUpdateOperationsInput | string
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: IntFieldUpdateOperationsInput | number
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayEast?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayWest?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayNorth?: NullableStringFieldUpdateOperationsInput | string | null
    fourWaySouth?: NullableStringFieldUpdateOperationsInput | string | null
    newWard?: StringFieldUpdateOperationsInput | string
    propertyType?: PropertyTypeMasterUpdateOneRequiredWithoutLocationDetailsNestedInput
    roadType?: RoadTypeMasterUpdateOneRequiredWithoutLocationDetailsNestedInput
    constructionType?: ConstructionTypeMasterUpdateOneRequiredWithoutLocationDetailsNestedInput
  }

  export type LocationDetailsUncheckedUpdateWithoutSurveyInput = {
    propertyLatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFieldUpdateOperationsInput | string
    propertyTypeId?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    roadTypeId?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    addressRoadName?: StringFieldUpdateOperationsInput | string
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: IntFieldUpdateOperationsInput | number
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayEast?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayWest?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayNorth?: NullableStringFieldUpdateOperationsInput | string | null
    fourWaySouth?: NullableStringFieldUpdateOperationsInput | string | null
    newWard?: StringFieldUpdateOperationsInput | string
  }

  export type LocationDetailsUncheckedUpdateManyWithoutSurveyInput = {
    propertyLatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    propertyLongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assessmentYear?: StringFieldUpdateOperationsInput | string
    propertyTypeId?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    roadTypeId?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    addressRoadName?: StringFieldUpdateOperationsInput | string
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: IntFieldUpdateOperationsInput | number
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayEast?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayWest?: NullableStringFieldUpdateOperationsInput | string | null
    fourWayNorth?: NullableStringFieldUpdateOperationsInput | string | null
    fourWaySouth?: NullableStringFieldUpdateOperationsInput | string | null
    newWard?: StringFieldUpdateOperationsInput | string
  }

  export type OtherDetailsUpdateWithoutSurveyInput = {
    rainWaterHarvestingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    plantation?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: NullableStringFieldUpdateOperationsInput | string | null
    pollution?: NullableStringFieldUpdateOperationsInput | string | null
    pollutionMeasurementTaken?: NullableStringFieldUpdateOperationsInput | string | null
    waterSupplyWithin200Meters?: NullableStringFieldUpdateOperationsInput | string | null
    sewerageLineWithin100Meters?: NullableStringFieldUpdateOperationsInput | string | null
    totalPlotArea?: FloatFieldUpdateOperationsInput | number
    builtupAreaOfGroundFloor?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    waterSource?: WaterSourceMasterUpdateOneRequiredWithoutOtherDetailsNestedInput
    disposalType?: DisposalTypeMasterUpdateOneRequiredWithoutOtherDetailsNestedInput
  }

  export type OtherDetailsUncheckedUpdateWithoutSurveyInput = {
    waterSourceId?: StringFieldUpdateOperationsInput | string
    rainWaterHarvestingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    plantation?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: NullableStringFieldUpdateOperationsInput | string | null
    pollution?: NullableStringFieldUpdateOperationsInput | string | null
    pollutionMeasurementTaken?: NullableStringFieldUpdateOperationsInput | string | null
    waterSupplyWithin200Meters?: NullableStringFieldUpdateOperationsInput | string | null
    sewerageLineWithin100Meters?: NullableStringFieldUpdateOperationsInput | string | null
    disposalTypeId?: StringFieldUpdateOperationsInput | string
    totalPlotArea?: FloatFieldUpdateOperationsInput | number
    builtupAreaOfGroundFloor?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OtherDetailsUncheckedUpdateManyWithoutSurveyInput = {
    waterSourceId?: StringFieldUpdateOperationsInput | string
    rainWaterHarvestingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    plantation?: NullableStringFieldUpdateOperationsInput | string | null
    parking?: NullableStringFieldUpdateOperationsInput | string | null
    pollution?: NullableStringFieldUpdateOperationsInput | string | null
    pollutionMeasurementTaken?: NullableStringFieldUpdateOperationsInput | string | null
    waterSupplyWithin200Meters?: NullableStringFieldUpdateOperationsInput | string | null
    sewerageLineWithin100Meters?: NullableStringFieldUpdateOperationsInput | string | null
    disposalTypeId?: StringFieldUpdateOperationsInput | string
    totalPlotArea?: FloatFieldUpdateOperationsInput | number
    builtupAreaOfGroundFloor?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResidentialPropertyAssessmentUpdateWithoutSurveyInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    coveredArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allRoomVerandaArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allGarageArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carpetArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    occupancyStatus?: OccupancyStatusMasterUpdateOneRequiredWithoutResidentialPropertyAssessmentsNestedInput
    constructionNature?: ConstructionNatureMasterUpdateOneRequiredWithoutResidentialPropertyAssessmentsNestedInput
  }

  export type ResidentialPropertyAssessmentUncheckedUpdateWithoutSurveyInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    coveredArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allRoomVerandaArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allGarageArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carpetArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    coveredArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allRoomVerandaArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allBalconyKitchenArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allGarageArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carpetArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentUpdateWithoutSurveyInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nrPropertyCategory?: NrPropertyCategoryMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    nrSubCategory?: NrPropertySubCategoryMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    occupancyStatus?: OccupancyStatusMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
    constructionNature?: ConstructionNatureMasterUpdateOneRequiredWithoutNonResidentialPropertyAssessmentsNestedInput
  }

  export type NonResidentialPropertyAssessmentUncheckedUpdateWithoutSurveyInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    nrPropertyCategoryId?: StringFieldUpdateOperationsInput | string
    nrSubCategoryId?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NonResidentialPropertyAssessmentUncheckedUpdateManyWithoutSurveyInput = {
    floorAssessmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: StringFieldUpdateOperationsInput | string
    nrPropertyCategoryId?: StringFieldUpdateOperationsInput | string
    nrSubCategoryId?: StringFieldUpdateOperationsInput | string
    establishmentName?: StringFieldUpdateOperationsInput | string
    licenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occupancyStatusId?: StringFieldUpdateOperationsInput | string
    constructionNatureId?: StringFieldUpdateOperationsInput | string
    builtupArea?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PropertyAttachmentDetailsUpdateWithoutSurveyInput = {
    image1Url?: NullableStringFieldUpdateOperationsInput | string | null
    image2Url?: NullableStringFieldUpdateOperationsInput | string | null
    image3Url?: NullableStringFieldUpdateOperationsInput | string | null
    image4Url?: NullableStringFieldUpdateOperationsInput | string | null
    image5Url?: NullableStringFieldUpdateOperationsInput | string | null
    image6Url?: NullableStringFieldUpdateOperationsInput | string | null
    image7Url?: NullableStringFieldUpdateOperationsInput | string | null
    image8Url?: NullableStringFieldUpdateOperationsInput | string | null
    image9Url?: NullableStringFieldUpdateOperationsInput | string | null
    image10Url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyAttachmentDetailsUncheckedUpdateWithoutSurveyInput = {
    image1Url?: NullableStringFieldUpdateOperationsInput | string | null
    image2Url?: NullableStringFieldUpdateOperationsInput | string | null
    image3Url?: NullableStringFieldUpdateOperationsInput | string | null
    image4Url?: NullableStringFieldUpdateOperationsInput | string | null
    image5Url?: NullableStringFieldUpdateOperationsInput | string | null
    image6Url?: NullableStringFieldUpdateOperationsInput | string | null
    image7Url?: NullableStringFieldUpdateOperationsInput | string | null
    image8Url?: NullableStringFieldUpdateOperationsInput | string | null
    image9Url?: NullableStringFieldUpdateOperationsInput | string | null
    image10Url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyAttachmentDetailsUncheckedUpdateManyWithoutSurveyInput = {
    image1Url?: NullableStringFieldUpdateOperationsInput | string | null
    image2Url?: NullableStringFieldUpdateOperationsInput | string | null
    image3Url?: NullableStringFieldUpdateOperationsInput | string | null
    image4Url?: NullableStringFieldUpdateOperationsInput | string | null
    image5Url?: NullableStringFieldUpdateOperationsInput | string | null
    image6Url?: NullableStringFieldUpdateOperationsInput | string | null
    image7Url?: NullableStringFieldUpdateOperationsInput | string | null
    image8Url?: NullableStringFieldUpdateOperationsInput | string | null
    image9Url?: NullableStringFieldUpdateOperationsInput | string | null
    image10Url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SurveyStatusMappingUpdateWithoutSurveyInput = {
    statusMappingId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: SurveyStatusMasterUpdateOneRequiredWithoutSurveyStatusMapsNestedInput
    revertedFrom?: SurveyStatusMasterUpdateOneWithoutSurveyStatusMapsRevertedNestedInput
    changedBy?: UsersMasterUpdateOneRequiredWithoutSurveyStatusMapsNestedInput
  }

  export type SurveyStatusMappingUncheckedUpdateWithoutSurveyInput = {
    statusMappingId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    revertedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurveyStatusMappingUncheckedUpdateManyWithoutSurveyInput = {
    statusMappingId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    revertedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UlbMasterCountOutputTypeDefaultArgs instead
     */
    export type UlbMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UlbMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZoneMasterCountOutputTypeDefaultArgs instead
     */
    export type ZoneMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZoneMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WardMasterCountOutputTypeDefaultArgs instead
     */
    export type WardMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WardMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MohallaMasterCountOutputTypeDefaultArgs instead
     */
    export type MohallaMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MohallaMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResponseTypeMasterCountOutputTypeDefaultArgs instead
     */
    export type ResponseTypeMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResponseTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyTypeMasterCountOutputTypeDefaultArgs instead
     */
    export type PropertyTypeMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RespondentStatusMasterCountOutputTypeDefaultArgs instead
     */
    export type RespondentStatusMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RespondentStatusMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadTypeMasterCountOutputTypeDefaultArgs instead
     */
    export type RoadTypeMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConstructionTypeMasterCountOutputTypeDefaultArgs instead
     */
    export type ConstructionTypeMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConstructionTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WaterSourceMasterCountOutputTypeDefaultArgs instead
     */
    export type WaterSourceMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WaterSourceMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DisposalTypeMasterCountOutputTypeDefaultArgs instead
     */
    export type DisposalTypeMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DisposalTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NrPropertyCategoryMasterCountOutputTypeDefaultArgs instead
     */
    export type NrPropertyCategoryMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NrPropertyCategoryMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NrPropertySubCategoryMasterCountOutputTypeDefaultArgs instead
     */
    export type NrPropertySubCategoryMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NrPropertySubCategoryMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConstructionNatureMasterCountOutputTypeDefaultArgs instead
     */
    export type ConstructionNatureMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConstructionNatureMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SurveyTypeMasterCountOutputTypeDefaultArgs instead
     */
    export type SurveyTypeMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SurveyTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OccupancyStatusMasterCountOutputTypeDefaultArgs instead
     */
    export type OccupancyStatusMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OccupancyStatusMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SurveyStatusMasterCountOutputTypeDefaultArgs instead
     */
    export type SurveyStatusMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SurveyStatusMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WardStatusMasterCountOutputTypeDefaultArgs instead
     */
    export type WardStatusMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WardStatusMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersMasterCountOutputTypeDefaultArgs instead
     */
    export type UsersMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolePermissionMasterCountOutputTypeDefaultArgs instead
     */
    export type RolePermissionMasterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolePermissionMasterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UlbZoneMappingCountOutputTypeDefaultArgs instead
     */
    export type UlbZoneMappingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UlbZoneMappingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZoneWardMappingCountOutputTypeDefaultArgs instead
     */
    export type ZoneWardMappingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZoneWardMappingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WardMohallaMappingCountOutputTypeDefaultArgs instead
     */
    export type WardMohallaMappingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WardMohallaMappingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SurveyDetailsCountOutputTypeDefaultArgs instead
     */
    export type SurveyDetailsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SurveyDetailsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UlbMasterDefaultArgs instead
     */
    export type UlbMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UlbMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZoneMasterDefaultArgs instead
     */
    export type ZoneMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZoneMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WardMasterDefaultArgs instead
     */
    export type WardMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WardMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MohallaMasterDefaultArgs instead
     */
    export type MohallaMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MohallaMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResponseTypeMasterDefaultArgs instead
     */
    export type ResponseTypeMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResponseTypeMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyTypeMasterDefaultArgs instead
     */
    export type PropertyTypeMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyTypeMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RespondentStatusMasterDefaultArgs instead
     */
    export type RespondentStatusMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RespondentStatusMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadTypeMasterDefaultArgs instead
     */
    export type RoadTypeMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadTypeMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConstructionTypeMasterDefaultArgs instead
     */
    export type ConstructionTypeMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConstructionTypeMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WaterSourceMasterDefaultArgs instead
     */
    export type WaterSourceMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WaterSourceMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DisposalTypeMasterDefaultArgs instead
     */
    export type DisposalTypeMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DisposalTypeMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NrPropertyCategoryMasterDefaultArgs instead
     */
    export type NrPropertyCategoryMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NrPropertyCategoryMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NrPropertySubCategoryMasterDefaultArgs instead
     */
    export type NrPropertySubCategoryMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NrPropertySubCategoryMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConstructionNatureMasterDefaultArgs instead
     */
    export type ConstructionNatureMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConstructionNatureMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SurveyTypeMasterDefaultArgs instead
     */
    export type SurveyTypeMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SurveyTypeMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OccupancyStatusMasterDefaultArgs instead
     */
    export type OccupancyStatusMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OccupancyStatusMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SurveyStatusMasterDefaultArgs instead
     */
    export type SurveyStatusMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SurveyStatusMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WardStatusMasterDefaultArgs instead
     */
    export type WardStatusMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WardStatusMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersMasterDefaultArgs instead
     */
    export type UsersMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolePermissionMasterDefaultArgs instead
     */
    export type RolePermissionMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolePermissionMasterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UlbZoneMappingDefaultArgs instead
     */
    export type UlbZoneMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UlbZoneMappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZoneWardMappingDefaultArgs instead
     */
    export type ZoneWardMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZoneWardMappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WardMohallaMappingDefaultArgs instead
     */
    export type WardMohallaMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WardMohallaMappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SurveyorAssignmentDefaultArgs instead
     */
    export type SurveyorAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SurveyorAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WardStatusMappingDefaultArgs instead
     */
    export type WardStatusMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WardStatusMappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SurveyStatusMappingDefaultArgs instead
     */
    export type SurveyStatusMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SurveyStatusMappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleMappingDefaultArgs instead
     */
    export type UserRoleMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleMappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SurveyorsDefaultArgs instead
     */
    export type SurveyorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SurveyorsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupervisorsDefaultArgs instead
     */
    export type SupervisorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupervisorsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminsDefaultArgs instead
     */
    export type AdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SurveyDetailsDefaultArgs instead
     */
    export type SurveyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SurveyDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyDetailsDefaultArgs instead
     */
    export type PropertyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OwnerDetailsDefaultArgs instead
     */
    export type OwnerDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OwnerDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationDetailsDefaultArgs instead
     */
    export type LocationDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OtherDetailsDefaultArgs instead
     */
    export type OtherDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OtherDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResidentialPropertyAssessmentDefaultArgs instead
     */
    export type ResidentialPropertyAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResidentialPropertyAssessmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NonResidentialPropertyAssessmentDefaultArgs instead
     */
    export type NonResidentialPropertyAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NonResidentialPropertyAssessmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyAttachmentDetailsDefaultArgs instead
     */
    export type PropertyAttachmentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyAttachmentDetailsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}