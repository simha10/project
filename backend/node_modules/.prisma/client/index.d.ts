
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model ULB
 * 
 */
export type ULB = $Result.DefaultSelection<Prisma.$ULBPayload>
/**
 * Model Zone
 * 
 */
export type Zone = $Result.DefaultSelection<Prisma.$ZonePayload>
/**
 * Model Ward
 * 
 */
export type Ward = $Result.DefaultSelection<Prisma.$WardPayload>
/**
 * Model Mohalla
 * 
 */
export type Mohalla = $Result.DefaultSelection<Prisma.$MohallaPayload>
/**
 * Model PropertyResponseType
 * 
 */
export type PropertyResponseType = $Result.DefaultSelection<Prisma.$PropertyResponseTypePayload>
/**
 * Model RoadTypeMapping
 * 
 */
export type RoadTypeMapping = $Result.DefaultSelection<Prisma.$RoadTypeMappingPayload>
/**
 * Model ConstructionTypeMapping
 * 
 */
export type ConstructionTypeMapping = $Result.DefaultSelection<Prisma.$ConstructionTypeMappingPayload>
/**
 * Model NRPropCategoryMapping
 * 
 */
export type NRPropCategoryMapping = $Result.DefaultSelection<Prisma.$NRPropCategoryMappingPayload>
/**
 * Model NRPropSubCategoryMapping
 * 
 */
export type NRPropSubCategoryMapping = $Result.DefaultSelection<Prisma.$NRPropSubCategoryMappingPayload>
/**
 * Model Survey
 * 
 */
export type Survey = $Result.DefaultSelection<Prisma.$SurveyPayload>
/**
 * Model PropertyDetails
 * 
 */
export type PropertyDetails = $Result.DefaultSelection<Prisma.$PropertyDetailsPayload>
/**
 * Model OwnerDetails
 * 
 */
export type OwnerDetails = $Result.DefaultSelection<Prisma.$OwnerDetailsPayload>
/**
 * Model LocationDetails
 * 
 */
export type LocationDetails = $Result.DefaultSelection<Prisma.$LocationDetailsPayload>
/**
 * Model OtherDetails
 * 
 */
export type OtherDetails = $Result.DefaultSelection<Prisma.$OtherDetailsPayload>
/**
 * Model FloorDetails
 * 
 */
export type FloorDetails = $Result.DefaultSelection<Prisma.$FloorDetailsPayload>
/**
 * Model PropertyAssessment
 * 
 */
export type PropertyAssessment = $Result.DefaultSelection<Prisma.$PropertyAssessmentPayload>
/**
 * Model QCRecord
 * 
 */
export type QCRecord = $Result.DefaultSelection<Prisma.$QCRecordPayload>
/**
 * Model PropertyAttachment
 * 
 */
export type PropertyAttachment = $Result.DefaultSelection<Prisma.$PropertyAttachmentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PropertyType: {
  RESIDENTIAL: 'RESIDENTIAL',
  NON_RESIDENTIAL: 'NON_RESIDENTIAL',
  MIXED: 'MIXED'
};

export type PropertyType = (typeof PropertyType)[keyof typeof PropertyType]

}

export type PropertyType = $Enums.PropertyType

export const PropertyType: typeof $Enums.PropertyType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.uLB`: Exposes CRUD operations for the **ULB** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ULBS
    * const uLBS = await prisma.uLB.findMany()
    * ```
    */
  get uLB(): Prisma.ULBDelegate<ExtArgs>;

  /**
   * `prisma.zone`: Exposes CRUD operations for the **Zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zone.findMany()
    * ```
    */
  get zone(): Prisma.ZoneDelegate<ExtArgs>;

  /**
   * `prisma.ward`: Exposes CRUD operations for the **Ward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wards
    * const wards = await prisma.ward.findMany()
    * ```
    */
  get ward(): Prisma.WardDelegate<ExtArgs>;

  /**
   * `prisma.mohalla`: Exposes CRUD operations for the **Mohalla** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mohallas
    * const mohallas = await prisma.mohalla.findMany()
    * ```
    */
  get mohalla(): Prisma.MohallaDelegate<ExtArgs>;

  /**
   * `prisma.propertyResponseType`: Exposes CRUD operations for the **PropertyResponseType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyResponseTypes
    * const propertyResponseTypes = await prisma.propertyResponseType.findMany()
    * ```
    */
  get propertyResponseType(): Prisma.PropertyResponseTypeDelegate<ExtArgs>;

  /**
   * `prisma.roadTypeMapping`: Exposes CRUD operations for the **RoadTypeMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoadTypeMappings
    * const roadTypeMappings = await prisma.roadTypeMapping.findMany()
    * ```
    */
  get roadTypeMapping(): Prisma.RoadTypeMappingDelegate<ExtArgs>;

  /**
   * `prisma.constructionTypeMapping`: Exposes CRUD operations for the **ConstructionTypeMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConstructionTypeMappings
    * const constructionTypeMappings = await prisma.constructionTypeMapping.findMany()
    * ```
    */
  get constructionTypeMapping(): Prisma.ConstructionTypeMappingDelegate<ExtArgs>;

  /**
   * `prisma.nRPropCategoryMapping`: Exposes CRUD operations for the **NRPropCategoryMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NRPropCategoryMappings
    * const nRPropCategoryMappings = await prisma.nRPropCategoryMapping.findMany()
    * ```
    */
  get nRPropCategoryMapping(): Prisma.NRPropCategoryMappingDelegate<ExtArgs>;

  /**
   * `prisma.nRPropSubCategoryMapping`: Exposes CRUD operations for the **NRPropSubCategoryMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NRPropSubCategoryMappings
    * const nRPropSubCategoryMappings = await prisma.nRPropSubCategoryMapping.findMany()
    * ```
    */
  get nRPropSubCategoryMapping(): Prisma.NRPropSubCategoryMappingDelegate<ExtArgs>;

  /**
   * `prisma.survey`: Exposes CRUD operations for the **Survey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Surveys
    * const surveys = await prisma.survey.findMany()
    * ```
    */
  get survey(): Prisma.SurveyDelegate<ExtArgs>;

  /**
   * `prisma.propertyDetails`: Exposes CRUD operations for the **PropertyDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyDetails
    * const propertyDetails = await prisma.propertyDetails.findMany()
    * ```
    */
  get propertyDetails(): Prisma.PropertyDetailsDelegate<ExtArgs>;

  /**
   * `prisma.ownerDetails`: Exposes CRUD operations for the **OwnerDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OwnerDetails
    * const ownerDetails = await prisma.ownerDetails.findMany()
    * ```
    */
  get ownerDetails(): Prisma.OwnerDetailsDelegate<ExtArgs>;

  /**
   * `prisma.locationDetails`: Exposes CRUD operations for the **LocationDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocationDetails
    * const locationDetails = await prisma.locationDetails.findMany()
    * ```
    */
  get locationDetails(): Prisma.LocationDetailsDelegate<ExtArgs>;

  /**
   * `prisma.otherDetails`: Exposes CRUD operations for the **OtherDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OtherDetails
    * const otherDetails = await prisma.otherDetails.findMany()
    * ```
    */
  get otherDetails(): Prisma.OtherDetailsDelegate<ExtArgs>;

  /**
   * `prisma.floorDetails`: Exposes CRUD operations for the **FloorDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FloorDetails
    * const floorDetails = await prisma.floorDetails.findMany()
    * ```
    */
  get floorDetails(): Prisma.FloorDetailsDelegate<ExtArgs>;

  /**
   * `prisma.propertyAssessment`: Exposes CRUD operations for the **PropertyAssessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyAssessments
    * const propertyAssessments = await prisma.propertyAssessment.findMany()
    * ```
    */
  get propertyAssessment(): Prisma.PropertyAssessmentDelegate<ExtArgs>;

  /**
   * `prisma.qCRecord`: Exposes CRUD operations for the **QCRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QCRecords
    * const qCRecords = await prisma.qCRecord.findMany()
    * ```
    */
  get qCRecord(): Prisma.QCRecordDelegate<ExtArgs>;

  /**
   * `prisma.propertyAttachment`: Exposes CRUD operations for the **PropertyAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyAttachments
    * const propertyAttachments = await prisma.propertyAttachment.findMany()
    * ```
    */
  get propertyAttachment(): Prisma.PropertyAttachmentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    ULB: 'ULB',
    Zone: 'Zone',
    Ward: 'Ward',
    Mohalla: 'Mohalla',
    PropertyResponseType: 'PropertyResponseType',
    RoadTypeMapping: 'RoadTypeMapping',
    ConstructionTypeMapping: 'ConstructionTypeMapping',
    NRPropCategoryMapping: 'NRPropCategoryMapping',
    NRPropSubCategoryMapping: 'NRPropSubCategoryMapping',
    Survey: 'Survey',
    PropertyDetails: 'PropertyDetails',
    OwnerDetails: 'OwnerDetails',
    LocationDetails: 'LocationDetails',
    OtherDetails: 'OtherDetails',
    FloorDetails: 'FloorDetails',
    PropertyAssessment: 'PropertyAssessment',
    QCRecord: 'QCRecord',
    PropertyAttachment: 'PropertyAttachment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "session" | "uLB" | "zone" | "ward" | "mohalla" | "propertyResponseType" | "roadTypeMapping" | "constructionTypeMapping" | "nRPropCategoryMapping" | "nRPropSubCategoryMapping" | "survey" | "propertyDetails" | "ownerDetails" | "locationDetails" | "otherDetails" | "floorDetails" | "propertyAssessment" | "qCRecord" | "propertyAttachment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      ULB: {
        payload: Prisma.$ULBPayload<ExtArgs>
        fields: Prisma.ULBFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ULBFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ULBPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ULBFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ULBPayload>
          }
          findFirst: {
            args: Prisma.ULBFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ULBPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ULBFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ULBPayload>
          }
          findMany: {
            args: Prisma.ULBFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ULBPayload>[]
          }
          create: {
            args: Prisma.ULBCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ULBPayload>
          }
          createMany: {
            args: Prisma.ULBCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ULBCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ULBPayload>[]
          }
          delete: {
            args: Prisma.ULBDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ULBPayload>
          }
          update: {
            args: Prisma.ULBUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ULBPayload>
          }
          deleteMany: {
            args: Prisma.ULBDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ULBUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ULBUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ULBPayload>
          }
          aggregate: {
            args: Prisma.ULBAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateULB>
          }
          groupBy: {
            args: Prisma.ULBGroupByArgs<ExtArgs>
            result: $Utils.Optional<ULBGroupByOutputType>[]
          }
          count: {
            args: Prisma.ULBCountArgs<ExtArgs>
            result: $Utils.Optional<ULBCountAggregateOutputType> | number
          }
        }
      }
      Zone: {
        payload: Prisma.$ZonePayload<ExtArgs>
        fields: Prisma.ZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findFirst: {
            args: Prisma.ZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findMany: {
            args: Prisma.ZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          create: {
            args: Prisma.ZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          createMany: {
            args: Prisma.ZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          delete: {
            args: Prisma.ZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          update: {
            args: Prisma.ZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          deleteMany: {
            args: Prisma.ZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          aggregate: {
            args: Prisma.ZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZone>
          }
          groupBy: {
            args: Prisma.ZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoneCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneCountAggregateOutputType> | number
          }
        }
      }
      Ward: {
        payload: Prisma.$WardPayload<ExtArgs>
        fields: Prisma.WardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          findFirst: {
            args: Prisma.WardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          findMany: {
            args: Prisma.WardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>[]
          }
          create: {
            args: Prisma.WardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          createMany: {
            args: Prisma.WardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>[]
          }
          delete: {
            args: Prisma.WardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          update: {
            args: Prisma.WardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          deleteMany: {
            args: Prisma.WardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          aggregate: {
            args: Prisma.WardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWard>
          }
          groupBy: {
            args: Prisma.WardGroupByArgs<ExtArgs>
            result: $Utils.Optional<WardGroupByOutputType>[]
          }
          count: {
            args: Prisma.WardCountArgs<ExtArgs>
            result: $Utils.Optional<WardCountAggregateOutputType> | number
          }
        }
      }
      Mohalla: {
        payload: Prisma.$MohallaPayload<ExtArgs>
        fields: Prisma.MohallaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MohallaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MohallaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaPayload>
          }
          findFirst: {
            args: Prisma.MohallaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MohallaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaPayload>
          }
          findMany: {
            args: Prisma.MohallaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaPayload>[]
          }
          create: {
            args: Prisma.MohallaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaPayload>
          }
          createMany: {
            args: Prisma.MohallaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MohallaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaPayload>[]
          }
          delete: {
            args: Prisma.MohallaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaPayload>
          }
          update: {
            args: Prisma.MohallaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaPayload>
          }
          deleteMany: {
            args: Prisma.MohallaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MohallaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MohallaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MohallaPayload>
          }
          aggregate: {
            args: Prisma.MohallaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMohalla>
          }
          groupBy: {
            args: Prisma.MohallaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MohallaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MohallaCountArgs<ExtArgs>
            result: $Utils.Optional<MohallaCountAggregateOutputType> | number
          }
        }
      }
      PropertyResponseType: {
        payload: Prisma.$PropertyResponseTypePayload<ExtArgs>
        fields: Prisma.PropertyResponseTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyResponseTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyResponseTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyResponseTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyResponseTypePayload>
          }
          findFirst: {
            args: Prisma.PropertyResponseTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyResponseTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyResponseTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyResponseTypePayload>
          }
          findMany: {
            args: Prisma.PropertyResponseTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyResponseTypePayload>[]
          }
          create: {
            args: Prisma.PropertyResponseTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyResponseTypePayload>
          }
          createMany: {
            args: Prisma.PropertyResponseTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyResponseTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyResponseTypePayload>[]
          }
          delete: {
            args: Prisma.PropertyResponseTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyResponseTypePayload>
          }
          update: {
            args: Prisma.PropertyResponseTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyResponseTypePayload>
          }
          deleteMany: {
            args: Prisma.PropertyResponseTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyResponseTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropertyResponseTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyResponseTypePayload>
          }
          aggregate: {
            args: Prisma.PropertyResponseTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyResponseType>
          }
          groupBy: {
            args: Prisma.PropertyResponseTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyResponseTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyResponseTypeCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyResponseTypeCountAggregateOutputType> | number
          }
        }
      }
      RoadTypeMapping: {
        payload: Prisma.$RoadTypeMappingPayload<ExtArgs>
        fields: Prisma.RoadTypeMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadTypeMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadTypeMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMappingPayload>
          }
          findFirst: {
            args: Prisma.RoadTypeMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadTypeMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMappingPayload>
          }
          findMany: {
            args: Prisma.RoadTypeMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMappingPayload>[]
          }
          create: {
            args: Prisma.RoadTypeMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMappingPayload>
          }
          createMany: {
            args: Prisma.RoadTypeMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoadTypeMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMappingPayload>[]
          }
          delete: {
            args: Prisma.RoadTypeMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMappingPayload>
          }
          update: {
            args: Prisma.RoadTypeMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMappingPayload>
          }
          deleteMany: {
            args: Prisma.RoadTypeMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadTypeMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoadTypeMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadTypeMappingPayload>
          }
          aggregate: {
            args: Prisma.RoadTypeMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadTypeMapping>
          }
          groupBy: {
            args: Prisma.RoadTypeMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadTypeMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadTypeMappingCountArgs<ExtArgs>
            result: $Utils.Optional<RoadTypeMappingCountAggregateOutputType> | number
          }
        }
      }
      ConstructionTypeMapping: {
        payload: Prisma.$ConstructionTypeMappingPayload<ExtArgs>
        fields: Prisma.ConstructionTypeMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConstructionTypeMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConstructionTypeMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMappingPayload>
          }
          findFirst: {
            args: Prisma.ConstructionTypeMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConstructionTypeMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMappingPayload>
          }
          findMany: {
            args: Prisma.ConstructionTypeMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMappingPayload>[]
          }
          create: {
            args: Prisma.ConstructionTypeMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMappingPayload>
          }
          createMany: {
            args: Prisma.ConstructionTypeMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConstructionTypeMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMappingPayload>[]
          }
          delete: {
            args: Prisma.ConstructionTypeMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMappingPayload>
          }
          update: {
            args: Prisma.ConstructionTypeMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMappingPayload>
          }
          deleteMany: {
            args: Prisma.ConstructionTypeMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConstructionTypeMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConstructionTypeMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTypeMappingPayload>
          }
          aggregate: {
            args: Prisma.ConstructionTypeMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConstructionTypeMapping>
          }
          groupBy: {
            args: Prisma.ConstructionTypeMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConstructionTypeMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConstructionTypeMappingCountArgs<ExtArgs>
            result: $Utils.Optional<ConstructionTypeMappingCountAggregateOutputType> | number
          }
        }
      }
      NRPropCategoryMapping: {
        payload: Prisma.$NRPropCategoryMappingPayload<ExtArgs>
        fields: Prisma.NRPropCategoryMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NRPropCategoryMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropCategoryMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NRPropCategoryMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropCategoryMappingPayload>
          }
          findFirst: {
            args: Prisma.NRPropCategoryMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropCategoryMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NRPropCategoryMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropCategoryMappingPayload>
          }
          findMany: {
            args: Prisma.NRPropCategoryMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropCategoryMappingPayload>[]
          }
          create: {
            args: Prisma.NRPropCategoryMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropCategoryMappingPayload>
          }
          createMany: {
            args: Prisma.NRPropCategoryMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NRPropCategoryMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropCategoryMappingPayload>[]
          }
          delete: {
            args: Prisma.NRPropCategoryMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropCategoryMappingPayload>
          }
          update: {
            args: Prisma.NRPropCategoryMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropCategoryMappingPayload>
          }
          deleteMany: {
            args: Prisma.NRPropCategoryMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NRPropCategoryMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NRPropCategoryMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropCategoryMappingPayload>
          }
          aggregate: {
            args: Prisma.NRPropCategoryMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNRPropCategoryMapping>
          }
          groupBy: {
            args: Prisma.NRPropCategoryMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<NRPropCategoryMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.NRPropCategoryMappingCountArgs<ExtArgs>
            result: $Utils.Optional<NRPropCategoryMappingCountAggregateOutputType> | number
          }
        }
      }
      NRPropSubCategoryMapping: {
        payload: Prisma.$NRPropSubCategoryMappingPayload<ExtArgs>
        fields: Prisma.NRPropSubCategoryMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NRPropSubCategoryMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropSubCategoryMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NRPropSubCategoryMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropSubCategoryMappingPayload>
          }
          findFirst: {
            args: Prisma.NRPropSubCategoryMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropSubCategoryMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NRPropSubCategoryMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropSubCategoryMappingPayload>
          }
          findMany: {
            args: Prisma.NRPropSubCategoryMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropSubCategoryMappingPayload>[]
          }
          create: {
            args: Prisma.NRPropSubCategoryMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropSubCategoryMappingPayload>
          }
          createMany: {
            args: Prisma.NRPropSubCategoryMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NRPropSubCategoryMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropSubCategoryMappingPayload>[]
          }
          delete: {
            args: Prisma.NRPropSubCategoryMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropSubCategoryMappingPayload>
          }
          update: {
            args: Prisma.NRPropSubCategoryMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropSubCategoryMappingPayload>
          }
          deleteMany: {
            args: Prisma.NRPropSubCategoryMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NRPropSubCategoryMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NRPropSubCategoryMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NRPropSubCategoryMappingPayload>
          }
          aggregate: {
            args: Prisma.NRPropSubCategoryMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNRPropSubCategoryMapping>
          }
          groupBy: {
            args: Prisma.NRPropSubCategoryMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<NRPropSubCategoryMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.NRPropSubCategoryMappingCountArgs<ExtArgs>
            result: $Utils.Optional<NRPropSubCategoryMappingCountAggregateOutputType> | number
          }
        }
      }
      Survey: {
        payload: Prisma.$SurveyPayload<ExtArgs>
        fields: Prisma.SurveyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          findFirst: {
            args: Prisma.SurveyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          findMany: {
            args: Prisma.SurveyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>[]
          }
          create: {
            args: Prisma.SurveyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          createMany: {
            args: Prisma.SurveyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurveyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>[]
          }
          delete: {
            args: Prisma.SurveyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          update: {
            args: Prisma.SurveyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          deleteMany: {
            args: Prisma.SurveyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SurveyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          aggregate: {
            args: Prisma.SurveyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurvey>
          }
          groupBy: {
            args: Prisma.SurveyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyCountAggregateOutputType> | number
          }
        }
      }
      PropertyDetails: {
        payload: Prisma.$PropertyDetailsPayload<ExtArgs>
        fields: Prisma.PropertyDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload>
          }
          findFirst: {
            args: Prisma.PropertyDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload>
          }
          findMany: {
            args: Prisma.PropertyDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload>[]
          }
          create: {
            args: Prisma.PropertyDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload>
          }
          createMany: {
            args: Prisma.PropertyDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload>[]
          }
          delete: {
            args: Prisma.PropertyDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload>
          }
          update: {
            args: Prisma.PropertyDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropertyDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDetailsPayload>
          }
          aggregate: {
            args: Prisma.PropertyDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyDetails>
          }
          groupBy: {
            args: Prisma.PropertyDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyDetailsCountAggregateOutputType> | number
          }
        }
      }
      OwnerDetails: {
        payload: Prisma.$OwnerDetailsPayload<ExtArgs>
        fields: Prisma.OwnerDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnerDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnerDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload>
          }
          findFirst: {
            args: Prisma.OwnerDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnerDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload>
          }
          findMany: {
            args: Prisma.OwnerDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload>[]
          }
          create: {
            args: Prisma.OwnerDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload>
          }
          createMany: {
            args: Prisma.OwnerDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OwnerDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload>[]
          }
          delete: {
            args: Prisma.OwnerDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload>
          }
          update: {
            args: Prisma.OwnerDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload>
          }
          deleteMany: {
            args: Prisma.OwnerDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OwnerDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OwnerDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDetailsPayload>
          }
          aggregate: {
            args: Prisma.OwnerDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwnerDetails>
          }
          groupBy: {
            args: Prisma.OwnerDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OwnerDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnerDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<OwnerDetailsCountAggregateOutputType> | number
          }
        }
      }
      LocationDetails: {
        payload: Prisma.$LocationDetailsPayload<ExtArgs>
        fields: Prisma.LocationDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload>
          }
          findFirst: {
            args: Prisma.LocationDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload>
          }
          findMany: {
            args: Prisma.LocationDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload>[]
          }
          create: {
            args: Prisma.LocationDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload>
          }
          createMany: {
            args: Prisma.LocationDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload>[]
          }
          delete: {
            args: Prisma.LocationDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload>
          }
          update: {
            args: Prisma.LocationDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload>
          }
          deleteMany: {
            args: Prisma.LocationDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDetailsPayload>
          }
          aggregate: {
            args: Prisma.LocationDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocationDetails>
          }
          groupBy: {
            args: Prisma.LocationDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<LocationDetailsCountAggregateOutputType> | number
          }
        }
      }
      OtherDetails: {
        payload: Prisma.$OtherDetailsPayload<ExtArgs>
        fields: Prisma.OtherDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtherDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtherDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload>
          }
          findFirst: {
            args: Prisma.OtherDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtherDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload>
          }
          findMany: {
            args: Prisma.OtherDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload>[]
          }
          create: {
            args: Prisma.OtherDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload>
          }
          createMany: {
            args: Prisma.OtherDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OtherDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload>[]
          }
          delete: {
            args: Prisma.OtherDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload>
          }
          update: {
            args: Prisma.OtherDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload>
          }
          deleteMany: {
            args: Prisma.OtherDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtherDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OtherDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtherDetailsPayload>
          }
          aggregate: {
            args: Prisma.OtherDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtherDetails>
          }
          groupBy: {
            args: Prisma.OtherDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtherDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtherDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<OtherDetailsCountAggregateOutputType> | number
          }
        }
      }
      FloorDetails: {
        payload: Prisma.$FloorDetailsPayload<ExtArgs>
        fields: Prisma.FloorDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FloorDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FloorDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorDetailsPayload>
          }
          findFirst: {
            args: Prisma.FloorDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FloorDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorDetailsPayload>
          }
          findMany: {
            args: Prisma.FloorDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorDetailsPayload>[]
          }
          create: {
            args: Prisma.FloorDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorDetailsPayload>
          }
          createMany: {
            args: Prisma.FloorDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FloorDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorDetailsPayload>[]
          }
          delete: {
            args: Prisma.FloorDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorDetailsPayload>
          }
          update: {
            args: Prisma.FloorDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorDetailsPayload>
          }
          deleteMany: {
            args: Prisma.FloorDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FloorDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FloorDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorDetailsPayload>
          }
          aggregate: {
            args: Prisma.FloorDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFloorDetails>
          }
          groupBy: {
            args: Prisma.FloorDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FloorDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FloorDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<FloorDetailsCountAggregateOutputType> | number
          }
        }
      }
      PropertyAssessment: {
        payload: Prisma.$PropertyAssessmentPayload<ExtArgs>
        fields: Prisma.PropertyAssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyAssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyAssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAssessmentPayload>
          }
          findFirst: {
            args: Prisma.PropertyAssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyAssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAssessmentPayload>
          }
          findMany: {
            args: Prisma.PropertyAssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAssessmentPayload>[]
          }
          create: {
            args: Prisma.PropertyAssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAssessmentPayload>
          }
          createMany: {
            args: Prisma.PropertyAssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyAssessmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAssessmentPayload>[]
          }
          delete: {
            args: Prisma.PropertyAssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAssessmentPayload>
          }
          update: {
            args: Prisma.PropertyAssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAssessmentPayload>
          }
          deleteMany: {
            args: Prisma.PropertyAssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyAssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropertyAssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAssessmentPayload>
          }
          aggregate: {
            args: Prisma.PropertyAssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyAssessment>
          }
          groupBy: {
            args: Prisma.PropertyAssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyAssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyAssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyAssessmentCountAggregateOutputType> | number
          }
        }
      }
      QCRecord: {
        payload: Prisma.$QCRecordPayload<ExtArgs>
        fields: Prisma.QCRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QCRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QCRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCRecordPayload>
          }
          findFirst: {
            args: Prisma.QCRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QCRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCRecordPayload>
          }
          findMany: {
            args: Prisma.QCRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCRecordPayload>[]
          }
          create: {
            args: Prisma.QCRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCRecordPayload>
          }
          createMany: {
            args: Prisma.QCRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QCRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCRecordPayload>[]
          }
          delete: {
            args: Prisma.QCRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCRecordPayload>
          }
          update: {
            args: Prisma.QCRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCRecordPayload>
          }
          deleteMany: {
            args: Prisma.QCRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QCRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QCRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCRecordPayload>
          }
          aggregate: {
            args: Prisma.QCRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQCRecord>
          }
          groupBy: {
            args: Prisma.QCRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<QCRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.QCRecordCountArgs<ExtArgs>
            result: $Utils.Optional<QCRecordCountAggregateOutputType> | number
          }
        }
      }
      PropertyAttachment: {
        payload: Prisma.$PropertyAttachmentPayload<ExtArgs>
        fields: Prisma.PropertyAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentPayload>
          }
          findFirst: {
            args: Prisma.PropertyAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentPayload>
          }
          findMany: {
            args: Prisma.PropertyAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentPayload>[]
          }
          create: {
            args: Prisma.PropertyAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentPayload>
          }
          createMany: {
            args: Prisma.PropertyAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentPayload>[]
          }
          delete: {
            args: Prisma.PropertyAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentPayload>
          }
          update: {
            args: Prisma.PropertyAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.PropertyAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropertyAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAttachmentPayload>
          }
          aggregate: {
            args: Prisma.PropertyAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyAttachment>
          }
          groupBy: {
            args: Prisma.PropertyAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyAttachmentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdUsers: number
    sessions: number
    surveys: number
    qcRecords: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdUsers?: boolean | UserCountOutputTypeCountCreatedUsersArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    surveys?: boolean | UserCountOutputTypeCountSurveysArgs
    qcRecords?: boolean | UserCountOutputTypeCountQcRecordsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSurveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQcRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QCRecordWhereInput
  }


  /**
   * Count Type ULBCountOutputType
   */

  export type ULBCountOutputType = {
    zones: number
    surveys: number
  }

  export type ULBCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zones?: boolean | ULBCountOutputTypeCountZonesArgs
    surveys?: boolean | ULBCountOutputTypeCountSurveysArgs
  }

  // Custom InputTypes
  /**
   * ULBCountOutputType without action
   */
  export type ULBCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ULBCountOutputType
     */
    select?: ULBCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ULBCountOutputType without action
   */
  export type ULBCountOutputTypeCountZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
  }

  /**
   * ULBCountOutputType without action
   */
  export type ULBCountOutputTypeCountSurveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyWhereInput
  }


  /**
   * Count Type ZoneCountOutputType
   */

  export type ZoneCountOutputType = {
    wards: number
    surveys: number
  }

  export type ZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wards?: boolean | ZoneCountOutputTypeCountWardsArgs
    surveys?: boolean | ZoneCountOutputTypeCountSurveysArgs
  }

  // Custom InputTypes
  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneCountOutputType
     */
    select?: ZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountWardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardWhereInput
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountSurveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyWhereInput
  }


  /**
   * Count Type WardCountOutputType
   */

  export type WardCountOutputType = {
    mohallas: number
    surveys: number
  }

  export type WardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mohallas?: boolean | WardCountOutputTypeCountMohallasArgs
    surveys?: boolean | WardCountOutputTypeCountSurveysArgs
  }

  // Custom InputTypes
  /**
   * WardCountOutputType without action
   */
  export type WardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardCountOutputType
     */
    select?: WardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WardCountOutputType without action
   */
  export type WardCountOutputTypeCountMohallasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MohallaWhereInput
  }

  /**
   * WardCountOutputType without action
   */
  export type WardCountOutputTypeCountSurveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyWhereInput
  }


  /**
   * Count Type MohallaCountOutputType
   */

  export type MohallaCountOutputType = {
    surveys: number
  }

  export type MohallaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveys?: boolean | MohallaCountOutputTypeCountSurveysArgs
  }

  // Custom InputTypes
  /**
   * MohallaCountOutputType without action
   */
  export type MohallaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MohallaCountOutputType
     */
    select?: MohallaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MohallaCountOutputType without action
   */
  export type MohallaCountOutputTypeCountSurveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyWhereInput
  }


  /**
   * Count Type PropertyResponseTypeCountOutputType
   */

  export type PropertyResponseTypeCountOutputType = {
    surveys: number
  }

  export type PropertyResponseTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveys?: boolean | PropertyResponseTypeCountOutputTypeCountSurveysArgs
  }

  // Custom InputTypes
  /**
   * PropertyResponseTypeCountOutputType without action
   */
  export type PropertyResponseTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyResponseTypeCountOutputType
     */
    select?: PropertyResponseTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyResponseTypeCountOutputType without action
   */
  export type PropertyResponseTypeCountOutputTypeCountSurveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyDetailsWhereInput
  }


  /**
   * Count Type RoadTypeMappingCountOutputType
   */

  export type RoadTypeMappingCountOutputType = {
    locations: number
  }

  export type RoadTypeMappingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | RoadTypeMappingCountOutputTypeCountLocationsArgs
  }

  // Custom InputTypes
  /**
   * RoadTypeMappingCountOutputType without action
   */
  export type RoadTypeMappingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMappingCountOutputType
     */
    select?: RoadTypeMappingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoadTypeMappingCountOutputType without action
   */
  export type RoadTypeMappingCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationDetailsWhereInput
  }


  /**
   * Count Type ConstructionTypeMappingCountOutputType
   */

  export type ConstructionTypeMappingCountOutputType = {
    locations: number
  }

  export type ConstructionTypeMappingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | ConstructionTypeMappingCountOutputTypeCountLocationsArgs
  }

  // Custom InputTypes
  /**
   * ConstructionTypeMappingCountOutputType without action
   */
  export type ConstructionTypeMappingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMappingCountOutputType
     */
    select?: ConstructionTypeMappingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConstructionTypeMappingCountOutputType without action
   */
  export type ConstructionTypeMappingCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationDetailsWhereInput
  }


  /**
   * Count Type NRPropCategoryMappingCountOutputType
   */

  export type NRPropCategoryMappingCountOutputType = {
    subCategories: number
    assessments: number
  }

  export type NRPropCategoryMappingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCategories?: boolean | NRPropCategoryMappingCountOutputTypeCountSubCategoriesArgs
    assessments?: boolean | NRPropCategoryMappingCountOutputTypeCountAssessmentsArgs
  }

  // Custom InputTypes
  /**
   * NRPropCategoryMappingCountOutputType without action
   */
  export type NRPropCategoryMappingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropCategoryMappingCountOutputType
     */
    select?: NRPropCategoryMappingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NRPropCategoryMappingCountOutputType without action
   */
  export type NRPropCategoryMappingCountOutputTypeCountSubCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NRPropSubCategoryMappingWhereInput
  }

  /**
   * NRPropCategoryMappingCountOutputType without action
   */
  export type NRPropCategoryMappingCountOutputTypeCountAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyAssessmentWhereInput
  }


  /**
   * Count Type NRPropSubCategoryMappingCountOutputType
   */

  export type NRPropSubCategoryMappingCountOutputType = {
    assessments: number
  }

  export type NRPropSubCategoryMappingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assessments?: boolean | NRPropSubCategoryMappingCountOutputTypeCountAssessmentsArgs
  }

  // Custom InputTypes
  /**
   * NRPropSubCategoryMappingCountOutputType without action
   */
  export type NRPropSubCategoryMappingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropSubCategoryMappingCountOutputType
     */
    select?: NRPropSubCategoryMappingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NRPropSubCategoryMappingCountOutputType without action
   */
  export type NRPropSubCategoryMappingCountOutputTypeCountAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyAssessmentWhereInput
  }


  /**
   * Count Type SurveyCountOutputType
   */

  export type SurveyCountOutputType = {
    floors: number
    attachments: number
  }

  export type SurveyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    floors?: boolean | SurveyCountOutputTypeCountFloorsArgs
    attachments?: boolean | SurveyCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * SurveyCountOutputType without action
   */
  export type SurveyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyCountOutputType
     */
    select?: SurveyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SurveyCountOutputType without action
   */
  export type SurveyCountOutputTypeCountFloorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FloorDetailsWhereInput
  }

  /**
   * SurveyCountOutputType without action
   */
  export type SurveyCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyAttachmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    role: string | null
    phoneNumber: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    role: string | null
    phoneNumber: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    role: number
    phoneNumber: number
    assignedWards: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role?: true
    phoneNumber?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role?: true
    phoneNumber?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role?: true
    phoneNumber?: true
    assignedWards?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    password: string
    role: string
    phoneNumber: string
    assignedWards: string[]
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    phoneNumber?: boolean
    assignedWards?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    surveys?: boolean | User$surveysArgs<ExtArgs>
    qcRecords?: boolean | User$qcRecordsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    phoneNumber?: boolean
    assignedWards?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    phoneNumber?: boolean
    assignedWards?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    surveys?: boolean | User$surveysArgs<ExtArgs>
    qcRecords?: boolean | User$qcRecordsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      createdUsers: Prisma.$UserPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      surveys: Prisma.$SurveyPayload<ExtArgs>[]
      qcRecords: Prisma.$QCRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      password: string
      role: string
      phoneNumber: string
      assignedWards: string[]
      createdById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends User$createdByArgs<ExtArgs> = {}>(args?: Subset<T, User$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdUsers<T extends User$createdUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    surveys<T extends User$surveysArgs<ExtArgs> = {}>(args?: Subset<T, User$surveysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findMany"> | Null>
    qcRecords<T extends User$qcRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$qcRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QCRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly assignedWards: FieldRef<"User", 'String[]'>
    readonly createdById: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.createdBy
   */
  export type User$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.createdUsers
   */
  export type User$createdUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.surveys
   */
  export type User$surveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    where?: SurveyWhereInput
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    cursor?: SurveyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * User.qcRecords
   */
  export type User$qcRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCRecord
     */
    select?: QCRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCRecordInclude<ExtArgs> | null
    where?: QCRecordWhereInput
    orderBy?: QCRecordOrderByWithRelationInput | QCRecordOrderByWithRelationInput[]
    cursor?: QCRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QCRecordScalarFieldEnum | QCRecordScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model ULB
   */

  export type AggregateULB = {
    _count: ULBCountAggregateOutputType | null
    _min: ULBMinAggregateOutputType | null
    _max: ULBMaxAggregateOutputType | null
  }

  export type ULBMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ULBMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ULBCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ULBMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ULBMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ULBCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ULBAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ULB to aggregate.
     */
    where?: ULBWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ULBS to fetch.
     */
    orderBy?: ULBOrderByWithRelationInput | ULBOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ULBWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ULBS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ULBS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ULBS
    **/
    _count?: true | ULBCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ULBMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ULBMaxAggregateInputType
  }

  export type GetULBAggregateType<T extends ULBAggregateArgs> = {
        [P in keyof T & keyof AggregateULB]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateULB[P]>
      : GetScalarType<T[P], AggregateULB[P]>
  }




  export type ULBGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ULBWhereInput
    orderBy?: ULBOrderByWithAggregationInput | ULBOrderByWithAggregationInput[]
    by: ULBScalarFieldEnum[] | ULBScalarFieldEnum
    having?: ULBScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ULBCountAggregateInputType | true
    _min?: ULBMinAggregateInputType
    _max?: ULBMaxAggregateInputType
  }

  export type ULBGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ULBCountAggregateOutputType | null
    _min: ULBMinAggregateOutputType | null
    _max: ULBMaxAggregateOutputType | null
  }

  type GetULBGroupByPayload<T extends ULBGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ULBGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ULBGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ULBGroupByOutputType[P]>
            : GetScalarType<T[P], ULBGroupByOutputType[P]>
        }
      >
    >


  export type ULBSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zones?: boolean | ULB$zonesArgs<ExtArgs>
    surveys?: boolean | ULB$surveysArgs<ExtArgs>
    _count?: boolean | ULBCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["uLB"]>

  export type ULBSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["uLB"]>

  export type ULBSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ULBInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zones?: boolean | ULB$zonesArgs<ExtArgs>
    surveys?: boolean | ULB$surveysArgs<ExtArgs>
    _count?: boolean | ULBCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ULBIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ULBPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ULB"
    objects: {
      zones: Prisma.$ZonePayload<ExtArgs>[]
      surveys: Prisma.$SurveyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["uLB"]>
    composites: {}
  }

  type ULBGetPayload<S extends boolean | null | undefined | ULBDefaultArgs> = $Result.GetResult<Prisma.$ULBPayload, S>

  type ULBCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ULBFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ULBCountAggregateInputType | true
    }

  export interface ULBDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ULB'], meta: { name: 'ULB' } }
    /**
     * Find zero or one ULB that matches the filter.
     * @param {ULBFindUniqueArgs} args - Arguments to find a ULB
     * @example
     * // Get one ULB
     * const uLB = await prisma.uLB.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ULBFindUniqueArgs>(args: SelectSubset<T, ULBFindUniqueArgs<ExtArgs>>): Prisma__ULBClient<$Result.GetResult<Prisma.$ULBPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ULB that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ULBFindUniqueOrThrowArgs} args - Arguments to find a ULB
     * @example
     * // Get one ULB
     * const uLB = await prisma.uLB.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ULBFindUniqueOrThrowArgs>(args: SelectSubset<T, ULBFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ULBClient<$Result.GetResult<Prisma.$ULBPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ULB that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ULBFindFirstArgs} args - Arguments to find a ULB
     * @example
     * // Get one ULB
     * const uLB = await prisma.uLB.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ULBFindFirstArgs>(args?: SelectSubset<T, ULBFindFirstArgs<ExtArgs>>): Prisma__ULBClient<$Result.GetResult<Prisma.$ULBPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ULB that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ULBFindFirstOrThrowArgs} args - Arguments to find a ULB
     * @example
     * // Get one ULB
     * const uLB = await prisma.uLB.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ULBFindFirstOrThrowArgs>(args?: SelectSubset<T, ULBFindFirstOrThrowArgs<ExtArgs>>): Prisma__ULBClient<$Result.GetResult<Prisma.$ULBPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ULBS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ULBFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ULBS
     * const uLBS = await prisma.uLB.findMany()
     * 
     * // Get first 10 ULBS
     * const uLBS = await prisma.uLB.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uLBWithIdOnly = await prisma.uLB.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ULBFindManyArgs>(args?: SelectSubset<T, ULBFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ULBPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ULB.
     * @param {ULBCreateArgs} args - Arguments to create a ULB.
     * @example
     * // Create one ULB
     * const ULB = await prisma.uLB.create({
     *   data: {
     *     // ... data to create a ULB
     *   }
     * })
     * 
     */
    create<T extends ULBCreateArgs>(args: SelectSubset<T, ULBCreateArgs<ExtArgs>>): Prisma__ULBClient<$Result.GetResult<Prisma.$ULBPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ULBS.
     * @param {ULBCreateManyArgs} args - Arguments to create many ULBS.
     * @example
     * // Create many ULBS
     * const uLB = await prisma.uLB.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ULBCreateManyArgs>(args?: SelectSubset<T, ULBCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ULBS and returns the data saved in the database.
     * @param {ULBCreateManyAndReturnArgs} args - Arguments to create many ULBS.
     * @example
     * // Create many ULBS
     * const uLB = await prisma.uLB.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ULBS and only return the `id`
     * const uLBWithIdOnly = await prisma.uLB.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ULBCreateManyAndReturnArgs>(args?: SelectSubset<T, ULBCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ULBPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ULB.
     * @param {ULBDeleteArgs} args - Arguments to delete one ULB.
     * @example
     * // Delete one ULB
     * const ULB = await prisma.uLB.delete({
     *   where: {
     *     // ... filter to delete one ULB
     *   }
     * })
     * 
     */
    delete<T extends ULBDeleteArgs>(args: SelectSubset<T, ULBDeleteArgs<ExtArgs>>): Prisma__ULBClient<$Result.GetResult<Prisma.$ULBPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ULB.
     * @param {ULBUpdateArgs} args - Arguments to update one ULB.
     * @example
     * // Update one ULB
     * const uLB = await prisma.uLB.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ULBUpdateArgs>(args: SelectSubset<T, ULBUpdateArgs<ExtArgs>>): Prisma__ULBClient<$Result.GetResult<Prisma.$ULBPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ULBS.
     * @param {ULBDeleteManyArgs} args - Arguments to filter ULBS to delete.
     * @example
     * // Delete a few ULBS
     * const { count } = await prisma.uLB.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ULBDeleteManyArgs>(args?: SelectSubset<T, ULBDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ULBS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ULBUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ULBS
     * const uLB = await prisma.uLB.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ULBUpdateManyArgs>(args: SelectSubset<T, ULBUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ULB.
     * @param {ULBUpsertArgs} args - Arguments to update or create a ULB.
     * @example
     * // Update or create a ULB
     * const uLB = await prisma.uLB.upsert({
     *   create: {
     *     // ... data to create a ULB
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ULB we want to update
     *   }
     * })
     */
    upsert<T extends ULBUpsertArgs>(args: SelectSubset<T, ULBUpsertArgs<ExtArgs>>): Prisma__ULBClient<$Result.GetResult<Prisma.$ULBPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ULBS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ULBCountArgs} args - Arguments to filter ULBS to count.
     * @example
     * // Count the number of ULBS
     * const count = await prisma.uLB.count({
     *   where: {
     *     // ... the filter for the ULBS we want to count
     *   }
     * })
    **/
    count<T extends ULBCountArgs>(
      args?: Subset<T, ULBCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ULBCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ULB.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ULBAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ULBAggregateArgs>(args: Subset<T, ULBAggregateArgs>): Prisma.PrismaPromise<GetULBAggregateType<T>>

    /**
     * Group by ULB.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ULBGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ULBGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ULBGroupByArgs['orderBy'] }
        : { orderBy?: ULBGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ULBGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetULBGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ULB model
   */
  readonly fields: ULBFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ULB.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ULBClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zones<T extends ULB$zonesArgs<ExtArgs> = {}>(args?: Subset<T, ULB$zonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany"> | Null>
    surveys<T extends ULB$surveysArgs<ExtArgs> = {}>(args?: Subset<T, ULB$surveysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ULB model
   */ 
  interface ULBFieldRefs {
    readonly id: FieldRef<"ULB", 'String'>
    readonly name: FieldRef<"ULB", 'String'>
    readonly createdAt: FieldRef<"ULB", 'DateTime'>
    readonly updatedAt: FieldRef<"ULB", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ULB findUnique
   */
  export type ULBFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ULB
     */
    select?: ULBSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ULBInclude<ExtArgs> | null
    /**
     * Filter, which ULB to fetch.
     */
    where: ULBWhereUniqueInput
  }

  /**
   * ULB findUniqueOrThrow
   */
  export type ULBFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ULB
     */
    select?: ULBSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ULBInclude<ExtArgs> | null
    /**
     * Filter, which ULB to fetch.
     */
    where: ULBWhereUniqueInput
  }

  /**
   * ULB findFirst
   */
  export type ULBFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ULB
     */
    select?: ULBSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ULBInclude<ExtArgs> | null
    /**
     * Filter, which ULB to fetch.
     */
    where?: ULBWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ULBS to fetch.
     */
    orderBy?: ULBOrderByWithRelationInput | ULBOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ULBS.
     */
    cursor?: ULBWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ULBS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ULBS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ULBS.
     */
    distinct?: ULBScalarFieldEnum | ULBScalarFieldEnum[]
  }

  /**
   * ULB findFirstOrThrow
   */
  export type ULBFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ULB
     */
    select?: ULBSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ULBInclude<ExtArgs> | null
    /**
     * Filter, which ULB to fetch.
     */
    where?: ULBWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ULBS to fetch.
     */
    orderBy?: ULBOrderByWithRelationInput | ULBOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ULBS.
     */
    cursor?: ULBWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ULBS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ULBS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ULBS.
     */
    distinct?: ULBScalarFieldEnum | ULBScalarFieldEnum[]
  }

  /**
   * ULB findMany
   */
  export type ULBFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ULB
     */
    select?: ULBSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ULBInclude<ExtArgs> | null
    /**
     * Filter, which ULBS to fetch.
     */
    where?: ULBWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ULBS to fetch.
     */
    orderBy?: ULBOrderByWithRelationInput | ULBOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ULBS.
     */
    cursor?: ULBWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ULBS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ULBS.
     */
    skip?: number
    distinct?: ULBScalarFieldEnum | ULBScalarFieldEnum[]
  }

  /**
   * ULB create
   */
  export type ULBCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ULB
     */
    select?: ULBSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ULBInclude<ExtArgs> | null
    /**
     * The data needed to create a ULB.
     */
    data: XOR<ULBCreateInput, ULBUncheckedCreateInput>
  }

  /**
   * ULB createMany
   */
  export type ULBCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ULBS.
     */
    data: ULBCreateManyInput | ULBCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ULB createManyAndReturn
   */
  export type ULBCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ULB
     */
    select?: ULBSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ULBS.
     */
    data: ULBCreateManyInput | ULBCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ULB update
   */
  export type ULBUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ULB
     */
    select?: ULBSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ULBInclude<ExtArgs> | null
    /**
     * The data needed to update a ULB.
     */
    data: XOR<ULBUpdateInput, ULBUncheckedUpdateInput>
    /**
     * Choose, which ULB to update.
     */
    where: ULBWhereUniqueInput
  }

  /**
   * ULB updateMany
   */
  export type ULBUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ULBS.
     */
    data: XOR<ULBUpdateManyMutationInput, ULBUncheckedUpdateManyInput>
    /**
     * Filter which ULBS to update
     */
    where?: ULBWhereInput
  }

  /**
   * ULB upsert
   */
  export type ULBUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ULB
     */
    select?: ULBSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ULBInclude<ExtArgs> | null
    /**
     * The filter to search for the ULB to update in case it exists.
     */
    where: ULBWhereUniqueInput
    /**
     * In case the ULB found by the `where` argument doesn't exist, create a new ULB with this data.
     */
    create: XOR<ULBCreateInput, ULBUncheckedCreateInput>
    /**
     * In case the ULB was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ULBUpdateInput, ULBUncheckedUpdateInput>
  }

  /**
   * ULB delete
   */
  export type ULBDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ULB
     */
    select?: ULBSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ULBInclude<ExtArgs> | null
    /**
     * Filter which ULB to delete.
     */
    where: ULBWhereUniqueInput
  }

  /**
   * ULB deleteMany
   */
  export type ULBDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ULBS to delete
     */
    where?: ULBWhereInput
  }

  /**
   * ULB.zones
   */
  export type ULB$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    cursor?: ZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * ULB.surveys
   */
  export type ULB$surveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    where?: SurveyWhereInput
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    cursor?: SurveyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * ULB without action
   */
  export type ULBDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ULB
     */
    select?: ULBSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ULBInclude<ExtArgs> | null
  }


  /**
   * Model Zone
   */

  export type AggregateZone = {
    _count: ZoneCountAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  export type ZoneMinAggregateOutputType = {
    id: string | null
    name: string | null
    ulbId: string | null
  }

  export type ZoneMaxAggregateOutputType = {
    id: string | null
    name: string | null
    ulbId: string | null
  }

  export type ZoneCountAggregateOutputType = {
    id: number
    name: number
    ulbId: number
    _all: number
  }


  export type ZoneMinAggregateInputType = {
    id?: true
    name?: true
    ulbId?: true
  }

  export type ZoneMaxAggregateInputType = {
    id?: true
    name?: true
    ulbId?: true
  }

  export type ZoneCountAggregateInputType = {
    id?: true
    name?: true
    ulbId?: true
    _all?: true
  }

  export type ZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zone to aggregate.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Zones
    **/
    _count?: true | ZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneMaxAggregateInputType
  }

  export type GetZoneAggregateType<T extends ZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZone[P]>
      : GetScalarType<T[P], AggregateZone[P]>
  }




  export type ZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithAggregationInput | ZoneOrderByWithAggregationInput[]
    by: ZoneScalarFieldEnum[] | ZoneScalarFieldEnum
    having?: ZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneCountAggregateInputType | true
    _min?: ZoneMinAggregateInputType
    _max?: ZoneMaxAggregateInputType
  }

  export type ZoneGroupByOutputType = {
    id: string
    name: string
    ulbId: string
    _count: ZoneCountAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  type GetZoneGroupByPayload<T extends ZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneGroupByOutputType[P]>
        }
      >
    >


  export type ZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ulbId?: boolean
    ulb?: boolean | ULBDefaultArgs<ExtArgs>
    wards?: boolean | Zone$wardsArgs<ExtArgs>
    surveys?: boolean | Zone$surveysArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ulbId?: boolean
    ulb?: boolean | ULBDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectScalar = {
    id?: boolean
    name?: boolean
    ulbId?: boolean
  }

  export type ZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ulb?: boolean | ULBDefaultArgs<ExtArgs>
    wards?: boolean | Zone$wardsArgs<ExtArgs>
    surveys?: boolean | Zone$surveysArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ulb?: boolean | ULBDefaultArgs<ExtArgs>
  }

  export type $ZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Zone"
    objects: {
      ulb: Prisma.$ULBPayload<ExtArgs>
      wards: Prisma.$WardPayload<ExtArgs>[]
      surveys: Prisma.$SurveyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      ulbId: string
    }, ExtArgs["result"]["zone"]>
    composites: {}
  }

  type ZoneGetPayload<S extends boolean | null | undefined | ZoneDefaultArgs> = $Result.GetResult<Prisma.$ZonePayload, S>

  type ZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ZoneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ZoneCountAggregateInputType | true
    }

  export interface ZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Zone'], meta: { name: 'Zone' } }
    /**
     * Find zero or one Zone that matches the filter.
     * @param {ZoneFindUniqueArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZoneFindUniqueArgs>(args: SelectSubset<T, ZoneFindUniqueArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Zone that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ZoneFindUniqueOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZoneFindFirstArgs>(args?: SelectSubset<T, ZoneFindFirstArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zone.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zoneWithIdOnly = await prisma.zone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZoneFindManyArgs>(args?: SelectSubset<T, ZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Zone.
     * @param {ZoneCreateArgs} args - Arguments to create a Zone.
     * @example
     * // Create one Zone
     * const Zone = await prisma.zone.create({
     *   data: {
     *     // ... data to create a Zone
     *   }
     * })
     * 
     */
    create<T extends ZoneCreateArgs>(args: SelectSubset<T, ZoneCreateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Zones.
     * @param {ZoneCreateManyArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZoneCreateManyArgs>(args?: SelectSubset<T, ZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zones and returns the data saved in the database.
     * @param {ZoneCreateManyAndReturnArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, ZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Zone.
     * @param {ZoneDeleteArgs} args - Arguments to delete one Zone.
     * @example
     * // Delete one Zone
     * const Zone = await prisma.zone.delete({
     *   where: {
     *     // ... filter to delete one Zone
     *   }
     * })
     * 
     */
    delete<T extends ZoneDeleteArgs>(args: SelectSubset<T, ZoneDeleteArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Zone.
     * @param {ZoneUpdateArgs} args - Arguments to update one Zone.
     * @example
     * // Update one Zone
     * const zone = await prisma.zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZoneUpdateArgs>(args: SelectSubset<T, ZoneUpdateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Zones.
     * @param {ZoneDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZoneDeleteManyArgs>(args?: SelectSubset<T, ZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZoneUpdateManyArgs>(args: SelectSubset<T, ZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Zone.
     * @param {ZoneUpsertArgs} args - Arguments to update or create a Zone.
     * @example
     * // Update or create a Zone
     * const zone = await prisma.zone.upsert({
     *   create: {
     *     // ... data to create a Zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zone we want to update
     *   }
     * })
     */
    upsert<T extends ZoneUpsertArgs>(args: SelectSubset<T, ZoneUpsertArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zone.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends ZoneCountArgs>(
      args?: Subset<T, ZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneAggregateArgs>(args: Subset<T, ZoneAggregateArgs>): Prisma.PrismaPromise<GetZoneAggregateType<T>>

    /**
     * Group by Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoneGroupByArgs['orderBy'] }
        : { orderBy?: ZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Zone model
   */
  readonly fields: ZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ulb<T extends ULBDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ULBDefaultArgs<ExtArgs>>): Prisma__ULBClient<$Result.GetResult<Prisma.$ULBPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    wards<T extends Zone$wardsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$wardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findMany"> | Null>
    surveys<T extends Zone$surveysArgs<ExtArgs> = {}>(args?: Subset<T, Zone$surveysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Zone model
   */ 
  interface ZoneFieldRefs {
    readonly id: FieldRef<"Zone", 'String'>
    readonly name: FieldRef<"Zone", 'String'>
    readonly ulbId: FieldRef<"Zone", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Zone findUnique
   */
  export type ZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findUniqueOrThrow
   */
  export type ZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findFirst
   */
  export type ZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findFirstOrThrow
   */
  export type ZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findMany
   */
  export type ZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zones to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone create
   */
  export type ZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Zone.
     */
    data: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
  }

  /**
   * Zone createMany
   */
  export type ZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Zone createManyAndReturn
   */
  export type ZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Zone update
   */
  export type ZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Zone.
     */
    data: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
    /**
     * Choose, which Zone to update.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone updateMany
   */
  export type ZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
  }

  /**
   * Zone upsert
   */
  export type ZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Zone to update in case it exists.
     */
    where: ZoneWhereUniqueInput
    /**
     * In case the Zone found by the `where` argument doesn't exist, create a new Zone with this data.
     */
    create: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
    /**
     * In case the Zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
  }

  /**
   * Zone delete
   */
  export type ZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter which Zone to delete.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone deleteMany
   */
  export type ZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zones to delete
     */
    where?: ZoneWhereInput
  }

  /**
   * Zone.wards
   */
  export type Zone$wardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    where?: WardWhereInput
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    cursor?: WardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Zone.surveys
   */
  export type Zone$surveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    where?: SurveyWhereInput
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    cursor?: SurveyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * Zone without action
   */
  export type ZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
  }


  /**
   * Model Ward
   */

  export type AggregateWard = {
    _count: WardCountAggregateOutputType | null
    _min: WardMinAggregateOutputType | null
    _max: WardMaxAggregateOutputType | null
  }

  export type WardMinAggregateOutputType = {
    id: string | null
    name: string | null
    zoneId: string | null
  }

  export type WardMaxAggregateOutputType = {
    id: string | null
    name: string | null
    zoneId: string | null
  }

  export type WardCountAggregateOutputType = {
    id: number
    name: number
    zoneId: number
    _all: number
  }


  export type WardMinAggregateInputType = {
    id?: true
    name?: true
    zoneId?: true
  }

  export type WardMaxAggregateInputType = {
    id?: true
    name?: true
    zoneId?: true
  }

  export type WardCountAggregateInputType = {
    id?: true
    name?: true
    zoneId?: true
    _all?: true
  }

  export type WardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ward to aggregate.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wards
    **/
    _count?: true | WardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WardMaxAggregateInputType
  }

  export type GetWardAggregateType<T extends WardAggregateArgs> = {
        [P in keyof T & keyof AggregateWard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWard[P]>
      : GetScalarType<T[P], AggregateWard[P]>
  }




  export type WardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardWhereInput
    orderBy?: WardOrderByWithAggregationInput | WardOrderByWithAggregationInput[]
    by: WardScalarFieldEnum[] | WardScalarFieldEnum
    having?: WardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WardCountAggregateInputType | true
    _min?: WardMinAggregateInputType
    _max?: WardMaxAggregateInputType
  }

  export type WardGroupByOutputType = {
    id: string
    name: string
    zoneId: string
    _count: WardCountAggregateOutputType | null
    _min: WardMinAggregateOutputType | null
    _max: WardMaxAggregateOutputType | null
  }

  type GetWardGroupByPayload<T extends WardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WardGroupByOutputType[P]>
            : GetScalarType<T[P], WardGroupByOutputType[P]>
        }
      >
    >


  export type WardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    zoneId?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    mohallas?: boolean | Ward$mohallasArgs<ExtArgs>
    surveys?: boolean | Ward$surveysArgs<ExtArgs>
    _count?: boolean | WardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ward"]>

  export type WardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    zoneId?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ward"]>

  export type WardSelectScalar = {
    id?: boolean
    name?: boolean
    zoneId?: boolean
  }

  export type WardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    mohallas?: boolean | Ward$mohallasArgs<ExtArgs>
    surveys?: boolean | Ward$surveysArgs<ExtArgs>
    _count?: boolean | WardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }

  export type $WardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ward"
    objects: {
      zone: Prisma.$ZonePayload<ExtArgs>
      mohallas: Prisma.$MohallaPayload<ExtArgs>[]
      surveys: Prisma.$SurveyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      zoneId: string
    }, ExtArgs["result"]["ward"]>
    composites: {}
  }

  type WardGetPayload<S extends boolean | null | undefined | WardDefaultArgs> = $Result.GetResult<Prisma.$WardPayload, S>

  type WardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WardCountAggregateInputType | true
    }

  export interface WardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ward'], meta: { name: 'Ward' } }
    /**
     * Find zero or one Ward that matches the filter.
     * @param {WardFindUniqueArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WardFindUniqueArgs>(args: SelectSubset<T, WardFindUniqueArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ward that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WardFindUniqueOrThrowArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WardFindUniqueOrThrowArgs>(args: SelectSubset<T, WardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardFindFirstArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WardFindFirstArgs>(args?: SelectSubset<T, WardFindFirstArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardFindFirstOrThrowArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WardFindFirstOrThrowArgs>(args?: SelectSubset<T, WardFindFirstOrThrowArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Wards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wards
     * const wards = await prisma.ward.findMany()
     * 
     * // Get first 10 Wards
     * const wards = await prisma.ward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wardWithIdOnly = await prisma.ward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WardFindManyArgs>(args?: SelectSubset<T, WardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ward.
     * @param {WardCreateArgs} args - Arguments to create a Ward.
     * @example
     * // Create one Ward
     * const Ward = await prisma.ward.create({
     *   data: {
     *     // ... data to create a Ward
     *   }
     * })
     * 
     */
    create<T extends WardCreateArgs>(args: SelectSubset<T, WardCreateArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Wards.
     * @param {WardCreateManyArgs} args - Arguments to create many Wards.
     * @example
     * // Create many Wards
     * const ward = await prisma.ward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WardCreateManyArgs>(args?: SelectSubset<T, WardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wards and returns the data saved in the database.
     * @param {WardCreateManyAndReturnArgs} args - Arguments to create many Wards.
     * @example
     * // Create many Wards
     * const ward = await prisma.ward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wards and only return the `id`
     * const wardWithIdOnly = await prisma.ward.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WardCreateManyAndReturnArgs>(args?: SelectSubset<T, WardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ward.
     * @param {WardDeleteArgs} args - Arguments to delete one Ward.
     * @example
     * // Delete one Ward
     * const Ward = await prisma.ward.delete({
     *   where: {
     *     // ... filter to delete one Ward
     *   }
     * })
     * 
     */
    delete<T extends WardDeleteArgs>(args: SelectSubset<T, WardDeleteArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ward.
     * @param {WardUpdateArgs} args - Arguments to update one Ward.
     * @example
     * // Update one Ward
     * const ward = await prisma.ward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WardUpdateArgs>(args: SelectSubset<T, WardUpdateArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Wards.
     * @param {WardDeleteManyArgs} args - Arguments to filter Wards to delete.
     * @example
     * // Delete a few Wards
     * const { count } = await prisma.ward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WardDeleteManyArgs>(args?: SelectSubset<T, WardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wards
     * const ward = await prisma.ward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WardUpdateManyArgs>(args: SelectSubset<T, WardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ward.
     * @param {WardUpsertArgs} args - Arguments to update or create a Ward.
     * @example
     * // Update or create a Ward
     * const ward = await prisma.ward.upsert({
     *   create: {
     *     // ... data to create a Ward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ward we want to update
     *   }
     * })
     */
    upsert<T extends WardUpsertArgs>(args: SelectSubset<T, WardUpsertArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Wards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardCountArgs} args - Arguments to filter Wards to count.
     * @example
     * // Count the number of Wards
     * const count = await prisma.ward.count({
     *   where: {
     *     // ... the filter for the Wards we want to count
     *   }
     * })
    **/
    count<T extends WardCountArgs>(
      args?: Subset<T, WardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WardAggregateArgs>(args: Subset<T, WardAggregateArgs>): Prisma.PrismaPromise<GetWardAggregateType<T>>

    /**
     * Group by Ward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WardGroupByArgs['orderBy'] }
        : { orderBy?: WardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ward model
   */
  readonly fields: WardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mohallas<T extends Ward$mohallasArgs<ExtArgs> = {}>(args?: Subset<T, Ward$mohallasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MohallaPayload<ExtArgs>, T, "findMany"> | Null>
    surveys<T extends Ward$surveysArgs<ExtArgs> = {}>(args?: Subset<T, Ward$surveysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ward model
   */ 
  interface WardFieldRefs {
    readonly id: FieldRef<"Ward", 'String'>
    readonly name: FieldRef<"Ward", 'String'>
    readonly zoneId: FieldRef<"Ward", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ward findUnique
   */
  export type WardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward findUniqueOrThrow
   */
  export type WardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward findFirst
   */
  export type WardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wards.
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wards.
     */
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Ward findFirstOrThrow
   */
  export type WardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wards.
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wards.
     */
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Ward findMany
   */
  export type WardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Wards to fetch.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wards.
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Ward create
   */
  export type WardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * The data needed to create a Ward.
     */
    data: XOR<WardCreateInput, WardUncheckedCreateInput>
  }

  /**
   * Ward createMany
   */
  export type WardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wards.
     */
    data: WardCreateManyInput | WardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ward createManyAndReturn
   */
  export type WardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Wards.
     */
    data: WardCreateManyInput | WardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ward update
   */
  export type WardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * The data needed to update a Ward.
     */
    data: XOR<WardUpdateInput, WardUncheckedUpdateInput>
    /**
     * Choose, which Ward to update.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward updateMany
   */
  export type WardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wards.
     */
    data: XOR<WardUpdateManyMutationInput, WardUncheckedUpdateManyInput>
    /**
     * Filter which Wards to update
     */
    where?: WardWhereInput
  }

  /**
   * Ward upsert
   */
  export type WardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * The filter to search for the Ward to update in case it exists.
     */
    where: WardWhereUniqueInput
    /**
     * In case the Ward found by the `where` argument doesn't exist, create a new Ward with this data.
     */
    create: XOR<WardCreateInput, WardUncheckedCreateInput>
    /**
     * In case the Ward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WardUpdateInput, WardUncheckedUpdateInput>
  }

  /**
   * Ward delete
   */
  export type WardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter which Ward to delete.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward deleteMany
   */
  export type WardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wards to delete
     */
    where?: WardWhereInput
  }

  /**
   * Ward.mohallas
   */
  export type Ward$mohallasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mohalla
     */
    select?: MohallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaInclude<ExtArgs> | null
    where?: MohallaWhereInput
    orderBy?: MohallaOrderByWithRelationInput | MohallaOrderByWithRelationInput[]
    cursor?: MohallaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MohallaScalarFieldEnum | MohallaScalarFieldEnum[]
  }

  /**
   * Ward.surveys
   */
  export type Ward$surveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    where?: SurveyWhereInput
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    cursor?: SurveyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * Ward without action
   */
  export type WardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
  }


  /**
   * Model Mohalla
   */

  export type AggregateMohalla = {
    _count: MohallaCountAggregateOutputType | null
    _min: MohallaMinAggregateOutputType | null
    _max: MohallaMaxAggregateOutputType | null
  }

  export type MohallaMinAggregateOutputType = {
    id: string | null
    name: string | null
    wardId: string | null
  }

  export type MohallaMaxAggregateOutputType = {
    id: string | null
    name: string | null
    wardId: string | null
  }

  export type MohallaCountAggregateOutputType = {
    id: number
    name: number
    wardId: number
    _all: number
  }


  export type MohallaMinAggregateInputType = {
    id?: true
    name?: true
    wardId?: true
  }

  export type MohallaMaxAggregateInputType = {
    id?: true
    name?: true
    wardId?: true
  }

  export type MohallaCountAggregateInputType = {
    id?: true
    name?: true
    wardId?: true
    _all?: true
  }

  export type MohallaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mohalla to aggregate.
     */
    where?: MohallaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mohallas to fetch.
     */
    orderBy?: MohallaOrderByWithRelationInput | MohallaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MohallaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mohallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mohallas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mohallas
    **/
    _count?: true | MohallaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MohallaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MohallaMaxAggregateInputType
  }

  export type GetMohallaAggregateType<T extends MohallaAggregateArgs> = {
        [P in keyof T & keyof AggregateMohalla]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMohalla[P]>
      : GetScalarType<T[P], AggregateMohalla[P]>
  }




  export type MohallaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MohallaWhereInput
    orderBy?: MohallaOrderByWithAggregationInput | MohallaOrderByWithAggregationInput[]
    by: MohallaScalarFieldEnum[] | MohallaScalarFieldEnum
    having?: MohallaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MohallaCountAggregateInputType | true
    _min?: MohallaMinAggregateInputType
    _max?: MohallaMaxAggregateInputType
  }

  export type MohallaGroupByOutputType = {
    id: string
    name: string
    wardId: string
    _count: MohallaCountAggregateOutputType | null
    _min: MohallaMinAggregateOutputType | null
    _max: MohallaMaxAggregateOutputType | null
  }

  type GetMohallaGroupByPayload<T extends MohallaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MohallaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MohallaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MohallaGroupByOutputType[P]>
            : GetScalarType<T[P], MohallaGroupByOutputType[P]>
        }
      >
    >


  export type MohallaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    wardId?: boolean
    ward?: boolean | WardDefaultArgs<ExtArgs>
    surveys?: boolean | Mohalla$surveysArgs<ExtArgs>
    _count?: boolean | MohallaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mohalla"]>

  export type MohallaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    wardId?: boolean
    ward?: boolean | WardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mohalla"]>

  export type MohallaSelectScalar = {
    id?: boolean
    name?: boolean
    wardId?: boolean
  }

  export type MohallaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ward?: boolean | WardDefaultArgs<ExtArgs>
    surveys?: boolean | Mohalla$surveysArgs<ExtArgs>
    _count?: boolean | MohallaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MohallaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ward?: boolean | WardDefaultArgs<ExtArgs>
  }

  export type $MohallaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mohalla"
    objects: {
      ward: Prisma.$WardPayload<ExtArgs>
      surveys: Prisma.$SurveyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      wardId: string
    }, ExtArgs["result"]["mohalla"]>
    composites: {}
  }

  type MohallaGetPayload<S extends boolean | null | undefined | MohallaDefaultArgs> = $Result.GetResult<Prisma.$MohallaPayload, S>

  type MohallaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MohallaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MohallaCountAggregateInputType | true
    }

  export interface MohallaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mohalla'], meta: { name: 'Mohalla' } }
    /**
     * Find zero or one Mohalla that matches the filter.
     * @param {MohallaFindUniqueArgs} args - Arguments to find a Mohalla
     * @example
     * // Get one Mohalla
     * const mohalla = await prisma.mohalla.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MohallaFindUniqueArgs>(args: SelectSubset<T, MohallaFindUniqueArgs<ExtArgs>>): Prisma__MohallaClient<$Result.GetResult<Prisma.$MohallaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mohalla that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MohallaFindUniqueOrThrowArgs} args - Arguments to find a Mohalla
     * @example
     * // Get one Mohalla
     * const mohalla = await prisma.mohalla.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MohallaFindUniqueOrThrowArgs>(args: SelectSubset<T, MohallaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MohallaClient<$Result.GetResult<Prisma.$MohallaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mohalla that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MohallaFindFirstArgs} args - Arguments to find a Mohalla
     * @example
     * // Get one Mohalla
     * const mohalla = await prisma.mohalla.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MohallaFindFirstArgs>(args?: SelectSubset<T, MohallaFindFirstArgs<ExtArgs>>): Prisma__MohallaClient<$Result.GetResult<Prisma.$MohallaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mohalla that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MohallaFindFirstOrThrowArgs} args - Arguments to find a Mohalla
     * @example
     * // Get one Mohalla
     * const mohalla = await prisma.mohalla.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MohallaFindFirstOrThrowArgs>(args?: SelectSubset<T, MohallaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MohallaClient<$Result.GetResult<Prisma.$MohallaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mohallas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MohallaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mohallas
     * const mohallas = await prisma.mohalla.findMany()
     * 
     * // Get first 10 Mohallas
     * const mohallas = await prisma.mohalla.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mohallaWithIdOnly = await prisma.mohalla.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MohallaFindManyArgs>(args?: SelectSubset<T, MohallaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MohallaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mohalla.
     * @param {MohallaCreateArgs} args - Arguments to create a Mohalla.
     * @example
     * // Create one Mohalla
     * const Mohalla = await prisma.mohalla.create({
     *   data: {
     *     // ... data to create a Mohalla
     *   }
     * })
     * 
     */
    create<T extends MohallaCreateArgs>(args: SelectSubset<T, MohallaCreateArgs<ExtArgs>>): Prisma__MohallaClient<$Result.GetResult<Prisma.$MohallaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mohallas.
     * @param {MohallaCreateManyArgs} args - Arguments to create many Mohallas.
     * @example
     * // Create many Mohallas
     * const mohalla = await prisma.mohalla.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MohallaCreateManyArgs>(args?: SelectSubset<T, MohallaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mohallas and returns the data saved in the database.
     * @param {MohallaCreateManyAndReturnArgs} args - Arguments to create many Mohallas.
     * @example
     * // Create many Mohallas
     * const mohalla = await prisma.mohalla.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mohallas and only return the `id`
     * const mohallaWithIdOnly = await prisma.mohalla.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MohallaCreateManyAndReturnArgs>(args?: SelectSubset<T, MohallaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MohallaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Mohalla.
     * @param {MohallaDeleteArgs} args - Arguments to delete one Mohalla.
     * @example
     * // Delete one Mohalla
     * const Mohalla = await prisma.mohalla.delete({
     *   where: {
     *     // ... filter to delete one Mohalla
     *   }
     * })
     * 
     */
    delete<T extends MohallaDeleteArgs>(args: SelectSubset<T, MohallaDeleteArgs<ExtArgs>>): Prisma__MohallaClient<$Result.GetResult<Prisma.$MohallaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mohalla.
     * @param {MohallaUpdateArgs} args - Arguments to update one Mohalla.
     * @example
     * // Update one Mohalla
     * const mohalla = await prisma.mohalla.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MohallaUpdateArgs>(args: SelectSubset<T, MohallaUpdateArgs<ExtArgs>>): Prisma__MohallaClient<$Result.GetResult<Prisma.$MohallaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mohallas.
     * @param {MohallaDeleteManyArgs} args - Arguments to filter Mohallas to delete.
     * @example
     * // Delete a few Mohallas
     * const { count } = await prisma.mohalla.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MohallaDeleteManyArgs>(args?: SelectSubset<T, MohallaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mohallas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MohallaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mohallas
     * const mohalla = await prisma.mohalla.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MohallaUpdateManyArgs>(args: SelectSubset<T, MohallaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mohalla.
     * @param {MohallaUpsertArgs} args - Arguments to update or create a Mohalla.
     * @example
     * // Update or create a Mohalla
     * const mohalla = await prisma.mohalla.upsert({
     *   create: {
     *     // ... data to create a Mohalla
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mohalla we want to update
     *   }
     * })
     */
    upsert<T extends MohallaUpsertArgs>(args: SelectSubset<T, MohallaUpsertArgs<ExtArgs>>): Prisma__MohallaClient<$Result.GetResult<Prisma.$MohallaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Mohallas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MohallaCountArgs} args - Arguments to filter Mohallas to count.
     * @example
     * // Count the number of Mohallas
     * const count = await prisma.mohalla.count({
     *   where: {
     *     // ... the filter for the Mohallas we want to count
     *   }
     * })
    **/
    count<T extends MohallaCountArgs>(
      args?: Subset<T, MohallaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MohallaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mohalla.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MohallaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MohallaAggregateArgs>(args: Subset<T, MohallaAggregateArgs>): Prisma.PrismaPromise<GetMohallaAggregateType<T>>

    /**
     * Group by Mohalla.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MohallaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MohallaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MohallaGroupByArgs['orderBy'] }
        : { orderBy?: MohallaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MohallaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMohallaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mohalla model
   */
  readonly fields: MohallaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mohalla.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MohallaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ward<T extends WardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WardDefaultArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    surveys<T extends Mohalla$surveysArgs<ExtArgs> = {}>(args?: Subset<T, Mohalla$surveysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mohalla model
   */ 
  interface MohallaFieldRefs {
    readonly id: FieldRef<"Mohalla", 'String'>
    readonly name: FieldRef<"Mohalla", 'String'>
    readonly wardId: FieldRef<"Mohalla", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Mohalla findUnique
   */
  export type MohallaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mohalla
     */
    select?: MohallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaInclude<ExtArgs> | null
    /**
     * Filter, which Mohalla to fetch.
     */
    where: MohallaWhereUniqueInput
  }

  /**
   * Mohalla findUniqueOrThrow
   */
  export type MohallaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mohalla
     */
    select?: MohallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaInclude<ExtArgs> | null
    /**
     * Filter, which Mohalla to fetch.
     */
    where: MohallaWhereUniqueInput
  }

  /**
   * Mohalla findFirst
   */
  export type MohallaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mohalla
     */
    select?: MohallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaInclude<ExtArgs> | null
    /**
     * Filter, which Mohalla to fetch.
     */
    where?: MohallaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mohallas to fetch.
     */
    orderBy?: MohallaOrderByWithRelationInput | MohallaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mohallas.
     */
    cursor?: MohallaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mohallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mohallas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mohallas.
     */
    distinct?: MohallaScalarFieldEnum | MohallaScalarFieldEnum[]
  }

  /**
   * Mohalla findFirstOrThrow
   */
  export type MohallaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mohalla
     */
    select?: MohallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaInclude<ExtArgs> | null
    /**
     * Filter, which Mohalla to fetch.
     */
    where?: MohallaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mohallas to fetch.
     */
    orderBy?: MohallaOrderByWithRelationInput | MohallaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mohallas.
     */
    cursor?: MohallaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mohallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mohallas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mohallas.
     */
    distinct?: MohallaScalarFieldEnum | MohallaScalarFieldEnum[]
  }

  /**
   * Mohalla findMany
   */
  export type MohallaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mohalla
     */
    select?: MohallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaInclude<ExtArgs> | null
    /**
     * Filter, which Mohallas to fetch.
     */
    where?: MohallaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mohallas to fetch.
     */
    orderBy?: MohallaOrderByWithRelationInput | MohallaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mohallas.
     */
    cursor?: MohallaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mohallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mohallas.
     */
    skip?: number
    distinct?: MohallaScalarFieldEnum | MohallaScalarFieldEnum[]
  }

  /**
   * Mohalla create
   */
  export type MohallaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mohalla
     */
    select?: MohallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaInclude<ExtArgs> | null
    /**
     * The data needed to create a Mohalla.
     */
    data: XOR<MohallaCreateInput, MohallaUncheckedCreateInput>
  }

  /**
   * Mohalla createMany
   */
  export type MohallaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mohallas.
     */
    data: MohallaCreateManyInput | MohallaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mohalla createManyAndReturn
   */
  export type MohallaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mohalla
     */
    select?: MohallaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Mohallas.
     */
    data: MohallaCreateManyInput | MohallaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mohalla update
   */
  export type MohallaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mohalla
     */
    select?: MohallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaInclude<ExtArgs> | null
    /**
     * The data needed to update a Mohalla.
     */
    data: XOR<MohallaUpdateInput, MohallaUncheckedUpdateInput>
    /**
     * Choose, which Mohalla to update.
     */
    where: MohallaWhereUniqueInput
  }

  /**
   * Mohalla updateMany
   */
  export type MohallaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mohallas.
     */
    data: XOR<MohallaUpdateManyMutationInput, MohallaUncheckedUpdateManyInput>
    /**
     * Filter which Mohallas to update
     */
    where?: MohallaWhereInput
  }

  /**
   * Mohalla upsert
   */
  export type MohallaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mohalla
     */
    select?: MohallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaInclude<ExtArgs> | null
    /**
     * The filter to search for the Mohalla to update in case it exists.
     */
    where: MohallaWhereUniqueInput
    /**
     * In case the Mohalla found by the `where` argument doesn't exist, create a new Mohalla with this data.
     */
    create: XOR<MohallaCreateInput, MohallaUncheckedCreateInput>
    /**
     * In case the Mohalla was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MohallaUpdateInput, MohallaUncheckedUpdateInput>
  }

  /**
   * Mohalla delete
   */
  export type MohallaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mohalla
     */
    select?: MohallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaInclude<ExtArgs> | null
    /**
     * Filter which Mohalla to delete.
     */
    where: MohallaWhereUniqueInput
  }

  /**
   * Mohalla deleteMany
   */
  export type MohallaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mohallas to delete
     */
    where?: MohallaWhereInput
  }

  /**
   * Mohalla.surveys
   */
  export type Mohalla$surveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    where?: SurveyWhereInput
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    cursor?: SurveyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * Mohalla without action
   */
  export type MohallaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mohalla
     */
    select?: MohallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MohallaInclude<ExtArgs> | null
  }


  /**
   * Model PropertyResponseType
   */

  export type AggregatePropertyResponseType = {
    _count: PropertyResponseTypeCountAggregateOutputType | null
    _min: PropertyResponseTypeMinAggregateOutputType | null
    _max: PropertyResponseTypeMaxAggregateOutputType | null
  }

  export type PropertyResponseTypeMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
  }

  export type PropertyResponseTypeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
  }

  export type PropertyResponseTypeCountAggregateOutputType = {
    id: number
    code: number
    description: number
    _all: number
  }


  export type PropertyResponseTypeMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
  }

  export type PropertyResponseTypeMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
  }

  export type PropertyResponseTypeCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    _all?: true
  }

  export type PropertyResponseTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyResponseType to aggregate.
     */
    where?: PropertyResponseTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyResponseTypes to fetch.
     */
    orderBy?: PropertyResponseTypeOrderByWithRelationInput | PropertyResponseTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyResponseTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyResponseTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyResponseTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyResponseTypes
    **/
    _count?: true | PropertyResponseTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyResponseTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyResponseTypeMaxAggregateInputType
  }

  export type GetPropertyResponseTypeAggregateType<T extends PropertyResponseTypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyResponseType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyResponseType[P]>
      : GetScalarType<T[P], AggregatePropertyResponseType[P]>
  }




  export type PropertyResponseTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyResponseTypeWhereInput
    orderBy?: PropertyResponseTypeOrderByWithAggregationInput | PropertyResponseTypeOrderByWithAggregationInput[]
    by: PropertyResponseTypeScalarFieldEnum[] | PropertyResponseTypeScalarFieldEnum
    having?: PropertyResponseTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyResponseTypeCountAggregateInputType | true
    _min?: PropertyResponseTypeMinAggregateInputType
    _max?: PropertyResponseTypeMaxAggregateInputType
  }

  export type PropertyResponseTypeGroupByOutputType = {
    id: string
    code: string
    description: string
    _count: PropertyResponseTypeCountAggregateOutputType | null
    _min: PropertyResponseTypeMinAggregateOutputType | null
    _max: PropertyResponseTypeMaxAggregateOutputType | null
  }

  type GetPropertyResponseTypeGroupByPayload<T extends PropertyResponseTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyResponseTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyResponseTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyResponseTypeGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyResponseTypeGroupByOutputType[P]>
        }
      >
    >


  export type PropertyResponseTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    surveys?: boolean | PropertyResponseType$surveysArgs<ExtArgs>
    _count?: boolean | PropertyResponseTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyResponseType"]>

  export type PropertyResponseTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
  }, ExtArgs["result"]["propertyResponseType"]>

  export type PropertyResponseTypeSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
  }

  export type PropertyResponseTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveys?: boolean | PropertyResponseType$surveysArgs<ExtArgs>
    _count?: boolean | PropertyResponseTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyResponseTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PropertyResponseTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyResponseType"
    objects: {
      surveys: Prisma.$PropertyDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string
    }, ExtArgs["result"]["propertyResponseType"]>
    composites: {}
  }

  type PropertyResponseTypeGetPayload<S extends boolean | null | undefined | PropertyResponseTypeDefaultArgs> = $Result.GetResult<Prisma.$PropertyResponseTypePayload, S>

  type PropertyResponseTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyResponseTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PropertyResponseTypeCountAggregateInputType | true
    }

  export interface PropertyResponseTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyResponseType'], meta: { name: 'PropertyResponseType' } }
    /**
     * Find zero or one PropertyResponseType that matches the filter.
     * @param {PropertyResponseTypeFindUniqueArgs} args - Arguments to find a PropertyResponseType
     * @example
     * // Get one PropertyResponseType
     * const propertyResponseType = await prisma.propertyResponseType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyResponseTypeFindUniqueArgs>(args: SelectSubset<T, PropertyResponseTypeFindUniqueArgs<ExtArgs>>): Prisma__PropertyResponseTypeClient<$Result.GetResult<Prisma.$PropertyResponseTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PropertyResponseType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PropertyResponseTypeFindUniqueOrThrowArgs} args - Arguments to find a PropertyResponseType
     * @example
     * // Get one PropertyResponseType
     * const propertyResponseType = await prisma.propertyResponseType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyResponseTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyResponseTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyResponseTypeClient<$Result.GetResult<Prisma.$PropertyResponseTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PropertyResponseType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyResponseTypeFindFirstArgs} args - Arguments to find a PropertyResponseType
     * @example
     * // Get one PropertyResponseType
     * const propertyResponseType = await prisma.propertyResponseType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyResponseTypeFindFirstArgs>(args?: SelectSubset<T, PropertyResponseTypeFindFirstArgs<ExtArgs>>): Prisma__PropertyResponseTypeClient<$Result.GetResult<Prisma.$PropertyResponseTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PropertyResponseType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyResponseTypeFindFirstOrThrowArgs} args - Arguments to find a PropertyResponseType
     * @example
     * // Get one PropertyResponseType
     * const propertyResponseType = await prisma.propertyResponseType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyResponseTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyResponseTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyResponseTypeClient<$Result.GetResult<Prisma.$PropertyResponseTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PropertyResponseTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyResponseTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyResponseTypes
     * const propertyResponseTypes = await prisma.propertyResponseType.findMany()
     * 
     * // Get first 10 PropertyResponseTypes
     * const propertyResponseTypes = await prisma.propertyResponseType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyResponseTypeWithIdOnly = await prisma.propertyResponseType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyResponseTypeFindManyArgs>(args?: SelectSubset<T, PropertyResponseTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyResponseTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PropertyResponseType.
     * @param {PropertyResponseTypeCreateArgs} args - Arguments to create a PropertyResponseType.
     * @example
     * // Create one PropertyResponseType
     * const PropertyResponseType = await prisma.propertyResponseType.create({
     *   data: {
     *     // ... data to create a PropertyResponseType
     *   }
     * })
     * 
     */
    create<T extends PropertyResponseTypeCreateArgs>(args: SelectSubset<T, PropertyResponseTypeCreateArgs<ExtArgs>>): Prisma__PropertyResponseTypeClient<$Result.GetResult<Prisma.$PropertyResponseTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PropertyResponseTypes.
     * @param {PropertyResponseTypeCreateManyArgs} args - Arguments to create many PropertyResponseTypes.
     * @example
     * // Create many PropertyResponseTypes
     * const propertyResponseType = await prisma.propertyResponseType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyResponseTypeCreateManyArgs>(args?: SelectSubset<T, PropertyResponseTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyResponseTypes and returns the data saved in the database.
     * @param {PropertyResponseTypeCreateManyAndReturnArgs} args - Arguments to create many PropertyResponseTypes.
     * @example
     * // Create many PropertyResponseTypes
     * const propertyResponseType = await prisma.propertyResponseType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyResponseTypes and only return the `id`
     * const propertyResponseTypeWithIdOnly = await prisma.propertyResponseType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyResponseTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyResponseTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyResponseTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PropertyResponseType.
     * @param {PropertyResponseTypeDeleteArgs} args - Arguments to delete one PropertyResponseType.
     * @example
     * // Delete one PropertyResponseType
     * const PropertyResponseType = await prisma.propertyResponseType.delete({
     *   where: {
     *     // ... filter to delete one PropertyResponseType
     *   }
     * })
     * 
     */
    delete<T extends PropertyResponseTypeDeleteArgs>(args: SelectSubset<T, PropertyResponseTypeDeleteArgs<ExtArgs>>): Prisma__PropertyResponseTypeClient<$Result.GetResult<Prisma.$PropertyResponseTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PropertyResponseType.
     * @param {PropertyResponseTypeUpdateArgs} args - Arguments to update one PropertyResponseType.
     * @example
     * // Update one PropertyResponseType
     * const propertyResponseType = await prisma.propertyResponseType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyResponseTypeUpdateArgs>(args: SelectSubset<T, PropertyResponseTypeUpdateArgs<ExtArgs>>): Prisma__PropertyResponseTypeClient<$Result.GetResult<Prisma.$PropertyResponseTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PropertyResponseTypes.
     * @param {PropertyResponseTypeDeleteManyArgs} args - Arguments to filter PropertyResponseTypes to delete.
     * @example
     * // Delete a few PropertyResponseTypes
     * const { count } = await prisma.propertyResponseType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyResponseTypeDeleteManyArgs>(args?: SelectSubset<T, PropertyResponseTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyResponseTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyResponseTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyResponseTypes
     * const propertyResponseType = await prisma.propertyResponseType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyResponseTypeUpdateManyArgs>(args: SelectSubset<T, PropertyResponseTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyResponseType.
     * @param {PropertyResponseTypeUpsertArgs} args - Arguments to update or create a PropertyResponseType.
     * @example
     * // Update or create a PropertyResponseType
     * const propertyResponseType = await prisma.propertyResponseType.upsert({
     *   create: {
     *     // ... data to create a PropertyResponseType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyResponseType we want to update
     *   }
     * })
     */
    upsert<T extends PropertyResponseTypeUpsertArgs>(args: SelectSubset<T, PropertyResponseTypeUpsertArgs<ExtArgs>>): Prisma__PropertyResponseTypeClient<$Result.GetResult<Prisma.$PropertyResponseTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PropertyResponseTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyResponseTypeCountArgs} args - Arguments to filter PropertyResponseTypes to count.
     * @example
     * // Count the number of PropertyResponseTypes
     * const count = await prisma.propertyResponseType.count({
     *   where: {
     *     // ... the filter for the PropertyResponseTypes we want to count
     *   }
     * })
    **/
    count<T extends PropertyResponseTypeCountArgs>(
      args?: Subset<T, PropertyResponseTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyResponseTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyResponseType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyResponseTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyResponseTypeAggregateArgs>(args: Subset<T, PropertyResponseTypeAggregateArgs>): Prisma.PrismaPromise<GetPropertyResponseTypeAggregateType<T>>

    /**
     * Group by PropertyResponseType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyResponseTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyResponseTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyResponseTypeGroupByArgs['orderBy'] }
        : { orderBy?: PropertyResponseTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyResponseTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyResponseTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyResponseType model
   */
  readonly fields: PropertyResponseTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyResponseType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyResponseTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    surveys<T extends PropertyResponseType$surveysArgs<ExtArgs> = {}>(args?: Subset<T, PropertyResponseType$surveysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyResponseType model
   */ 
  interface PropertyResponseTypeFieldRefs {
    readonly id: FieldRef<"PropertyResponseType", 'String'>
    readonly code: FieldRef<"PropertyResponseType", 'String'>
    readonly description: FieldRef<"PropertyResponseType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PropertyResponseType findUnique
   */
  export type PropertyResponseTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyResponseType
     */
    select?: PropertyResponseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyResponseTypeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyResponseType to fetch.
     */
    where: PropertyResponseTypeWhereUniqueInput
  }

  /**
   * PropertyResponseType findUniqueOrThrow
   */
  export type PropertyResponseTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyResponseType
     */
    select?: PropertyResponseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyResponseTypeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyResponseType to fetch.
     */
    where: PropertyResponseTypeWhereUniqueInput
  }

  /**
   * PropertyResponseType findFirst
   */
  export type PropertyResponseTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyResponseType
     */
    select?: PropertyResponseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyResponseTypeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyResponseType to fetch.
     */
    where?: PropertyResponseTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyResponseTypes to fetch.
     */
    orderBy?: PropertyResponseTypeOrderByWithRelationInput | PropertyResponseTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyResponseTypes.
     */
    cursor?: PropertyResponseTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyResponseTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyResponseTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyResponseTypes.
     */
    distinct?: PropertyResponseTypeScalarFieldEnum | PropertyResponseTypeScalarFieldEnum[]
  }

  /**
   * PropertyResponseType findFirstOrThrow
   */
  export type PropertyResponseTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyResponseType
     */
    select?: PropertyResponseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyResponseTypeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyResponseType to fetch.
     */
    where?: PropertyResponseTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyResponseTypes to fetch.
     */
    orderBy?: PropertyResponseTypeOrderByWithRelationInput | PropertyResponseTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyResponseTypes.
     */
    cursor?: PropertyResponseTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyResponseTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyResponseTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyResponseTypes.
     */
    distinct?: PropertyResponseTypeScalarFieldEnum | PropertyResponseTypeScalarFieldEnum[]
  }

  /**
   * PropertyResponseType findMany
   */
  export type PropertyResponseTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyResponseType
     */
    select?: PropertyResponseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyResponseTypeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyResponseTypes to fetch.
     */
    where?: PropertyResponseTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyResponseTypes to fetch.
     */
    orderBy?: PropertyResponseTypeOrderByWithRelationInput | PropertyResponseTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyResponseTypes.
     */
    cursor?: PropertyResponseTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyResponseTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyResponseTypes.
     */
    skip?: number
    distinct?: PropertyResponseTypeScalarFieldEnum | PropertyResponseTypeScalarFieldEnum[]
  }

  /**
   * PropertyResponseType create
   */
  export type PropertyResponseTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyResponseType
     */
    select?: PropertyResponseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyResponseTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyResponseType.
     */
    data: XOR<PropertyResponseTypeCreateInput, PropertyResponseTypeUncheckedCreateInput>
  }

  /**
   * PropertyResponseType createMany
   */
  export type PropertyResponseTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyResponseTypes.
     */
    data: PropertyResponseTypeCreateManyInput | PropertyResponseTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyResponseType createManyAndReturn
   */
  export type PropertyResponseTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyResponseType
     */
    select?: PropertyResponseTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PropertyResponseTypes.
     */
    data: PropertyResponseTypeCreateManyInput | PropertyResponseTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyResponseType update
   */
  export type PropertyResponseTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyResponseType
     */
    select?: PropertyResponseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyResponseTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyResponseType.
     */
    data: XOR<PropertyResponseTypeUpdateInput, PropertyResponseTypeUncheckedUpdateInput>
    /**
     * Choose, which PropertyResponseType to update.
     */
    where: PropertyResponseTypeWhereUniqueInput
  }

  /**
   * PropertyResponseType updateMany
   */
  export type PropertyResponseTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyResponseTypes.
     */
    data: XOR<PropertyResponseTypeUpdateManyMutationInput, PropertyResponseTypeUncheckedUpdateManyInput>
    /**
     * Filter which PropertyResponseTypes to update
     */
    where?: PropertyResponseTypeWhereInput
  }

  /**
   * PropertyResponseType upsert
   */
  export type PropertyResponseTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyResponseType
     */
    select?: PropertyResponseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyResponseTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyResponseType to update in case it exists.
     */
    where: PropertyResponseTypeWhereUniqueInput
    /**
     * In case the PropertyResponseType found by the `where` argument doesn't exist, create a new PropertyResponseType with this data.
     */
    create: XOR<PropertyResponseTypeCreateInput, PropertyResponseTypeUncheckedCreateInput>
    /**
     * In case the PropertyResponseType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyResponseTypeUpdateInput, PropertyResponseTypeUncheckedUpdateInput>
  }

  /**
   * PropertyResponseType delete
   */
  export type PropertyResponseTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyResponseType
     */
    select?: PropertyResponseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyResponseTypeInclude<ExtArgs> | null
    /**
     * Filter which PropertyResponseType to delete.
     */
    where: PropertyResponseTypeWhereUniqueInput
  }

  /**
   * PropertyResponseType deleteMany
   */
  export type PropertyResponseTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyResponseTypes to delete
     */
    where?: PropertyResponseTypeWhereInput
  }

  /**
   * PropertyResponseType.surveys
   */
  export type PropertyResponseType$surveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    where?: PropertyDetailsWhereInput
    orderBy?: PropertyDetailsOrderByWithRelationInput | PropertyDetailsOrderByWithRelationInput[]
    cursor?: PropertyDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyDetailsScalarFieldEnum | PropertyDetailsScalarFieldEnum[]
  }

  /**
   * PropertyResponseType without action
   */
  export type PropertyResponseTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyResponseType
     */
    select?: PropertyResponseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyResponseTypeInclude<ExtArgs> | null
  }


  /**
   * Model RoadTypeMapping
   */

  export type AggregateRoadTypeMapping = {
    _count: RoadTypeMappingCountAggregateOutputType | null
    _min: RoadTypeMappingMinAggregateOutputType | null
    _max: RoadTypeMappingMaxAggregateOutputType | null
  }

  export type RoadTypeMappingMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
  }

  export type RoadTypeMappingMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
  }

  export type RoadTypeMappingCountAggregateOutputType = {
    id: number
    code: number
    description: number
    _all: number
  }


  export type RoadTypeMappingMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
  }

  export type RoadTypeMappingMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
  }

  export type RoadTypeMappingCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    _all?: true
  }

  export type RoadTypeMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadTypeMapping to aggregate.
     */
    where?: RoadTypeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadTypeMappings to fetch.
     */
    orderBy?: RoadTypeMappingOrderByWithRelationInput | RoadTypeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadTypeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadTypeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadTypeMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoadTypeMappings
    **/
    _count?: true | RoadTypeMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadTypeMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadTypeMappingMaxAggregateInputType
  }

  export type GetRoadTypeMappingAggregateType<T extends RoadTypeMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadTypeMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadTypeMapping[P]>
      : GetScalarType<T[P], AggregateRoadTypeMapping[P]>
  }




  export type RoadTypeMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadTypeMappingWhereInput
    orderBy?: RoadTypeMappingOrderByWithAggregationInput | RoadTypeMappingOrderByWithAggregationInput[]
    by: RoadTypeMappingScalarFieldEnum[] | RoadTypeMappingScalarFieldEnum
    having?: RoadTypeMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadTypeMappingCountAggregateInputType | true
    _min?: RoadTypeMappingMinAggregateInputType
    _max?: RoadTypeMappingMaxAggregateInputType
  }

  export type RoadTypeMappingGroupByOutputType = {
    id: string
    code: string
    description: string
    _count: RoadTypeMappingCountAggregateOutputType | null
    _min: RoadTypeMappingMinAggregateOutputType | null
    _max: RoadTypeMappingMaxAggregateOutputType | null
  }

  type GetRoadTypeMappingGroupByPayload<T extends RoadTypeMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadTypeMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadTypeMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadTypeMappingGroupByOutputType[P]>
            : GetScalarType<T[P], RoadTypeMappingGroupByOutputType[P]>
        }
      >
    >


  export type RoadTypeMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    locations?: boolean | RoadTypeMapping$locationsArgs<ExtArgs>
    _count?: boolean | RoadTypeMappingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadTypeMapping"]>

  export type RoadTypeMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
  }, ExtArgs["result"]["roadTypeMapping"]>

  export type RoadTypeMappingSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
  }

  export type RoadTypeMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | RoadTypeMapping$locationsArgs<ExtArgs>
    _count?: boolean | RoadTypeMappingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoadTypeMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RoadTypeMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoadTypeMapping"
    objects: {
      locations: Prisma.$LocationDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string
    }, ExtArgs["result"]["roadTypeMapping"]>
    composites: {}
  }

  type RoadTypeMappingGetPayload<S extends boolean | null | undefined | RoadTypeMappingDefaultArgs> = $Result.GetResult<Prisma.$RoadTypeMappingPayload, S>

  type RoadTypeMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoadTypeMappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoadTypeMappingCountAggregateInputType | true
    }

  export interface RoadTypeMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoadTypeMapping'], meta: { name: 'RoadTypeMapping' } }
    /**
     * Find zero or one RoadTypeMapping that matches the filter.
     * @param {RoadTypeMappingFindUniqueArgs} args - Arguments to find a RoadTypeMapping
     * @example
     * // Get one RoadTypeMapping
     * const roadTypeMapping = await prisma.roadTypeMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadTypeMappingFindUniqueArgs>(args: SelectSubset<T, RoadTypeMappingFindUniqueArgs<ExtArgs>>): Prisma__RoadTypeMappingClient<$Result.GetResult<Prisma.$RoadTypeMappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoadTypeMapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoadTypeMappingFindUniqueOrThrowArgs} args - Arguments to find a RoadTypeMapping
     * @example
     * // Get one RoadTypeMapping
     * const roadTypeMapping = await prisma.roadTypeMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadTypeMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadTypeMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadTypeMappingClient<$Result.GetResult<Prisma.$RoadTypeMappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoadTypeMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadTypeMappingFindFirstArgs} args - Arguments to find a RoadTypeMapping
     * @example
     * // Get one RoadTypeMapping
     * const roadTypeMapping = await prisma.roadTypeMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadTypeMappingFindFirstArgs>(args?: SelectSubset<T, RoadTypeMappingFindFirstArgs<ExtArgs>>): Prisma__RoadTypeMappingClient<$Result.GetResult<Prisma.$RoadTypeMappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoadTypeMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadTypeMappingFindFirstOrThrowArgs} args - Arguments to find a RoadTypeMapping
     * @example
     * // Get one RoadTypeMapping
     * const roadTypeMapping = await prisma.roadTypeMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadTypeMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadTypeMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadTypeMappingClient<$Result.GetResult<Prisma.$RoadTypeMappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoadTypeMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadTypeMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoadTypeMappings
     * const roadTypeMappings = await prisma.roadTypeMapping.findMany()
     * 
     * // Get first 10 RoadTypeMappings
     * const roadTypeMappings = await prisma.roadTypeMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadTypeMappingWithIdOnly = await prisma.roadTypeMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadTypeMappingFindManyArgs>(args?: SelectSubset<T, RoadTypeMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadTypeMappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoadTypeMapping.
     * @param {RoadTypeMappingCreateArgs} args - Arguments to create a RoadTypeMapping.
     * @example
     * // Create one RoadTypeMapping
     * const RoadTypeMapping = await prisma.roadTypeMapping.create({
     *   data: {
     *     // ... data to create a RoadTypeMapping
     *   }
     * })
     * 
     */
    create<T extends RoadTypeMappingCreateArgs>(args: SelectSubset<T, RoadTypeMappingCreateArgs<ExtArgs>>): Prisma__RoadTypeMappingClient<$Result.GetResult<Prisma.$RoadTypeMappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoadTypeMappings.
     * @param {RoadTypeMappingCreateManyArgs} args - Arguments to create many RoadTypeMappings.
     * @example
     * // Create many RoadTypeMappings
     * const roadTypeMapping = await prisma.roadTypeMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadTypeMappingCreateManyArgs>(args?: SelectSubset<T, RoadTypeMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoadTypeMappings and returns the data saved in the database.
     * @param {RoadTypeMappingCreateManyAndReturnArgs} args - Arguments to create many RoadTypeMappings.
     * @example
     * // Create many RoadTypeMappings
     * const roadTypeMapping = await prisma.roadTypeMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoadTypeMappings and only return the `id`
     * const roadTypeMappingWithIdOnly = await prisma.roadTypeMapping.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoadTypeMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, RoadTypeMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadTypeMappingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoadTypeMapping.
     * @param {RoadTypeMappingDeleteArgs} args - Arguments to delete one RoadTypeMapping.
     * @example
     * // Delete one RoadTypeMapping
     * const RoadTypeMapping = await prisma.roadTypeMapping.delete({
     *   where: {
     *     // ... filter to delete one RoadTypeMapping
     *   }
     * })
     * 
     */
    delete<T extends RoadTypeMappingDeleteArgs>(args: SelectSubset<T, RoadTypeMappingDeleteArgs<ExtArgs>>): Prisma__RoadTypeMappingClient<$Result.GetResult<Prisma.$RoadTypeMappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoadTypeMapping.
     * @param {RoadTypeMappingUpdateArgs} args - Arguments to update one RoadTypeMapping.
     * @example
     * // Update one RoadTypeMapping
     * const roadTypeMapping = await prisma.roadTypeMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadTypeMappingUpdateArgs>(args: SelectSubset<T, RoadTypeMappingUpdateArgs<ExtArgs>>): Prisma__RoadTypeMappingClient<$Result.GetResult<Prisma.$RoadTypeMappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoadTypeMappings.
     * @param {RoadTypeMappingDeleteManyArgs} args - Arguments to filter RoadTypeMappings to delete.
     * @example
     * // Delete a few RoadTypeMappings
     * const { count } = await prisma.roadTypeMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadTypeMappingDeleteManyArgs>(args?: SelectSubset<T, RoadTypeMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoadTypeMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadTypeMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoadTypeMappings
     * const roadTypeMapping = await prisma.roadTypeMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadTypeMappingUpdateManyArgs>(args: SelectSubset<T, RoadTypeMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoadTypeMapping.
     * @param {RoadTypeMappingUpsertArgs} args - Arguments to update or create a RoadTypeMapping.
     * @example
     * // Update or create a RoadTypeMapping
     * const roadTypeMapping = await prisma.roadTypeMapping.upsert({
     *   create: {
     *     // ... data to create a RoadTypeMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoadTypeMapping we want to update
     *   }
     * })
     */
    upsert<T extends RoadTypeMappingUpsertArgs>(args: SelectSubset<T, RoadTypeMappingUpsertArgs<ExtArgs>>): Prisma__RoadTypeMappingClient<$Result.GetResult<Prisma.$RoadTypeMappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoadTypeMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadTypeMappingCountArgs} args - Arguments to filter RoadTypeMappings to count.
     * @example
     * // Count the number of RoadTypeMappings
     * const count = await prisma.roadTypeMapping.count({
     *   where: {
     *     // ... the filter for the RoadTypeMappings we want to count
     *   }
     * })
    **/
    count<T extends RoadTypeMappingCountArgs>(
      args?: Subset<T, RoadTypeMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadTypeMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoadTypeMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadTypeMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadTypeMappingAggregateArgs>(args: Subset<T, RoadTypeMappingAggregateArgs>): Prisma.PrismaPromise<GetRoadTypeMappingAggregateType<T>>

    /**
     * Group by RoadTypeMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadTypeMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadTypeMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadTypeMappingGroupByArgs['orderBy'] }
        : { orderBy?: RoadTypeMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadTypeMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadTypeMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoadTypeMapping model
   */
  readonly fields: RoadTypeMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoadTypeMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadTypeMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    locations<T extends RoadTypeMapping$locationsArgs<ExtArgs> = {}>(args?: Subset<T, RoadTypeMapping$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoadTypeMapping model
   */ 
  interface RoadTypeMappingFieldRefs {
    readonly id: FieldRef<"RoadTypeMapping", 'String'>
    readonly code: FieldRef<"RoadTypeMapping", 'String'>
    readonly description: FieldRef<"RoadTypeMapping", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RoadTypeMapping findUnique
   */
  export type RoadTypeMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMapping
     */
    select?: RoadTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMappingInclude<ExtArgs> | null
    /**
     * Filter, which RoadTypeMapping to fetch.
     */
    where: RoadTypeMappingWhereUniqueInput
  }

  /**
   * RoadTypeMapping findUniqueOrThrow
   */
  export type RoadTypeMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMapping
     */
    select?: RoadTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMappingInclude<ExtArgs> | null
    /**
     * Filter, which RoadTypeMapping to fetch.
     */
    where: RoadTypeMappingWhereUniqueInput
  }

  /**
   * RoadTypeMapping findFirst
   */
  export type RoadTypeMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMapping
     */
    select?: RoadTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMappingInclude<ExtArgs> | null
    /**
     * Filter, which RoadTypeMapping to fetch.
     */
    where?: RoadTypeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadTypeMappings to fetch.
     */
    orderBy?: RoadTypeMappingOrderByWithRelationInput | RoadTypeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadTypeMappings.
     */
    cursor?: RoadTypeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadTypeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadTypeMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadTypeMappings.
     */
    distinct?: RoadTypeMappingScalarFieldEnum | RoadTypeMappingScalarFieldEnum[]
  }

  /**
   * RoadTypeMapping findFirstOrThrow
   */
  export type RoadTypeMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMapping
     */
    select?: RoadTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMappingInclude<ExtArgs> | null
    /**
     * Filter, which RoadTypeMapping to fetch.
     */
    where?: RoadTypeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadTypeMappings to fetch.
     */
    orderBy?: RoadTypeMappingOrderByWithRelationInput | RoadTypeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadTypeMappings.
     */
    cursor?: RoadTypeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadTypeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadTypeMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadTypeMappings.
     */
    distinct?: RoadTypeMappingScalarFieldEnum | RoadTypeMappingScalarFieldEnum[]
  }

  /**
   * RoadTypeMapping findMany
   */
  export type RoadTypeMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMapping
     */
    select?: RoadTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMappingInclude<ExtArgs> | null
    /**
     * Filter, which RoadTypeMappings to fetch.
     */
    where?: RoadTypeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadTypeMappings to fetch.
     */
    orderBy?: RoadTypeMappingOrderByWithRelationInput | RoadTypeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoadTypeMappings.
     */
    cursor?: RoadTypeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadTypeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadTypeMappings.
     */
    skip?: number
    distinct?: RoadTypeMappingScalarFieldEnum | RoadTypeMappingScalarFieldEnum[]
  }

  /**
   * RoadTypeMapping create
   */
  export type RoadTypeMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMapping
     */
    select?: RoadTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a RoadTypeMapping.
     */
    data: XOR<RoadTypeMappingCreateInput, RoadTypeMappingUncheckedCreateInput>
  }

  /**
   * RoadTypeMapping createMany
   */
  export type RoadTypeMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoadTypeMappings.
     */
    data: RoadTypeMappingCreateManyInput | RoadTypeMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoadTypeMapping createManyAndReturn
   */
  export type RoadTypeMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMapping
     */
    select?: RoadTypeMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoadTypeMappings.
     */
    data: RoadTypeMappingCreateManyInput | RoadTypeMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoadTypeMapping update
   */
  export type RoadTypeMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMapping
     */
    select?: RoadTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a RoadTypeMapping.
     */
    data: XOR<RoadTypeMappingUpdateInput, RoadTypeMappingUncheckedUpdateInput>
    /**
     * Choose, which RoadTypeMapping to update.
     */
    where: RoadTypeMappingWhereUniqueInput
  }

  /**
   * RoadTypeMapping updateMany
   */
  export type RoadTypeMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoadTypeMappings.
     */
    data: XOR<RoadTypeMappingUpdateManyMutationInput, RoadTypeMappingUncheckedUpdateManyInput>
    /**
     * Filter which RoadTypeMappings to update
     */
    where?: RoadTypeMappingWhereInput
  }

  /**
   * RoadTypeMapping upsert
   */
  export type RoadTypeMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMapping
     */
    select?: RoadTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the RoadTypeMapping to update in case it exists.
     */
    where: RoadTypeMappingWhereUniqueInput
    /**
     * In case the RoadTypeMapping found by the `where` argument doesn't exist, create a new RoadTypeMapping with this data.
     */
    create: XOR<RoadTypeMappingCreateInput, RoadTypeMappingUncheckedCreateInput>
    /**
     * In case the RoadTypeMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadTypeMappingUpdateInput, RoadTypeMappingUncheckedUpdateInput>
  }

  /**
   * RoadTypeMapping delete
   */
  export type RoadTypeMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMapping
     */
    select?: RoadTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMappingInclude<ExtArgs> | null
    /**
     * Filter which RoadTypeMapping to delete.
     */
    where: RoadTypeMappingWhereUniqueInput
  }

  /**
   * RoadTypeMapping deleteMany
   */
  export type RoadTypeMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadTypeMappings to delete
     */
    where?: RoadTypeMappingWhereInput
  }

  /**
   * RoadTypeMapping.locations
   */
  export type RoadTypeMapping$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    where?: LocationDetailsWhereInput
    orderBy?: LocationDetailsOrderByWithRelationInput | LocationDetailsOrderByWithRelationInput[]
    cursor?: LocationDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationDetailsScalarFieldEnum | LocationDetailsScalarFieldEnum[]
  }

  /**
   * RoadTypeMapping without action
   */
  export type RoadTypeMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadTypeMapping
     */
    select?: RoadTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadTypeMappingInclude<ExtArgs> | null
  }


  /**
   * Model ConstructionTypeMapping
   */

  export type AggregateConstructionTypeMapping = {
    _count: ConstructionTypeMappingCountAggregateOutputType | null
    _min: ConstructionTypeMappingMinAggregateOutputType | null
    _max: ConstructionTypeMappingMaxAggregateOutputType | null
  }

  export type ConstructionTypeMappingMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
  }

  export type ConstructionTypeMappingMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
  }

  export type ConstructionTypeMappingCountAggregateOutputType = {
    id: number
    code: number
    description: number
    _all: number
  }


  export type ConstructionTypeMappingMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
  }

  export type ConstructionTypeMappingMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
  }

  export type ConstructionTypeMappingCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    _all?: true
  }

  export type ConstructionTypeMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConstructionTypeMapping to aggregate.
     */
    where?: ConstructionTypeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionTypeMappings to fetch.
     */
    orderBy?: ConstructionTypeMappingOrderByWithRelationInput | ConstructionTypeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConstructionTypeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionTypeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionTypeMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConstructionTypeMappings
    **/
    _count?: true | ConstructionTypeMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConstructionTypeMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConstructionTypeMappingMaxAggregateInputType
  }

  export type GetConstructionTypeMappingAggregateType<T extends ConstructionTypeMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateConstructionTypeMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConstructionTypeMapping[P]>
      : GetScalarType<T[P], AggregateConstructionTypeMapping[P]>
  }




  export type ConstructionTypeMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConstructionTypeMappingWhereInput
    orderBy?: ConstructionTypeMappingOrderByWithAggregationInput | ConstructionTypeMappingOrderByWithAggregationInput[]
    by: ConstructionTypeMappingScalarFieldEnum[] | ConstructionTypeMappingScalarFieldEnum
    having?: ConstructionTypeMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConstructionTypeMappingCountAggregateInputType | true
    _min?: ConstructionTypeMappingMinAggregateInputType
    _max?: ConstructionTypeMappingMaxAggregateInputType
  }

  export type ConstructionTypeMappingGroupByOutputType = {
    id: string
    code: string
    description: string
    _count: ConstructionTypeMappingCountAggregateOutputType | null
    _min: ConstructionTypeMappingMinAggregateOutputType | null
    _max: ConstructionTypeMappingMaxAggregateOutputType | null
  }

  type GetConstructionTypeMappingGroupByPayload<T extends ConstructionTypeMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConstructionTypeMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConstructionTypeMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConstructionTypeMappingGroupByOutputType[P]>
            : GetScalarType<T[P], ConstructionTypeMappingGroupByOutputType[P]>
        }
      >
    >


  export type ConstructionTypeMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    locations?: boolean | ConstructionTypeMapping$locationsArgs<ExtArgs>
    _count?: boolean | ConstructionTypeMappingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["constructionTypeMapping"]>

  export type ConstructionTypeMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
  }, ExtArgs["result"]["constructionTypeMapping"]>

  export type ConstructionTypeMappingSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
  }

  export type ConstructionTypeMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | ConstructionTypeMapping$locationsArgs<ExtArgs>
    _count?: boolean | ConstructionTypeMappingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConstructionTypeMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ConstructionTypeMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConstructionTypeMapping"
    objects: {
      locations: Prisma.$LocationDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string
    }, ExtArgs["result"]["constructionTypeMapping"]>
    composites: {}
  }

  type ConstructionTypeMappingGetPayload<S extends boolean | null | undefined | ConstructionTypeMappingDefaultArgs> = $Result.GetResult<Prisma.$ConstructionTypeMappingPayload, S>

  type ConstructionTypeMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConstructionTypeMappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConstructionTypeMappingCountAggregateInputType | true
    }

  export interface ConstructionTypeMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConstructionTypeMapping'], meta: { name: 'ConstructionTypeMapping' } }
    /**
     * Find zero or one ConstructionTypeMapping that matches the filter.
     * @param {ConstructionTypeMappingFindUniqueArgs} args - Arguments to find a ConstructionTypeMapping
     * @example
     * // Get one ConstructionTypeMapping
     * const constructionTypeMapping = await prisma.constructionTypeMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConstructionTypeMappingFindUniqueArgs>(args: SelectSubset<T, ConstructionTypeMappingFindUniqueArgs<ExtArgs>>): Prisma__ConstructionTypeMappingClient<$Result.GetResult<Prisma.$ConstructionTypeMappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConstructionTypeMapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConstructionTypeMappingFindUniqueOrThrowArgs} args - Arguments to find a ConstructionTypeMapping
     * @example
     * // Get one ConstructionTypeMapping
     * const constructionTypeMapping = await prisma.constructionTypeMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConstructionTypeMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, ConstructionTypeMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConstructionTypeMappingClient<$Result.GetResult<Prisma.$ConstructionTypeMappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConstructionTypeMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTypeMappingFindFirstArgs} args - Arguments to find a ConstructionTypeMapping
     * @example
     * // Get one ConstructionTypeMapping
     * const constructionTypeMapping = await prisma.constructionTypeMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConstructionTypeMappingFindFirstArgs>(args?: SelectSubset<T, ConstructionTypeMappingFindFirstArgs<ExtArgs>>): Prisma__ConstructionTypeMappingClient<$Result.GetResult<Prisma.$ConstructionTypeMappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConstructionTypeMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTypeMappingFindFirstOrThrowArgs} args - Arguments to find a ConstructionTypeMapping
     * @example
     * // Get one ConstructionTypeMapping
     * const constructionTypeMapping = await prisma.constructionTypeMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConstructionTypeMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, ConstructionTypeMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConstructionTypeMappingClient<$Result.GetResult<Prisma.$ConstructionTypeMappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConstructionTypeMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTypeMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConstructionTypeMappings
     * const constructionTypeMappings = await prisma.constructionTypeMapping.findMany()
     * 
     * // Get first 10 ConstructionTypeMappings
     * const constructionTypeMappings = await prisma.constructionTypeMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const constructionTypeMappingWithIdOnly = await prisma.constructionTypeMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConstructionTypeMappingFindManyArgs>(args?: SelectSubset<T, ConstructionTypeMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionTypeMappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConstructionTypeMapping.
     * @param {ConstructionTypeMappingCreateArgs} args - Arguments to create a ConstructionTypeMapping.
     * @example
     * // Create one ConstructionTypeMapping
     * const ConstructionTypeMapping = await prisma.constructionTypeMapping.create({
     *   data: {
     *     // ... data to create a ConstructionTypeMapping
     *   }
     * })
     * 
     */
    create<T extends ConstructionTypeMappingCreateArgs>(args: SelectSubset<T, ConstructionTypeMappingCreateArgs<ExtArgs>>): Prisma__ConstructionTypeMappingClient<$Result.GetResult<Prisma.$ConstructionTypeMappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConstructionTypeMappings.
     * @param {ConstructionTypeMappingCreateManyArgs} args - Arguments to create many ConstructionTypeMappings.
     * @example
     * // Create many ConstructionTypeMappings
     * const constructionTypeMapping = await prisma.constructionTypeMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConstructionTypeMappingCreateManyArgs>(args?: SelectSubset<T, ConstructionTypeMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConstructionTypeMappings and returns the data saved in the database.
     * @param {ConstructionTypeMappingCreateManyAndReturnArgs} args - Arguments to create many ConstructionTypeMappings.
     * @example
     * // Create many ConstructionTypeMappings
     * const constructionTypeMapping = await prisma.constructionTypeMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConstructionTypeMappings and only return the `id`
     * const constructionTypeMappingWithIdOnly = await prisma.constructionTypeMapping.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConstructionTypeMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, ConstructionTypeMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionTypeMappingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConstructionTypeMapping.
     * @param {ConstructionTypeMappingDeleteArgs} args - Arguments to delete one ConstructionTypeMapping.
     * @example
     * // Delete one ConstructionTypeMapping
     * const ConstructionTypeMapping = await prisma.constructionTypeMapping.delete({
     *   where: {
     *     // ... filter to delete one ConstructionTypeMapping
     *   }
     * })
     * 
     */
    delete<T extends ConstructionTypeMappingDeleteArgs>(args: SelectSubset<T, ConstructionTypeMappingDeleteArgs<ExtArgs>>): Prisma__ConstructionTypeMappingClient<$Result.GetResult<Prisma.$ConstructionTypeMappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConstructionTypeMapping.
     * @param {ConstructionTypeMappingUpdateArgs} args - Arguments to update one ConstructionTypeMapping.
     * @example
     * // Update one ConstructionTypeMapping
     * const constructionTypeMapping = await prisma.constructionTypeMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConstructionTypeMappingUpdateArgs>(args: SelectSubset<T, ConstructionTypeMappingUpdateArgs<ExtArgs>>): Prisma__ConstructionTypeMappingClient<$Result.GetResult<Prisma.$ConstructionTypeMappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConstructionTypeMappings.
     * @param {ConstructionTypeMappingDeleteManyArgs} args - Arguments to filter ConstructionTypeMappings to delete.
     * @example
     * // Delete a few ConstructionTypeMappings
     * const { count } = await prisma.constructionTypeMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConstructionTypeMappingDeleteManyArgs>(args?: SelectSubset<T, ConstructionTypeMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConstructionTypeMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTypeMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConstructionTypeMappings
     * const constructionTypeMapping = await prisma.constructionTypeMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConstructionTypeMappingUpdateManyArgs>(args: SelectSubset<T, ConstructionTypeMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConstructionTypeMapping.
     * @param {ConstructionTypeMappingUpsertArgs} args - Arguments to update or create a ConstructionTypeMapping.
     * @example
     * // Update or create a ConstructionTypeMapping
     * const constructionTypeMapping = await prisma.constructionTypeMapping.upsert({
     *   create: {
     *     // ... data to create a ConstructionTypeMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConstructionTypeMapping we want to update
     *   }
     * })
     */
    upsert<T extends ConstructionTypeMappingUpsertArgs>(args: SelectSubset<T, ConstructionTypeMappingUpsertArgs<ExtArgs>>): Prisma__ConstructionTypeMappingClient<$Result.GetResult<Prisma.$ConstructionTypeMappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConstructionTypeMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTypeMappingCountArgs} args - Arguments to filter ConstructionTypeMappings to count.
     * @example
     * // Count the number of ConstructionTypeMappings
     * const count = await prisma.constructionTypeMapping.count({
     *   where: {
     *     // ... the filter for the ConstructionTypeMappings we want to count
     *   }
     * })
    **/
    count<T extends ConstructionTypeMappingCountArgs>(
      args?: Subset<T, ConstructionTypeMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConstructionTypeMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConstructionTypeMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTypeMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConstructionTypeMappingAggregateArgs>(args: Subset<T, ConstructionTypeMappingAggregateArgs>): Prisma.PrismaPromise<GetConstructionTypeMappingAggregateType<T>>

    /**
     * Group by ConstructionTypeMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTypeMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConstructionTypeMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConstructionTypeMappingGroupByArgs['orderBy'] }
        : { orderBy?: ConstructionTypeMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConstructionTypeMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConstructionTypeMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConstructionTypeMapping model
   */
  readonly fields: ConstructionTypeMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConstructionTypeMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConstructionTypeMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    locations<T extends ConstructionTypeMapping$locationsArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionTypeMapping$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConstructionTypeMapping model
   */ 
  interface ConstructionTypeMappingFieldRefs {
    readonly id: FieldRef<"ConstructionTypeMapping", 'String'>
    readonly code: FieldRef<"ConstructionTypeMapping", 'String'>
    readonly description: FieldRef<"ConstructionTypeMapping", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConstructionTypeMapping findUnique
   */
  export type ConstructionTypeMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMapping
     */
    select?: ConstructionTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMappingInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionTypeMapping to fetch.
     */
    where: ConstructionTypeMappingWhereUniqueInput
  }

  /**
   * ConstructionTypeMapping findUniqueOrThrow
   */
  export type ConstructionTypeMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMapping
     */
    select?: ConstructionTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMappingInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionTypeMapping to fetch.
     */
    where: ConstructionTypeMappingWhereUniqueInput
  }

  /**
   * ConstructionTypeMapping findFirst
   */
  export type ConstructionTypeMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMapping
     */
    select?: ConstructionTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMappingInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionTypeMapping to fetch.
     */
    where?: ConstructionTypeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionTypeMappings to fetch.
     */
    orderBy?: ConstructionTypeMappingOrderByWithRelationInput | ConstructionTypeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConstructionTypeMappings.
     */
    cursor?: ConstructionTypeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionTypeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionTypeMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConstructionTypeMappings.
     */
    distinct?: ConstructionTypeMappingScalarFieldEnum | ConstructionTypeMappingScalarFieldEnum[]
  }

  /**
   * ConstructionTypeMapping findFirstOrThrow
   */
  export type ConstructionTypeMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMapping
     */
    select?: ConstructionTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMappingInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionTypeMapping to fetch.
     */
    where?: ConstructionTypeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionTypeMappings to fetch.
     */
    orderBy?: ConstructionTypeMappingOrderByWithRelationInput | ConstructionTypeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConstructionTypeMappings.
     */
    cursor?: ConstructionTypeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionTypeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionTypeMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConstructionTypeMappings.
     */
    distinct?: ConstructionTypeMappingScalarFieldEnum | ConstructionTypeMappingScalarFieldEnum[]
  }

  /**
   * ConstructionTypeMapping findMany
   */
  export type ConstructionTypeMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMapping
     */
    select?: ConstructionTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMappingInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionTypeMappings to fetch.
     */
    where?: ConstructionTypeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionTypeMappings to fetch.
     */
    orderBy?: ConstructionTypeMappingOrderByWithRelationInput | ConstructionTypeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConstructionTypeMappings.
     */
    cursor?: ConstructionTypeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionTypeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionTypeMappings.
     */
    skip?: number
    distinct?: ConstructionTypeMappingScalarFieldEnum | ConstructionTypeMappingScalarFieldEnum[]
  }

  /**
   * ConstructionTypeMapping create
   */
  export type ConstructionTypeMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMapping
     */
    select?: ConstructionTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a ConstructionTypeMapping.
     */
    data: XOR<ConstructionTypeMappingCreateInput, ConstructionTypeMappingUncheckedCreateInput>
  }

  /**
   * ConstructionTypeMapping createMany
   */
  export type ConstructionTypeMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConstructionTypeMappings.
     */
    data: ConstructionTypeMappingCreateManyInput | ConstructionTypeMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConstructionTypeMapping createManyAndReturn
   */
  export type ConstructionTypeMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMapping
     */
    select?: ConstructionTypeMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConstructionTypeMappings.
     */
    data: ConstructionTypeMappingCreateManyInput | ConstructionTypeMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConstructionTypeMapping update
   */
  export type ConstructionTypeMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMapping
     */
    select?: ConstructionTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a ConstructionTypeMapping.
     */
    data: XOR<ConstructionTypeMappingUpdateInput, ConstructionTypeMappingUncheckedUpdateInput>
    /**
     * Choose, which ConstructionTypeMapping to update.
     */
    where: ConstructionTypeMappingWhereUniqueInput
  }

  /**
   * ConstructionTypeMapping updateMany
   */
  export type ConstructionTypeMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConstructionTypeMappings.
     */
    data: XOR<ConstructionTypeMappingUpdateManyMutationInput, ConstructionTypeMappingUncheckedUpdateManyInput>
    /**
     * Filter which ConstructionTypeMappings to update
     */
    where?: ConstructionTypeMappingWhereInput
  }

  /**
   * ConstructionTypeMapping upsert
   */
  export type ConstructionTypeMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMapping
     */
    select?: ConstructionTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the ConstructionTypeMapping to update in case it exists.
     */
    where: ConstructionTypeMappingWhereUniqueInput
    /**
     * In case the ConstructionTypeMapping found by the `where` argument doesn't exist, create a new ConstructionTypeMapping with this data.
     */
    create: XOR<ConstructionTypeMappingCreateInput, ConstructionTypeMappingUncheckedCreateInput>
    /**
     * In case the ConstructionTypeMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConstructionTypeMappingUpdateInput, ConstructionTypeMappingUncheckedUpdateInput>
  }

  /**
   * ConstructionTypeMapping delete
   */
  export type ConstructionTypeMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMapping
     */
    select?: ConstructionTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMappingInclude<ExtArgs> | null
    /**
     * Filter which ConstructionTypeMapping to delete.
     */
    where: ConstructionTypeMappingWhereUniqueInput
  }

  /**
   * ConstructionTypeMapping deleteMany
   */
  export type ConstructionTypeMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConstructionTypeMappings to delete
     */
    where?: ConstructionTypeMappingWhereInput
  }

  /**
   * ConstructionTypeMapping.locations
   */
  export type ConstructionTypeMapping$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    where?: LocationDetailsWhereInput
    orderBy?: LocationDetailsOrderByWithRelationInput | LocationDetailsOrderByWithRelationInput[]
    cursor?: LocationDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationDetailsScalarFieldEnum | LocationDetailsScalarFieldEnum[]
  }

  /**
   * ConstructionTypeMapping without action
   */
  export type ConstructionTypeMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTypeMapping
     */
    select?: ConstructionTypeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTypeMappingInclude<ExtArgs> | null
  }


  /**
   * Model NRPropCategoryMapping
   */

  export type AggregateNRPropCategoryMapping = {
    _count: NRPropCategoryMappingCountAggregateOutputType | null
    _min: NRPropCategoryMappingMinAggregateOutputType | null
    _max: NRPropCategoryMappingMaxAggregateOutputType | null
  }

  export type NRPropCategoryMappingMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
  }

  export type NRPropCategoryMappingMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
  }

  export type NRPropCategoryMappingCountAggregateOutputType = {
    id: number
    code: number
    description: number
    _all: number
  }


  export type NRPropCategoryMappingMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
  }

  export type NRPropCategoryMappingMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
  }

  export type NRPropCategoryMappingCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    _all?: true
  }

  export type NRPropCategoryMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NRPropCategoryMapping to aggregate.
     */
    where?: NRPropCategoryMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NRPropCategoryMappings to fetch.
     */
    orderBy?: NRPropCategoryMappingOrderByWithRelationInput | NRPropCategoryMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NRPropCategoryMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NRPropCategoryMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NRPropCategoryMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NRPropCategoryMappings
    **/
    _count?: true | NRPropCategoryMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NRPropCategoryMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NRPropCategoryMappingMaxAggregateInputType
  }

  export type GetNRPropCategoryMappingAggregateType<T extends NRPropCategoryMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateNRPropCategoryMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNRPropCategoryMapping[P]>
      : GetScalarType<T[P], AggregateNRPropCategoryMapping[P]>
  }




  export type NRPropCategoryMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NRPropCategoryMappingWhereInput
    orderBy?: NRPropCategoryMappingOrderByWithAggregationInput | NRPropCategoryMappingOrderByWithAggregationInput[]
    by: NRPropCategoryMappingScalarFieldEnum[] | NRPropCategoryMappingScalarFieldEnum
    having?: NRPropCategoryMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NRPropCategoryMappingCountAggregateInputType | true
    _min?: NRPropCategoryMappingMinAggregateInputType
    _max?: NRPropCategoryMappingMaxAggregateInputType
  }

  export type NRPropCategoryMappingGroupByOutputType = {
    id: string
    code: string
    description: string
    _count: NRPropCategoryMappingCountAggregateOutputType | null
    _min: NRPropCategoryMappingMinAggregateOutputType | null
    _max: NRPropCategoryMappingMaxAggregateOutputType | null
  }

  type GetNRPropCategoryMappingGroupByPayload<T extends NRPropCategoryMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NRPropCategoryMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NRPropCategoryMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NRPropCategoryMappingGroupByOutputType[P]>
            : GetScalarType<T[P], NRPropCategoryMappingGroupByOutputType[P]>
        }
      >
    >


  export type NRPropCategoryMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    subCategories?: boolean | NRPropCategoryMapping$subCategoriesArgs<ExtArgs>
    assessments?: boolean | NRPropCategoryMapping$assessmentsArgs<ExtArgs>
    _count?: boolean | NRPropCategoryMappingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nRPropCategoryMapping"]>

  export type NRPropCategoryMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
  }, ExtArgs["result"]["nRPropCategoryMapping"]>

  export type NRPropCategoryMappingSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
  }

  export type NRPropCategoryMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCategories?: boolean | NRPropCategoryMapping$subCategoriesArgs<ExtArgs>
    assessments?: boolean | NRPropCategoryMapping$assessmentsArgs<ExtArgs>
    _count?: boolean | NRPropCategoryMappingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NRPropCategoryMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NRPropCategoryMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NRPropCategoryMapping"
    objects: {
      subCategories: Prisma.$NRPropSubCategoryMappingPayload<ExtArgs>[]
      assessments: Prisma.$PropertyAssessmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string
    }, ExtArgs["result"]["nRPropCategoryMapping"]>
    composites: {}
  }

  type NRPropCategoryMappingGetPayload<S extends boolean | null | undefined | NRPropCategoryMappingDefaultArgs> = $Result.GetResult<Prisma.$NRPropCategoryMappingPayload, S>

  type NRPropCategoryMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NRPropCategoryMappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NRPropCategoryMappingCountAggregateInputType | true
    }

  export interface NRPropCategoryMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NRPropCategoryMapping'], meta: { name: 'NRPropCategoryMapping' } }
    /**
     * Find zero or one NRPropCategoryMapping that matches the filter.
     * @param {NRPropCategoryMappingFindUniqueArgs} args - Arguments to find a NRPropCategoryMapping
     * @example
     * // Get one NRPropCategoryMapping
     * const nRPropCategoryMapping = await prisma.nRPropCategoryMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NRPropCategoryMappingFindUniqueArgs>(args: SelectSubset<T, NRPropCategoryMappingFindUniqueArgs<ExtArgs>>): Prisma__NRPropCategoryMappingClient<$Result.GetResult<Prisma.$NRPropCategoryMappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NRPropCategoryMapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NRPropCategoryMappingFindUniqueOrThrowArgs} args - Arguments to find a NRPropCategoryMapping
     * @example
     * // Get one NRPropCategoryMapping
     * const nRPropCategoryMapping = await prisma.nRPropCategoryMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NRPropCategoryMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, NRPropCategoryMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NRPropCategoryMappingClient<$Result.GetResult<Prisma.$NRPropCategoryMappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NRPropCategoryMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRPropCategoryMappingFindFirstArgs} args - Arguments to find a NRPropCategoryMapping
     * @example
     * // Get one NRPropCategoryMapping
     * const nRPropCategoryMapping = await prisma.nRPropCategoryMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NRPropCategoryMappingFindFirstArgs>(args?: SelectSubset<T, NRPropCategoryMappingFindFirstArgs<ExtArgs>>): Prisma__NRPropCategoryMappingClient<$Result.GetResult<Prisma.$NRPropCategoryMappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NRPropCategoryMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRPropCategoryMappingFindFirstOrThrowArgs} args - Arguments to find a NRPropCategoryMapping
     * @example
     * // Get one NRPropCategoryMapping
     * const nRPropCategoryMapping = await prisma.nRPropCategoryMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NRPropCategoryMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, NRPropCategoryMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__NRPropCategoryMappingClient<$Result.GetResult<Prisma.$NRPropCategoryMappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NRPropCategoryMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRPropCategoryMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NRPropCategoryMappings
     * const nRPropCategoryMappings = await prisma.nRPropCategoryMapping.findMany()
     * 
     * // Get first 10 NRPropCategoryMappings
     * const nRPropCategoryMappings = await prisma.nRPropCategoryMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nRPropCategoryMappingWithIdOnly = await prisma.nRPropCategoryMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NRPropCategoryMappingFindManyArgs>(args?: SelectSubset<T, NRPropCategoryMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NRPropCategoryMappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NRPropCategoryMapping.
     * @param {NRPropCategoryMappingCreateArgs} args - Arguments to create a NRPropCategoryMapping.
     * @example
     * // Create one NRPropCategoryMapping
     * const NRPropCategoryMapping = await prisma.nRPropCategoryMapping.create({
     *   data: {
     *     // ... data to create a NRPropCategoryMapping
     *   }
     * })
     * 
     */
    create<T extends NRPropCategoryMappingCreateArgs>(args: SelectSubset<T, NRPropCategoryMappingCreateArgs<ExtArgs>>): Prisma__NRPropCategoryMappingClient<$Result.GetResult<Prisma.$NRPropCategoryMappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NRPropCategoryMappings.
     * @param {NRPropCategoryMappingCreateManyArgs} args - Arguments to create many NRPropCategoryMappings.
     * @example
     * // Create many NRPropCategoryMappings
     * const nRPropCategoryMapping = await prisma.nRPropCategoryMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NRPropCategoryMappingCreateManyArgs>(args?: SelectSubset<T, NRPropCategoryMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NRPropCategoryMappings and returns the data saved in the database.
     * @param {NRPropCategoryMappingCreateManyAndReturnArgs} args - Arguments to create many NRPropCategoryMappings.
     * @example
     * // Create many NRPropCategoryMappings
     * const nRPropCategoryMapping = await prisma.nRPropCategoryMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NRPropCategoryMappings and only return the `id`
     * const nRPropCategoryMappingWithIdOnly = await prisma.nRPropCategoryMapping.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NRPropCategoryMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, NRPropCategoryMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NRPropCategoryMappingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NRPropCategoryMapping.
     * @param {NRPropCategoryMappingDeleteArgs} args - Arguments to delete one NRPropCategoryMapping.
     * @example
     * // Delete one NRPropCategoryMapping
     * const NRPropCategoryMapping = await prisma.nRPropCategoryMapping.delete({
     *   where: {
     *     // ... filter to delete one NRPropCategoryMapping
     *   }
     * })
     * 
     */
    delete<T extends NRPropCategoryMappingDeleteArgs>(args: SelectSubset<T, NRPropCategoryMappingDeleteArgs<ExtArgs>>): Prisma__NRPropCategoryMappingClient<$Result.GetResult<Prisma.$NRPropCategoryMappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NRPropCategoryMapping.
     * @param {NRPropCategoryMappingUpdateArgs} args - Arguments to update one NRPropCategoryMapping.
     * @example
     * // Update one NRPropCategoryMapping
     * const nRPropCategoryMapping = await prisma.nRPropCategoryMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NRPropCategoryMappingUpdateArgs>(args: SelectSubset<T, NRPropCategoryMappingUpdateArgs<ExtArgs>>): Prisma__NRPropCategoryMappingClient<$Result.GetResult<Prisma.$NRPropCategoryMappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NRPropCategoryMappings.
     * @param {NRPropCategoryMappingDeleteManyArgs} args - Arguments to filter NRPropCategoryMappings to delete.
     * @example
     * // Delete a few NRPropCategoryMappings
     * const { count } = await prisma.nRPropCategoryMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NRPropCategoryMappingDeleteManyArgs>(args?: SelectSubset<T, NRPropCategoryMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NRPropCategoryMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRPropCategoryMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NRPropCategoryMappings
     * const nRPropCategoryMapping = await prisma.nRPropCategoryMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NRPropCategoryMappingUpdateManyArgs>(args: SelectSubset<T, NRPropCategoryMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NRPropCategoryMapping.
     * @param {NRPropCategoryMappingUpsertArgs} args - Arguments to update or create a NRPropCategoryMapping.
     * @example
     * // Update or create a NRPropCategoryMapping
     * const nRPropCategoryMapping = await prisma.nRPropCategoryMapping.upsert({
     *   create: {
     *     // ... data to create a NRPropCategoryMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NRPropCategoryMapping we want to update
     *   }
     * })
     */
    upsert<T extends NRPropCategoryMappingUpsertArgs>(args: SelectSubset<T, NRPropCategoryMappingUpsertArgs<ExtArgs>>): Prisma__NRPropCategoryMappingClient<$Result.GetResult<Prisma.$NRPropCategoryMappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NRPropCategoryMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRPropCategoryMappingCountArgs} args - Arguments to filter NRPropCategoryMappings to count.
     * @example
     * // Count the number of NRPropCategoryMappings
     * const count = await prisma.nRPropCategoryMapping.count({
     *   where: {
     *     // ... the filter for the NRPropCategoryMappings we want to count
     *   }
     * })
    **/
    count<T extends NRPropCategoryMappingCountArgs>(
      args?: Subset<T, NRPropCategoryMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NRPropCategoryMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NRPropCategoryMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRPropCategoryMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NRPropCategoryMappingAggregateArgs>(args: Subset<T, NRPropCategoryMappingAggregateArgs>): Prisma.PrismaPromise<GetNRPropCategoryMappingAggregateType<T>>

    /**
     * Group by NRPropCategoryMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRPropCategoryMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NRPropCategoryMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NRPropCategoryMappingGroupByArgs['orderBy'] }
        : { orderBy?: NRPropCategoryMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NRPropCategoryMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNRPropCategoryMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NRPropCategoryMapping model
   */
  readonly fields: NRPropCategoryMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NRPropCategoryMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NRPropCategoryMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subCategories<T extends NRPropCategoryMapping$subCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, NRPropCategoryMapping$subCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NRPropSubCategoryMappingPayload<ExtArgs>, T, "findMany"> | Null>
    assessments<T extends NRPropCategoryMapping$assessmentsArgs<ExtArgs> = {}>(args?: Subset<T, NRPropCategoryMapping$assessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAssessmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NRPropCategoryMapping model
   */ 
  interface NRPropCategoryMappingFieldRefs {
    readonly id: FieldRef<"NRPropCategoryMapping", 'String'>
    readonly code: FieldRef<"NRPropCategoryMapping", 'String'>
    readonly description: FieldRef<"NRPropCategoryMapping", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NRPropCategoryMapping findUnique
   */
  export type NRPropCategoryMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropCategoryMapping
     */
    select?: NRPropCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropCategoryMappingInclude<ExtArgs> | null
    /**
     * Filter, which NRPropCategoryMapping to fetch.
     */
    where: NRPropCategoryMappingWhereUniqueInput
  }

  /**
   * NRPropCategoryMapping findUniqueOrThrow
   */
  export type NRPropCategoryMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropCategoryMapping
     */
    select?: NRPropCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropCategoryMappingInclude<ExtArgs> | null
    /**
     * Filter, which NRPropCategoryMapping to fetch.
     */
    where: NRPropCategoryMappingWhereUniqueInput
  }

  /**
   * NRPropCategoryMapping findFirst
   */
  export type NRPropCategoryMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropCategoryMapping
     */
    select?: NRPropCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropCategoryMappingInclude<ExtArgs> | null
    /**
     * Filter, which NRPropCategoryMapping to fetch.
     */
    where?: NRPropCategoryMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NRPropCategoryMappings to fetch.
     */
    orderBy?: NRPropCategoryMappingOrderByWithRelationInput | NRPropCategoryMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NRPropCategoryMappings.
     */
    cursor?: NRPropCategoryMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NRPropCategoryMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NRPropCategoryMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NRPropCategoryMappings.
     */
    distinct?: NRPropCategoryMappingScalarFieldEnum | NRPropCategoryMappingScalarFieldEnum[]
  }

  /**
   * NRPropCategoryMapping findFirstOrThrow
   */
  export type NRPropCategoryMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropCategoryMapping
     */
    select?: NRPropCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropCategoryMappingInclude<ExtArgs> | null
    /**
     * Filter, which NRPropCategoryMapping to fetch.
     */
    where?: NRPropCategoryMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NRPropCategoryMappings to fetch.
     */
    orderBy?: NRPropCategoryMappingOrderByWithRelationInput | NRPropCategoryMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NRPropCategoryMappings.
     */
    cursor?: NRPropCategoryMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NRPropCategoryMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NRPropCategoryMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NRPropCategoryMappings.
     */
    distinct?: NRPropCategoryMappingScalarFieldEnum | NRPropCategoryMappingScalarFieldEnum[]
  }

  /**
   * NRPropCategoryMapping findMany
   */
  export type NRPropCategoryMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropCategoryMapping
     */
    select?: NRPropCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropCategoryMappingInclude<ExtArgs> | null
    /**
     * Filter, which NRPropCategoryMappings to fetch.
     */
    where?: NRPropCategoryMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NRPropCategoryMappings to fetch.
     */
    orderBy?: NRPropCategoryMappingOrderByWithRelationInput | NRPropCategoryMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NRPropCategoryMappings.
     */
    cursor?: NRPropCategoryMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NRPropCategoryMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NRPropCategoryMappings.
     */
    skip?: number
    distinct?: NRPropCategoryMappingScalarFieldEnum | NRPropCategoryMappingScalarFieldEnum[]
  }

  /**
   * NRPropCategoryMapping create
   */
  export type NRPropCategoryMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropCategoryMapping
     */
    select?: NRPropCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropCategoryMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a NRPropCategoryMapping.
     */
    data: XOR<NRPropCategoryMappingCreateInput, NRPropCategoryMappingUncheckedCreateInput>
  }

  /**
   * NRPropCategoryMapping createMany
   */
  export type NRPropCategoryMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NRPropCategoryMappings.
     */
    data: NRPropCategoryMappingCreateManyInput | NRPropCategoryMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NRPropCategoryMapping createManyAndReturn
   */
  export type NRPropCategoryMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropCategoryMapping
     */
    select?: NRPropCategoryMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NRPropCategoryMappings.
     */
    data: NRPropCategoryMappingCreateManyInput | NRPropCategoryMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NRPropCategoryMapping update
   */
  export type NRPropCategoryMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropCategoryMapping
     */
    select?: NRPropCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropCategoryMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a NRPropCategoryMapping.
     */
    data: XOR<NRPropCategoryMappingUpdateInput, NRPropCategoryMappingUncheckedUpdateInput>
    /**
     * Choose, which NRPropCategoryMapping to update.
     */
    where: NRPropCategoryMappingWhereUniqueInput
  }

  /**
   * NRPropCategoryMapping updateMany
   */
  export type NRPropCategoryMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NRPropCategoryMappings.
     */
    data: XOR<NRPropCategoryMappingUpdateManyMutationInput, NRPropCategoryMappingUncheckedUpdateManyInput>
    /**
     * Filter which NRPropCategoryMappings to update
     */
    where?: NRPropCategoryMappingWhereInput
  }

  /**
   * NRPropCategoryMapping upsert
   */
  export type NRPropCategoryMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropCategoryMapping
     */
    select?: NRPropCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropCategoryMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the NRPropCategoryMapping to update in case it exists.
     */
    where: NRPropCategoryMappingWhereUniqueInput
    /**
     * In case the NRPropCategoryMapping found by the `where` argument doesn't exist, create a new NRPropCategoryMapping with this data.
     */
    create: XOR<NRPropCategoryMappingCreateInput, NRPropCategoryMappingUncheckedCreateInput>
    /**
     * In case the NRPropCategoryMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NRPropCategoryMappingUpdateInput, NRPropCategoryMappingUncheckedUpdateInput>
  }

  /**
   * NRPropCategoryMapping delete
   */
  export type NRPropCategoryMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropCategoryMapping
     */
    select?: NRPropCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropCategoryMappingInclude<ExtArgs> | null
    /**
     * Filter which NRPropCategoryMapping to delete.
     */
    where: NRPropCategoryMappingWhereUniqueInput
  }

  /**
   * NRPropCategoryMapping deleteMany
   */
  export type NRPropCategoryMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NRPropCategoryMappings to delete
     */
    where?: NRPropCategoryMappingWhereInput
  }

  /**
   * NRPropCategoryMapping.subCategories
   */
  export type NRPropCategoryMapping$subCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropSubCategoryMapping
     */
    select?: NRPropSubCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropSubCategoryMappingInclude<ExtArgs> | null
    where?: NRPropSubCategoryMappingWhereInput
    orderBy?: NRPropSubCategoryMappingOrderByWithRelationInput | NRPropSubCategoryMappingOrderByWithRelationInput[]
    cursor?: NRPropSubCategoryMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NRPropSubCategoryMappingScalarFieldEnum | NRPropSubCategoryMappingScalarFieldEnum[]
  }

  /**
   * NRPropCategoryMapping.assessments
   */
  export type NRPropCategoryMapping$assessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAssessment
     */
    select?: PropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAssessmentInclude<ExtArgs> | null
    where?: PropertyAssessmentWhereInput
    orderBy?: PropertyAssessmentOrderByWithRelationInput | PropertyAssessmentOrderByWithRelationInput[]
    cursor?: PropertyAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyAssessmentScalarFieldEnum | PropertyAssessmentScalarFieldEnum[]
  }

  /**
   * NRPropCategoryMapping without action
   */
  export type NRPropCategoryMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropCategoryMapping
     */
    select?: NRPropCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropCategoryMappingInclude<ExtArgs> | null
  }


  /**
   * Model NRPropSubCategoryMapping
   */

  export type AggregateNRPropSubCategoryMapping = {
    _count: NRPropSubCategoryMappingCountAggregateOutputType | null
    _min: NRPropSubCategoryMappingMinAggregateOutputType | null
    _max: NRPropSubCategoryMappingMaxAggregateOutputType | null
  }

  export type NRPropSubCategoryMappingMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    categoryId: string | null
  }

  export type NRPropSubCategoryMappingMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    categoryId: string | null
  }

  export type NRPropSubCategoryMappingCountAggregateOutputType = {
    id: number
    code: number
    description: number
    categoryId: number
    _all: number
  }


  export type NRPropSubCategoryMappingMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    categoryId?: true
  }

  export type NRPropSubCategoryMappingMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    categoryId?: true
  }

  export type NRPropSubCategoryMappingCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    categoryId?: true
    _all?: true
  }

  export type NRPropSubCategoryMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NRPropSubCategoryMapping to aggregate.
     */
    where?: NRPropSubCategoryMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NRPropSubCategoryMappings to fetch.
     */
    orderBy?: NRPropSubCategoryMappingOrderByWithRelationInput | NRPropSubCategoryMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NRPropSubCategoryMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NRPropSubCategoryMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NRPropSubCategoryMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NRPropSubCategoryMappings
    **/
    _count?: true | NRPropSubCategoryMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NRPropSubCategoryMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NRPropSubCategoryMappingMaxAggregateInputType
  }

  export type GetNRPropSubCategoryMappingAggregateType<T extends NRPropSubCategoryMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateNRPropSubCategoryMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNRPropSubCategoryMapping[P]>
      : GetScalarType<T[P], AggregateNRPropSubCategoryMapping[P]>
  }




  export type NRPropSubCategoryMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NRPropSubCategoryMappingWhereInput
    orderBy?: NRPropSubCategoryMappingOrderByWithAggregationInput | NRPropSubCategoryMappingOrderByWithAggregationInput[]
    by: NRPropSubCategoryMappingScalarFieldEnum[] | NRPropSubCategoryMappingScalarFieldEnum
    having?: NRPropSubCategoryMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NRPropSubCategoryMappingCountAggregateInputType | true
    _min?: NRPropSubCategoryMappingMinAggregateInputType
    _max?: NRPropSubCategoryMappingMaxAggregateInputType
  }

  export type NRPropSubCategoryMappingGroupByOutputType = {
    id: string
    code: string
    description: string
    categoryId: string
    _count: NRPropSubCategoryMappingCountAggregateOutputType | null
    _min: NRPropSubCategoryMappingMinAggregateOutputType | null
    _max: NRPropSubCategoryMappingMaxAggregateOutputType | null
  }

  type GetNRPropSubCategoryMappingGroupByPayload<T extends NRPropSubCategoryMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NRPropSubCategoryMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NRPropSubCategoryMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NRPropSubCategoryMappingGroupByOutputType[P]>
            : GetScalarType<T[P], NRPropSubCategoryMappingGroupByOutputType[P]>
        }
      >
    >


  export type NRPropSubCategoryMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    categoryId?: boolean
    category?: boolean | NRPropCategoryMappingDefaultArgs<ExtArgs>
    assessments?: boolean | NRPropSubCategoryMapping$assessmentsArgs<ExtArgs>
    _count?: boolean | NRPropSubCategoryMappingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nRPropSubCategoryMapping"]>

  export type NRPropSubCategoryMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    categoryId?: boolean
    category?: boolean | NRPropCategoryMappingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nRPropSubCategoryMapping"]>

  export type NRPropSubCategoryMappingSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    categoryId?: boolean
  }

  export type NRPropSubCategoryMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | NRPropCategoryMappingDefaultArgs<ExtArgs>
    assessments?: boolean | NRPropSubCategoryMapping$assessmentsArgs<ExtArgs>
    _count?: boolean | NRPropSubCategoryMappingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NRPropSubCategoryMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | NRPropCategoryMappingDefaultArgs<ExtArgs>
  }

  export type $NRPropSubCategoryMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NRPropSubCategoryMapping"
    objects: {
      category: Prisma.$NRPropCategoryMappingPayload<ExtArgs>
      assessments: Prisma.$PropertyAssessmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string
      categoryId: string
    }, ExtArgs["result"]["nRPropSubCategoryMapping"]>
    composites: {}
  }

  type NRPropSubCategoryMappingGetPayload<S extends boolean | null | undefined | NRPropSubCategoryMappingDefaultArgs> = $Result.GetResult<Prisma.$NRPropSubCategoryMappingPayload, S>

  type NRPropSubCategoryMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NRPropSubCategoryMappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NRPropSubCategoryMappingCountAggregateInputType | true
    }

  export interface NRPropSubCategoryMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NRPropSubCategoryMapping'], meta: { name: 'NRPropSubCategoryMapping' } }
    /**
     * Find zero or one NRPropSubCategoryMapping that matches the filter.
     * @param {NRPropSubCategoryMappingFindUniqueArgs} args - Arguments to find a NRPropSubCategoryMapping
     * @example
     * // Get one NRPropSubCategoryMapping
     * const nRPropSubCategoryMapping = await prisma.nRPropSubCategoryMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NRPropSubCategoryMappingFindUniqueArgs>(args: SelectSubset<T, NRPropSubCategoryMappingFindUniqueArgs<ExtArgs>>): Prisma__NRPropSubCategoryMappingClient<$Result.GetResult<Prisma.$NRPropSubCategoryMappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NRPropSubCategoryMapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NRPropSubCategoryMappingFindUniqueOrThrowArgs} args - Arguments to find a NRPropSubCategoryMapping
     * @example
     * // Get one NRPropSubCategoryMapping
     * const nRPropSubCategoryMapping = await prisma.nRPropSubCategoryMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NRPropSubCategoryMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, NRPropSubCategoryMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NRPropSubCategoryMappingClient<$Result.GetResult<Prisma.$NRPropSubCategoryMappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NRPropSubCategoryMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRPropSubCategoryMappingFindFirstArgs} args - Arguments to find a NRPropSubCategoryMapping
     * @example
     * // Get one NRPropSubCategoryMapping
     * const nRPropSubCategoryMapping = await prisma.nRPropSubCategoryMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NRPropSubCategoryMappingFindFirstArgs>(args?: SelectSubset<T, NRPropSubCategoryMappingFindFirstArgs<ExtArgs>>): Prisma__NRPropSubCategoryMappingClient<$Result.GetResult<Prisma.$NRPropSubCategoryMappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NRPropSubCategoryMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRPropSubCategoryMappingFindFirstOrThrowArgs} args - Arguments to find a NRPropSubCategoryMapping
     * @example
     * // Get one NRPropSubCategoryMapping
     * const nRPropSubCategoryMapping = await prisma.nRPropSubCategoryMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NRPropSubCategoryMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, NRPropSubCategoryMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__NRPropSubCategoryMappingClient<$Result.GetResult<Prisma.$NRPropSubCategoryMappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NRPropSubCategoryMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRPropSubCategoryMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NRPropSubCategoryMappings
     * const nRPropSubCategoryMappings = await prisma.nRPropSubCategoryMapping.findMany()
     * 
     * // Get first 10 NRPropSubCategoryMappings
     * const nRPropSubCategoryMappings = await prisma.nRPropSubCategoryMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nRPropSubCategoryMappingWithIdOnly = await prisma.nRPropSubCategoryMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NRPropSubCategoryMappingFindManyArgs>(args?: SelectSubset<T, NRPropSubCategoryMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NRPropSubCategoryMappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NRPropSubCategoryMapping.
     * @param {NRPropSubCategoryMappingCreateArgs} args - Arguments to create a NRPropSubCategoryMapping.
     * @example
     * // Create one NRPropSubCategoryMapping
     * const NRPropSubCategoryMapping = await prisma.nRPropSubCategoryMapping.create({
     *   data: {
     *     // ... data to create a NRPropSubCategoryMapping
     *   }
     * })
     * 
     */
    create<T extends NRPropSubCategoryMappingCreateArgs>(args: SelectSubset<T, NRPropSubCategoryMappingCreateArgs<ExtArgs>>): Prisma__NRPropSubCategoryMappingClient<$Result.GetResult<Prisma.$NRPropSubCategoryMappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NRPropSubCategoryMappings.
     * @param {NRPropSubCategoryMappingCreateManyArgs} args - Arguments to create many NRPropSubCategoryMappings.
     * @example
     * // Create many NRPropSubCategoryMappings
     * const nRPropSubCategoryMapping = await prisma.nRPropSubCategoryMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NRPropSubCategoryMappingCreateManyArgs>(args?: SelectSubset<T, NRPropSubCategoryMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NRPropSubCategoryMappings and returns the data saved in the database.
     * @param {NRPropSubCategoryMappingCreateManyAndReturnArgs} args - Arguments to create many NRPropSubCategoryMappings.
     * @example
     * // Create many NRPropSubCategoryMappings
     * const nRPropSubCategoryMapping = await prisma.nRPropSubCategoryMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NRPropSubCategoryMappings and only return the `id`
     * const nRPropSubCategoryMappingWithIdOnly = await prisma.nRPropSubCategoryMapping.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NRPropSubCategoryMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, NRPropSubCategoryMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NRPropSubCategoryMappingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NRPropSubCategoryMapping.
     * @param {NRPropSubCategoryMappingDeleteArgs} args - Arguments to delete one NRPropSubCategoryMapping.
     * @example
     * // Delete one NRPropSubCategoryMapping
     * const NRPropSubCategoryMapping = await prisma.nRPropSubCategoryMapping.delete({
     *   where: {
     *     // ... filter to delete one NRPropSubCategoryMapping
     *   }
     * })
     * 
     */
    delete<T extends NRPropSubCategoryMappingDeleteArgs>(args: SelectSubset<T, NRPropSubCategoryMappingDeleteArgs<ExtArgs>>): Prisma__NRPropSubCategoryMappingClient<$Result.GetResult<Prisma.$NRPropSubCategoryMappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NRPropSubCategoryMapping.
     * @param {NRPropSubCategoryMappingUpdateArgs} args - Arguments to update one NRPropSubCategoryMapping.
     * @example
     * // Update one NRPropSubCategoryMapping
     * const nRPropSubCategoryMapping = await prisma.nRPropSubCategoryMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NRPropSubCategoryMappingUpdateArgs>(args: SelectSubset<T, NRPropSubCategoryMappingUpdateArgs<ExtArgs>>): Prisma__NRPropSubCategoryMappingClient<$Result.GetResult<Prisma.$NRPropSubCategoryMappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NRPropSubCategoryMappings.
     * @param {NRPropSubCategoryMappingDeleteManyArgs} args - Arguments to filter NRPropSubCategoryMappings to delete.
     * @example
     * // Delete a few NRPropSubCategoryMappings
     * const { count } = await prisma.nRPropSubCategoryMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NRPropSubCategoryMappingDeleteManyArgs>(args?: SelectSubset<T, NRPropSubCategoryMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NRPropSubCategoryMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRPropSubCategoryMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NRPropSubCategoryMappings
     * const nRPropSubCategoryMapping = await prisma.nRPropSubCategoryMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NRPropSubCategoryMappingUpdateManyArgs>(args: SelectSubset<T, NRPropSubCategoryMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NRPropSubCategoryMapping.
     * @param {NRPropSubCategoryMappingUpsertArgs} args - Arguments to update or create a NRPropSubCategoryMapping.
     * @example
     * // Update or create a NRPropSubCategoryMapping
     * const nRPropSubCategoryMapping = await prisma.nRPropSubCategoryMapping.upsert({
     *   create: {
     *     // ... data to create a NRPropSubCategoryMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NRPropSubCategoryMapping we want to update
     *   }
     * })
     */
    upsert<T extends NRPropSubCategoryMappingUpsertArgs>(args: SelectSubset<T, NRPropSubCategoryMappingUpsertArgs<ExtArgs>>): Prisma__NRPropSubCategoryMappingClient<$Result.GetResult<Prisma.$NRPropSubCategoryMappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NRPropSubCategoryMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRPropSubCategoryMappingCountArgs} args - Arguments to filter NRPropSubCategoryMappings to count.
     * @example
     * // Count the number of NRPropSubCategoryMappings
     * const count = await prisma.nRPropSubCategoryMapping.count({
     *   where: {
     *     // ... the filter for the NRPropSubCategoryMappings we want to count
     *   }
     * })
    **/
    count<T extends NRPropSubCategoryMappingCountArgs>(
      args?: Subset<T, NRPropSubCategoryMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NRPropSubCategoryMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NRPropSubCategoryMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRPropSubCategoryMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NRPropSubCategoryMappingAggregateArgs>(args: Subset<T, NRPropSubCategoryMappingAggregateArgs>): Prisma.PrismaPromise<GetNRPropSubCategoryMappingAggregateType<T>>

    /**
     * Group by NRPropSubCategoryMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NRPropSubCategoryMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NRPropSubCategoryMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NRPropSubCategoryMappingGroupByArgs['orderBy'] }
        : { orderBy?: NRPropSubCategoryMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NRPropSubCategoryMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNRPropSubCategoryMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NRPropSubCategoryMapping model
   */
  readonly fields: NRPropSubCategoryMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NRPropSubCategoryMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NRPropSubCategoryMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends NRPropCategoryMappingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NRPropCategoryMappingDefaultArgs<ExtArgs>>): Prisma__NRPropCategoryMappingClient<$Result.GetResult<Prisma.$NRPropCategoryMappingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assessments<T extends NRPropSubCategoryMapping$assessmentsArgs<ExtArgs> = {}>(args?: Subset<T, NRPropSubCategoryMapping$assessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAssessmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NRPropSubCategoryMapping model
   */ 
  interface NRPropSubCategoryMappingFieldRefs {
    readonly id: FieldRef<"NRPropSubCategoryMapping", 'String'>
    readonly code: FieldRef<"NRPropSubCategoryMapping", 'String'>
    readonly description: FieldRef<"NRPropSubCategoryMapping", 'String'>
    readonly categoryId: FieldRef<"NRPropSubCategoryMapping", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NRPropSubCategoryMapping findUnique
   */
  export type NRPropSubCategoryMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropSubCategoryMapping
     */
    select?: NRPropSubCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropSubCategoryMappingInclude<ExtArgs> | null
    /**
     * Filter, which NRPropSubCategoryMapping to fetch.
     */
    where: NRPropSubCategoryMappingWhereUniqueInput
  }

  /**
   * NRPropSubCategoryMapping findUniqueOrThrow
   */
  export type NRPropSubCategoryMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropSubCategoryMapping
     */
    select?: NRPropSubCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropSubCategoryMappingInclude<ExtArgs> | null
    /**
     * Filter, which NRPropSubCategoryMapping to fetch.
     */
    where: NRPropSubCategoryMappingWhereUniqueInput
  }

  /**
   * NRPropSubCategoryMapping findFirst
   */
  export type NRPropSubCategoryMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropSubCategoryMapping
     */
    select?: NRPropSubCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropSubCategoryMappingInclude<ExtArgs> | null
    /**
     * Filter, which NRPropSubCategoryMapping to fetch.
     */
    where?: NRPropSubCategoryMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NRPropSubCategoryMappings to fetch.
     */
    orderBy?: NRPropSubCategoryMappingOrderByWithRelationInput | NRPropSubCategoryMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NRPropSubCategoryMappings.
     */
    cursor?: NRPropSubCategoryMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NRPropSubCategoryMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NRPropSubCategoryMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NRPropSubCategoryMappings.
     */
    distinct?: NRPropSubCategoryMappingScalarFieldEnum | NRPropSubCategoryMappingScalarFieldEnum[]
  }

  /**
   * NRPropSubCategoryMapping findFirstOrThrow
   */
  export type NRPropSubCategoryMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropSubCategoryMapping
     */
    select?: NRPropSubCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropSubCategoryMappingInclude<ExtArgs> | null
    /**
     * Filter, which NRPropSubCategoryMapping to fetch.
     */
    where?: NRPropSubCategoryMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NRPropSubCategoryMappings to fetch.
     */
    orderBy?: NRPropSubCategoryMappingOrderByWithRelationInput | NRPropSubCategoryMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NRPropSubCategoryMappings.
     */
    cursor?: NRPropSubCategoryMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NRPropSubCategoryMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NRPropSubCategoryMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NRPropSubCategoryMappings.
     */
    distinct?: NRPropSubCategoryMappingScalarFieldEnum | NRPropSubCategoryMappingScalarFieldEnum[]
  }

  /**
   * NRPropSubCategoryMapping findMany
   */
  export type NRPropSubCategoryMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropSubCategoryMapping
     */
    select?: NRPropSubCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropSubCategoryMappingInclude<ExtArgs> | null
    /**
     * Filter, which NRPropSubCategoryMappings to fetch.
     */
    where?: NRPropSubCategoryMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NRPropSubCategoryMappings to fetch.
     */
    orderBy?: NRPropSubCategoryMappingOrderByWithRelationInput | NRPropSubCategoryMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NRPropSubCategoryMappings.
     */
    cursor?: NRPropSubCategoryMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NRPropSubCategoryMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NRPropSubCategoryMappings.
     */
    skip?: number
    distinct?: NRPropSubCategoryMappingScalarFieldEnum | NRPropSubCategoryMappingScalarFieldEnum[]
  }

  /**
   * NRPropSubCategoryMapping create
   */
  export type NRPropSubCategoryMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropSubCategoryMapping
     */
    select?: NRPropSubCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropSubCategoryMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a NRPropSubCategoryMapping.
     */
    data: XOR<NRPropSubCategoryMappingCreateInput, NRPropSubCategoryMappingUncheckedCreateInput>
  }

  /**
   * NRPropSubCategoryMapping createMany
   */
  export type NRPropSubCategoryMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NRPropSubCategoryMappings.
     */
    data: NRPropSubCategoryMappingCreateManyInput | NRPropSubCategoryMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NRPropSubCategoryMapping createManyAndReturn
   */
  export type NRPropSubCategoryMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropSubCategoryMapping
     */
    select?: NRPropSubCategoryMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NRPropSubCategoryMappings.
     */
    data: NRPropSubCategoryMappingCreateManyInput | NRPropSubCategoryMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropSubCategoryMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NRPropSubCategoryMapping update
   */
  export type NRPropSubCategoryMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropSubCategoryMapping
     */
    select?: NRPropSubCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropSubCategoryMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a NRPropSubCategoryMapping.
     */
    data: XOR<NRPropSubCategoryMappingUpdateInput, NRPropSubCategoryMappingUncheckedUpdateInput>
    /**
     * Choose, which NRPropSubCategoryMapping to update.
     */
    where: NRPropSubCategoryMappingWhereUniqueInput
  }

  /**
   * NRPropSubCategoryMapping updateMany
   */
  export type NRPropSubCategoryMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NRPropSubCategoryMappings.
     */
    data: XOR<NRPropSubCategoryMappingUpdateManyMutationInput, NRPropSubCategoryMappingUncheckedUpdateManyInput>
    /**
     * Filter which NRPropSubCategoryMappings to update
     */
    where?: NRPropSubCategoryMappingWhereInput
  }

  /**
   * NRPropSubCategoryMapping upsert
   */
  export type NRPropSubCategoryMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropSubCategoryMapping
     */
    select?: NRPropSubCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropSubCategoryMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the NRPropSubCategoryMapping to update in case it exists.
     */
    where: NRPropSubCategoryMappingWhereUniqueInput
    /**
     * In case the NRPropSubCategoryMapping found by the `where` argument doesn't exist, create a new NRPropSubCategoryMapping with this data.
     */
    create: XOR<NRPropSubCategoryMappingCreateInput, NRPropSubCategoryMappingUncheckedCreateInput>
    /**
     * In case the NRPropSubCategoryMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NRPropSubCategoryMappingUpdateInput, NRPropSubCategoryMappingUncheckedUpdateInput>
  }

  /**
   * NRPropSubCategoryMapping delete
   */
  export type NRPropSubCategoryMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropSubCategoryMapping
     */
    select?: NRPropSubCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropSubCategoryMappingInclude<ExtArgs> | null
    /**
     * Filter which NRPropSubCategoryMapping to delete.
     */
    where: NRPropSubCategoryMappingWhereUniqueInput
  }

  /**
   * NRPropSubCategoryMapping deleteMany
   */
  export type NRPropSubCategoryMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NRPropSubCategoryMappings to delete
     */
    where?: NRPropSubCategoryMappingWhereInput
  }

  /**
   * NRPropSubCategoryMapping.assessments
   */
  export type NRPropSubCategoryMapping$assessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAssessment
     */
    select?: PropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAssessmentInclude<ExtArgs> | null
    where?: PropertyAssessmentWhereInput
    orderBy?: PropertyAssessmentOrderByWithRelationInput | PropertyAssessmentOrderByWithRelationInput[]
    cursor?: PropertyAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyAssessmentScalarFieldEnum | PropertyAssessmentScalarFieldEnum[]
  }

  /**
   * NRPropSubCategoryMapping without action
   */
  export type NRPropSubCategoryMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NRPropSubCategoryMapping
     */
    select?: NRPropSubCategoryMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NRPropSubCategoryMappingInclude<ExtArgs> | null
  }


  /**
   * Model Survey
   */

  export type AggregateSurvey = {
    _count: SurveyCountAggregateOutputType | null
    _min: SurveyMinAggregateOutputType | null
    _max: SurveyMaxAggregateOutputType | null
  }

  export type SurveyMinAggregateOutputType = {
    id: string | null
    surveyorId: string | null
    ulbId: string | null
    zoneId: string | null
    wardId: string | null
    mohallaId: string | null
    dateOfEntry: Date | null
    gisId: string | null
    mapId: string | null
    subGisId: string | null
    propertyType: $Enums.PropertyType | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyMaxAggregateOutputType = {
    id: string | null
    surveyorId: string | null
    ulbId: string | null
    zoneId: string | null
    wardId: string | null
    mohallaId: string | null
    dateOfEntry: Date | null
    gisId: string | null
    mapId: string | null
    subGisId: string | null
    propertyType: $Enums.PropertyType | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyCountAggregateOutputType = {
    id: number
    surveyorId: number
    ulbId: number
    zoneId: number
    wardId: number
    mohallaId: number
    dateOfEntry: number
    gisId: number
    mapId: number
    subGisId: number
    propertyType: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SurveyMinAggregateInputType = {
    id?: true
    surveyorId?: true
    ulbId?: true
    zoneId?: true
    wardId?: true
    mohallaId?: true
    dateOfEntry?: true
    gisId?: true
    mapId?: true
    subGisId?: true
    propertyType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyMaxAggregateInputType = {
    id?: true
    surveyorId?: true
    ulbId?: true
    zoneId?: true
    wardId?: true
    mohallaId?: true
    dateOfEntry?: true
    gisId?: true
    mapId?: true
    subGisId?: true
    propertyType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyCountAggregateInputType = {
    id?: true
    surveyorId?: true
    ulbId?: true
    zoneId?: true
    wardId?: true
    mohallaId?: true
    dateOfEntry?: true
    gisId?: true
    mapId?: true
    subGisId?: true
    propertyType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SurveyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Survey to aggregate.
     */
    where?: SurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveys to fetch.
     */
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Surveys
    **/
    _count?: true | SurveyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyMaxAggregateInputType
  }

  export type GetSurveyAggregateType<T extends SurveyAggregateArgs> = {
        [P in keyof T & keyof AggregateSurvey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurvey[P]>
      : GetScalarType<T[P], AggregateSurvey[P]>
  }




  export type SurveyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyWhereInput
    orderBy?: SurveyOrderByWithAggregationInput | SurveyOrderByWithAggregationInput[]
    by: SurveyScalarFieldEnum[] | SurveyScalarFieldEnum
    having?: SurveyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyCountAggregateInputType | true
    _min?: SurveyMinAggregateInputType
    _max?: SurveyMaxAggregateInputType
  }

  export type SurveyGroupByOutputType = {
    id: string
    surveyorId: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    dateOfEntry: Date
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status: string
    createdAt: Date
    updatedAt: Date
    _count: SurveyCountAggregateOutputType | null
    _min: SurveyMinAggregateOutputType | null
    _max: SurveyMaxAggregateOutputType | null
  }

  type GetSurveyGroupByPayload<T extends SurveyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyGroupByOutputType[P]>
        }
      >
    >


  export type SurveySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyorId?: boolean
    ulbId?: boolean
    zoneId?: boolean
    wardId?: boolean
    mohallaId?: boolean
    dateOfEntry?: boolean
    gisId?: boolean
    mapId?: boolean
    subGisId?: boolean
    propertyType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    surveyor?: boolean | UserDefaultArgs<ExtArgs>
    ulb?: boolean | ULBDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    ward?: boolean | WardDefaultArgs<ExtArgs>
    mohalla?: boolean | MohallaDefaultArgs<ExtArgs>
    property?: boolean | Survey$propertyArgs<ExtArgs>
    owner?: boolean | Survey$ownerArgs<ExtArgs>
    location?: boolean | Survey$locationArgs<ExtArgs>
    other?: boolean | Survey$otherArgs<ExtArgs>
    floors?: boolean | Survey$floorsArgs<ExtArgs>
    assessment?: boolean | Survey$assessmentArgs<ExtArgs>
    qcRecord?: boolean | Survey$qcRecordArgs<ExtArgs>
    attachments?: boolean | Survey$attachmentsArgs<ExtArgs>
    _count?: boolean | SurveyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["survey"]>

  export type SurveySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyorId?: boolean
    ulbId?: boolean
    zoneId?: boolean
    wardId?: boolean
    mohallaId?: boolean
    dateOfEntry?: boolean
    gisId?: boolean
    mapId?: boolean
    subGisId?: boolean
    propertyType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    surveyor?: boolean | UserDefaultArgs<ExtArgs>
    ulb?: boolean | ULBDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    ward?: boolean | WardDefaultArgs<ExtArgs>
    mohalla?: boolean | MohallaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["survey"]>

  export type SurveySelectScalar = {
    id?: boolean
    surveyorId?: boolean
    ulbId?: boolean
    zoneId?: boolean
    wardId?: boolean
    mohallaId?: boolean
    dateOfEntry?: boolean
    gisId?: boolean
    mapId?: boolean
    subGisId?: boolean
    propertyType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SurveyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyor?: boolean | UserDefaultArgs<ExtArgs>
    ulb?: boolean | ULBDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    ward?: boolean | WardDefaultArgs<ExtArgs>
    mohalla?: boolean | MohallaDefaultArgs<ExtArgs>
    property?: boolean | Survey$propertyArgs<ExtArgs>
    owner?: boolean | Survey$ownerArgs<ExtArgs>
    location?: boolean | Survey$locationArgs<ExtArgs>
    other?: boolean | Survey$otherArgs<ExtArgs>
    floors?: boolean | Survey$floorsArgs<ExtArgs>
    assessment?: boolean | Survey$assessmentArgs<ExtArgs>
    qcRecord?: boolean | Survey$qcRecordArgs<ExtArgs>
    attachments?: boolean | Survey$attachmentsArgs<ExtArgs>
    _count?: boolean | SurveyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SurveyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyor?: boolean | UserDefaultArgs<ExtArgs>
    ulb?: boolean | ULBDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    ward?: boolean | WardDefaultArgs<ExtArgs>
    mohalla?: boolean | MohallaDefaultArgs<ExtArgs>
  }

  export type $SurveyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Survey"
    objects: {
      surveyor: Prisma.$UserPayload<ExtArgs>
      ulb: Prisma.$ULBPayload<ExtArgs>
      zone: Prisma.$ZonePayload<ExtArgs>
      ward: Prisma.$WardPayload<ExtArgs>
      mohalla: Prisma.$MohallaPayload<ExtArgs>
      property: Prisma.$PropertyDetailsPayload<ExtArgs> | null
      owner: Prisma.$OwnerDetailsPayload<ExtArgs> | null
      location: Prisma.$LocationDetailsPayload<ExtArgs> | null
      other: Prisma.$OtherDetailsPayload<ExtArgs> | null
      floors: Prisma.$FloorDetailsPayload<ExtArgs>[]
      assessment: Prisma.$PropertyAssessmentPayload<ExtArgs> | null
      qcRecord: Prisma.$QCRecordPayload<ExtArgs> | null
      attachments: Prisma.$PropertyAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      surveyorId: string
      ulbId: string
      zoneId: string
      wardId: string
      mohallaId: string
      dateOfEntry: Date
      gisId: string
      mapId: string
      subGisId: string
      propertyType: $Enums.PropertyType
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["survey"]>
    composites: {}
  }

  type SurveyGetPayload<S extends boolean | null | undefined | SurveyDefaultArgs> = $Result.GetResult<Prisma.$SurveyPayload, S>

  type SurveyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SurveyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SurveyCountAggregateInputType | true
    }

  export interface SurveyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Survey'], meta: { name: 'Survey' } }
    /**
     * Find zero or one Survey that matches the filter.
     * @param {SurveyFindUniqueArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyFindUniqueArgs>(args: SelectSubset<T, SurveyFindUniqueArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Survey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SurveyFindUniqueOrThrowArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Survey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFindFirstArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyFindFirstArgs>(args?: SelectSubset<T, SurveyFindFirstArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Survey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFindFirstOrThrowArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Surveys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Surveys
     * const surveys = await prisma.survey.findMany()
     * 
     * // Get first 10 Surveys
     * const surveys = await prisma.survey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyWithIdOnly = await prisma.survey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SurveyFindManyArgs>(args?: SelectSubset<T, SurveyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Survey.
     * @param {SurveyCreateArgs} args - Arguments to create a Survey.
     * @example
     * // Create one Survey
     * const Survey = await prisma.survey.create({
     *   data: {
     *     // ... data to create a Survey
     *   }
     * })
     * 
     */
    create<T extends SurveyCreateArgs>(args: SelectSubset<T, SurveyCreateArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Surveys.
     * @param {SurveyCreateManyArgs} args - Arguments to create many Surveys.
     * @example
     * // Create many Surveys
     * const survey = await prisma.survey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyCreateManyArgs>(args?: SelectSubset<T, SurveyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Surveys and returns the data saved in the database.
     * @param {SurveyCreateManyAndReturnArgs} args - Arguments to create many Surveys.
     * @example
     * // Create many Surveys
     * const survey = await prisma.survey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Surveys and only return the `id`
     * const surveyWithIdOnly = await prisma.survey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurveyCreateManyAndReturnArgs>(args?: SelectSubset<T, SurveyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Survey.
     * @param {SurveyDeleteArgs} args - Arguments to delete one Survey.
     * @example
     * // Delete one Survey
     * const Survey = await prisma.survey.delete({
     *   where: {
     *     // ... filter to delete one Survey
     *   }
     * })
     * 
     */
    delete<T extends SurveyDeleteArgs>(args: SelectSubset<T, SurveyDeleteArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Survey.
     * @param {SurveyUpdateArgs} args - Arguments to update one Survey.
     * @example
     * // Update one Survey
     * const survey = await prisma.survey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyUpdateArgs>(args: SelectSubset<T, SurveyUpdateArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Surveys.
     * @param {SurveyDeleteManyArgs} args - Arguments to filter Surveys to delete.
     * @example
     * // Delete a few Surveys
     * const { count } = await prisma.survey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyDeleteManyArgs>(args?: SelectSubset<T, SurveyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Surveys
     * const survey = await prisma.survey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyUpdateManyArgs>(args: SelectSubset<T, SurveyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Survey.
     * @param {SurveyUpsertArgs} args - Arguments to update or create a Survey.
     * @example
     * // Update or create a Survey
     * const survey = await prisma.survey.upsert({
     *   create: {
     *     // ... data to create a Survey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Survey we want to update
     *   }
     * })
     */
    upsert<T extends SurveyUpsertArgs>(args: SelectSubset<T, SurveyUpsertArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyCountArgs} args - Arguments to filter Surveys to count.
     * @example
     * // Count the number of Surveys
     * const count = await prisma.survey.count({
     *   where: {
     *     // ... the filter for the Surveys we want to count
     *   }
     * })
    **/
    count<T extends SurveyCountArgs>(
      args?: Subset<T, SurveyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Survey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyAggregateArgs>(args: Subset<T, SurveyAggregateArgs>): Prisma.PrismaPromise<GetSurveyAggregateType<T>>

    /**
     * Group by Survey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyGroupByArgs['orderBy'] }
        : { orderBy?: SurveyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Survey model
   */
  readonly fields: SurveyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Survey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    surveyor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ulb<T extends ULBDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ULBDefaultArgs<ExtArgs>>): Prisma__ULBClient<$Result.GetResult<Prisma.$ULBPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ward<T extends WardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WardDefaultArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mohalla<T extends MohallaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MohallaDefaultArgs<ExtArgs>>): Prisma__MohallaClient<$Result.GetResult<Prisma.$MohallaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    property<T extends Survey$propertyArgs<ExtArgs> = {}>(args?: Subset<T, Survey$propertyArgs<ExtArgs>>): Prisma__PropertyDetailsClient<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    owner<T extends Survey$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Survey$ownerArgs<ExtArgs>>): Prisma__OwnerDetailsClient<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    location<T extends Survey$locationArgs<ExtArgs> = {}>(args?: Subset<T, Survey$locationArgs<ExtArgs>>): Prisma__LocationDetailsClient<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    other<T extends Survey$otherArgs<ExtArgs> = {}>(args?: Subset<T, Survey$otherArgs<ExtArgs>>): Prisma__OtherDetailsClient<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    floors<T extends Survey$floorsArgs<ExtArgs> = {}>(args?: Subset<T, Survey$floorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FloorDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    assessment<T extends Survey$assessmentArgs<ExtArgs> = {}>(args?: Subset<T, Survey$assessmentArgs<ExtArgs>>): Prisma__PropertyAssessmentClient<$Result.GetResult<Prisma.$PropertyAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    qcRecord<T extends Survey$qcRecordArgs<ExtArgs> = {}>(args?: Subset<T, Survey$qcRecordArgs<ExtArgs>>): Prisma__QCRecordClient<$Result.GetResult<Prisma.$QCRecordPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    attachments<T extends Survey$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Survey$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Survey model
   */ 
  interface SurveyFieldRefs {
    readonly id: FieldRef<"Survey", 'String'>
    readonly surveyorId: FieldRef<"Survey", 'String'>
    readonly ulbId: FieldRef<"Survey", 'String'>
    readonly zoneId: FieldRef<"Survey", 'String'>
    readonly wardId: FieldRef<"Survey", 'String'>
    readonly mohallaId: FieldRef<"Survey", 'String'>
    readonly dateOfEntry: FieldRef<"Survey", 'DateTime'>
    readonly gisId: FieldRef<"Survey", 'String'>
    readonly mapId: FieldRef<"Survey", 'String'>
    readonly subGisId: FieldRef<"Survey", 'String'>
    readonly propertyType: FieldRef<"Survey", 'PropertyType'>
    readonly status: FieldRef<"Survey", 'String'>
    readonly createdAt: FieldRef<"Survey", 'DateTime'>
    readonly updatedAt: FieldRef<"Survey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Survey findUnique
   */
  export type SurveyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter, which Survey to fetch.
     */
    where: SurveyWhereUniqueInput
  }

  /**
   * Survey findUniqueOrThrow
   */
  export type SurveyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter, which Survey to fetch.
     */
    where: SurveyWhereUniqueInput
  }

  /**
   * Survey findFirst
   */
  export type SurveyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter, which Survey to fetch.
     */
    where?: SurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveys to fetch.
     */
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Surveys.
     */
    cursor?: SurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Surveys.
     */
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * Survey findFirstOrThrow
   */
  export type SurveyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter, which Survey to fetch.
     */
    where?: SurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveys to fetch.
     */
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Surveys.
     */
    cursor?: SurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Surveys.
     */
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * Survey findMany
   */
  export type SurveyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter, which Surveys to fetch.
     */
    where?: SurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveys to fetch.
     */
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Surveys.
     */
    cursor?: SurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveys.
     */
    skip?: number
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * Survey create
   */
  export type SurveyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * The data needed to create a Survey.
     */
    data: XOR<SurveyCreateInput, SurveyUncheckedCreateInput>
  }

  /**
   * Survey createMany
   */
  export type SurveyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Surveys.
     */
    data: SurveyCreateManyInput | SurveyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Survey createManyAndReturn
   */
  export type SurveyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Surveys.
     */
    data: SurveyCreateManyInput | SurveyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Survey update
   */
  export type SurveyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * The data needed to update a Survey.
     */
    data: XOR<SurveyUpdateInput, SurveyUncheckedUpdateInput>
    /**
     * Choose, which Survey to update.
     */
    where: SurveyWhereUniqueInput
  }

  /**
   * Survey updateMany
   */
  export type SurveyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Surveys.
     */
    data: XOR<SurveyUpdateManyMutationInput, SurveyUncheckedUpdateManyInput>
    /**
     * Filter which Surveys to update
     */
    where?: SurveyWhereInput
  }

  /**
   * Survey upsert
   */
  export type SurveyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * The filter to search for the Survey to update in case it exists.
     */
    where: SurveyWhereUniqueInput
    /**
     * In case the Survey found by the `where` argument doesn't exist, create a new Survey with this data.
     */
    create: XOR<SurveyCreateInput, SurveyUncheckedCreateInput>
    /**
     * In case the Survey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyUpdateInput, SurveyUncheckedUpdateInput>
  }

  /**
   * Survey delete
   */
  export type SurveyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter which Survey to delete.
     */
    where: SurveyWhereUniqueInput
  }

  /**
   * Survey deleteMany
   */
  export type SurveyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Surveys to delete
     */
    where?: SurveyWhereInput
  }

  /**
   * Survey.property
   */
  export type Survey$propertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    where?: PropertyDetailsWhereInput
  }

  /**
   * Survey.owner
   */
  export type Survey$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    where?: OwnerDetailsWhereInput
  }

  /**
   * Survey.location
   */
  export type Survey$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    where?: LocationDetailsWhereInput
  }

  /**
   * Survey.other
   */
  export type Survey$otherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    where?: OtherDetailsWhereInput
  }

  /**
   * Survey.floors
   */
  export type Survey$floorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorDetails
     */
    select?: FloorDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorDetailsInclude<ExtArgs> | null
    where?: FloorDetailsWhereInput
    orderBy?: FloorDetailsOrderByWithRelationInput | FloorDetailsOrderByWithRelationInput[]
    cursor?: FloorDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FloorDetailsScalarFieldEnum | FloorDetailsScalarFieldEnum[]
  }

  /**
   * Survey.assessment
   */
  export type Survey$assessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAssessment
     */
    select?: PropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAssessmentInclude<ExtArgs> | null
    where?: PropertyAssessmentWhereInput
  }

  /**
   * Survey.qcRecord
   */
  export type Survey$qcRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCRecord
     */
    select?: QCRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCRecordInclude<ExtArgs> | null
    where?: QCRecordWhereInput
  }

  /**
   * Survey.attachments
   */
  export type Survey$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachment
     */
    select?: PropertyAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentInclude<ExtArgs> | null
    where?: PropertyAttachmentWhereInput
    orderBy?: PropertyAttachmentOrderByWithRelationInput | PropertyAttachmentOrderByWithRelationInput[]
    cursor?: PropertyAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyAttachmentScalarFieldEnum | PropertyAttachmentScalarFieldEnum[]
  }

  /**
   * Survey without action
   */
  export type SurveyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
  }


  /**
   * Model PropertyDetails
   */

  export type AggregatePropertyDetails = {
    _count: PropertyDetailsCountAggregateOutputType | null
    _avg: PropertyDetailsAvgAggregateOutputType | null
    _sum: PropertyDetailsSumAggregateOutputType | null
    _min: PropertyDetailsMinAggregateOutputType | null
    _max: PropertyDetailsMaxAggregateOutputType | null
  }

  export type PropertyDetailsAvgAggregateOutputType = {
    rentAmount: number | null
  }

  export type PropertyDetailsSumAggregateOutputType = {
    rentAmount: number | null
  }

  export type PropertyDetailsMinAggregateOutputType = {
    id: string | null
    surveyId: string | null
    responseTypeId: string | null
    houseNumber: string | null
    electricityNo: string | null
    wardSewerageNo: string | null
    respondentName: string | null
    isRented: boolean | null
    rentAmount: number | null
    tenantName: string | null
    tenantMobile: string | null
    tenantAadhaar: string | null
  }

  export type PropertyDetailsMaxAggregateOutputType = {
    id: string | null
    surveyId: string | null
    responseTypeId: string | null
    houseNumber: string | null
    electricityNo: string | null
    wardSewerageNo: string | null
    respondentName: string | null
    isRented: boolean | null
    rentAmount: number | null
    tenantName: string | null
    tenantMobile: string | null
    tenantAadhaar: string | null
  }

  export type PropertyDetailsCountAggregateOutputType = {
    id: number
    surveyId: number
    responseTypeId: number
    houseNumber: number
    electricityNo: number
    wardSewerageNo: number
    respondentName: number
    isRented: number
    rentAmount: number
    tenantName: number
    tenantMobile: number
    tenantAadhaar: number
    _all: number
  }


  export type PropertyDetailsAvgAggregateInputType = {
    rentAmount?: true
  }

  export type PropertyDetailsSumAggregateInputType = {
    rentAmount?: true
  }

  export type PropertyDetailsMinAggregateInputType = {
    id?: true
    surveyId?: true
    responseTypeId?: true
    houseNumber?: true
    electricityNo?: true
    wardSewerageNo?: true
    respondentName?: true
    isRented?: true
    rentAmount?: true
    tenantName?: true
    tenantMobile?: true
    tenantAadhaar?: true
  }

  export type PropertyDetailsMaxAggregateInputType = {
    id?: true
    surveyId?: true
    responseTypeId?: true
    houseNumber?: true
    electricityNo?: true
    wardSewerageNo?: true
    respondentName?: true
    isRented?: true
    rentAmount?: true
    tenantName?: true
    tenantMobile?: true
    tenantAadhaar?: true
  }

  export type PropertyDetailsCountAggregateInputType = {
    id?: true
    surveyId?: true
    responseTypeId?: true
    houseNumber?: true
    electricityNo?: true
    wardSewerageNo?: true
    respondentName?: true
    isRented?: true
    rentAmount?: true
    tenantName?: true
    tenantMobile?: true
    tenantAadhaar?: true
    _all?: true
  }

  export type PropertyDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyDetails to aggregate.
     */
    where?: PropertyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyDetails to fetch.
     */
    orderBy?: PropertyDetailsOrderByWithRelationInput | PropertyDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyDetails
    **/
    _count?: true | PropertyDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyDetailsMaxAggregateInputType
  }

  export type GetPropertyDetailsAggregateType<T extends PropertyDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyDetails[P]>
      : GetScalarType<T[P], AggregatePropertyDetails[P]>
  }




  export type PropertyDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyDetailsWhereInput
    orderBy?: PropertyDetailsOrderByWithAggregationInput | PropertyDetailsOrderByWithAggregationInput[]
    by: PropertyDetailsScalarFieldEnum[] | PropertyDetailsScalarFieldEnum
    having?: PropertyDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyDetailsCountAggregateInputType | true
    _avg?: PropertyDetailsAvgAggregateInputType
    _sum?: PropertyDetailsSumAggregateInputType
    _min?: PropertyDetailsMinAggregateInputType
    _max?: PropertyDetailsMaxAggregateInputType
  }

  export type PropertyDetailsGroupByOutputType = {
    id: string
    surveyId: string
    responseTypeId: string
    houseNumber: string
    electricityNo: string
    wardSewerageNo: string
    respondentName: string
    isRented: boolean
    rentAmount: number | null
    tenantName: string | null
    tenantMobile: string | null
    tenantAadhaar: string | null
    _count: PropertyDetailsCountAggregateOutputType | null
    _avg: PropertyDetailsAvgAggregateOutputType | null
    _sum: PropertyDetailsSumAggregateOutputType | null
    _min: PropertyDetailsMinAggregateOutputType | null
    _max: PropertyDetailsMaxAggregateOutputType | null
  }

  type GetPropertyDetailsGroupByPayload<T extends PropertyDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyDetailsGroupByOutputType[P]>
        }
      >
    >


  export type PropertyDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    responseTypeId?: boolean
    houseNumber?: boolean
    electricityNo?: boolean
    wardSewerageNo?: boolean
    respondentName?: boolean
    isRented?: boolean
    rentAmount?: boolean
    tenantName?: boolean
    tenantMobile?: boolean
    tenantAadhaar?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    responseType?: boolean | PropertyResponseTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyDetails"]>

  export type PropertyDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    responseTypeId?: boolean
    houseNumber?: boolean
    electricityNo?: boolean
    wardSewerageNo?: boolean
    respondentName?: boolean
    isRented?: boolean
    rentAmount?: boolean
    tenantName?: boolean
    tenantMobile?: boolean
    tenantAadhaar?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    responseType?: boolean | PropertyResponseTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyDetails"]>

  export type PropertyDetailsSelectScalar = {
    id?: boolean
    surveyId?: boolean
    responseTypeId?: boolean
    houseNumber?: boolean
    electricityNo?: boolean
    wardSewerageNo?: boolean
    respondentName?: boolean
    isRented?: boolean
    rentAmount?: boolean
    tenantName?: boolean
    tenantMobile?: boolean
    tenantAadhaar?: boolean
  }

  export type PropertyDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    responseType?: boolean | PropertyResponseTypeDefaultArgs<ExtArgs>
  }
  export type PropertyDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    responseType?: boolean | PropertyResponseTypeDefaultArgs<ExtArgs>
  }

  export type $PropertyDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyDetails"
    objects: {
      survey: Prisma.$SurveyPayload<ExtArgs>
      responseType: Prisma.$PropertyResponseTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      surveyId: string
      responseTypeId: string
      houseNumber: string
      electricityNo: string
      wardSewerageNo: string
      respondentName: string
      isRented: boolean
      rentAmount: number | null
      tenantName: string | null
      tenantMobile: string | null
      tenantAadhaar: string | null
    }, ExtArgs["result"]["propertyDetails"]>
    composites: {}
  }

  type PropertyDetailsGetPayload<S extends boolean | null | undefined | PropertyDetailsDefaultArgs> = $Result.GetResult<Prisma.$PropertyDetailsPayload, S>

  type PropertyDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PropertyDetailsCountAggregateInputType | true
    }

  export interface PropertyDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyDetails'], meta: { name: 'PropertyDetails' } }
    /**
     * Find zero or one PropertyDetails that matches the filter.
     * @param {PropertyDetailsFindUniqueArgs} args - Arguments to find a PropertyDetails
     * @example
     * // Get one PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyDetailsFindUniqueArgs>(args: SelectSubset<T, PropertyDetailsFindUniqueArgs<ExtArgs>>): Prisma__PropertyDetailsClient<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PropertyDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PropertyDetailsFindUniqueOrThrowArgs} args - Arguments to find a PropertyDetails
     * @example
     * // Get one PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyDetailsClient<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PropertyDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDetailsFindFirstArgs} args - Arguments to find a PropertyDetails
     * @example
     * // Get one PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyDetailsFindFirstArgs>(args?: SelectSubset<T, PropertyDetailsFindFirstArgs<ExtArgs>>): Prisma__PropertyDetailsClient<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PropertyDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDetailsFindFirstOrThrowArgs} args - Arguments to find a PropertyDetails
     * @example
     * // Get one PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyDetailsClient<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PropertyDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.findMany()
     * 
     * // Get first 10 PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyDetailsWithIdOnly = await prisma.propertyDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyDetailsFindManyArgs>(args?: SelectSubset<T, PropertyDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PropertyDetails.
     * @param {PropertyDetailsCreateArgs} args - Arguments to create a PropertyDetails.
     * @example
     * // Create one PropertyDetails
     * const PropertyDetails = await prisma.propertyDetails.create({
     *   data: {
     *     // ... data to create a PropertyDetails
     *   }
     * })
     * 
     */
    create<T extends PropertyDetailsCreateArgs>(args: SelectSubset<T, PropertyDetailsCreateArgs<ExtArgs>>): Prisma__PropertyDetailsClient<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PropertyDetails.
     * @param {PropertyDetailsCreateManyArgs} args - Arguments to create many PropertyDetails.
     * @example
     * // Create many PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyDetailsCreateManyArgs>(args?: SelectSubset<T, PropertyDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyDetails and returns the data saved in the database.
     * @param {PropertyDetailsCreateManyAndReturnArgs} args - Arguments to create many PropertyDetails.
     * @example
     * // Create many PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyDetails and only return the `id`
     * const propertyDetailsWithIdOnly = await prisma.propertyDetails.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PropertyDetails.
     * @param {PropertyDetailsDeleteArgs} args - Arguments to delete one PropertyDetails.
     * @example
     * // Delete one PropertyDetails
     * const PropertyDetails = await prisma.propertyDetails.delete({
     *   where: {
     *     // ... filter to delete one PropertyDetails
     *   }
     * })
     * 
     */
    delete<T extends PropertyDetailsDeleteArgs>(args: SelectSubset<T, PropertyDetailsDeleteArgs<ExtArgs>>): Prisma__PropertyDetailsClient<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PropertyDetails.
     * @param {PropertyDetailsUpdateArgs} args - Arguments to update one PropertyDetails.
     * @example
     * // Update one PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyDetailsUpdateArgs>(args: SelectSubset<T, PropertyDetailsUpdateArgs<ExtArgs>>): Prisma__PropertyDetailsClient<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PropertyDetails.
     * @param {PropertyDetailsDeleteManyArgs} args - Arguments to filter PropertyDetails to delete.
     * @example
     * // Delete a few PropertyDetails
     * const { count } = await prisma.propertyDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDetailsDeleteManyArgs>(args?: SelectSubset<T, PropertyDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyDetailsUpdateManyArgs>(args: SelectSubset<T, PropertyDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyDetails.
     * @param {PropertyDetailsUpsertArgs} args - Arguments to update or create a PropertyDetails.
     * @example
     * // Update or create a PropertyDetails
     * const propertyDetails = await prisma.propertyDetails.upsert({
     *   create: {
     *     // ... data to create a PropertyDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyDetails we want to update
     *   }
     * })
     */
    upsert<T extends PropertyDetailsUpsertArgs>(args: SelectSubset<T, PropertyDetailsUpsertArgs<ExtArgs>>): Prisma__PropertyDetailsClient<$Result.GetResult<Prisma.$PropertyDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PropertyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDetailsCountArgs} args - Arguments to filter PropertyDetails to count.
     * @example
     * // Count the number of PropertyDetails
     * const count = await prisma.propertyDetails.count({
     *   where: {
     *     // ... the filter for the PropertyDetails we want to count
     *   }
     * })
    **/
    count<T extends PropertyDetailsCountArgs>(
      args?: Subset<T, PropertyDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyDetailsAggregateArgs>(args: Subset<T, PropertyDetailsAggregateArgs>): Prisma.PrismaPromise<GetPropertyDetailsAggregateType<T>>

    /**
     * Group by PropertyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyDetailsGroupByArgs['orderBy'] }
        : { orderBy?: PropertyDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyDetails model
   */
  readonly fields: PropertyDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDefaultArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    responseType<T extends PropertyResponseTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyResponseTypeDefaultArgs<ExtArgs>>): Prisma__PropertyResponseTypeClient<$Result.GetResult<Prisma.$PropertyResponseTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyDetails model
   */ 
  interface PropertyDetailsFieldRefs {
    readonly id: FieldRef<"PropertyDetails", 'String'>
    readonly surveyId: FieldRef<"PropertyDetails", 'String'>
    readonly responseTypeId: FieldRef<"PropertyDetails", 'String'>
    readonly houseNumber: FieldRef<"PropertyDetails", 'String'>
    readonly electricityNo: FieldRef<"PropertyDetails", 'String'>
    readonly wardSewerageNo: FieldRef<"PropertyDetails", 'String'>
    readonly respondentName: FieldRef<"PropertyDetails", 'String'>
    readonly isRented: FieldRef<"PropertyDetails", 'Boolean'>
    readonly rentAmount: FieldRef<"PropertyDetails", 'Float'>
    readonly tenantName: FieldRef<"PropertyDetails", 'String'>
    readonly tenantMobile: FieldRef<"PropertyDetails", 'String'>
    readonly tenantAadhaar: FieldRef<"PropertyDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PropertyDetails findUnique
   */
  export type PropertyDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyDetails to fetch.
     */
    where: PropertyDetailsWhereUniqueInput
  }

  /**
   * PropertyDetails findUniqueOrThrow
   */
  export type PropertyDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyDetails to fetch.
     */
    where: PropertyDetailsWhereUniqueInput
  }

  /**
   * PropertyDetails findFirst
   */
  export type PropertyDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyDetails to fetch.
     */
    where?: PropertyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyDetails to fetch.
     */
    orderBy?: PropertyDetailsOrderByWithRelationInput | PropertyDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyDetails.
     */
    cursor?: PropertyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyDetails.
     */
    distinct?: PropertyDetailsScalarFieldEnum | PropertyDetailsScalarFieldEnum[]
  }

  /**
   * PropertyDetails findFirstOrThrow
   */
  export type PropertyDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyDetails to fetch.
     */
    where?: PropertyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyDetails to fetch.
     */
    orderBy?: PropertyDetailsOrderByWithRelationInput | PropertyDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyDetails.
     */
    cursor?: PropertyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyDetails.
     */
    distinct?: PropertyDetailsScalarFieldEnum | PropertyDetailsScalarFieldEnum[]
  }

  /**
   * PropertyDetails findMany
   */
  export type PropertyDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyDetails to fetch.
     */
    where?: PropertyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyDetails to fetch.
     */
    orderBy?: PropertyDetailsOrderByWithRelationInput | PropertyDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyDetails.
     */
    cursor?: PropertyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyDetails.
     */
    skip?: number
    distinct?: PropertyDetailsScalarFieldEnum | PropertyDetailsScalarFieldEnum[]
  }

  /**
   * PropertyDetails create
   */
  export type PropertyDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyDetails.
     */
    data: XOR<PropertyDetailsCreateInput, PropertyDetailsUncheckedCreateInput>
  }

  /**
   * PropertyDetails createMany
   */
  export type PropertyDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyDetails.
     */
    data: PropertyDetailsCreateManyInput | PropertyDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyDetails createManyAndReturn
   */
  export type PropertyDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PropertyDetails.
     */
    data: PropertyDetailsCreateManyInput | PropertyDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyDetails update
   */
  export type PropertyDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyDetails.
     */
    data: XOR<PropertyDetailsUpdateInput, PropertyDetailsUncheckedUpdateInput>
    /**
     * Choose, which PropertyDetails to update.
     */
    where: PropertyDetailsWhereUniqueInput
  }

  /**
   * PropertyDetails updateMany
   */
  export type PropertyDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyDetails.
     */
    data: XOR<PropertyDetailsUpdateManyMutationInput, PropertyDetailsUncheckedUpdateManyInput>
    /**
     * Filter which PropertyDetails to update
     */
    where?: PropertyDetailsWhereInput
  }

  /**
   * PropertyDetails upsert
   */
  export type PropertyDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyDetails to update in case it exists.
     */
    where: PropertyDetailsWhereUniqueInput
    /**
     * In case the PropertyDetails found by the `where` argument doesn't exist, create a new PropertyDetails with this data.
     */
    create: XOR<PropertyDetailsCreateInput, PropertyDetailsUncheckedCreateInput>
    /**
     * In case the PropertyDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyDetailsUpdateInput, PropertyDetailsUncheckedUpdateInput>
  }

  /**
   * PropertyDetails delete
   */
  export type PropertyDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
    /**
     * Filter which PropertyDetails to delete.
     */
    where: PropertyDetailsWhereUniqueInput
  }

  /**
   * PropertyDetails deleteMany
   */
  export type PropertyDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyDetails to delete
     */
    where?: PropertyDetailsWhereInput
  }

  /**
   * PropertyDetails without action
   */
  export type PropertyDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDetails
     */
    select?: PropertyDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDetailsInclude<ExtArgs> | null
  }


  /**
   * Model OwnerDetails
   */

  export type AggregateOwnerDetails = {
    _count: OwnerDetailsCountAggregateOutputType | null
    _min: OwnerDetailsMinAggregateOutputType | null
    _max: OwnerDetailsMaxAggregateOutputType | null
  }

  export type OwnerDetailsMinAggregateOutputType = {
    id: string | null
    surveyId: string | null
    ownerName: string | null
    fatherHusbandName: string | null
    mobileNo: string | null
    aadhaarNo: string | null
    email: string | null
    alternateMobile: string | null
    isNRI: boolean | null
    nriAddress: string | null
  }

  export type OwnerDetailsMaxAggregateOutputType = {
    id: string | null
    surveyId: string | null
    ownerName: string | null
    fatherHusbandName: string | null
    mobileNo: string | null
    aadhaarNo: string | null
    email: string | null
    alternateMobile: string | null
    isNRI: boolean | null
    nriAddress: string | null
  }

  export type OwnerDetailsCountAggregateOutputType = {
    id: number
    surveyId: number
    ownerName: number
    fatherHusbandName: number
    mobileNo: number
    aadhaarNo: number
    email: number
    alternateMobile: number
    isNRI: number
    nriAddress: number
    _all: number
  }


  export type OwnerDetailsMinAggregateInputType = {
    id?: true
    surveyId?: true
    ownerName?: true
    fatherHusbandName?: true
    mobileNo?: true
    aadhaarNo?: true
    email?: true
    alternateMobile?: true
    isNRI?: true
    nriAddress?: true
  }

  export type OwnerDetailsMaxAggregateInputType = {
    id?: true
    surveyId?: true
    ownerName?: true
    fatherHusbandName?: true
    mobileNo?: true
    aadhaarNo?: true
    email?: true
    alternateMobile?: true
    isNRI?: true
    nriAddress?: true
  }

  export type OwnerDetailsCountAggregateInputType = {
    id?: true
    surveyId?: true
    ownerName?: true
    fatherHusbandName?: true
    mobileNo?: true
    aadhaarNo?: true
    email?: true
    alternateMobile?: true
    isNRI?: true
    nriAddress?: true
    _all?: true
  }

  export type OwnerDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerDetails to aggregate.
     */
    where?: OwnerDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerDetails to fetch.
     */
    orderBy?: OwnerDetailsOrderByWithRelationInput | OwnerDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnerDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OwnerDetails
    **/
    _count?: true | OwnerDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnerDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnerDetailsMaxAggregateInputType
  }

  export type GetOwnerDetailsAggregateType<T extends OwnerDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateOwnerDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwnerDetails[P]>
      : GetScalarType<T[P], AggregateOwnerDetails[P]>
  }




  export type OwnerDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerDetailsWhereInput
    orderBy?: OwnerDetailsOrderByWithAggregationInput | OwnerDetailsOrderByWithAggregationInput[]
    by: OwnerDetailsScalarFieldEnum[] | OwnerDetailsScalarFieldEnum
    having?: OwnerDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnerDetailsCountAggregateInputType | true
    _min?: OwnerDetailsMinAggregateInputType
    _max?: OwnerDetailsMaxAggregateInputType
  }

  export type OwnerDetailsGroupByOutputType = {
    id: string
    surveyId: string
    ownerName: string
    fatherHusbandName: string
    mobileNo: string
    aadhaarNo: string
    email: string | null
    alternateMobile: string | null
    isNRI: boolean
    nriAddress: string | null
    _count: OwnerDetailsCountAggregateOutputType | null
    _min: OwnerDetailsMinAggregateOutputType | null
    _max: OwnerDetailsMaxAggregateOutputType | null
  }

  type GetOwnerDetailsGroupByPayload<T extends OwnerDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnerDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnerDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnerDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], OwnerDetailsGroupByOutputType[P]>
        }
      >
    >


  export type OwnerDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    ownerName?: boolean
    fatherHusbandName?: boolean
    mobileNo?: boolean
    aadhaarNo?: boolean
    email?: boolean
    alternateMobile?: boolean
    isNRI?: boolean
    nriAddress?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerDetails"]>

  export type OwnerDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    ownerName?: boolean
    fatherHusbandName?: boolean
    mobileNo?: boolean
    aadhaarNo?: boolean
    email?: boolean
    alternateMobile?: boolean
    isNRI?: boolean
    nriAddress?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerDetails"]>

  export type OwnerDetailsSelectScalar = {
    id?: boolean
    surveyId?: boolean
    ownerName?: boolean
    fatherHusbandName?: boolean
    mobileNo?: boolean
    aadhaarNo?: boolean
    email?: boolean
    alternateMobile?: boolean
    isNRI?: boolean
    nriAddress?: boolean
  }

  export type OwnerDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
  }
  export type OwnerDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
  }

  export type $OwnerDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OwnerDetails"
    objects: {
      survey: Prisma.$SurveyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      surveyId: string
      ownerName: string
      fatherHusbandName: string
      mobileNo: string
      aadhaarNo: string
      email: string | null
      alternateMobile: string | null
      isNRI: boolean
      nriAddress: string | null
    }, ExtArgs["result"]["ownerDetails"]>
    composites: {}
  }

  type OwnerDetailsGetPayload<S extends boolean | null | undefined | OwnerDetailsDefaultArgs> = $Result.GetResult<Prisma.$OwnerDetailsPayload, S>

  type OwnerDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OwnerDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OwnerDetailsCountAggregateInputType | true
    }

  export interface OwnerDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OwnerDetails'], meta: { name: 'OwnerDetails' } }
    /**
     * Find zero or one OwnerDetails that matches the filter.
     * @param {OwnerDetailsFindUniqueArgs} args - Arguments to find a OwnerDetails
     * @example
     * // Get one OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OwnerDetailsFindUniqueArgs>(args: SelectSubset<T, OwnerDetailsFindUniqueArgs<ExtArgs>>): Prisma__OwnerDetailsClient<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OwnerDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OwnerDetailsFindUniqueOrThrowArgs} args - Arguments to find a OwnerDetails
     * @example
     * // Get one OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OwnerDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, OwnerDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OwnerDetailsClient<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OwnerDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDetailsFindFirstArgs} args - Arguments to find a OwnerDetails
     * @example
     * // Get one OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OwnerDetailsFindFirstArgs>(args?: SelectSubset<T, OwnerDetailsFindFirstArgs<ExtArgs>>): Prisma__OwnerDetailsClient<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OwnerDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDetailsFindFirstOrThrowArgs} args - Arguments to find a OwnerDetails
     * @example
     * // Get one OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OwnerDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, OwnerDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__OwnerDetailsClient<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OwnerDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.findMany()
     * 
     * // Get first 10 OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ownerDetailsWithIdOnly = await prisma.ownerDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OwnerDetailsFindManyArgs>(args?: SelectSubset<T, OwnerDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OwnerDetails.
     * @param {OwnerDetailsCreateArgs} args - Arguments to create a OwnerDetails.
     * @example
     * // Create one OwnerDetails
     * const OwnerDetails = await prisma.ownerDetails.create({
     *   data: {
     *     // ... data to create a OwnerDetails
     *   }
     * })
     * 
     */
    create<T extends OwnerDetailsCreateArgs>(args: SelectSubset<T, OwnerDetailsCreateArgs<ExtArgs>>): Prisma__OwnerDetailsClient<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OwnerDetails.
     * @param {OwnerDetailsCreateManyArgs} args - Arguments to create many OwnerDetails.
     * @example
     * // Create many OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OwnerDetailsCreateManyArgs>(args?: SelectSubset<T, OwnerDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OwnerDetails and returns the data saved in the database.
     * @param {OwnerDetailsCreateManyAndReturnArgs} args - Arguments to create many OwnerDetails.
     * @example
     * // Create many OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OwnerDetails and only return the `id`
     * const ownerDetailsWithIdOnly = await prisma.ownerDetails.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OwnerDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, OwnerDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OwnerDetails.
     * @param {OwnerDetailsDeleteArgs} args - Arguments to delete one OwnerDetails.
     * @example
     * // Delete one OwnerDetails
     * const OwnerDetails = await prisma.ownerDetails.delete({
     *   where: {
     *     // ... filter to delete one OwnerDetails
     *   }
     * })
     * 
     */
    delete<T extends OwnerDetailsDeleteArgs>(args: SelectSubset<T, OwnerDetailsDeleteArgs<ExtArgs>>): Prisma__OwnerDetailsClient<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OwnerDetails.
     * @param {OwnerDetailsUpdateArgs} args - Arguments to update one OwnerDetails.
     * @example
     * // Update one OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OwnerDetailsUpdateArgs>(args: SelectSubset<T, OwnerDetailsUpdateArgs<ExtArgs>>): Prisma__OwnerDetailsClient<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OwnerDetails.
     * @param {OwnerDetailsDeleteManyArgs} args - Arguments to filter OwnerDetails to delete.
     * @example
     * // Delete a few OwnerDetails
     * const { count } = await prisma.ownerDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OwnerDetailsDeleteManyArgs>(args?: SelectSubset<T, OwnerDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnerDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OwnerDetailsUpdateManyArgs>(args: SelectSubset<T, OwnerDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OwnerDetails.
     * @param {OwnerDetailsUpsertArgs} args - Arguments to update or create a OwnerDetails.
     * @example
     * // Update or create a OwnerDetails
     * const ownerDetails = await prisma.ownerDetails.upsert({
     *   create: {
     *     // ... data to create a OwnerDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OwnerDetails we want to update
     *   }
     * })
     */
    upsert<T extends OwnerDetailsUpsertArgs>(args: SelectSubset<T, OwnerDetailsUpsertArgs<ExtArgs>>): Prisma__OwnerDetailsClient<$Result.GetResult<Prisma.$OwnerDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OwnerDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDetailsCountArgs} args - Arguments to filter OwnerDetails to count.
     * @example
     * // Count the number of OwnerDetails
     * const count = await prisma.ownerDetails.count({
     *   where: {
     *     // ... the filter for the OwnerDetails we want to count
     *   }
     * })
    **/
    count<T extends OwnerDetailsCountArgs>(
      args?: Subset<T, OwnerDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnerDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OwnerDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnerDetailsAggregateArgs>(args: Subset<T, OwnerDetailsAggregateArgs>): Prisma.PrismaPromise<GetOwnerDetailsAggregateType<T>>

    /**
     * Group by OwnerDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnerDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnerDetailsGroupByArgs['orderBy'] }
        : { orderBy?: OwnerDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnerDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnerDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OwnerDetails model
   */
  readonly fields: OwnerDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OwnerDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnerDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDefaultArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OwnerDetails model
   */ 
  interface OwnerDetailsFieldRefs {
    readonly id: FieldRef<"OwnerDetails", 'String'>
    readonly surveyId: FieldRef<"OwnerDetails", 'String'>
    readonly ownerName: FieldRef<"OwnerDetails", 'String'>
    readonly fatherHusbandName: FieldRef<"OwnerDetails", 'String'>
    readonly mobileNo: FieldRef<"OwnerDetails", 'String'>
    readonly aadhaarNo: FieldRef<"OwnerDetails", 'String'>
    readonly email: FieldRef<"OwnerDetails", 'String'>
    readonly alternateMobile: FieldRef<"OwnerDetails", 'String'>
    readonly isNRI: FieldRef<"OwnerDetails", 'Boolean'>
    readonly nriAddress: FieldRef<"OwnerDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OwnerDetails findUnique
   */
  export type OwnerDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDetails to fetch.
     */
    where: OwnerDetailsWhereUniqueInput
  }

  /**
   * OwnerDetails findUniqueOrThrow
   */
  export type OwnerDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDetails to fetch.
     */
    where: OwnerDetailsWhereUniqueInput
  }

  /**
   * OwnerDetails findFirst
   */
  export type OwnerDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDetails to fetch.
     */
    where?: OwnerDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerDetails to fetch.
     */
    orderBy?: OwnerDetailsOrderByWithRelationInput | OwnerDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerDetails.
     */
    cursor?: OwnerDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerDetails.
     */
    distinct?: OwnerDetailsScalarFieldEnum | OwnerDetailsScalarFieldEnum[]
  }

  /**
   * OwnerDetails findFirstOrThrow
   */
  export type OwnerDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDetails to fetch.
     */
    where?: OwnerDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerDetails to fetch.
     */
    orderBy?: OwnerDetailsOrderByWithRelationInput | OwnerDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerDetails.
     */
    cursor?: OwnerDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerDetails.
     */
    distinct?: OwnerDetailsScalarFieldEnum | OwnerDetailsScalarFieldEnum[]
  }

  /**
   * OwnerDetails findMany
   */
  export type OwnerDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDetails to fetch.
     */
    where?: OwnerDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerDetails to fetch.
     */
    orderBy?: OwnerDetailsOrderByWithRelationInput | OwnerDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OwnerDetails.
     */
    cursor?: OwnerDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerDetails.
     */
    skip?: number
    distinct?: OwnerDetailsScalarFieldEnum | OwnerDetailsScalarFieldEnum[]
  }

  /**
   * OwnerDetails create
   */
  export type OwnerDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a OwnerDetails.
     */
    data: XOR<OwnerDetailsCreateInput, OwnerDetailsUncheckedCreateInput>
  }

  /**
   * OwnerDetails createMany
   */
  export type OwnerDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OwnerDetails.
     */
    data: OwnerDetailsCreateManyInput | OwnerDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OwnerDetails createManyAndReturn
   */
  export type OwnerDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OwnerDetails.
     */
    data: OwnerDetailsCreateManyInput | OwnerDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OwnerDetails update
   */
  export type OwnerDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a OwnerDetails.
     */
    data: XOR<OwnerDetailsUpdateInput, OwnerDetailsUncheckedUpdateInput>
    /**
     * Choose, which OwnerDetails to update.
     */
    where: OwnerDetailsWhereUniqueInput
  }

  /**
   * OwnerDetails updateMany
   */
  export type OwnerDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OwnerDetails.
     */
    data: XOR<OwnerDetailsUpdateManyMutationInput, OwnerDetailsUncheckedUpdateManyInput>
    /**
     * Filter which OwnerDetails to update
     */
    where?: OwnerDetailsWhereInput
  }

  /**
   * OwnerDetails upsert
   */
  export type OwnerDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the OwnerDetails to update in case it exists.
     */
    where: OwnerDetailsWhereUniqueInput
    /**
     * In case the OwnerDetails found by the `where` argument doesn't exist, create a new OwnerDetails with this data.
     */
    create: XOR<OwnerDetailsCreateInput, OwnerDetailsUncheckedCreateInput>
    /**
     * In case the OwnerDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnerDetailsUpdateInput, OwnerDetailsUncheckedUpdateInput>
  }

  /**
   * OwnerDetails delete
   */
  export type OwnerDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
    /**
     * Filter which OwnerDetails to delete.
     */
    where: OwnerDetailsWhereUniqueInput
  }

  /**
   * OwnerDetails deleteMany
   */
  export type OwnerDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerDetails to delete
     */
    where?: OwnerDetailsWhereInput
  }

  /**
   * OwnerDetails without action
   */
  export type OwnerDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDetails
     */
    select?: OwnerDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDetailsInclude<ExtArgs> | null
  }


  /**
   * Model LocationDetails
   */

  export type AggregateLocationDetails = {
    _count: LocationDetailsCountAggregateOutputType | null
    _avg: LocationDetailsAvgAggregateOutputType | null
    _sum: LocationDetailsSumAggregateOutputType | null
    _min: LocationDetailsMinAggregateOutputType | null
    _max: LocationDetailsMaxAggregateOutputType | null
  }

  export type LocationDetailsAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    plotArea: number | null
    builtUpArea: number | null
  }

  export type LocationDetailsSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    plotArea: number | null
    builtUpArea: number | null
  }

  export type LocationDetailsMinAggregateOutputType = {
    id: string | null
    surveyId: string | null
    latitude: number | null
    longitude: number | null
    assessmentYear: string | null
    roadTypeId: string | null
    constructionYear: string | null
    constructionTypeId: string | null
    landmark: string | null
    address: string | null
    newWardNo: string | null
    plotArea: number | null
    builtUpArea: number | null
  }

  export type LocationDetailsMaxAggregateOutputType = {
    id: string | null
    surveyId: string | null
    latitude: number | null
    longitude: number | null
    assessmentYear: string | null
    roadTypeId: string | null
    constructionYear: string | null
    constructionTypeId: string | null
    landmark: string | null
    address: string | null
    newWardNo: string | null
    plotArea: number | null
    builtUpArea: number | null
  }

  export type LocationDetailsCountAggregateOutputType = {
    id: number
    surveyId: number
    latitude: number
    longitude: number
    assessmentYear: number
    roadTypeId: number
    constructionYear: number
    constructionTypeId: number
    landmark: number
    address: number
    newWardNo: number
    plotArea: number
    builtUpArea: number
    _all: number
  }


  export type LocationDetailsAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    plotArea?: true
    builtUpArea?: true
  }

  export type LocationDetailsSumAggregateInputType = {
    latitude?: true
    longitude?: true
    plotArea?: true
    builtUpArea?: true
  }

  export type LocationDetailsMinAggregateInputType = {
    id?: true
    surveyId?: true
    latitude?: true
    longitude?: true
    assessmentYear?: true
    roadTypeId?: true
    constructionYear?: true
    constructionTypeId?: true
    landmark?: true
    address?: true
    newWardNo?: true
    plotArea?: true
    builtUpArea?: true
  }

  export type LocationDetailsMaxAggregateInputType = {
    id?: true
    surveyId?: true
    latitude?: true
    longitude?: true
    assessmentYear?: true
    roadTypeId?: true
    constructionYear?: true
    constructionTypeId?: true
    landmark?: true
    address?: true
    newWardNo?: true
    plotArea?: true
    builtUpArea?: true
  }

  export type LocationDetailsCountAggregateInputType = {
    id?: true
    surveyId?: true
    latitude?: true
    longitude?: true
    assessmentYear?: true
    roadTypeId?: true
    constructionYear?: true
    constructionTypeId?: true
    landmark?: true
    address?: true
    newWardNo?: true
    plotArea?: true
    builtUpArea?: true
    _all?: true
  }

  export type LocationDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationDetails to aggregate.
     */
    where?: LocationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationDetails to fetch.
     */
    orderBy?: LocationDetailsOrderByWithRelationInput | LocationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocationDetails
    **/
    _count?: true | LocationDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationDetailsMaxAggregateInputType
  }

  export type GetLocationDetailsAggregateType<T extends LocationDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateLocationDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocationDetails[P]>
      : GetScalarType<T[P], AggregateLocationDetails[P]>
  }




  export type LocationDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationDetailsWhereInput
    orderBy?: LocationDetailsOrderByWithAggregationInput | LocationDetailsOrderByWithAggregationInput[]
    by: LocationDetailsScalarFieldEnum[] | LocationDetailsScalarFieldEnum
    having?: LocationDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationDetailsCountAggregateInputType | true
    _avg?: LocationDetailsAvgAggregateInputType
    _sum?: LocationDetailsSumAggregateInputType
    _min?: LocationDetailsMinAggregateInputType
    _max?: LocationDetailsMaxAggregateInputType
  }

  export type LocationDetailsGroupByOutputType = {
    id: string
    surveyId: string
    latitude: number
    longitude: number
    assessmentYear: string
    roadTypeId: string
    constructionYear: string
    constructionTypeId: string
    landmark: string
    address: string
    newWardNo: string
    plotArea: number
    builtUpArea: number
    _count: LocationDetailsCountAggregateOutputType | null
    _avg: LocationDetailsAvgAggregateOutputType | null
    _sum: LocationDetailsSumAggregateOutputType | null
    _min: LocationDetailsMinAggregateOutputType | null
    _max: LocationDetailsMaxAggregateOutputType | null
  }

  type GetLocationDetailsGroupByPayload<T extends LocationDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], LocationDetailsGroupByOutputType[P]>
        }
      >
    >


  export type LocationDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    latitude?: boolean
    longitude?: boolean
    assessmentYear?: boolean
    roadTypeId?: boolean
    constructionYear?: boolean
    constructionTypeId?: boolean
    landmark?: boolean
    address?: boolean
    newWardNo?: boolean
    plotArea?: boolean
    builtUpArea?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    roadType?: boolean | RoadTypeMappingDefaultArgs<ExtArgs>
    constructionType?: boolean | ConstructionTypeMappingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationDetails"]>

  export type LocationDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    latitude?: boolean
    longitude?: boolean
    assessmentYear?: boolean
    roadTypeId?: boolean
    constructionYear?: boolean
    constructionTypeId?: boolean
    landmark?: boolean
    address?: boolean
    newWardNo?: boolean
    plotArea?: boolean
    builtUpArea?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    roadType?: boolean | RoadTypeMappingDefaultArgs<ExtArgs>
    constructionType?: boolean | ConstructionTypeMappingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationDetails"]>

  export type LocationDetailsSelectScalar = {
    id?: boolean
    surveyId?: boolean
    latitude?: boolean
    longitude?: boolean
    assessmentYear?: boolean
    roadTypeId?: boolean
    constructionYear?: boolean
    constructionTypeId?: boolean
    landmark?: boolean
    address?: boolean
    newWardNo?: boolean
    plotArea?: boolean
    builtUpArea?: boolean
  }

  export type LocationDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    roadType?: boolean | RoadTypeMappingDefaultArgs<ExtArgs>
    constructionType?: boolean | ConstructionTypeMappingDefaultArgs<ExtArgs>
  }
  export type LocationDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    roadType?: boolean | RoadTypeMappingDefaultArgs<ExtArgs>
    constructionType?: boolean | ConstructionTypeMappingDefaultArgs<ExtArgs>
  }

  export type $LocationDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocationDetails"
    objects: {
      survey: Prisma.$SurveyPayload<ExtArgs>
      roadType: Prisma.$RoadTypeMappingPayload<ExtArgs>
      constructionType: Prisma.$ConstructionTypeMappingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      surveyId: string
      latitude: number
      longitude: number
      assessmentYear: string
      roadTypeId: string
      constructionYear: string
      constructionTypeId: string
      landmark: string
      address: string
      newWardNo: string
      plotArea: number
      builtUpArea: number
    }, ExtArgs["result"]["locationDetails"]>
    composites: {}
  }

  type LocationDetailsGetPayload<S extends boolean | null | undefined | LocationDetailsDefaultArgs> = $Result.GetResult<Prisma.$LocationDetailsPayload, S>

  type LocationDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocationDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationDetailsCountAggregateInputType | true
    }

  export interface LocationDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocationDetails'], meta: { name: 'LocationDetails' } }
    /**
     * Find zero or one LocationDetails that matches the filter.
     * @param {LocationDetailsFindUniqueArgs} args - Arguments to find a LocationDetails
     * @example
     * // Get one LocationDetails
     * const locationDetails = await prisma.locationDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationDetailsFindUniqueArgs>(args: SelectSubset<T, LocationDetailsFindUniqueArgs<ExtArgs>>): Prisma__LocationDetailsClient<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LocationDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocationDetailsFindUniqueOrThrowArgs} args - Arguments to find a LocationDetails
     * @example
     * // Get one LocationDetails
     * const locationDetails = await prisma.locationDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationDetailsClient<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LocationDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDetailsFindFirstArgs} args - Arguments to find a LocationDetails
     * @example
     * // Get one LocationDetails
     * const locationDetails = await prisma.locationDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationDetailsFindFirstArgs>(args?: SelectSubset<T, LocationDetailsFindFirstArgs<ExtArgs>>): Prisma__LocationDetailsClient<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LocationDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDetailsFindFirstOrThrowArgs} args - Arguments to find a LocationDetails
     * @example
     * // Get one LocationDetails
     * const locationDetails = await prisma.locationDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationDetailsClient<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LocationDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocationDetails
     * const locationDetails = await prisma.locationDetails.findMany()
     * 
     * // Get first 10 LocationDetails
     * const locationDetails = await prisma.locationDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationDetailsWithIdOnly = await prisma.locationDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationDetailsFindManyArgs>(args?: SelectSubset<T, LocationDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LocationDetails.
     * @param {LocationDetailsCreateArgs} args - Arguments to create a LocationDetails.
     * @example
     * // Create one LocationDetails
     * const LocationDetails = await prisma.locationDetails.create({
     *   data: {
     *     // ... data to create a LocationDetails
     *   }
     * })
     * 
     */
    create<T extends LocationDetailsCreateArgs>(args: SelectSubset<T, LocationDetailsCreateArgs<ExtArgs>>): Prisma__LocationDetailsClient<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LocationDetails.
     * @param {LocationDetailsCreateManyArgs} args - Arguments to create many LocationDetails.
     * @example
     * // Create many LocationDetails
     * const locationDetails = await prisma.locationDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationDetailsCreateManyArgs>(args?: SelectSubset<T, LocationDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocationDetails and returns the data saved in the database.
     * @param {LocationDetailsCreateManyAndReturnArgs} args - Arguments to create many LocationDetails.
     * @example
     * // Create many LocationDetails
     * const locationDetails = await prisma.locationDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocationDetails and only return the `id`
     * const locationDetailsWithIdOnly = await prisma.locationDetails.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LocationDetails.
     * @param {LocationDetailsDeleteArgs} args - Arguments to delete one LocationDetails.
     * @example
     * // Delete one LocationDetails
     * const LocationDetails = await prisma.locationDetails.delete({
     *   where: {
     *     // ... filter to delete one LocationDetails
     *   }
     * })
     * 
     */
    delete<T extends LocationDetailsDeleteArgs>(args: SelectSubset<T, LocationDetailsDeleteArgs<ExtArgs>>): Prisma__LocationDetailsClient<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LocationDetails.
     * @param {LocationDetailsUpdateArgs} args - Arguments to update one LocationDetails.
     * @example
     * // Update one LocationDetails
     * const locationDetails = await prisma.locationDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationDetailsUpdateArgs>(args: SelectSubset<T, LocationDetailsUpdateArgs<ExtArgs>>): Prisma__LocationDetailsClient<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LocationDetails.
     * @param {LocationDetailsDeleteManyArgs} args - Arguments to filter LocationDetails to delete.
     * @example
     * // Delete a few LocationDetails
     * const { count } = await prisma.locationDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDetailsDeleteManyArgs>(args?: SelectSubset<T, LocationDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocationDetails
     * const locationDetails = await prisma.locationDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationDetailsUpdateManyArgs>(args: SelectSubset<T, LocationDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocationDetails.
     * @param {LocationDetailsUpsertArgs} args - Arguments to update or create a LocationDetails.
     * @example
     * // Update or create a LocationDetails
     * const locationDetails = await prisma.locationDetails.upsert({
     *   create: {
     *     // ... data to create a LocationDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocationDetails we want to update
     *   }
     * })
     */
    upsert<T extends LocationDetailsUpsertArgs>(args: SelectSubset<T, LocationDetailsUpsertArgs<ExtArgs>>): Prisma__LocationDetailsClient<$Result.GetResult<Prisma.$LocationDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LocationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDetailsCountArgs} args - Arguments to filter LocationDetails to count.
     * @example
     * // Count the number of LocationDetails
     * const count = await prisma.locationDetails.count({
     *   where: {
     *     // ... the filter for the LocationDetails we want to count
     *   }
     * })
    **/
    count<T extends LocationDetailsCountArgs>(
      args?: Subset<T, LocationDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationDetailsAggregateArgs>(args: Subset<T, LocationDetailsAggregateArgs>): Prisma.PrismaPromise<GetLocationDetailsAggregateType<T>>

    /**
     * Group by LocationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationDetailsGroupByArgs['orderBy'] }
        : { orderBy?: LocationDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocationDetails model
   */
  readonly fields: LocationDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocationDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDefaultArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    roadType<T extends RoadTypeMappingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoadTypeMappingDefaultArgs<ExtArgs>>): Prisma__RoadTypeMappingClient<$Result.GetResult<Prisma.$RoadTypeMappingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    constructionType<T extends ConstructionTypeMappingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionTypeMappingDefaultArgs<ExtArgs>>): Prisma__ConstructionTypeMappingClient<$Result.GetResult<Prisma.$ConstructionTypeMappingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocationDetails model
   */ 
  interface LocationDetailsFieldRefs {
    readonly id: FieldRef<"LocationDetails", 'String'>
    readonly surveyId: FieldRef<"LocationDetails", 'String'>
    readonly latitude: FieldRef<"LocationDetails", 'Float'>
    readonly longitude: FieldRef<"LocationDetails", 'Float'>
    readonly assessmentYear: FieldRef<"LocationDetails", 'String'>
    readonly roadTypeId: FieldRef<"LocationDetails", 'String'>
    readonly constructionYear: FieldRef<"LocationDetails", 'String'>
    readonly constructionTypeId: FieldRef<"LocationDetails", 'String'>
    readonly landmark: FieldRef<"LocationDetails", 'String'>
    readonly address: FieldRef<"LocationDetails", 'String'>
    readonly newWardNo: FieldRef<"LocationDetails", 'String'>
    readonly plotArea: FieldRef<"LocationDetails", 'Float'>
    readonly builtUpArea: FieldRef<"LocationDetails", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * LocationDetails findUnique
   */
  export type LocationDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which LocationDetails to fetch.
     */
    where: LocationDetailsWhereUniqueInput
  }

  /**
   * LocationDetails findUniqueOrThrow
   */
  export type LocationDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which LocationDetails to fetch.
     */
    where: LocationDetailsWhereUniqueInput
  }

  /**
   * LocationDetails findFirst
   */
  export type LocationDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which LocationDetails to fetch.
     */
    where?: LocationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationDetails to fetch.
     */
    orderBy?: LocationDetailsOrderByWithRelationInput | LocationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationDetails.
     */
    cursor?: LocationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationDetails.
     */
    distinct?: LocationDetailsScalarFieldEnum | LocationDetailsScalarFieldEnum[]
  }

  /**
   * LocationDetails findFirstOrThrow
   */
  export type LocationDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which LocationDetails to fetch.
     */
    where?: LocationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationDetails to fetch.
     */
    orderBy?: LocationDetailsOrderByWithRelationInput | LocationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationDetails.
     */
    cursor?: LocationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationDetails.
     */
    distinct?: LocationDetailsScalarFieldEnum | LocationDetailsScalarFieldEnum[]
  }

  /**
   * LocationDetails findMany
   */
  export type LocationDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which LocationDetails to fetch.
     */
    where?: LocationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationDetails to fetch.
     */
    orderBy?: LocationDetailsOrderByWithRelationInput | LocationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocationDetails.
     */
    cursor?: LocationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationDetails.
     */
    skip?: number
    distinct?: LocationDetailsScalarFieldEnum | LocationDetailsScalarFieldEnum[]
  }

  /**
   * LocationDetails create
   */
  export type LocationDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a LocationDetails.
     */
    data: XOR<LocationDetailsCreateInput, LocationDetailsUncheckedCreateInput>
  }

  /**
   * LocationDetails createMany
   */
  export type LocationDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocationDetails.
     */
    data: LocationDetailsCreateManyInput | LocationDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LocationDetails createManyAndReturn
   */
  export type LocationDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LocationDetails.
     */
    data: LocationDetailsCreateManyInput | LocationDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LocationDetails update
   */
  export type LocationDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a LocationDetails.
     */
    data: XOR<LocationDetailsUpdateInput, LocationDetailsUncheckedUpdateInput>
    /**
     * Choose, which LocationDetails to update.
     */
    where: LocationDetailsWhereUniqueInput
  }

  /**
   * LocationDetails updateMany
   */
  export type LocationDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocationDetails.
     */
    data: XOR<LocationDetailsUpdateManyMutationInput, LocationDetailsUncheckedUpdateManyInput>
    /**
     * Filter which LocationDetails to update
     */
    where?: LocationDetailsWhereInput
  }

  /**
   * LocationDetails upsert
   */
  export type LocationDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the LocationDetails to update in case it exists.
     */
    where: LocationDetailsWhereUniqueInput
    /**
     * In case the LocationDetails found by the `where` argument doesn't exist, create a new LocationDetails with this data.
     */
    create: XOR<LocationDetailsCreateInput, LocationDetailsUncheckedCreateInput>
    /**
     * In case the LocationDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationDetailsUpdateInput, LocationDetailsUncheckedUpdateInput>
  }

  /**
   * LocationDetails delete
   */
  export type LocationDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
    /**
     * Filter which LocationDetails to delete.
     */
    where: LocationDetailsWhereUniqueInput
  }

  /**
   * LocationDetails deleteMany
   */
  export type LocationDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationDetails to delete
     */
    where?: LocationDetailsWhereInput
  }

  /**
   * LocationDetails without action
   */
  export type LocationDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDetails
     */
    select?: LocationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationDetailsInclude<ExtArgs> | null
  }


  /**
   * Model OtherDetails
   */

  export type AggregateOtherDetails = {
    _count: OtherDetailsCountAggregateOutputType | null
    _avg: OtherDetailsAvgAggregateOutputType | null
    _sum: OtherDetailsSumAggregateOutputType | null
    _min: OtherDetailsMinAggregateOutputType | null
    _max: OtherDetailsMaxAggregateOutputType | null
  }

  export type OtherDetailsAvgAggregateOutputType = {
    parkingArea: number | null
    commercialArea: number | null
  }

  export type OtherDetailsSumAggregateOutputType = {
    parkingArea: number | null
    commercialArea: number | null
  }

  export type OtherDetailsMinAggregateOutputType = {
    id: string | null
    surveyId: string | null
    rainHarvesting: boolean | null
    waterSupply: string | null
    sewerageLine: string | null
    parkingType: string | null
    parkingArea: number | null
    isCommercial: boolean | null
    commercialArea: number | null
  }

  export type OtherDetailsMaxAggregateOutputType = {
    id: string | null
    surveyId: string | null
    rainHarvesting: boolean | null
    waterSupply: string | null
    sewerageLine: string | null
    parkingType: string | null
    parkingArea: number | null
    isCommercial: boolean | null
    commercialArea: number | null
  }

  export type OtherDetailsCountAggregateOutputType = {
    id: number
    surveyId: number
    rainHarvesting: number
    waterSupply: number
    sewerageLine: number
    parkingType: number
    parkingArea: number
    isCommercial: number
    commercialArea: number
    _all: number
  }


  export type OtherDetailsAvgAggregateInputType = {
    parkingArea?: true
    commercialArea?: true
  }

  export type OtherDetailsSumAggregateInputType = {
    parkingArea?: true
    commercialArea?: true
  }

  export type OtherDetailsMinAggregateInputType = {
    id?: true
    surveyId?: true
    rainHarvesting?: true
    waterSupply?: true
    sewerageLine?: true
    parkingType?: true
    parkingArea?: true
    isCommercial?: true
    commercialArea?: true
  }

  export type OtherDetailsMaxAggregateInputType = {
    id?: true
    surveyId?: true
    rainHarvesting?: true
    waterSupply?: true
    sewerageLine?: true
    parkingType?: true
    parkingArea?: true
    isCommercial?: true
    commercialArea?: true
  }

  export type OtherDetailsCountAggregateInputType = {
    id?: true
    surveyId?: true
    rainHarvesting?: true
    waterSupply?: true
    sewerageLine?: true
    parkingType?: true
    parkingArea?: true
    isCommercial?: true
    commercialArea?: true
    _all?: true
  }

  export type OtherDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtherDetails to aggregate.
     */
    where?: OtherDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtherDetails to fetch.
     */
    orderBy?: OtherDetailsOrderByWithRelationInput | OtherDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtherDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtherDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtherDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OtherDetails
    **/
    _count?: true | OtherDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OtherDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OtherDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtherDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtherDetailsMaxAggregateInputType
  }

  export type GetOtherDetailsAggregateType<T extends OtherDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateOtherDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtherDetails[P]>
      : GetScalarType<T[P], AggregateOtherDetails[P]>
  }




  export type OtherDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtherDetailsWhereInput
    orderBy?: OtherDetailsOrderByWithAggregationInput | OtherDetailsOrderByWithAggregationInput[]
    by: OtherDetailsScalarFieldEnum[] | OtherDetailsScalarFieldEnum
    having?: OtherDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtherDetailsCountAggregateInputType | true
    _avg?: OtherDetailsAvgAggregateInputType
    _sum?: OtherDetailsSumAggregateInputType
    _min?: OtherDetailsMinAggregateInputType
    _max?: OtherDetailsMaxAggregateInputType
  }

  export type OtherDetailsGroupByOutputType = {
    id: string
    surveyId: string
    rainHarvesting: boolean
    waterSupply: string
    sewerageLine: string
    parkingType: string
    parkingArea: number | null
    isCommercial: boolean
    commercialArea: number | null
    _count: OtherDetailsCountAggregateOutputType | null
    _avg: OtherDetailsAvgAggregateOutputType | null
    _sum: OtherDetailsSumAggregateOutputType | null
    _min: OtherDetailsMinAggregateOutputType | null
    _max: OtherDetailsMaxAggregateOutputType | null
  }

  type GetOtherDetailsGroupByPayload<T extends OtherDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtherDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtherDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtherDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], OtherDetailsGroupByOutputType[P]>
        }
      >
    >


  export type OtherDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    rainHarvesting?: boolean
    waterSupply?: boolean
    sewerageLine?: boolean
    parkingType?: boolean
    parkingArea?: boolean
    isCommercial?: boolean
    commercialArea?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otherDetails"]>

  export type OtherDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    rainHarvesting?: boolean
    waterSupply?: boolean
    sewerageLine?: boolean
    parkingType?: boolean
    parkingArea?: boolean
    isCommercial?: boolean
    commercialArea?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otherDetails"]>

  export type OtherDetailsSelectScalar = {
    id?: boolean
    surveyId?: boolean
    rainHarvesting?: boolean
    waterSupply?: boolean
    sewerageLine?: boolean
    parkingType?: boolean
    parkingArea?: boolean
    isCommercial?: boolean
    commercialArea?: boolean
  }

  export type OtherDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
  }
  export type OtherDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
  }

  export type $OtherDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OtherDetails"
    objects: {
      survey: Prisma.$SurveyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      surveyId: string
      rainHarvesting: boolean
      waterSupply: string
      sewerageLine: string
      parkingType: string
      parkingArea: number | null
      isCommercial: boolean
      commercialArea: number | null
    }, ExtArgs["result"]["otherDetails"]>
    composites: {}
  }

  type OtherDetailsGetPayload<S extends boolean | null | undefined | OtherDetailsDefaultArgs> = $Result.GetResult<Prisma.$OtherDetailsPayload, S>

  type OtherDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OtherDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OtherDetailsCountAggregateInputType | true
    }

  export interface OtherDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OtherDetails'], meta: { name: 'OtherDetails' } }
    /**
     * Find zero or one OtherDetails that matches the filter.
     * @param {OtherDetailsFindUniqueArgs} args - Arguments to find a OtherDetails
     * @example
     * // Get one OtherDetails
     * const otherDetails = await prisma.otherDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtherDetailsFindUniqueArgs>(args: SelectSubset<T, OtherDetailsFindUniqueArgs<ExtArgs>>): Prisma__OtherDetailsClient<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OtherDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OtherDetailsFindUniqueOrThrowArgs} args - Arguments to find a OtherDetails
     * @example
     * // Get one OtherDetails
     * const otherDetails = await prisma.otherDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtherDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, OtherDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtherDetailsClient<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OtherDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherDetailsFindFirstArgs} args - Arguments to find a OtherDetails
     * @example
     * // Get one OtherDetails
     * const otherDetails = await prisma.otherDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtherDetailsFindFirstArgs>(args?: SelectSubset<T, OtherDetailsFindFirstArgs<ExtArgs>>): Prisma__OtherDetailsClient<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OtherDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherDetailsFindFirstOrThrowArgs} args - Arguments to find a OtherDetails
     * @example
     * // Get one OtherDetails
     * const otherDetails = await prisma.otherDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtherDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, OtherDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtherDetailsClient<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OtherDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OtherDetails
     * const otherDetails = await prisma.otherDetails.findMany()
     * 
     * // Get first 10 OtherDetails
     * const otherDetails = await prisma.otherDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otherDetailsWithIdOnly = await prisma.otherDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtherDetailsFindManyArgs>(args?: SelectSubset<T, OtherDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OtherDetails.
     * @param {OtherDetailsCreateArgs} args - Arguments to create a OtherDetails.
     * @example
     * // Create one OtherDetails
     * const OtherDetails = await prisma.otherDetails.create({
     *   data: {
     *     // ... data to create a OtherDetails
     *   }
     * })
     * 
     */
    create<T extends OtherDetailsCreateArgs>(args: SelectSubset<T, OtherDetailsCreateArgs<ExtArgs>>): Prisma__OtherDetailsClient<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OtherDetails.
     * @param {OtherDetailsCreateManyArgs} args - Arguments to create many OtherDetails.
     * @example
     * // Create many OtherDetails
     * const otherDetails = await prisma.otherDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtherDetailsCreateManyArgs>(args?: SelectSubset<T, OtherDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OtherDetails and returns the data saved in the database.
     * @param {OtherDetailsCreateManyAndReturnArgs} args - Arguments to create many OtherDetails.
     * @example
     * // Create many OtherDetails
     * const otherDetails = await prisma.otherDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OtherDetails and only return the `id`
     * const otherDetailsWithIdOnly = await prisma.otherDetails.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OtherDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, OtherDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OtherDetails.
     * @param {OtherDetailsDeleteArgs} args - Arguments to delete one OtherDetails.
     * @example
     * // Delete one OtherDetails
     * const OtherDetails = await prisma.otherDetails.delete({
     *   where: {
     *     // ... filter to delete one OtherDetails
     *   }
     * })
     * 
     */
    delete<T extends OtherDetailsDeleteArgs>(args: SelectSubset<T, OtherDetailsDeleteArgs<ExtArgs>>): Prisma__OtherDetailsClient<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OtherDetails.
     * @param {OtherDetailsUpdateArgs} args - Arguments to update one OtherDetails.
     * @example
     * // Update one OtherDetails
     * const otherDetails = await prisma.otherDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtherDetailsUpdateArgs>(args: SelectSubset<T, OtherDetailsUpdateArgs<ExtArgs>>): Prisma__OtherDetailsClient<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OtherDetails.
     * @param {OtherDetailsDeleteManyArgs} args - Arguments to filter OtherDetails to delete.
     * @example
     * // Delete a few OtherDetails
     * const { count } = await prisma.otherDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtherDetailsDeleteManyArgs>(args?: SelectSubset<T, OtherDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OtherDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OtherDetails
     * const otherDetails = await prisma.otherDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtherDetailsUpdateManyArgs>(args: SelectSubset<T, OtherDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OtherDetails.
     * @param {OtherDetailsUpsertArgs} args - Arguments to update or create a OtherDetails.
     * @example
     * // Update or create a OtherDetails
     * const otherDetails = await prisma.otherDetails.upsert({
     *   create: {
     *     // ... data to create a OtherDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OtherDetails we want to update
     *   }
     * })
     */
    upsert<T extends OtherDetailsUpsertArgs>(args: SelectSubset<T, OtherDetailsUpsertArgs<ExtArgs>>): Prisma__OtherDetailsClient<$Result.GetResult<Prisma.$OtherDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OtherDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherDetailsCountArgs} args - Arguments to filter OtherDetails to count.
     * @example
     * // Count the number of OtherDetails
     * const count = await prisma.otherDetails.count({
     *   where: {
     *     // ... the filter for the OtherDetails we want to count
     *   }
     * })
    **/
    count<T extends OtherDetailsCountArgs>(
      args?: Subset<T, OtherDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtherDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OtherDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtherDetailsAggregateArgs>(args: Subset<T, OtherDetailsAggregateArgs>): Prisma.PrismaPromise<GetOtherDetailsAggregateType<T>>

    /**
     * Group by OtherDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtherDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtherDetailsGroupByArgs['orderBy'] }
        : { orderBy?: OtherDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtherDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtherDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OtherDetails model
   */
  readonly fields: OtherDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OtherDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtherDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDefaultArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OtherDetails model
   */ 
  interface OtherDetailsFieldRefs {
    readonly id: FieldRef<"OtherDetails", 'String'>
    readonly surveyId: FieldRef<"OtherDetails", 'String'>
    readonly rainHarvesting: FieldRef<"OtherDetails", 'Boolean'>
    readonly waterSupply: FieldRef<"OtherDetails", 'String'>
    readonly sewerageLine: FieldRef<"OtherDetails", 'String'>
    readonly parkingType: FieldRef<"OtherDetails", 'String'>
    readonly parkingArea: FieldRef<"OtherDetails", 'Float'>
    readonly isCommercial: FieldRef<"OtherDetails", 'Boolean'>
    readonly commercialArea: FieldRef<"OtherDetails", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * OtherDetails findUnique
   */
  export type OtherDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OtherDetails to fetch.
     */
    where: OtherDetailsWhereUniqueInput
  }

  /**
   * OtherDetails findUniqueOrThrow
   */
  export type OtherDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OtherDetails to fetch.
     */
    where: OtherDetailsWhereUniqueInput
  }

  /**
   * OtherDetails findFirst
   */
  export type OtherDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OtherDetails to fetch.
     */
    where?: OtherDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtherDetails to fetch.
     */
    orderBy?: OtherDetailsOrderByWithRelationInput | OtherDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtherDetails.
     */
    cursor?: OtherDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtherDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtherDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtherDetails.
     */
    distinct?: OtherDetailsScalarFieldEnum | OtherDetailsScalarFieldEnum[]
  }

  /**
   * OtherDetails findFirstOrThrow
   */
  export type OtherDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OtherDetails to fetch.
     */
    where?: OtherDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtherDetails to fetch.
     */
    orderBy?: OtherDetailsOrderByWithRelationInput | OtherDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtherDetails.
     */
    cursor?: OtherDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtherDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtherDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtherDetails.
     */
    distinct?: OtherDetailsScalarFieldEnum | OtherDetailsScalarFieldEnum[]
  }

  /**
   * OtherDetails findMany
   */
  export type OtherDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OtherDetails to fetch.
     */
    where?: OtherDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtherDetails to fetch.
     */
    orderBy?: OtherDetailsOrderByWithRelationInput | OtherDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OtherDetails.
     */
    cursor?: OtherDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtherDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtherDetails.
     */
    skip?: number
    distinct?: OtherDetailsScalarFieldEnum | OtherDetailsScalarFieldEnum[]
  }

  /**
   * OtherDetails create
   */
  export type OtherDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a OtherDetails.
     */
    data: XOR<OtherDetailsCreateInput, OtherDetailsUncheckedCreateInput>
  }

  /**
   * OtherDetails createMany
   */
  export type OtherDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OtherDetails.
     */
    data: OtherDetailsCreateManyInput | OtherDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OtherDetails createManyAndReturn
   */
  export type OtherDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OtherDetails.
     */
    data: OtherDetailsCreateManyInput | OtherDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OtherDetails update
   */
  export type OtherDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a OtherDetails.
     */
    data: XOR<OtherDetailsUpdateInput, OtherDetailsUncheckedUpdateInput>
    /**
     * Choose, which OtherDetails to update.
     */
    where: OtherDetailsWhereUniqueInput
  }

  /**
   * OtherDetails updateMany
   */
  export type OtherDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OtherDetails.
     */
    data: XOR<OtherDetailsUpdateManyMutationInput, OtherDetailsUncheckedUpdateManyInput>
    /**
     * Filter which OtherDetails to update
     */
    where?: OtherDetailsWhereInput
  }

  /**
   * OtherDetails upsert
   */
  export type OtherDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the OtherDetails to update in case it exists.
     */
    where: OtherDetailsWhereUniqueInput
    /**
     * In case the OtherDetails found by the `where` argument doesn't exist, create a new OtherDetails with this data.
     */
    create: XOR<OtherDetailsCreateInput, OtherDetailsUncheckedCreateInput>
    /**
     * In case the OtherDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtherDetailsUpdateInput, OtherDetailsUncheckedUpdateInput>
  }

  /**
   * OtherDetails delete
   */
  export type OtherDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
    /**
     * Filter which OtherDetails to delete.
     */
    where: OtherDetailsWhereUniqueInput
  }

  /**
   * OtherDetails deleteMany
   */
  export type OtherDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtherDetails to delete
     */
    where?: OtherDetailsWhereInput
  }

  /**
   * OtherDetails without action
   */
  export type OtherDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherDetails
     */
    select?: OtherDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtherDetailsInclude<ExtArgs> | null
  }


  /**
   * Model FloorDetails
   */

  export type AggregateFloorDetails = {
    _count: FloorDetailsCountAggregateOutputType | null
    _avg: FloorDetailsAvgAggregateOutputType | null
    _sum: FloorDetailsSumAggregateOutputType | null
    _min: FloorDetailsMinAggregateOutputType | null
    _max: FloorDetailsMaxAggregateOutputType | null
  }

  export type FloorDetailsAvgAggregateOutputType = {
    floorNo: number | null
    area: number | null
    rentAmount: number | null
  }

  export type FloorDetailsSumAggregateOutputType = {
    floorNo: number | null
    area: number | null
    rentAmount: number | null
  }

  export type FloorDetailsMinAggregateOutputType = {
    id: string | null
    surveyId: string | null
    floorNo: number | null
    floorType: string | null
    details: string | null
    area: number | null
    usage: string | null
    isRented: boolean | null
    rentAmount: number | null
  }

  export type FloorDetailsMaxAggregateOutputType = {
    id: string | null
    surveyId: string | null
    floorNo: number | null
    floorType: string | null
    details: string | null
    area: number | null
    usage: string | null
    isRented: boolean | null
    rentAmount: number | null
  }

  export type FloorDetailsCountAggregateOutputType = {
    id: number
    surveyId: number
    floorNo: number
    floorType: number
    details: number
    area: number
    usage: number
    isRented: number
    rentAmount: number
    _all: number
  }


  export type FloorDetailsAvgAggregateInputType = {
    floorNo?: true
    area?: true
    rentAmount?: true
  }

  export type FloorDetailsSumAggregateInputType = {
    floorNo?: true
    area?: true
    rentAmount?: true
  }

  export type FloorDetailsMinAggregateInputType = {
    id?: true
    surveyId?: true
    floorNo?: true
    floorType?: true
    details?: true
    area?: true
    usage?: true
    isRented?: true
    rentAmount?: true
  }

  export type FloorDetailsMaxAggregateInputType = {
    id?: true
    surveyId?: true
    floorNo?: true
    floorType?: true
    details?: true
    area?: true
    usage?: true
    isRented?: true
    rentAmount?: true
  }

  export type FloorDetailsCountAggregateInputType = {
    id?: true
    surveyId?: true
    floorNo?: true
    floorType?: true
    details?: true
    area?: true
    usage?: true
    isRented?: true
    rentAmount?: true
    _all?: true
  }

  export type FloorDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FloorDetails to aggregate.
     */
    where?: FloorDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FloorDetails to fetch.
     */
    orderBy?: FloorDetailsOrderByWithRelationInput | FloorDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FloorDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FloorDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FloorDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FloorDetails
    **/
    _count?: true | FloorDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FloorDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FloorDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FloorDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FloorDetailsMaxAggregateInputType
  }

  export type GetFloorDetailsAggregateType<T extends FloorDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateFloorDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFloorDetails[P]>
      : GetScalarType<T[P], AggregateFloorDetails[P]>
  }




  export type FloorDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FloorDetailsWhereInput
    orderBy?: FloorDetailsOrderByWithAggregationInput | FloorDetailsOrderByWithAggregationInput[]
    by: FloorDetailsScalarFieldEnum[] | FloorDetailsScalarFieldEnum
    having?: FloorDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FloorDetailsCountAggregateInputType | true
    _avg?: FloorDetailsAvgAggregateInputType
    _sum?: FloorDetailsSumAggregateInputType
    _min?: FloorDetailsMinAggregateInputType
    _max?: FloorDetailsMaxAggregateInputType
  }

  export type FloorDetailsGroupByOutputType = {
    id: string
    surveyId: string
    floorNo: number
    floorType: string
    details: string
    area: number
    usage: string
    isRented: boolean
    rentAmount: number | null
    _count: FloorDetailsCountAggregateOutputType | null
    _avg: FloorDetailsAvgAggregateOutputType | null
    _sum: FloorDetailsSumAggregateOutputType | null
    _min: FloorDetailsMinAggregateOutputType | null
    _max: FloorDetailsMaxAggregateOutputType | null
  }

  type GetFloorDetailsGroupByPayload<T extends FloorDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FloorDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FloorDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FloorDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], FloorDetailsGroupByOutputType[P]>
        }
      >
    >


  export type FloorDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    floorNo?: boolean
    floorType?: boolean
    details?: boolean
    area?: boolean
    usage?: boolean
    isRented?: boolean
    rentAmount?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["floorDetails"]>

  export type FloorDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    floorNo?: boolean
    floorType?: boolean
    details?: boolean
    area?: boolean
    usage?: boolean
    isRented?: boolean
    rentAmount?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["floorDetails"]>

  export type FloorDetailsSelectScalar = {
    id?: boolean
    surveyId?: boolean
    floorNo?: boolean
    floorType?: boolean
    details?: boolean
    area?: boolean
    usage?: boolean
    isRented?: boolean
    rentAmount?: boolean
  }

  export type FloorDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
  }
  export type FloorDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
  }

  export type $FloorDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FloorDetails"
    objects: {
      survey: Prisma.$SurveyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      surveyId: string
      floorNo: number
      floorType: string
      details: string
      area: number
      usage: string
      isRented: boolean
      rentAmount: number | null
    }, ExtArgs["result"]["floorDetails"]>
    composites: {}
  }

  type FloorDetailsGetPayload<S extends boolean | null | undefined | FloorDetailsDefaultArgs> = $Result.GetResult<Prisma.$FloorDetailsPayload, S>

  type FloorDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FloorDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FloorDetailsCountAggregateInputType | true
    }

  export interface FloorDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FloorDetails'], meta: { name: 'FloorDetails' } }
    /**
     * Find zero or one FloorDetails that matches the filter.
     * @param {FloorDetailsFindUniqueArgs} args - Arguments to find a FloorDetails
     * @example
     * // Get one FloorDetails
     * const floorDetails = await prisma.floorDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FloorDetailsFindUniqueArgs>(args: SelectSubset<T, FloorDetailsFindUniqueArgs<ExtArgs>>): Prisma__FloorDetailsClient<$Result.GetResult<Prisma.$FloorDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FloorDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FloorDetailsFindUniqueOrThrowArgs} args - Arguments to find a FloorDetails
     * @example
     * // Get one FloorDetails
     * const floorDetails = await prisma.floorDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FloorDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, FloorDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FloorDetailsClient<$Result.GetResult<Prisma.$FloorDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FloorDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorDetailsFindFirstArgs} args - Arguments to find a FloorDetails
     * @example
     * // Get one FloorDetails
     * const floorDetails = await prisma.floorDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FloorDetailsFindFirstArgs>(args?: SelectSubset<T, FloorDetailsFindFirstArgs<ExtArgs>>): Prisma__FloorDetailsClient<$Result.GetResult<Prisma.$FloorDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FloorDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorDetailsFindFirstOrThrowArgs} args - Arguments to find a FloorDetails
     * @example
     * // Get one FloorDetails
     * const floorDetails = await prisma.floorDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FloorDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, FloorDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FloorDetailsClient<$Result.GetResult<Prisma.$FloorDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FloorDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FloorDetails
     * const floorDetails = await prisma.floorDetails.findMany()
     * 
     * // Get first 10 FloorDetails
     * const floorDetails = await prisma.floorDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const floorDetailsWithIdOnly = await prisma.floorDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FloorDetailsFindManyArgs>(args?: SelectSubset<T, FloorDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FloorDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FloorDetails.
     * @param {FloorDetailsCreateArgs} args - Arguments to create a FloorDetails.
     * @example
     * // Create one FloorDetails
     * const FloorDetails = await prisma.floorDetails.create({
     *   data: {
     *     // ... data to create a FloorDetails
     *   }
     * })
     * 
     */
    create<T extends FloorDetailsCreateArgs>(args: SelectSubset<T, FloorDetailsCreateArgs<ExtArgs>>): Prisma__FloorDetailsClient<$Result.GetResult<Prisma.$FloorDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FloorDetails.
     * @param {FloorDetailsCreateManyArgs} args - Arguments to create many FloorDetails.
     * @example
     * // Create many FloorDetails
     * const floorDetails = await prisma.floorDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FloorDetailsCreateManyArgs>(args?: SelectSubset<T, FloorDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FloorDetails and returns the data saved in the database.
     * @param {FloorDetailsCreateManyAndReturnArgs} args - Arguments to create many FloorDetails.
     * @example
     * // Create many FloorDetails
     * const floorDetails = await prisma.floorDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FloorDetails and only return the `id`
     * const floorDetailsWithIdOnly = await prisma.floorDetails.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FloorDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, FloorDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FloorDetailsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FloorDetails.
     * @param {FloorDetailsDeleteArgs} args - Arguments to delete one FloorDetails.
     * @example
     * // Delete one FloorDetails
     * const FloorDetails = await prisma.floorDetails.delete({
     *   where: {
     *     // ... filter to delete one FloorDetails
     *   }
     * })
     * 
     */
    delete<T extends FloorDetailsDeleteArgs>(args: SelectSubset<T, FloorDetailsDeleteArgs<ExtArgs>>): Prisma__FloorDetailsClient<$Result.GetResult<Prisma.$FloorDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FloorDetails.
     * @param {FloorDetailsUpdateArgs} args - Arguments to update one FloorDetails.
     * @example
     * // Update one FloorDetails
     * const floorDetails = await prisma.floorDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FloorDetailsUpdateArgs>(args: SelectSubset<T, FloorDetailsUpdateArgs<ExtArgs>>): Prisma__FloorDetailsClient<$Result.GetResult<Prisma.$FloorDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FloorDetails.
     * @param {FloorDetailsDeleteManyArgs} args - Arguments to filter FloorDetails to delete.
     * @example
     * // Delete a few FloorDetails
     * const { count } = await prisma.floorDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FloorDetailsDeleteManyArgs>(args?: SelectSubset<T, FloorDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FloorDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FloorDetails
     * const floorDetails = await prisma.floorDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FloorDetailsUpdateManyArgs>(args: SelectSubset<T, FloorDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FloorDetails.
     * @param {FloorDetailsUpsertArgs} args - Arguments to update or create a FloorDetails.
     * @example
     * // Update or create a FloorDetails
     * const floorDetails = await prisma.floorDetails.upsert({
     *   create: {
     *     // ... data to create a FloorDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FloorDetails we want to update
     *   }
     * })
     */
    upsert<T extends FloorDetailsUpsertArgs>(args: SelectSubset<T, FloorDetailsUpsertArgs<ExtArgs>>): Prisma__FloorDetailsClient<$Result.GetResult<Prisma.$FloorDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FloorDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorDetailsCountArgs} args - Arguments to filter FloorDetails to count.
     * @example
     * // Count the number of FloorDetails
     * const count = await prisma.floorDetails.count({
     *   where: {
     *     // ... the filter for the FloorDetails we want to count
     *   }
     * })
    **/
    count<T extends FloorDetailsCountArgs>(
      args?: Subset<T, FloorDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FloorDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FloorDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FloorDetailsAggregateArgs>(args: Subset<T, FloorDetailsAggregateArgs>): Prisma.PrismaPromise<GetFloorDetailsAggregateType<T>>

    /**
     * Group by FloorDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FloorDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FloorDetailsGroupByArgs['orderBy'] }
        : { orderBy?: FloorDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FloorDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFloorDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FloorDetails model
   */
  readonly fields: FloorDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FloorDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FloorDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDefaultArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FloorDetails model
   */ 
  interface FloorDetailsFieldRefs {
    readonly id: FieldRef<"FloorDetails", 'String'>
    readonly surveyId: FieldRef<"FloorDetails", 'String'>
    readonly floorNo: FieldRef<"FloorDetails", 'Int'>
    readonly floorType: FieldRef<"FloorDetails", 'String'>
    readonly details: FieldRef<"FloorDetails", 'String'>
    readonly area: FieldRef<"FloorDetails", 'Float'>
    readonly usage: FieldRef<"FloorDetails", 'String'>
    readonly isRented: FieldRef<"FloorDetails", 'Boolean'>
    readonly rentAmount: FieldRef<"FloorDetails", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * FloorDetails findUnique
   */
  export type FloorDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorDetails
     */
    select?: FloorDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorDetailsInclude<ExtArgs> | null
    /**
     * Filter, which FloorDetails to fetch.
     */
    where: FloorDetailsWhereUniqueInput
  }

  /**
   * FloorDetails findUniqueOrThrow
   */
  export type FloorDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorDetails
     */
    select?: FloorDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorDetailsInclude<ExtArgs> | null
    /**
     * Filter, which FloorDetails to fetch.
     */
    where: FloorDetailsWhereUniqueInput
  }

  /**
   * FloorDetails findFirst
   */
  export type FloorDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorDetails
     */
    select?: FloorDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorDetailsInclude<ExtArgs> | null
    /**
     * Filter, which FloorDetails to fetch.
     */
    where?: FloorDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FloorDetails to fetch.
     */
    orderBy?: FloorDetailsOrderByWithRelationInput | FloorDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FloorDetails.
     */
    cursor?: FloorDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FloorDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FloorDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FloorDetails.
     */
    distinct?: FloorDetailsScalarFieldEnum | FloorDetailsScalarFieldEnum[]
  }

  /**
   * FloorDetails findFirstOrThrow
   */
  export type FloorDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorDetails
     */
    select?: FloorDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorDetailsInclude<ExtArgs> | null
    /**
     * Filter, which FloorDetails to fetch.
     */
    where?: FloorDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FloorDetails to fetch.
     */
    orderBy?: FloorDetailsOrderByWithRelationInput | FloorDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FloorDetails.
     */
    cursor?: FloorDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FloorDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FloorDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FloorDetails.
     */
    distinct?: FloorDetailsScalarFieldEnum | FloorDetailsScalarFieldEnum[]
  }

  /**
   * FloorDetails findMany
   */
  export type FloorDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorDetails
     */
    select?: FloorDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorDetailsInclude<ExtArgs> | null
    /**
     * Filter, which FloorDetails to fetch.
     */
    where?: FloorDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FloorDetails to fetch.
     */
    orderBy?: FloorDetailsOrderByWithRelationInput | FloorDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FloorDetails.
     */
    cursor?: FloorDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FloorDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FloorDetails.
     */
    skip?: number
    distinct?: FloorDetailsScalarFieldEnum | FloorDetailsScalarFieldEnum[]
  }

  /**
   * FloorDetails create
   */
  export type FloorDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorDetails
     */
    select?: FloorDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a FloorDetails.
     */
    data: XOR<FloorDetailsCreateInput, FloorDetailsUncheckedCreateInput>
  }

  /**
   * FloorDetails createMany
   */
  export type FloorDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FloorDetails.
     */
    data: FloorDetailsCreateManyInput | FloorDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FloorDetails createManyAndReturn
   */
  export type FloorDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorDetails
     */
    select?: FloorDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FloorDetails.
     */
    data: FloorDetailsCreateManyInput | FloorDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FloorDetails update
   */
  export type FloorDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorDetails
     */
    select?: FloorDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a FloorDetails.
     */
    data: XOR<FloorDetailsUpdateInput, FloorDetailsUncheckedUpdateInput>
    /**
     * Choose, which FloorDetails to update.
     */
    where: FloorDetailsWhereUniqueInput
  }

  /**
   * FloorDetails updateMany
   */
  export type FloorDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FloorDetails.
     */
    data: XOR<FloorDetailsUpdateManyMutationInput, FloorDetailsUncheckedUpdateManyInput>
    /**
     * Filter which FloorDetails to update
     */
    where?: FloorDetailsWhereInput
  }

  /**
   * FloorDetails upsert
   */
  export type FloorDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorDetails
     */
    select?: FloorDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the FloorDetails to update in case it exists.
     */
    where: FloorDetailsWhereUniqueInput
    /**
     * In case the FloorDetails found by the `where` argument doesn't exist, create a new FloorDetails with this data.
     */
    create: XOR<FloorDetailsCreateInput, FloorDetailsUncheckedCreateInput>
    /**
     * In case the FloorDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FloorDetailsUpdateInput, FloorDetailsUncheckedUpdateInput>
  }

  /**
   * FloorDetails delete
   */
  export type FloorDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorDetails
     */
    select?: FloorDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorDetailsInclude<ExtArgs> | null
    /**
     * Filter which FloorDetails to delete.
     */
    where: FloorDetailsWhereUniqueInput
  }

  /**
   * FloorDetails deleteMany
   */
  export type FloorDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FloorDetails to delete
     */
    where?: FloorDetailsWhereInput
  }

  /**
   * FloorDetails without action
   */
  export type FloorDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorDetails
     */
    select?: FloorDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorDetailsInclude<ExtArgs> | null
  }


  /**
   * Model PropertyAssessment
   */

  export type AggregatePropertyAssessment = {
    _count: PropertyAssessmentCountAggregateOutputType | null
    _avg: PropertyAssessmentAvgAggregateOutputType | null
    _sum: PropertyAssessmentSumAggregateOutputType | null
    _min: PropertyAssessmentMinAggregateOutputType | null
    _max: PropertyAssessmentMaxAggregateOutputType | null
  }

  export type PropertyAssessmentAvgAggregateOutputType = {
    annualRent: number | null
    marketValue: number | null
    assessedValue: number | null
    taxAmount: number | null
  }

  export type PropertyAssessmentSumAggregateOutputType = {
    annualRent: number | null
    marketValue: number | null
    assessedValue: number | null
    taxAmount: number | null
  }

  export type PropertyAssessmentMinAggregateOutputType = {
    id: string | null
    surveyId: string | null
    categoryId: string | null
    subCategoryId: string | null
    annualRent: number | null
    marketValue: number | null
    assessedValue: number | null
    taxAmount: number | null
    remarks: string | null
  }

  export type PropertyAssessmentMaxAggregateOutputType = {
    id: string | null
    surveyId: string | null
    categoryId: string | null
    subCategoryId: string | null
    annualRent: number | null
    marketValue: number | null
    assessedValue: number | null
    taxAmount: number | null
    remarks: string | null
  }

  export type PropertyAssessmentCountAggregateOutputType = {
    id: number
    surveyId: number
    categoryId: number
    subCategoryId: number
    annualRent: number
    marketValue: number
    assessedValue: number
    taxAmount: number
    remarks: number
    _all: number
  }


  export type PropertyAssessmentAvgAggregateInputType = {
    annualRent?: true
    marketValue?: true
    assessedValue?: true
    taxAmount?: true
  }

  export type PropertyAssessmentSumAggregateInputType = {
    annualRent?: true
    marketValue?: true
    assessedValue?: true
    taxAmount?: true
  }

  export type PropertyAssessmentMinAggregateInputType = {
    id?: true
    surveyId?: true
    categoryId?: true
    subCategoryId?: true
    annualRent?: true
    marketValue?: true
    assessedValue?: true
    taxAmount?: true
    remarks?: true
  }

  export type PropertyAssessmentMaxAggregateInputType = {
    id?: true
    surveyId?: true
    categoryId?: true
    subCategoryId?: true
    annualRent?: true
    marketValue?: true
    assessedValue?: true
    taxAmount?: true
    remarks?: true
  }

  export type PropertyAssessmentCountAggregateInputType = {
    id?: true
    surveyId?: true
    categoryId?: true
    subCategoryId?: true
    annualRent?: true
    marketValue?: true
    assessedValue?: true
    taxAmount?: true
    remarks?: true
    _all?: true
  }

  export type PropertyAssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyAssessment to aggregate.
     */
    where?: PropertyAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAssessments to fetch.
     */
    orderBy?: PropertyAssessmentOrderByWithRelationInput | PropertyAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyAssessments
    **/
    _count?: true | PropertyAssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAssessmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyAssessmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyAssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyAssessmentMaxAggregateInputType
  }

  export type GetPropertyAssessmentAggregateType<T extends PropertyAssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyAssessment[P]>
      : GetScalarType<T[P], AggregatePropertyAssessment[P]>
  }




  export type PropertyAssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyAssessmentWhereInput
    orderBy?: PropertyAssessmentOrderByWithAggregationInput | PropertyAssessmentOrderByWithAggregationInput[]
    by: PropertyAssessmentScalarFieldEnum[] | PropertyAssessmentScalarFieldEnum
    having?: PropertyAssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyAssessmentCountAggregateInputType | true
    _avg?: PropertyAssessmentAvgAggregateInputType
    _sum?: PropertyAssessmentSumAggregateInputType
    _min?: PropertyAssessmentMinAggregateInputType
    _max?: PropertyAssessmentMaxAggregateInputType
  }

  export type PropertyAssessmentGroupByOutputType = {
    id: string
    surveyId: string
    categoryId: string
    subCategoryId: string
    annualRent: number
    marketValue: number
    assessedValue: number
    taxAmount: number
    remarks: string | null
    _count: PropertyAssessmentCountAggregateOutputType | null
    _avg: PropertyAssessmentAvgAggregateOutputType | null
    _sum: PropertyAssessmentSumAggregateOutputType | null
    _min: PropertyAssessmentMinAggregateOutputType | null
    _max: PropertyAssessmentMaxAggregateOutputType | null
  }

  type GetPropertyAssessmentGroupByPayload<T extends PropertyAssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyAssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyAssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyAssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyAssessmentGroupByOutputType[P]>
        }
      >
    >


  export type PropertyAssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    categoryId?: boolean
    subCategoryId?: boolean
    annualRent?: boolean
    marketValue?: boolean
    assessedValue?: boolean
    taxAmount?: boolean
    remarks?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    category?: boolean | NRPropCategoryMappingDefaultArgs<ExtArgs>
    subCategory?: boolean | NRPropSubCategoryMappingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyAssessment"]>

  export type PropertyAssessmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    categoryId?: boolean
    subCategoryId?: boolean
    annualRent?: boolean
    marketValue?: boolean
    assessedValue?: boolean
    taxAmount?: boolean
    remarks?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    category?: boolean | NRPropCategoryMappingDefaultArgs<ExtArgs>
    subCategory?: boolean | NRPropSubCategoryMappingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyAssessment"]>

  export type PropertyAssessmentSelectScalar = {
    id?: boolean
    surveyId?: boolean
    categoryId?: boolean
    subCategoryId?: boolean
    annualRent?: boolean
    marketValue?: boolean
    assessedValue?: boolean
    taxAmount?: boolean
    remarks?: boolean
  }

  export type PropertyAssessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    category?: boolean | NRPropCategoryMappingDefaultArgs<ExtArgs>
    subCategory?: boolean | NRPropSubCategoryMappingDefaultArgs<ExtArgs>
  }
  export type PropertyAssessmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    category?: boolean | NRPropCategoryMappingDefaultArgs<ExtArgs>
    subCategory?: boolean | NRPropSubCategoryMappingDefaultArgs<ExtArgs>
  }

  export type $PropertyAssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyAssessment"
    objects: {
      survey: Prisma.$SurveyPayload<ExtArgs>
      category: Prisma.$NRPropCategoryMappingPayload<ExtArgs>
      subCategory: Prisma.$NRPropSubCategoryMappingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      surveyId: string
      categoryId: string
      subCategoryId: string
      annualRent: number
      marketValue: number
      assessedValue: number
      taxAmount: number
      remarks: string | null
    }, ExtArgs["result"]["propertyAssessment"]>
    composites: {}
  }

  type PropertyAssessmentGetPayload<S extends boolean | null | undefined | PropertyAssessmentDefaultArgs> = $Result.GetResult<Prisma.$PropertyAssessmentPayload, S>

  type PropertyAssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyAssessmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PropertyAssessmentCountAggregateInputType | true
    }

  export interface PropertyAssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyAssessment'], meta: { name: 'PropertyAssessment' } }
    /**
     * Find zero or one PropertyAssessment that matches the filter.
     * @param {PropertyAssessmentFindUniqueArgs} args - Arguments to find a PropertyAssessment
     * @example
     * // Get one PropertyAssessment
     * const propertyAssessment = await prisma.propertyAssessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyAssessmentFindUniqueArgs>(args: SelectSubset<T, PropertyAssessmentFindUniqueArgs<ExtArgs>>): Prisma__PropertyAssessmentClient<$Result.GetResult<Prisma.$PropertyAssessmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PropertyAssessment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PropertyAssessmentFindUniqueOrThrowArgs} args - Arguments to find a PropertyAssessment
     * @example
     * // Get one PropertyAssessment
     * const propertyAssessment = await prisma.propertyAssessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyAssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyAssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyAssessmentClient<$Result.GetResult<Prisma.$PropertyAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PropertyAssessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAssessmentFindFirstArgs} args - Arguments to find a PropertyAssessment
     * @example
     * // Get one PropertyAssessment
     * const propertyAssessment = await prisma.propertyAssessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyAssessmentFindFirstArgs>(args?: SelectSubset<T, PropertyAssessmentFindFirstArgs<ExtArgs>>): Prisma__PropertyAssessmentClient<$Result.GetResult<Prisma.$PropertyAssessmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PropertyAssessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAssessmentFindFirstOrThrowArgs} args - Arguments to find a PropertyAssessment
     * @example
     * // Get one PropertyAssessment
     * const propertyAssessment = await prisma.propertyAssessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyAssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyAssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyAssessmentClient<$Result.GetResult<Prisma.$PropertyAssessmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PropertyAssessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyAssessments
     * const propertyAssessments = await prisma.propertyAssessment.findMany()
     * 
     * // Get first 10 PropertyAssessments
     * const propertyAssessments = await prisma.propertyAssessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyAssessmentWithIdOnly = await prisma.propertyAssessment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyAssessmentFindManyArgs>(args?: SelectSubset<T, PropertyAssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAssessmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PropertyAssessment.
     * @param {PropertyAssessmentCreateArgs} args - Arguments to create a PropertyAssessment.
     * @example
     * // Create one PropertyAssessment
     * const PropertyAssessment = await prisma.propertyAssessment.create({
     *   data: {
     *     // ... data to create a PropertyAssessment
     *   }
     * })
     * 
     */
    create<T extends PropertyAssessmentCreateArgs>(args: SelectSubset<T, PropertyAssessmentCreateArgs<ExtArgs>>): Prisma__PropertyAssessmentClient<$Result.GetResult<Prisma.$PropertyAssessmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PropertyAssessments.
     * @param {PropertyAssessmentCreateManyArgs} args - Arguments to create many PropertyAssessments.
     * @example
     * // Create many PropertyAssessments
     * const propertyAssessment = await prisma.propertyAssessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyAssessmentCreateManyArgs>(args?: SelectSubset<T, PropertyAssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyAssessments and returns the data saved in the database.
     * @param {PropertyAssessmentCreateManyAndReturnArgs} args - Arguments to create many PropertyAssessments.
     * @example
     * // Create many PropertyAssessments
     * const propertyAssessment = await prisma.propertyAssessment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyAssessments and only return the `id`
     * const propertyAssessmentWithIdOnly = await prisma.propertyAssessment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyAssessmentCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyAssessmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAssessmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PropertyAssessment.
     * @param {PropertyAssessmentDeleteArgs} args - Arguments to delete one PropertyAssessment.
     * @example
     * // Delete one PropertyAssessment
     * const PropertyAssessment = await prisma.propertyAssessment.delete({
     *   where: {
     *     // ... filter to delete one PropertyAssessment
     *   }
     * })
     * 
     */
    delete<T extends PropertyAssessmentDeleteArgs>(args: SelectSubset<T, PropertyAssessmentDeleteArgs<ExtArgs>>): Prisma__PropertyAssessmentClient<$Result.GetResult<Prisma.$PropertyAssessmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PropertyAssessment.
     * @param {PropertyAssessmentUpdateArgs} args - Arguments to update one PropertyAssessment.
     * @example
     * // Update one PropertyAssessment
     * const propertyAssessment = await prisma.propertyAssessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyAssessmentUpdateArgs>(args: SelectSubset<T, PropertyAssessmentUpdateArgs<ExtArgs>>): Prisma__PropertyAssessmentClient<$Result.GetResult<Prisma.$PropertyAssessmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PropertyAssessments.
     * @param {PropertyAssessmentDeleteManyArgs} args - Arguments to filter PropertyAssessments to delete.
     * @example
     * // Delete a few PropertyAssessments
     * const { count } = await prisma.propertyAssessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyAssessmentDeleteManyArgs>(args?: SelectSubset<T, PropertyAssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyAssessments
     * const propertyAssessment = await prisma.propertyAssessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyAssessmentUpdateManyArgs>(args: SelectSubset<T, PropertyAssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyAssessment.
     * @param {PropertyAssessmentUpsertArgs} args - Arguments to update or create a PropertyAssessment.
     * @example
     * // Update or create a PropertyAssessment
     * const propertyAssessment = await prisma.propertyAssessment.upsert({
     *   create: {
     *     // ... data to create a PropertyAssessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyAssessment we want to update
     *   }
     * })
     */
    upsert<T extends PropertyAssessmentUpsertArgs>(args: SelectSubset<T, PropertyAssessmentUpsertArgs<ExtArgs>>): Prisma__PropertyAssessmentClient<$Result.GetResult<Prisma.$PropertyAssessmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PropertyAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAssessmentCountArgs} args - Arguments to filter PropertyAssessments to count.
     * @example
     * // Count the number of PropertyAssessments
     * const count = await prisma.propertyAssessment.count({
     *   where: {
     *     // ... the filter for the PropertyAssessments we want to count
     *   }
     * })
    **/
    count<T extends PropertyAssessmentCountArgs>(
      args?: Subset<T, PropertyAssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyAssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAssessmentAggregateArgs>(args: Subset<T, PropertyAssessmentAggregateArgs>): Prisma.PrismaPromise<GetPropertyAssessmentAggregateType<T>>

    /**
     * Group by PropertyAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyAssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyAssessmentGroupByArgs['orderBy'] }
        : { orderBy?: PropertyAssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyAssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyAssessment model
   */
  readonly fields: PropertyAssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyAssessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyAssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDefaultArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    category<T extends NRPropCategoryMappingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NRPropCategoryMappingDefaultArgs<ExtArgs>>): Prisma__NRPropCategoryMappingClient<$Result.GetResult<Prisma.$NRPropCategoryMappingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subCategory<T extends NRPropSubCategoryMappingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NRPropSubCategoryMappingDefaultArgs<ExtArgs>>): Prisma__NRPropSubCategoryMappingClient<$Result.GetResult<Prisma.$NRPropSubCategoryMappingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyAssessment model
   */ 
  interface PropertyAssessmentFieldRefs {
    readonly id: FieldRef<"PropertyAssessment", 'String'>
    readonly surveyId: FieldRef<"PropertyAssessment", 'String'>
    readonly categoryId: FieldRef<"PropertyAssessment", 'String'>
    readonly subCategoryId: FieldRef<"PropertyAssessment", 'String'>
    readonly annualRent: FieldRef<"PropertyAssessment", 'Float'>
    readonly marketValue: FieldRef<"PropertyAssessment", 'Float'>
    readonly assessedValue: FieldRef<"PropertyAssessment", 'Float'>
    readonly taxAmount: FieldRef<"PropertyAssessment", 'Float'>
    readonly remarks: FieldRef<"PropertyAssessment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PropertyAssessment findUnique
   */
  export type PropertyAssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAssessment
     */
    select?: PropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAssessment to fetch.
     */
    where: PropertyAssessmentWhereUniqueInput
  }

  /**
   * PropertyAssessment findUniqueOrThrow
   */
  export type PropertyAssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAssessment
     */
    select?: PropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAssessment to fetch.
     */
    where: PropertyAssessmentWhereUniqueInput
  }

  /**
   * PropertyAssessment findFirst
   */
  export type PropertyAssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAssessment
     */
    select?: PropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAssessment to fetch.
     */
    where?: PropertyAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAssessments to fetch.
     */
    orderBy?: PropertyAssessmentOrderByWithRelationInput | PropertyAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyAssessments.
     */
    cursor?: PropertyAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyAssessments.
     */
    distinct?: PropertyAssessmentScalarFieldEnum | PropertyAssessmentScalarFieldEnum[]
  }

  /**
   * PropertyAssessment findFirstOrThrow
   */
  export type PropertyAssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAssessment
     */
    select?: PropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAssessment to fetch.
     */
    where?: PropertyAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAssessments to fetch.
     */
    orderBy?: PropertyAssessmentOrderByWithRelationInput | PropertyAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyAssessments.
     */
    cursor?: PropertyAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyAssessments.
     */
    distinct?: PropertyAssessmentScalarFieldEnum | PropertyAssessmentScalarFieldEnum[]
  }

  /**
   * PropertyAssessment findMany
   */
  export type PropertyAssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAssessment
     */
    select?: PropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAssessments to fetch.
     */
    where?: PropertyAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAssessments to fetch.
     */
    orderBy?: PropertyAssessmentOrderByWithRelationInput | PropertyAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyAssessments.
     */
    cursor?: PropertyAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAssessments.
     */
    skip?: number
    distinct?: PropertyAssessmentScalarFieldEnum | PropertyAssessmentScalarFieldEnum[]
  }

  /**
   * PropertyAssessment create
   */
  export type PropertyAssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAssessment
     */
    select?: PropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyAssessment.
     */
    data: XOR<PropertyAssessmentCreateInput, PropertyAssessmentUncheckedCreateInput>
  }

  /**
   * PropertyAssessment createMany
   */
  export type PropertyAssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyAssessments.
     */
    data: PropertyAssessmentCreateManyInput | PropertyAssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyAssessment createManyAndReturn
   */
  export type PropertyAssessmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAssessment
     */
    select?: PropertyAssessmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PropertyAssessments.
     */
    data: PropertyAssessmentCreateManyInput | PropertyAssessmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAssessmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyAssessment update
   */
  export type PropertyAssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAssessment
     */
    select?: PropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyAssessment.
     */
    data: XOR<PropertyAssessmentUpdateInput, PropertyAssessmentUncheckedUpdateInput>
    /**
     * Choose, which PropertyAssessment to update.
     */
    where: PropertyAssessmentWhereUniqueInput
  }

  /**
   * PropertyAssessment updateMany
   */
  export type PropertyAssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyAssessments.
     */
    data: XOR<PropertyAssessmentUpdateManyMutationInput, PropertyAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which PropertyAssessments to update
     */
    where?: PropertyAssessmentWhereInput
  }

  /**
   * PropertyAssessment upsert
   */
  export type PropertyAssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAssessment
     */
    select?: PropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAssessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyAssessment to update in case it exists.
     */
    where: PropertyAssessmentWhereUniqueInput
    /**
     * In case the PropertyAssessment found by the `where` argument doesn't exist, create a new PropertyAssessment with this data.
     */
    create: XOR<PropertyAssessmentCreateInput, PropertyAssessmentUncheckedCreateInput>
    /**
     * In case the PropertyAssessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyAssessmentUpdateInput, PropertyAssessmentUncheckedUpdateInput>
  }

  /**
   * PropertyAssessment delete
   */
  export type PropertyAssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAssessment
     */
    select?: PropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAssessmentInclude<ExtArgs> | null
    /**
     * Filter which PropertyAssessment to delete.
     */
    where: PropertyAssessmentWhereUniqueInput
  }

  /**
   * PropertyAssessment deleteMany
   */
  export type PropertyAssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyAssessments to delete
     */
    where?: PropertyAssessmentWhereInput
  }

  /**
   * PropertyAssessment without action
   */
  export type PropertyAssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAssessment
     */
    select?: PropertyAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAssessmentInclude<ExtArgs> | null
  }


  /**
   * Model QCRecord
   */

  export type AggregateQCRecord = {
    _count: QCRecordCountAggregateOutputType | null
    _min: QCRecordMinAggregateOutputType | null
    _max: QCRecordMaxAggregateOutputType | null
  }

  export type QCRecordMinAggregateOutputType = {
    id: string | null
    surveyId: string | null
    qcOfficerId: string | null
    status: string | null
    remarks: string | null
    qcDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QCRecordMaxAggregateOutputType = {
    id: string | null
    surveyId: string | null
    qcOfficerId: string | null
    status: string | null
    remarks: string | null
    qcDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QCRecordCountAggregateOutputType = {
    id: number
    surveyId: number
    qcOfficerId: number
    status: number
    remarks: number
    qcDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QCRecordMinAggregateInputType = {
    id?: true
    surveyId?: true
    qcOfficerId?: true
    status?: true
    remarks?: true
    qcDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QCRecordMaxAggregateInputType = {
    id?: true
    surveyId?: true
    qcOfficerId?: true
    status?: true
    remarks?: true
    qcDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QCRecordCountAggregateInputType = {
    id?: true
    surveyId?: true
    qcOfficerId?: true
    status?: true
    remarks?: true
    qcDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QCRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QCRecord to aggregate.
     */
    where?: QCRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QCRecords to fetch.
     */
    orderBy?: QCRecordOrderByWithRelationInput | QCRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QCRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QCRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QCRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QCRecords
    **/
    _count?: true | QCRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QCRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QCRecordMaxAggregateInputType
  }

  export type GetQCRecordAggregateType<T extends QCRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateQCRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQCRecord[P]>
      : GetScalarType<T[P], AggregateQCRecord[P]>
  }




  export type QCRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QCRecordWhereInput
    orderBy?: QCRecordOrderByWithAggregationInput | QCRecordOrderByWithAggregationInput[]
    by: QCRecordScalarFieldEnum[] | QCRecordScalarFieldEnum
    having?: QCRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QCRecordCountAggregateInputType | true
    _min?: QCRecordMinAggregateInputType
    _max?: QCRecordMaxAggregateInputType
  }

  export type QCRecordGroupByOutputType = {
    id: string
    surveyId: string
    qcOfficerId: string
    status: string
    remarks: string | null
    qcDate: Date
    createdAt: Date
    updatedAt: Date
    _count: QCRecordCountAggregateOutputType | null
    _min: QCRecordMinAggregateOutputType | null
    _max: QCRecordMaxAggregateOutputType | null
  }

  type GetQCRecordGroupByPayload<T extends QCRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QCRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QCRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QCRecordGroupByOutputType[P]>
            : GetScalarType<T[P], QCRecordGroupByOutputType[P]>
        }
      >
    >


  export type QCRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    qcOfficerId?: boolean
    status?: boolean
    remarks?: boolean
    qcDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    qcOfficer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qCRecord"]>

  export type QCRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    qcOfficerId?: boolean
    status?: boolean
    remarks?: boolean
    qcDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    qcOfficer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qCRecord"]>

  export type QCRecordSelectScalar = {
    id?: boolean
    surveyId?: boolean
    qcOfficerId?: boolean
    status?: boolean
    remarks?: boolean
    qcDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QCRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    qcOfficer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QCRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    qcOfficer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QCRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QCRecord"
    objects: {
      survey: Prisma.$SurveyPayload<ExtArgs>
      qcOfficer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      surveyId: string
      qcOfficerId: string
      status: string
      remarks: string | null
      qcDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["qCRecord"]>
    composites: {}
  }

  type QCRecordGetPayload<S extends boolean | null | undefined | QCRecordDefaultArgs> = $Result.GetResult<Prisma.$QCRecordPayload, S>

  type QCRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QCRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QCRecordCountAggregateInputType | true
    }

  export interface QCRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QCRecord'], meta: { name: 'QCRecord' } }
    /**
     * Find zero or one QCRecord that matches the filter.
     * @param {QCRecordFindUniqueArgs} args - Arguments to find a QCRecord
     * @example
     * // Get one QCRecord
     * const qCRecord = await prisma.qCRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QCRecordFindUniqueArgs>(args: SelectSubset<T, QCRecordFindUniqueArgs<ExtArgs>>): Prisma__QCRecordClient<$Result.GetResult<Prisma.$QCRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QCRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QCRecordFindUniqueOrThrowArgs} args - Arguments to find a QCRecord
     * @example
     * // Get one QCRecord
     * const qCRecord = await prisma.qCRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QCRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, QCRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QCRecordClient<$Result.GetResult<Prisma.$QCRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QCRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QCRecordFindFirstArgs} args - Arguments to find a QCRecord
     * @example
     * // Get one QCRecord
     * const qCRecord = await prisma.qCRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QCRecordFindFirstArgs>(args?: SelectSubset<T, QCRecordFindFirstArgs<ExtArgs>>): Prisma__QCRecordClient<$Result.GetResult<Prisma.$QCRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QCRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QCRecordFindFirstOrThrowArgs} args - Arguments to find a QCRecord
     * @example
     * // Get one QCRecord
     * const qCRecord = await prisma.qCRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QCRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, QCRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__QCRecordClient<$Result.GetResult<Prisma.$QCRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QCRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QCRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QCRecords
     * const qCRecords = await prisma.qCRecord.findMany()
     * 
     * // Get first 10 QCRecords
     * const qCRecords = await prisma.qCRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qCRecordWithIdOnly = await prisma.qCRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QCRecordFindManyArgs>(args?: SelectSubset<T, QCRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QCRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QCRecord.
     * @param {QCRecordCreateArgs} args - Arguments to create a QCRecord.
     * @example
     * // Create one QCRecord
     * const QCRecord = await prisma.qCRecord.create({
     *   data: {
     *     // ... data to create a QCRecord
     *   }
     * })
     * 
     */
    create<T extends QCRecordCreateArgs>(args: SelectSubset<T, QCRecordCreateArgs<ExtArgs>>): Prisma__QCRecordClient<$Result.GetResult<Prisma.$QCRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QCRecords.
     * @param {QCRecordCreateManyArgs} args - Arguments to create many QCRecords.
     * @example
     * // Create many QCRecords
     * const qCRecord = await prisma.qCRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QCRecordCreateManyArgs>(args?: SelectSubset<T, QCRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QCRecords and returns the data saved in the database.
     * @param {QCRecordCreateManyAndReturnArgs} args - Arguments to create many QCRecords.
     * @example
     * // Create many QCRecords
     * const qCRecord = await prisma.qCRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QCRecords and only return the `id`
     * const qCRecordWithIdOnly = await prisma.qCRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QCRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, QCRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QCRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QCRecord.
     * @param {QCRecordDeleteArgs} args - Arguments to delete one QCRecord.
     * @example
     * // Delete one QCRecord
     * const QCRecord = await prisma.qCRecord.delete({
     *   where: {
     *     // ... filter to delete one QCRecord
     *   }
     * })
     * 
     */
    delete<T extends QCRecordDeleteArgs>(args: SelectSubset<T, QCRecordDeleteArgs<ExtArgs>>): Prisma__QCRecordClient<$Result.GetResult<Prisma.$QCRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QCRecord.
     * @param {QCRecordUpdateArgs} args - Arguments to update one QCRecord.
     * @example
     * // Update one QCRecord
     * const qCRecord = await prisma.qCRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QCRecordUpdateArgs>(args: SelectSubset<T, QCRecordUpdateArgs<ExtArgs>>): Prisma__QCRecordClient<$Result.GetResult<Prisma.$QCRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QCRecords.
     * @param {QCRecordDeleteManyArgs} args - Arguments to filter QCRecords to delete.
     * @example
     * // Delete a few QCRecords
     * const { count } = await prisma.qCRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QCRecordDeleteManyArgs>(args?: SelectSubset<T, QCRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QCRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QCRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QCRecords
     * const qCRecord = await prisma.qCRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QCRecordUpdateManyArgs>(args: SelectSubset<T, QCRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QCRecord.
     * @param {QCRecordUpsertArgs} args - Arguments to update or create a QCRecord.
     * @example
     * // Update or create a QCRecord
     * const qCRecord = await prisma.qCRecord.upsert({
     *   create: {
     *     // ... data to create a QCRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QCRecord we want to update
     *   }
     * })
     */
    upsert<T extends QCRecordUpsertArgs>(args: SelectSubset<T, QCRecordUpsertArgs<ExtArgs>>): Prisma__QCRecordClient<$Result.GetResult<Prisma.$QCRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QCRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QCRecordCountArgs} args - Arguments to filter QCRecords to count.
     * @example
     * // Count the number of QCRecords
     * const count = await prisma.qCRecord.count({
     *   where: {
     *     // ... the filter for the QCRecords we want to count
     *   }
     * })
    **/
    count<T extends QCRecordCountArgs>(
      args?: Subset<T, QCRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QCRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QCRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QCRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QCRecordAggregateArgs>(args: Subset<T, QCRecordAggregateArgs>): Prisma.PrismaPromise<GetQCRecordAggregateType<T>>

    /**
     * Group by QCRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QCRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QCRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QCRecordGroupByArgs['orderBy'] }
        : { orderBy?: QCRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QCRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQCRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QCRecord model
   */
  readonly fields: QCRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QCRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QCRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDefaultArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    qcOfficer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QCRecord model
   */ 
  interface QCRecordFieldRefs {
    readonly id: FieldRef<"QCRecord", 'String'>
    readonly surveyId: FieldRef<"QCRecord", 'String'>
    readonly qcOfficerId: FieldRef<"QCRecord", 'String'>
    readonly status: FieldRef<"QCRecord", 'String'>
    readonly remarks: FieldRef<"QCRecord", 'String'>
    readonly qcDate: FieldRef<"QCRecord", 'DateTime'>
    readonly createdAt: FieldRef<"QCRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"QCRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QCRecord findUnique
   */
  export type QCRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCRecord
     */
    select?: QCRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCRecordInclude<ExtArgs> | null
    /**
     * Filter, which QCRecord to fetch.
     */
    where: QCRecordWhereUniqueInput
  }

  /**
   * QCRecord findUniqueOrThrow
   */
  export type QCRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCRecord
     */
    select?: QCRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCRecordInclude<ExtArgs> | null
    /**
     * Filter, which QCRecord to fetch.
     */
    where: QCRecordWhereUniqueInput
  }

  /**
   * QCRecord findFirst
   */
  export type QCRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCRecord
     */
    select?: QCRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCRecordInclude<ExtArgs> | null
    /**
     * Filter, which QCRecord to fetch.
     */
    where?: QCRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QCRecords to fetch.
     */
    orderBy?: QCRecordOrderByWithRelationInput | QCRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QCRecords.
     */
    cursor?: QCRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QCRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QCRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QCRecords.
     */
    distinct?: QCRecordScalarFieldEnum | QCRecordScalarFieldEnum[]
  }

  /**
   * QCRecord findFirstOrThrow
   */
  export type QCRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCRecord
     */
    select?: QCRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCRecordInclude<ExtArgs> | null
    /**
     * Filter, which QCRecord to fetch.
     */
    where?: QCRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QCRecords to fetch.
     */
    orderBy?: QCRecordOrderByWithRelationInput | QCRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QCRecords.
     */
    cursor?: QCRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QCRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QCRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QCRecords.
     */
    distinct?: QCRecordScalarFieldEnum | QCRecordScalarFieldEnum[]
  }

  /**
   * QCRecord findMany
   */
  export type QCRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCRecord
     */
    select?: QCRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCRecordInclude<ExtArgs> | null
    /**
     * Filter, which QCRecords to fetch.
     */
    where?: QCRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QCRecords to fetch.
     */
    orderBy?: QCRecordOrderByWithRelationInput | QCRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QCRecords.
     */
    cursor?: QCRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QCRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QCRecords.
     */
    skip?: number
    distinct?: QCRecordScalarFieldEnum | QCRecordScalarFieldEnum[]
  }

  /**
   * QCRecord create
   */
  export type QCRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCRecord
     */
    select?: QCRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a QCRecord.
     */
    data: XOR<QCRecordCreateInput, QCRecordUncheckedCreateInput>
  }

  /**
   * QCRecord createMany
   */
  export type QCRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QCRecords.
     */
    data: QCRecordCreateManyInput | QCRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QCRecord createManyAndReturn
   */
  export type QCRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCRecord
     */
    select?: QCRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QCRecords.
     */
    data: QCRecordCreateManyInput | QCRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QCRecord update
   */
  export type QCRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCRecord
     */
    select?: QCRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a QCRecord.
     */
    data: XOR<QCRecordUpdateInput, QCRecordUncheckedUpdateInput>
    /**
     * Choose, which QCRecord to update.
     */
    where: QCRecordWhereUniqueInput
  }

  /**
   * QCRecord updateMany
   */
  export type QCRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QCRecords.
     */
    data: XOR<QCRecordUpdateManyMutationInput, QCRecordUncheckedUpdateManyInput>
    /**
     * Filter which QCRecords to update
     */
    where?: QCRecordWhereInput
  }

  /**
   * QCRecord upsert
   */
  export type QCRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCRecord
     */
    select?: QCRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the QCRecord to update in case it exists.
     */
    where: QCRecordWhereUniqueInput
    /**
     * In case the QCRecord found by the `where` argument doesn't exist, create a new QCRecord with this data.
     */
    create: XOR<QCRecordCreateInput, QCRecordUncheckedCreateInput>
    /**
     * In case the QCRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QCRecordUpdateInput, QCRecordUncheckedUpdateInput>
  }

  /**
   * QCRecord delete
   */
  export type QCRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCRecord
     */
    select?: QCRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCRecordInclude<ExtArgs> | null
    /**
     * Filter which QCRecord to delete.
     */
    where: QCRecordWhereUniqueInput
  }

  /**
   * QCRecord deleteMany
   */
  export type QCRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QCRecords to delete
     */
    where?: QCRecordWhereInput
  }

  /**
   * QCRecord without action
   */
  export type QCRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCRecord
     */
    select?: QCRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCRecordInclude<ExtArgs> | null
  }


  /**
   * Model PropertyAttachment
   */

  export type AggregatePropertyAttachment = {
    _count: PropertyAttachmentCountAggregateOutputType | null
    _min: PropertyAttachmentMinAggregateOutputType | null
    _max: PropertyAttachmentMaxAggregateOutputType | null
  }

  export type PropertyAttachmentMinAggregateOutputType = {
    id: string | null
    surveyId: string | null
    type: string | null
    url: string | null
    description: string | null
    createdAt: Date | null
  }

  export type PropertyAttachmentMaxAggregateOutputType = {
    id: string | null
    surveyId: string | null
    type: string | null
    url: string | null
    description: string | null
    createdAt: Date | null
  }

  export type PropertyAttachmentCountAggregateOutputType = {
    id: number
    surveyId: number
    type: number
    url: number
    description: number
    createdAt: number
    _all: number
  }


  export type PropertyAttachmentMinAggregateInputType = {
    id?: true
    surveyId?: true
    type?: true
    url?: true
    description?: true
    createdAt?: true
  }

  export type PropertyAttachmentMaxAggregateInputType = {
    id?: true
    surveyId?: true
    type?: true
    url?: true
    description?: true
    createdAt?: true
  }

  export type PropertyAttachmentCountAggregateInputType = {
    id?: true
    surveyId?: true
    type?: true
    url?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type PropertyAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyAttachment to aggregate.
     */
    where?: PropertyAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAttachments to fetch.
     */
    orderBy?: PropertyAttachmentOrderByWithRelationInput | PropertyAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyAttachments
    **/
    _count?: true | PropertyAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyAttachmentMaxAggregateInputType
  }

  export type GetPropertyAttachmentAggregateType<T extends PropertyAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyAttachment[P]>
      : GetScalarType<T[P], AggregatePropertyAttachment[P]>
  }




  export type PropertyAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyAttachmentWhereInput
    orderBy?: PropertyAttachmentOrderByWithAggregationInput | PropertyAttachmentOrderByWithAggregationInput[]
    by: PropertyAttachmentScalarFieldEnum[] | PropertyAttachmentScalarFieldEnum
    having?: PropertyAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyAttachmentCountAggregateInputType | true
    _min?: PropertyAttachmentMinAggregateInputType
    _max?: PropertyAttachmentMaxAggregateInputType
  }

  export type PropertyAttachmentGroupByOutputType = {
    id: string
    surveyId: string
    type: string
    url: string
    description: string | null
    createdAt: Date
    _count: PropertyAttachmentCountAggregateOutputType | null
    _min: PropertyAttachmentMinAggregateOutputType | null
    _max: PropertyAttachmentMaxAggregateOutputType | null
  }

  type GetPropertyAttachmentGroupByPayload<T extends PropertyAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type PropertyAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    type?: boolean
    url?: boolean
    description?: boolean
    createdAt?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyAttachment"]>

  export type PropertyAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    type?: boolean
    url?: boolean
    description?: boolean
    createdAt?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyAttachment"]>

  export type PropertyAttachmentSelectScalar = {
    id?: boolean
    surveyId?: boolean
    type?: boolean
    url?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type PropertyAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
  }
  export type PropertyAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
  }

  export type $PropertyAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyAttachment"
    objects: {
      survey: Prisma.$SurveyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      surveyId: string
      type: string
      url: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["propertyAttachment"]>
    composites: {}
  }

  type PropertyAttachmentGetPayload<S extends boolean | null | undefined | PropertyAttachmentDefaultArgs> = $Result.GetResult<Prisma.$PropertyAttachmentPayload, S>

  type PropertyAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyAttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PropertyAttachmentCountAggregateInputType | true
    }

  export interface PropertyAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyAttachment'], meta: { name: 'PropertyAttachment' } }
    /**
     * Find zero or one PropertyAttachment that matches the filter.
     * @param {PropertyAttachmentFindUniqueArgs} args - Arguments to find a PropertyAttachment
     * @example
     * // Get one PropertyAttachment
     * const propertyAttachment = await prisma.propertyAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyAttachmentFindUniqueArgs>(args: SelectSubset<T, PropertyAttachmentFindUniqueArgs<ExtArgs>>): Prisma__PropertyAttachmentClient<$Result.GetResult<Prisma.$PropertyAttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PropertyAttachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PropertyAttachmentFindUniqueOrThrowArgs} args - Arguments to find a PropertyAttachment
     * @example
     * // Get one PropertyAttachment
     * const propertyAttachment = await prisma.propertyAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyAttachmentClient<$Result.GetResult<Prisma.$PropertyAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PropertyAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAttachmentFindFirstArgs} args - Arguments to find a PropertyAttachment
     * @example
     * // Get one PropertyAttachment
     * const propertyAttachment = await prisma.propertyAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyAttachmentFindFirstArgs>(args?: SelectSubset<T, PropertyAttachmentFindFirstArgs<ExtArgs>>): Prisma__PropertyAttachmentClient<$Result.GetResult<Prisma.$PropertyAttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PropertyAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAttachmentFindFirstOrThrowArgs} args - Arguments to find a PropertyAttachment
     * @example
     * // Get one PropertyAttachment
     * const propertyAttachment = await prisma.propertyAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyAttachmentClient<$Result.GetResult<Prisma.$PropertyAttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PropertyAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyAttachments
     * const propertyAttachments = await prisma.propertyAttachment.findMany()
     * 
     * // Get first 10 PropertyAttachments
     * const propertyAttachments = await prisma.propertyAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyAttachmentWithIdOnly = await prisma.propertyAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyAttachmentFindManyArgs>(args?: SelectSubset<T, PropertyAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PropertyAttachment.
     * @param {PropertyAttachmentCreateArgs} args - Arguments to create a PropertyAttachment.
     * @example
     * // Create one PropertyAttachment
     * const PropertyAttachment = await prisma.propertyAttachment.create({
     *   data: {
     *     // ... data to create a PropertyAttachment
     *   }
     * })
     * 
     */
    create<T extends PropertyAttachmentCreateArgs>(args: SelectSubset<T, PropertyAttachmentCreateArgs<ExtArgs>>): Prisma__PropertyAttachmentClient<$Result.GetResult<Prisma.$PropertyAttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PropertyAttachments.
     * @param {PropertyAttachmentCreateManyArgs} args - Arguments to create many PropertyAttachments.
     * @example
     * // Create many PropertyAttachments
     * const propertyAttachment = await prisma.propertyAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyAttachmentCreateManyArgs>(args?: SelectSubset<T, PropertyAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyAttachments and returns the data saved in the database.
     * @param {PropertyAttachmentCreateManyAndReturnArgs} args - Arguments to create many PropertyAttachments.
     * @example
     * // Create many PropertyAttachments
     * const propertyAttachment = await prisma.propertyAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyAttachments and only return the `id`
     * const propertyAttachmentWithIdOnly = await prisma.propertyAttachment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAttachmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PropertyAttachment.
     * @param {PropertyAttachmentDeleteArgs} args - Arguments to delete one PropertyAttachment.
     * @example
     * // Delete one PropertyAttachment
     * const PropertyAttachment = await prisma.propertyAttachment.delete({
     *   where: {
     *     // ... filter to delete one PropertyAttachment
     *   }
     * })
     * 
     */
    delete<T extends PropertyAttachmentDeleteArgs>(args: SelectSubset<T, PropertyAttachmentDeleteArgs<ExtArgs>>): Prisma__PropertyAttachmentClient<$Result.GetResult<Prisma.$PropertyAttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PropertyAttachment.
     * @param {PropertyAttachmentUpdateArgs} args - Arguments to update one PropertyAttachment.
     * @example
     * // Update one PropertyAttachment
     * const propertyAttachment = await prisma.propertyAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyAttachmentUpdateArgs>(args: SelectSubset<T, PropertyAttachmentUpdateArgs<ExtArgs>>): Prisma__PropertyAttachmentClient<$Result.GetResult<Prisma.$PropertyAttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PropertyAttachments.
     * @param {PropertyAttachmentDeleteManyArgs} args - Arguments to filter PropertyAttachments to delete.
     * @example
     * // Delete a few PropertyAttachments
     * const { count } = await prisma.propertyAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyAttachmentDeleteManyArgs>(args?: SelectSubset<T, PropertyAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyAttachments
     * const propertyAttachment = await prisma.propertyAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyAttachmentUpdateManyArgs>(args: SelectSubset<T, PropertyAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyAttachment.
     * @param {PropertyAttachmentUpsertArgs} args - Arguments to update or create a PropertyAttachment.
     * @example
     * // Update or create a PropertyAttachment
     * const propertyAttachment = await prisma.propertyAttachment.upsert({
     *   create: {
     *     // ... data to create a PropertyAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyAttachment we want to update
     *   }
     * })
     */
    upsert<T extends PropertyAttachmentUpsertArgs>(args: SelectSubset<T, PropertyAttachmentUpsertArgs<ExtArgs>>): Prisma__PropertyAttachmentClient<$Result.GetResult<Prisma.$PropertyAttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PropertyAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAttachmentCountArgs} args - Arguments to filter PropertyAttachments to count.
     * @example
     * // Count the number of PropertyAttachments
     * const count = await prisma.propertyAttachment.count({
     *   where: {
     *     // ... the filter for the PropertyAttachments we want to count
     *   }
     * })
    **/
    count<T extends PropertyAttachmentCountArgs>(
      args?: Subset<T, PropertyAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAttachmentAggregateArgs>(args: Subset<T, PropertyAttachmentAggregateArgs>): Prisma.PrismaPromise<GetPropertyAttachmentAggregateType<T>>

    /**
     * Group by PropertyAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: PropertyAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyAttachment model
   */
  readonly fields: PropertyAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDefaultArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyAttachment model
   */ 
  interface PropertyAttachmentFieldRefs {
    readonly id: FieldRef<"PropertyAttachment", 'String'>
    readonly surveyId: FieldRef<"PropertyAttachment", 'String'>
    readonly type: FieldRef<"PropertyAttachment", 'String'>
    readonly url: FieldRef<"PropertyAttachment", 'String'>
    readonly description: FieldRef<"PropertyAttachment", 'String'>
    readonly createdAt: FieldRef<"PropertyAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyAttachment findUnique
   */
  export type PropertyAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachment
     */
    select?: PropertyAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAttachment to fetch.
     */
    where: PropertyAttachmentWhereUniqueInput
  }

  /**
   * PropertyAttachment findUniqueOrThrow
   */
  export type PropertyAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachment
     */
    select?: PropertyAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAttachment to fetch.
     */
    where: PropertyAttachmentWhereUniqueInput
  }

  /**
   * PropertyAttachment findFirst
   */
  export type PropertyAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachment
     */
    select?: PropertyAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAttachment to fetch.
     */
    where?: PropertyAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAttachments to fetch.
     */
    orderBy?: PropertyAttachmentOrderByWithRelationInput | PropertyAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyAttachments.
     */
    cursor?: PropertyAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyAttachments.
     */
    distinct?: PropertyAttachmentScalarFieldEnum | PropertyAttachmentScalarFieldEnum[]
  }

  /**
   * PropertyAttachment findFirstOrThrow
   */
  export type PropertyAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachment
     */
    select?: PropertyAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAttachment to fetch.
     */
    where?: PropertyAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAttachments to fetch.
     */
    orderBy?: PropertyAttachmentOrderByWithRelationInput | PropertyAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyAttachments.
     */
    cursor?: PropertyAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyAttachments.
     */
    distinct?: PropertyAttachmentScalarFieldEnum | PropertyAttachmentScalarFieldEnum[]
  }

  /**
   * PropertyAttachment findMany
   */
  export type PropertyAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachment
     */
    select?: PropertyAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAttachments to fetch.
     */
    where?: PropertyAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAttachments to fetch.
     */
    orderBy?: PropertyAttachmentOrderByWithRelationInput | PropertyAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyAttachments.
     */
    cursor?: PropertyAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAttachments.
     */
    skip?: number
    distinct?: PropertyAttachmentScalarFieldEnum | PropertyAttachmentScalarFieldEnum[]
  }

  /**
   * PropertyAttachment create
   */
  export type PropertyAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachment
     */
    select?: PropertyAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyAttachment.
     */
    data: XOR<PropertyAttachmentCreateInput, PropertyAttachmentUncheckedCreateInput>
  }

  /**
   * PropertyAttachment createMany
   */
  export type PropertyAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyAttachments.
     */
    data: PropertyAttachmentCreateManyInput | PropertyAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyAttachment createManyAndReturn
   */
  export type PropertyAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachment
     */
    select?: PropertyAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PropertyAttachments.
     */
    data: PropertyAttachmentCreateManyInput | PropertyAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyAttachment update
   */
  export type PropertyAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachment
     */
    select?: PropertyAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyAttachment.
     */
    data: XOR<PropertyAttachmentUpdateInput, PropertyAttachmentUncheckedUpdateInput>
    /**
     * Choose, which PropertyAttachment to update.
     */
    where: PropertyAttachmentWhereUniqueInput
  }

  /**
   * PropertyAttachment updateMany
   */
  export type PropertyAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyAttachments.
     */
    data: XOR<PropertyAttachmentUpdateManyMutationInput, PropertyAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which PropertyAttachments to update
     */
    where?: PropertyAttachmentWhereInput
  }

  /**
   * PropertyAttachment upsert
   */
  export type PropertyAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachment
     */
    select?: PropertyAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyAttachment to update in case it exists.
     */
    where: PropertyAttachmentWhereUniqueInput
    /**
     * In case the PropertyAttachment found by the `where` argument doesn't exist, create a new PropertyAttachment with this data.
     */
    create: XOR<PropertyAttachmentCreateInput, PropertyAttachmentUncheckedCreateInput>
    /**
     * In case the PropertyAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyAttachmentUpdateInput, PropertyAttachmentUncheckedUpdateInput>
  }

  /**
   * PropertyAttachment delete
   */
  export type PropertyAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachment
     */
    select?: PropertyAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentInclude<ExtArgs> | null
    /**
     * Filter which PropertyAttachment to delete.
     */
    where: PropertyAttachmentWhereUniqueInput
  }

  /**
   * PropertyAttachment deleteMany
   */
  export type PropertyAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyAttachments to delete
     */
    where?: PropertyAttachmentWhereInput
  }

  /**
   * PropertyAttachment without action
   */
  export type PropertyAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAttachment
     */
    select?: PropertyAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAttachmentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    role: 'role',
    phoneNumber: 'phoneNumber',
    assignedWards: 'assignedWards',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ULBScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ULBScalarFieldEnum = (typeof ULBScalarFieldEnum)[keyof typeof ULBScalarFieldEnum]


  export const ZoneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    ulbId: 'ulbId'
  };

  export type ZoneScalarFieldEnum = (typeof ZoneScalarFieldEnum)[keyof typeof ZoneScalarFieldEnum]


  export const WardScalarFieldEnum: {
    id: 'id',
    name: 'name',
    zoneId: 'zoneId'
  };

  export type WardScalarFieldEnum = (typeof WardScalarFieldEnum)[keyof typeof WardScalarFieldEnum]


  export const MohallaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    wardId: 'wardId'
  };

  export type MohallaScalarFieldEnum = (typeof MohallaScalarFieldEnum)[keyof typeof MohallaScalarFieldEnum]


  export const PropertyResponseTypeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description'
  };

  export type PropertyResponseTypeScalarFieldEnum = (typeof PropertyResponseTypeScalarFieldEnum)[keyof typeof PropertyResponseTypeScalarFieldEnum]


  export const RoadTypeMappingScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description'
  };

  export type RoadTypeMappingScalarFieldEnum = (typeof RoadTypeMappingScalarFieldEnum)[keyof typeof RoadTypeMappingScalarFieldEnum]


  export const ConstructionTypeMappingScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description'
  };

  export type ConstructionTypeMappingScalarFieldEnum = (typeof ConstructionTypeMappingScalarFieldEnum)[keyof typeof ConstructionTypeMappingScalarFieldEnum]


  export const NRPropCategoryMappingScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description'
  };

  export type NRPropCategoryMappingScalarFieldEnum = (typeof NRPropCategoryMappingScalarFieldEnum)[keyof typeof NRPropCategoryMappingScalarFieldEnum]


  export const NRPropSubCategoryMappingScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    categoryId: 'categoryId'
  };

  export type NRPropSubCategoryMappingScalarFieldEnum = (typeof NRPropSubCategoryMappingScalarFieldEnum)[keyof typeof NRPropSubCategoryMappingScalarFieldEnum]


  export const SurveyScalarFieldEnum: {
    id: 'id',
    surveyorId: 'surveyorId',
    ulbId: 'ulbId',
    zoneId: 'zoneId',
    wardId: 'wardId',
    mohallaId: 'mohallaId',
    dateOfEntry: 'dateOfEntry',
    gisId: 'gisId',
    mapId: 'mapId',
    subGisId: 'subGisId',
    propertyType: 'propertyType',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SurveyScalarFieldEnum = (typeof SurveyScalarFieldEnum)[keyof typeof SurveyScalarFieldEnum]


  export const PropertyDetailsScalarFieldEnum: {
    id: 'id',
    surveyId: 'surveyId',
    responseTypeId: 'responseTypeId',
    houseNumber: 'houseNumber',
    electricityNo: 'electricityNo',
    wardSewerageNo: 'wardSewerageNo',
    respondentName: 'respondentName',
    isRented: 'isRented',
    rentAmount: 'rentAmount',
    tenantName: 'tenantName',
    tenantMobile: 'tenantMobile',
    tenantAadhaar: 'tenantAadhaar'
  };

  export type PropertyDetailsScalarFieldEnum = (typeof PropertyDetailsScalarFieldEnum)[keyof typeof PropertyDetailsScalarFieldEnum]


  export const OwnerDetailsScalarFieldEnum: {
    id: 'id',
    surveyId: 'surveyId',
    ownerName: 'ownerName',
    fatherHusbandName: 'fatherHusbandName',
    mobileNo: 'mobileNo',
    aadhaarNo: 'aadhaarNo',
    email: 'email',
    alternateMobile: 'alternateMobile',
    isNRI: 'isNRI',
    nriAddress: 'nriAddress'
  };

  export type OwnerDetailsScalarFieldEnum = (typeof OwnerDetailsScalarFieldEnum)[keyof typeof OwnerDetailsScalarFieldEnum]


  export const LocationDetailsScalarFieldEnum: {
    id: 'id',
    surveyId: 'surveyId',
    latitude: 'latitude',
    longitude: 'longitude',
    assessmentYear: 'assessmentYear',
    roadTypeId: 'roadTypeId',
    constructionYear: 'constructionYear',
    constructionTypeId: 'constructionTypeId',
    landmark: 'landmark',
    address: 'address',
    newWardNo: 'newWardNo',
    plotArea: 'plotArea',
    builtUpArea: 'builtUpArea'
  };

  export type LocationDetailsScalarFieldEnum = (typeof LocationDetailsScalarFieldEnum)[keyof typeof LocationDetailsScalarFieldEnum]


  export const OtherDetailsScalarFieldEnum: {
    id: 'id',
    surveyId: 'surveyId',
    rainHarvesting: 'rainHarvesting',
    waterSupply: 'waterSupply',
    sewerageLine: 'sewerageLine',
    parkingType: 'parkingType',
    parkingArea: 'parkingArea',
    isCommercial: 'isCommercial',
    commercialArea: 'commercialArea'
  };

  export type OtherDetailsScalarFieldEnum = (typeof OtherDetailsScalarFieldEnum)[keyof typeof OtherDetailsScalarFieldEnum]


  export const FloorDetailsScalarFieldEnum: {
    id: 'id',
    surveyId: 'surveyId',
    floorNo: 'floorNo',
    floorType: 'floorType',
    details: 'details',
    area: 'area',
    usage: 'usage',
    isRented: 'isRented',
    rentAmount: 'rentAmount'
  };

  export type FloorDetailsScalarFieldEnum = (typeof FloorDetailsScalarFieldEnum)[keyof typeof FloorDetailsScalarFieldEnum]


  export const PropertyAssessmentScalarFieldEnum: {
    id: 'id',
    surveyId: 'surveyId',
    categoryId: 'categoryId',
    subCategoryId: 'subCategoryId',
    annualRent: 'annualRent',
    marketValue: 'marketValue',
    assessedValue: 'assessedValue',
    taxAmount: 'taxAmount',
    remarks: 'remarks'
  };

  export type PropertyAssessmentScalarFieldEnum = (typeof PropertyAssessmentScalarFieldEnum)[keyof typeof PropertyAssessmentScalarFieldEnum]


  export const QCRecordScalarFieldEnum: {
    id: 'id',
    surveyId: 'surveyId',
    qcOfficerId: 'qcOfficerId',
    status: 'status',
    remarks: 'remarks',
    qcDate: 'qcDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QCRecordScalarFieldEnum = (typeof QCRecordScalarFieldEnum)[keyof typeof QCRecordScalarFieldEnum]


  export const PropertyAttachmentScalarFieldEnum: {
    id: 'id',
    surveyId: 'surveyId',
    type: 'type',
    url: 'url',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type PropertyAttachmentScalarFieldEnum = (typeof PropertyAttachmentScalarFieldEnum)[keyof typeof PropertyAttachmentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PropertyType'
   */
  export type EnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType'>
    


  /**
   * Reference to a field of type 'PropertyType[]'
   */
  export type ListEnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    phoneNumber?: StringFilter<"User"> | string
    assignedWards?: StringNullableListFilter<"User">
    createdById?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    sessions?: SessionListRelationFilter
    surveys?: SurveyListRelationFilter
    qcRecords?: QCRecordListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phoneNumber?: SortOrder
    assignedWards?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    createdUsers?: UserOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    surveys?: SurveyOrderByRelationAggregateInput
    qcRecords?: QCRecordOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    phoneNumber?: StringFilter<"User"> | string
    assignedWards?: StringNullableListFilter<"User">
    createdById?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    sessions?: SessionListRelationFilter
    surveys?: SurveyListRelationFilter
    qcRecords?: QCRecordListRelationFilter
  }, "id" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phoneNumber?: SortOrder
    assignedWards?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringWithAggregatesFilter<"User"> | string
    assignedWards?: StringNullableListFilter<"User">
    createdById?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type ULBWhereInput = {
    AND?: ULBWhereInput | ULBWhereInput[]
    OR?: ULBWhereInput[]
    NOT?: ULBWhereInput | ULBWhereInput[]
    id?: StringFilter<"ULB"> | string
    name?: StringFilter<"ULB"> | string
    createdAt?: DateTimeFilter<"ULB"> | Date | string
    updatedAt?: DateTimeFilter<"ULB"> | Date | string
    zones?: ZoneListRelationFilter
    surveys?: SurveyListRelationFilter
  }

  export type ULBOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    zones?: ZoneOrderByRelationAggregateInput
    surveys?: SurveyOrderByRelationAggregateInput
  }

  export type ULBWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ULBWhereInput | ULBWhereInput[]
    OR?: ULBWhereInput[]
    NOT?: ULBWhereInput | ULBWhereInput[]
    createdAt?: DateTimeFilter<"ULB"> | Date | string
    updatedAt?: DateTimeFilter<"ULB"> | Date | string
    zones?: ZoneListRelationFilter
    surveys?: SurveyListRelationFilter
  }, "id" | "name">

  export type ULBOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ULBCountOrderByAggregateInput
    _max?: ULBMaxOrderByAggregateInput
    _min?: ULBMinOrderByAggregateInput
  }

  export type ULBScalarWhereWithAggregatesInput = {
    AND?: ULBScalarWhereWithAggregatesInput | ULBScalarWhereWithAggregatesInput[]
    OR?: ULBScalarWhereWithAggregatesInput[]
    NOT?: ULBScalarWhereWithAggregatesInput | ULBScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ULB"> | string
    name?: StringWithAggregatesFilter<"ULB"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ULB"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ULB"> | Date | string
  }

  export type ZoneWhereInput = {
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    id?: StringFilter<"Zone"> | string
    name?: StringFilter<"Zone"> | string
    ulbId?: StringFilter<"Zone"> | string
    ulb?: XOR<ULBRelationFilter, ULBWhereInput>
    wards?: WardListRelationFilter
    surveys?: SurveyListRelationFilter
  }

  export type ZoneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ulbId?: SortOrder
    ulb?: ULBOrderByWithRelationInput
    wards?: WardOrderByRelationAggregateInput
    surveys?: SurveyOrderByRelationAggregateInput
  }

  export type ZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    name?: StringFilter<"Zone"> | string
    ulbId?: StringFilter<"Zone"> | string
    ulb?: XOR<ULBRelationFilter, ULBWhereInput>
    wards?: WardListRelationFilter
    surveys?: SurveyListRelationFilter
  }, "id">

  export type ZoneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    ulbId?: SortOrder
    _count?: ZoneCountOrderByAggregateInput
    _max?: ZoneMaxOrderByAggregateInput
    _min?: ZoneMinOrderByAggregateInput
  }

  export type ZoneScalarWhereWithAggregatesInput = {
    AND?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    OR?: ZoneScalarWhereWithAggregatesInput[]
    NOT?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Zone"> | string
    name?: StringWithAggregatesFilter<"Zone"> | string
    ulbId?: StringWithAggregatesFilter<"Zone"> | string
  }

  export type WardWhereInput = {
    AND?: WardWhereInput | WardWhereInput[]
    OR?: WardWhereInput[]
    NOT?: WardWhereInput | WardWhereInput[]
    id?: StringFilter<"Ward"> | string
    name?: StringFilter<"Ward"> | string
    zoneId?: StringFilter<"Ward"> | string
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    mohallas?: MohallaListRelationFilter
    surveys?: SurveyListRelationFilter
  }

  export type WardOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    zoneId?: SortOrder
    zone?: ZoneOrderByWithRelationInput
    mohallas?: MohallaOrderByRelationAggregateInput
    surveys?: SurveyOrderByRelationAggregateInput
  }

  export type WardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WardWhereInput | WardWhereInput[]
    OR?: WardWhereInput[]
    NOT?: WardWhereInput | WardWhereInput[]
    name?: StringFilter<"Ward"> | string
    zoneId?: StringFilter<"Ward"> | string
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    mohallas?: MohallaListRelationFilter
    surveys?: SurveyListRelationFilter
  }, "id">

  export type WardOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    zoneId?: SortOrder
    _count?: WardCountOrderByAggregateInput
    _max?: WardMaxOrderByAggregateInput
    _min?: WardMinOrderByAggregateInput
  }

  export type WardScalarWhereWithAggregatesInput = {
    AND?: WardScalarWhereWithAggregatesInput | WardScalarWhereWithAggregatesInput[]
    OR?: WardScalarWhereWithAggregatesInput[]
    NOT?: WardScalarWhereWithAggregatesInput | WardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ward"> | string
    name?: StringWithAggregatesFilter<"Ward"> | string
    zoneId?: StringWithAggregatesFilter<"Ward"> | string
  }

  export type MohallaWhereInput = {
    AND?: MohallaWhereInput | MohallaWhereInput[]
    OR?: MohallaWhereInput[]
    NOT?: MohallaWhereInput | MohallaWhereInput[]
    id?: StringFilter<"Mohalla"> | string
    name?: StringFilter<"Mohalla"> | string
    wardId?: StringFilter<"Mohalla"> | string
    ward?: XOR<WardRelationFilter, WardWhereInput>
    surveys?: SurveyListRelationFilter
  }

  export type MohallaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    wardId?: SortOrder
    ward?: WardOrderByWithRelationInput
    surveys?: SurveyOrderByRelationAggregateInput
  }

  export type MohallaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MohallaWhereInput | MohallaWhereInput[]
    OR?: MohallaWhereInput[]
    NOT?: MohallaWhereInput | MohallaWhereInput[]
    name?: StringFilter<"Mohalla"> | string
    wardId?: StringFilter<"Mohalla"> | string
    ward?: XOR<WardRelationFilter, WardWhereInput>
    surveys?: SurveyListRelationFilter
  }, "id">

  export type MohallaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    wardId?: SortOrder
    _count?: MohallaCountOrderByAggregateInput
    _max?: MohallaMaxOrderByAggregateInput
    _min?: MohallaMinOrderByAggregateInput
  }

  export type MohallaScalarWhereWithAggregatesInput = {
    AND?: MohallaScalarWhereWithAggregatesInput | MohallaScalarWhereWithAggregatesInput[]
    OR?: MohallaScalarWhereWithAggregatesInput[]
    NOT?: MohallaScalarWhereWithAggregatesInput | MohallaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Mohalla"> | string
    name?: StringWithAggregatesFilter<"Mohalla"> | string
    wardId?: StringWithAggregatesFilter<"Mohalla"> | string
  }

  export type PropertyResponseTypeWhereInput = {
    AND?: PropertyResponseTypeWhereInput | PropertyResponseTypeWhereInput[]
    OR?: PropertyResponseTypeWhereInput[]
    NOT?: PropertyResponseTypeWhereInput | PropertyResponseTypeWhereInput[]
    id?: StringFilter<"PropertyResponseType"> | string
    code?: StringFilter<"PropertyResponseType"> | string
    description?: StringFilter<"PropertyResponseType"> | string
    surveys?: PropertyDetailsListRelationFilter
  }

  export type PropertyResponseTypeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    surveys?: PropertyDetailsOrderByRelationAggregateInput
  }

  export type PropertyResponseTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PropertyResponseTypeWhereInput | PropertyResponseTypeWhereInput[]
    OR?: PropertyResponseTypeWhereInput[]
    NOT?: PropertyResponseTypeWhereInput | PropertyResponseTypeWhereInput[]
    description?: StringFilter<"PropertyResponseType"> | string
    surveys?: PropertyDetailsListRelationFilter
  }, "id" | "code">

  export type PropertyResponseTypeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    _count?: PropertyResponseTypeCountOrderByAggregateInput
    _max?: PropertyResponseTypeMaxOrderByAggregateInput
    _min?: PropertyResponseTypeMinOrderByAggregateInput
  }

  export type PropertyResponseTypeScalarWhereWithAggregatesInput = {
    AND?: PropertyResponseTypeScalarWhereWithAggregatesInput | PropertyResponseTypeScalarWhereWithAggregatesInput[]
    OR?: PropertyResponseTypeScalarWhereWithAggregatesInput[]
    NOT?: PropertyResponseTypeScalarWhereWithAggregatesInput | PropertyResponseTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyResponseType"> | string
    code?: StringWithAggregatesFilter<"PropertyResponseType"> | string
    description?: StringWithAggregatesFilter<"PropertyResponseType"> | string
  }

  export type RoadTypeMappingWhereInput = {
    AND?: RoadTypeMappingWhereInput | RoadTypeMappingWhereInput[]
    OR?: RoadTypeMappingWhereInput[]
    NOT?: RoadTypeMappingWhereInput | RoadTypeMappingWhereInput[]
    id?: StringFilter<"RoadTypeMapping"> | string
    code?: StringFilter<"RoadTypeMapping"> | string
    description?: StringFilter<"RoadTypeMapping"> | string
    locations?: LocationDetailsListRelationFilter
  }

  export type RoadTypeMappingOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    locations?: LocationDetailsOrderByRelationAggregateInput
  }

  export type RoadTypeMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: RoadTypeMappingWhereInput | RoadTypeMappingWhereInput[]
    OR?: RoadTypeMappingWhereInput[]
    NOT?: RoadTypeMappingWhereInput | RoadTypeMappingWhereInput[]
    description?: StringFilter<"RoadTypeMapping"> | string
    locations?: LocationDetailsListRelationFilter
  }, "id" | "code">

  export type RoadTypeMappingOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    _count?: RoadTypeMappingCountOrderByAggregateInput
    _max?: RoadTypeMappingMaxOrderByAggregateInput
    _min?: RoadTypeMappingMinOrderByAggregateInput
  }

  export type RoadTypeMappingScalarWhereWithAggregatesInput = {
    AND?: RoadTypeMappingScalarWhereWithAggregatesInput | RoadTypeMappingScalarWhereWithAggregatesInput[]
    OR?: RoadTypeMappingScalarWhereWithAggregatesInput[]
    NOT?: RoadTypeMappingScalarWhereWithAggregatesInput | RoadTypeMappingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoadTypeMapping"> | string
    code?: StringWithAggregatesFilter<"RoadTypeMapping"> | string
    description?: StringWithAggregatesFilter<"RoadTypeMapping"> | string
  }

  export type ConstructionTypeMappingWhereInput = {
    AND?: ConstructionTypeMappingWhereInput | ConstructionTypeMappingWhereInput[]
    OR?: ConstructionTypeMappingWhereInput[]
    NOT?: ConstructionTypeMappingWhereInput | ConstructionTypeMappingWhereInput[]
    id?: StringFilter<"ConstructionTypeMapping"> | string
    code?: StringFilter<"ConstructionTypeMapping"> | string
    description?: StringFilter<"ConstructionTypeMapping"> | string
    locations?: LocationDetailsListRelationFilter
  }

  export type ConstructionTypeMappingOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    locations?: LocationDetailsOrderByRelationAggregateInput
  }

  export type ConstructionTypeMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ConstructionTypeMappingWhereInput | ConstructionTypeMappingWhereInput[]
    OR?: ConstructionTypeMappingWhereInput[]
    NOT?: ConstructionTypeMappingWhereInput | ConstructionTypeMappingWhereInput[]
    description?: StringFilter<"ConstructionTypeMapping"> | string
    locations?: LocationDetailsListRelationFilter
  }, "id" | "code">

  export type ConstructionTypeMappingOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    _count?: ConstructionTypeMappingCountOrderByAggregateInput
    _max?: ConstructionTypeMappingMaxOrderByAggregateInput
    _min?: ConstructionTypeMappingMinOrderByAggregateInput
  }

  export type ConstructionTypeMappingScalarWhereWithAggregatesInput = {
    AND?: ConstructionTypeMappingScalarWhereWithAggregatesInput | ConstructionTypeMappingScalarWhereWithAggregatesInput[]
    OR?: ConstructionTypeMappingScalarWhereWithAggregatesInput[]
    NOT?: ConstructionTypeMappingScalarWhereWithAggregatesInput | ConstructionTypeMappingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConstructionTypeMapping"> | string
    code?: StringWithAggregatesFilter<"ConstructionTypeMapping"> | string
    description?: StringWithAggregatesFilter<"ConstructionTypeMapping"> | string
  }

  export type NRPropCategoryMappingWhereInput = {
    AND?: NRPropCategoryMappingWhereInput | NRPropCategoryMappingWhereInput[]
    OR?: NRPropCategoryMappingWhereInput[]
    NOT?: NRPropCategoryMappingWhereInput | NRPropCategoryMappingWhereInput[]
    id?: StringFilter<"NRPropCategoryMapping"> | string
    code?: StringFilter<"NRPropCategoryMapping"> | string
    description?: StringFilter<"NRPropCategoryMapping"> | string
    subCategories?: NRPropSubCategoryMappingListRelationFilter
    assessments?: PropertyAssessmentListRelationFilter
  }

  export type NRPropCategoryMappingOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    subCategories?: NRPropSubCategoryMappingOrderByRelationAggregateInput
    assessments?: PropertyAssessmentOrderByRelationAggregateInput
  }

  export type NRPropCategoryMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: NRPropCategoryMappingWhereInput | NRPropCategoryMappingWhereInput[]
    OR?: NRPropCategoryMappingWhereInput[]
    NOT?: NRPropCategoryMappingWhereInput | NRPropCategoryMappingWhereInput[]
    description?: StringFilter<"NRPropCategoryMapping"> | string
    subCategories?: NRPropSubCategoryMappingListRelationFilter
    assessments?: PropertyAssessmentListRelationFilter
  }, "id" | "code">

  export type NRPropCategoryMappingOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    _count?: NRPropCategoryMappingCountOrderByAggregateInput
    _max?: NRPropCategoryMappingMaxOrderByAggregateInput
    _min?: NRPropCategoryMappingMinOrderByAggregateInput
  }

  export type NRPropCategoryMappingScalarWhereWithAggregatesInput = {
    AND?: NRPropCategoryMappingScalarWhereWithAggregatesInput | NRPropCategoryMappingScalarWhereWithAggregatesInput[]
    OR?: NRPropCategoryMappingScalarWhereWithAggregatesInput[]
    NOT?: NRPropCategoryMappingScalarWhereWithAggregatesInput | NRPropCategoryMappingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NRPropCategoryMapping"> | string
    code?: StringWithAggregatesFilter<"NRPropCategoryMapping"> | string
    description?: StringWithAggregatesFilter<"NRPropCategoryMapping"> | string
  }

  export type NRPropSubCategoryMappingWhereInput = {
    AND?: NRPropSubCategoryMappingWhereInput | NRPropSubCategoryMappingWhereInput[]
    OR?: NRPropSubCategoryMappingWhereInput[]
    NOT?: NRPropSubCategoryMappingWhereInput | NRPropSubCategoryMappingWhereInput[]
    id?: StringFilter<"NRPropSubCategoryMapping"> | string
    code?: StringFilter<"NRPropSubCategoryMapping"> | string
    description?: StringFilter<"NRPropSubCategoryMapping"> | string
    categoryId?: StringFilter<"NRPropSubCategoryMapping"> | string
    category?: XOR<NRPropCategoryMappingRelationFilter, NRPropCategoryMappingWhereInput>
    assessments?: PropertyAssessmentListRelationFilter
  }

  export type NRPropSubCategoryMappingOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    category?: NRPropCategoryMappingOrderByWithRelationInput
    assessments?: PropertyAssessmentOrderByRelationAggregateInput
  }

  export type NRPropSubCategoryMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: NRPropSubCategoryMappingWhereInput | NRPropSubCategoryMappingWhereInput[]
    OR?: NRPropSubCategoryMappingWhereInput[]
    NOT?: NRPropSubCategoryMappingWhereInput | NRPropSubCategoryMappingWhereInput[]
    description?: StringFilter<"NRPropSubCategoryMapping"> | string
    categoryId?: StringFilter<"NRPropSubCategoryMapping"> | string
    category?: XOR<NRPropCategoryMappingRelationFilter, NRPropCategoryMappingWhereInput>
    assessments?: PropertyAssessmentListRelationFilter
  }, "id" | "code">

  export type NRPropSubCategoryMappingOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    _count?: NRPropSubCategoryMappingCountOrderByAggregateInput
    _max?: NRPropSubCategoryMappingMaxOrderByAggregateInput
    _min?: NRPropSubCategoryMappingMinOrderByAggregateInput
  }

  export type NRPropSubCategoryMappingScalarWhereWithAggregatesInput = {
    AND?: NRPropSubCategoryMappingScalarWhereWithAggregatesInput | NRPropSubCategoryMappingScalarWhereWithAggregatesInput[]
    OR?: NRPropSubCategoryMappingScalarWhereWithAggregatesInput[]
    NOT?: NRPropSubCategoryMappingScalarWhereWithAggregatesInput | NRPropSubCategoryMappingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NRPropSubCategoryMapping"> | string
    code?: StringWithAggregatesFilter<"NRPropSubCategoryMapping"> | string
    description?: StringWithAggregatesFilter<"NRPropSubCategoryMapping"> | string
    categoryId?: StringWithAggregatesFilter<"NRPropSubCategoryMapping"> | string
  }

  export type SurveyWhereInput = {
    AND?: SurveyWhereInput | SurveyWhereInput[]
    OR?: SurveyWhereInput[]
    NOT?: SurveyWhereInput | SurveyWhereInput[]
    id?: StringFilter<"Survey"> | string
    surveyorId?: StringFilter<"Survey"> | string
    ulbId?: StringFilter<"Survey"> | string
    zoneId?: StringFilter<"Survey"> | string
    wardId?: StringFilter<"Survey"> | string
    mohallaId?: StringFilter<"Survey"> | string
    dateOfEntry?: DateTimeFilter<"Survey"> | Date | string
    gisId?: StringFilter<"Survey"> | string
    mapId?: StringFilter<"Survey"> | string
    subGisId?: StringFilter<"Survey"> | string
    propertyType?: EnumPropertyTypeFilter<"Survey"> | $Enums.PropertyType
    status?: StringFilter<"Survey"> | string
    createdAt?: DateTimeFilter<"Survey"> | Date | string
    updatedAt?: DateTimeFilter<"Survey"> | Date | string
    surveyor?: XOR<UserRelationFilter, UserWhereInput>
    ulb?: XOR<ULBRelationFilter, ULBWhereInput>
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    ward?: XOR<WardRelationFilter, WardWhereInput>
    mohalla?: XOR<MohallaRelationFilter, MohallaWhereInput>
    property?: XOR<PropertyDetailsNullableRelationFilter, PropertyDetailsWhereInput> | null
    owner?: XOR<OwnerDetailsNullableRelationFilter, OwnerDetailsWhereInput> | null
    location?: XOR<LocationDetailsNullableRelationFilter, LocationDetailsWhereInput> | null
    other?: XOR<OtherDetailsNullableRelationFilter, OtherDetailsWhereInput> | null
    floors?: FloorDetailsListRelationFilter
    assessment?: XOR<PropertyAssessmentNullableRelationFilter, PropertyAssessmentWhereInput> | null
    qcRecord?: XOR<QCRecordNullableRelationFilter, QCRecordWhereInput> | null
    attachments?: PropertyAttachmentListRelationFilter
  }

  export type SurveyOrderByWithRelationInput = {
    id?: SortOrder
    surveyorId?: SortOrder
    ulbId?: SortOrder
    zoneId?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    dateOfEntry?: SortOrder
    gisId?: SortOrder
    mapId?: SortOrder
    subGisId?: SortOrder
    propertyType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    surveyor?: UserOrderByWithRelationInput
    ulb?: ULBOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
    ward?: WardOrderByWithRelationInput
    mohalla?: MohallaOrderByWithRelationInput
    property?: PropertyDetailsOrderByWithRelationInput
    owner?: OwnerDetailsOrderByWithRelationInput
    location?: LocationDetailsOrderByWithRelationInput
    other?: OtherDetailsOrderByWithRelationInput
    floors?: FloorDetailsOrderByRelationAggregateInput
    assessment?: PropertyAssessmentOrderByWithRelationInput
    qcRecord?: QCRecordOrderByWithRelationInput
    attachments?: PropertyAttachmentOrderByRelationAggregateInput
  }

  export type SurveyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SurveyWhereInput | SurveyWhereInput[]
    OR?: SurveyWhereInput[]
    NOT?: SurveyWhereInput | SurveyWhereInput[]
    surveyorId?: StringFilter<"Survey"> | string
    ulbId?: StringFilter<"Survey"> | string
    zoneId?: StringFilter<"Survey"> | string
    wardId?: StringFilter<"Survey"> | string
    mohallaId?: StringFilter<"Survey"> | string
    dateOfEntry?: DateTimeFilter<"Survey"> | Date | string
    gisId?: StringFilter<"Survey"> | string
    mapId?: StringFilter<"Survey"> | string
    subGisId?: StringFilter<"Survey"> | string
    propertyType?: EnumPropertyTypeFilter<"Survey"> | $Enums.PropertyType
    status?: StringFilter<"Survey"> | string
    createdAt?: DateTimeFilter<"Survey"> | Date | string
    updatedAt?: DateTimeFilter<"Survey"> | Date | string
    surveyor?: XOR<UserRelationFilter, UserWhereInput>
    ulb?: XOR<ULBRelationFilter, ULBWhereInput>
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    ward?: XOR<WardRelationFilter, WardWhereInput>
    mohalla?: XOR<MohallaRelationFilter, MohallaWhereInput>
    property?: XOR<PropertyDetailsNullableRelationFilter, PropertyDetailsWhereInput> | null
    owner?: XOR<OwnerDetailsNullableRelationFilter, OwnerDetailsWhereInput> | null
    location?: XOR<LocationDetailsNullableRelationFilter, LocationDetailsWhereInput> | null
    other?: XOR<OtherDetailsNullableRelationFilter, OtherDetailsWhereInput> | null
    floors?: FloorDetailsListRelationFilter
    assessment?: XOR<PropertyAssessmentNullableRelationFilter, PropertyAssessmentWhereInput> | null
    qcRecord?: XOR<QCRecordNullableRelationFilter, QCRecordWhereInput> | null
    attachments?: PropertyAttachmentListRelationFilter
  }, "id">

  export type SurveyOrderByWithAggregationInput = {
    id?: SortOrder
    surveyorId?: SortOrder
    ulbId?: SortOrder
    zoneId?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    dateOfEntry?: SortOrder
    gisId?: SortOrder
    mapId?: SortOrder
    subGisId?: SortOrder
    propertyType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SurveyCountOrderByAggregateInput
    _max?: SurveyMaxOrderByAggregateInput
    _min?: SurveyMinOrderByAggregateInput
  }

  export type SurveyScalarWhereWithAggregatesInput = {
    AND?: SurveyScalarWhereWithAggregatesInput | SurveyScalarWhereWithAggregatesInput[]
    OR?: SurveyScalarWhereWithAggregatesInput[]
    NOT?: SurveyScalarWhereWithAggregatesInput | SurveyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Survey"> | string
    surveyorId?: StringWithAggregatesFilter<"Survey"> | string
    ulbId?: StringWithAggregatesFilter<"Survey"> | string
    zoneId?: StringWithAggregatesFilter<"Survey"> | string
    wardId?: StringWithAggregatesFilter<"Survey"> | string
    mohallaId?: StringWithAggregatesFilter<"Survey"> | string
    dateOfEntry?: DateTimeWithAggregatesFilter<"Survey"> | Date | string
    gisId?: StringWithAggregatesFilter<"Survey"> | string
    mapId?: StringWithAggregatesFilter<"Survey"> | string
    subGisId?: StringWithAggregatesFilter<"Survey"> | string
    propertyType?: EnumPropertyTypeWithAggregatesFilter<"Survey"> | $Enums.PropertyType
    status?: StringWithAggregatesFilter<"Survey"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Survey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Survey"> | Date | string
  }

  export type PropertyDetailsWhereInput = {
    AND?: PropertyDetailsWhereInput | PropertyDetailsWhereInput[]
    OR?: PropertyDetailsWhereInput[]
    NOT?: PropertyDetailsWhereInput | PropertyDetailsWhereInput[]
    id?: StringFilter<"PropertyDetails"> | string
    surveyId?: StringFilter<"PropertyDetails"> | string
    responseTypeId?: StringFilter<"PropertyDetails"> | string
    houseNumber?: StringFilter<"PropertyDetails"> | string
    electricityNo?: StringFilter<"PropertyDetails"> | string
    wardSewerageNo?: StringFilter<"PropertyDetails"> | string
    respondentName?: StringFilter<"PropertyDetails"> | string
    isRented?: BoolFilter<"PropertyDetails"> | boolean
    rentAmount?: FloatNullableFilter<"PropertyDetails"> | number | null
    tenantName?: StringNullableFilter<"PropertyDetails"> | string | null
    tenantMobile?: StringNullableFilter<"PropertyDetails"> | string | null
    tenantAadhaar?: StringNullableFilter<"PropertyDetails"> | string | null
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
    responseType?: XOR<PropertyResponseTypeRelationFilter, PropertyResponseTypeWhereInput>
  }

  export type PropertyDetailsOrderByWithRelationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    responseTypeId?: SortOrder
    houseNumber?: SortOrder
    electricityNo?: SortOrder
    wardSewerageNo?: SortOrder
    respondentName?: SortOrder
    isRented?: SortOrder
    rentAmount?: SortOrderInput | SortOrder
    tenantName?: SortOrderInput | SortOrder
    tenantMobile?: SortOrderInput | SortOrder
    tenantAadhaar?: SortOrderInput | SortOrder
    survey?: SurveyOrderByWithRelationInput
    responseType?: PropertyResponseTypeOrderByWithRelationInput
  }

  export type PropertyDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    surveyId?: string
    AND?: PropertyDetailsWhereInput | PropertyDetailsWhereInput[]
    OR?: PropertyDetailsWhereInput[]
    NOT?: PropertyDetailsWhereInput | PropertyDetailsWhereInput[]
    responseTypeId?: StringFilter<"PropertyDetails"> | string
    houseNumber?: StringFilter<"PropertyDetails"> | string
    electricityNo?: StringFilter<"PropertyDetails"> | string
    wardSewerageNo?: StringFilter<"PropertyDetails"> | string
    respondentName?: StringFilter<"PropertyDetails"> | string
    isRented?: BoolFilter<"PropertyDetails"> | boolean
    rentAmount?: FloatNullableFilter<"PropertyDetails"> | number | null
    tenantName?: StringNullableFilter<"PropertyDetails"> | string | null
    tenantMobile?: StringNullableFilter<"PropertyDetails"> | string | null
    tenantAadhaar?: StringNullableFilter<"PropertyDetails"> | string | null
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
    responseType?: XOR<PropertyResponseTypeRelationFilter, PropertyResponseTypeWhereInput>
  }, "id" | "surveyId">

  export type PropertyDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    responseTypeId?: SortOrder
    houseNumber?: SortOrder
    electricityNo?: SortOrder
    wardSewerageNo?: SortOrder
    respondentName?: SortOrder
    isRented?: SortOrder
    rentAmount?: SortOrderInput | SortOrder
    tenantName?: SortOrderInput | SortOrder
    tenantMobile?: SortOrderInput | SortOrder
    tenantAadhaar?: SortOrderInput | SortOrder
    _count?: PropertyDetailsCountOrderByAggregateInput
    _avg?: PropertyDetailsAvgOrderByAggregateInput
    _max?: PropertyDetailsMaxOrderByAggregateInput
    _min?: PropertyDetailsMinOrderByAggregateInput
    _sum?: PropertyDetailsSumOrderByAggregateInput
  }

  export type PropertyDetailsScalarWhereWithAggregatesInput = {
    AND?: PropertyDetailsScalarWhereWithAggregatesInput | PropertyDetailsScalarWhereWithAggregatesInput[]
    OR?: PropertyDetailsScalarWhereWithAggregatesInput[]
    NOT?: PropertyDetailsScalarWhereWithAggregatesInput | PropertyDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyDetails"> | string
    surveyId?: StringWithAggregatesFilter<"PropertyDetails"> | string
    responseTypeId?: StringWithAggregatesFilter<"PropertyDetails"> | string
    houseNumber?: StringWithAggregatesFilter<"PropertyDetails"> | string
    electricityNo?: StringWithAggregatesFilter<"PropertyDetails"> | string
    wardSewerageNo?: StringWithAggregatesFilter<"PropertyDetails"> | string
    respondentName?: StringWithAggregatesFilter<"PropertyDetails"> | string
    isRented?: BoolWithAggregatesFilter<"PropertyDetails"> | boolean
    rentAmount?: FloatNullableWithAggregatesFilter<"PropertyDetails"> | number | null
    tenantName?: StringNullableWithAggregatesFilter<"PropertyDetails"> | string | null
    tenantMobile?: StringNullableWithAggregatesFilter<"PropertyDetails"> | string | null
    tenantAadhaar?: StringNullableWithAggregatesFilter<"PropertyDetails"> | string | null
  }

  export type OwnerDetailsWhereInput = {
    AND?: OwnerDetailsWhereInput | OwnerDetailsWhereInput[]
    OR?: OwnerDetailsWhereInput[]
    NOT?: OwnerDetailsWhereInput | OwnerDetailsWhereInput[]
    id?: StringFilter<"OwnerDetails"> | string
    surveyId?: StringFilter<"OwnerDetails"> | string
    ownerName?: StringFilter<"OwnerDetails"> | string
    fatherHusbandName?: StringFilter<"OwnerDetails"> | string
    mobileNo?: StringFilter<"OwnerDetails"> | string
    aadhaarNo?: StringFilter<"OwnerDetails"> | string
    email?: StringNullableFilter<"OwnerDetails"> | string | null
    alternateMobile?: StringNullableFilter<"OwnerDetails"> | string | null
    isNRI?: BoolFilter<"OwnerDetails"> | boolean
    nriAddress?: StringNullableFilter<"OwnerDetails"> | string | null
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
  }

  export type OwnerDetailsOrderByWithRelationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    ownerName?: SortOrder
    fatherHusbandName?: SortOrder
    mobileNo?: SortOrder
    aadhaarNo?: SortOrder
    email?: SortOrderInput | SortOrder
    alternateMobile?: SortOrderInput | SortOrder
    isNRI?: SortOrder
    nriAddress?: SortOrderInput | SortOrder
    survey?: SurveyOrderByWithRelationInput
  }

  export type OwnerDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    surveyId?: string
    AND?: OwnerDetailsWhereInput | OwnerDetailsWhereInput[]
    OR?: OwnerDetailsWhereInput[]
    NOT?: OwnerDetailsWhereInput | OwnerDetailsWhereInput[]
    ownerName?: StringFilter<"OwnerDetails"> | string
    fatherHusbandName?: StringFilter<"OwnerDetails"> | string
    mobileNo?: StringFilter<"OwnerDetails"> | string
    aadhaarNo?: StringFilter<"OwnerDetails"> | string
    email?: StringNullableFilter<"OwnerDetails"> | string | null
    alternateMobile?: StringNullableFilter<"OwnerDetails"> | string | null
    isNRI?: BoolFilter<"OwnerDetails"> | boolean
    nriAddress?: StringNullableFilter<"OwnerDetails"> | string | null
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
  }, "id" | "surveyId">

  export type OwnerDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    ownerName?: SortOrder
    fatherHusbandName?: SortOrder
    mobileNo?: SortOrder
    aadhaarNo?: SortOrder
    email?: SortOrderInput | SortOrder
    alternateMobile?: SortOrderInput | SortOrder
    isNRI?: SortOrder
    nriAddress?: SortOrderInput | SortOrder
    _count?: OwnerDetailsCountOrderByAggregateInput
    _max?: OwnerDetailsMaxOrderByAggregateInput
    _min?: OwnerDetailsMinOrderByAggregateInput
  }

  export type OwnerDetailsScalarWhereWithAggregatesInput = {
    AND?: OwnerDetailsScalarWhereWithAggregatesInput | OwnerDetailsScalarWhereWithAggregatesInput[]
    OR?: OwnerDetailsScalarWhereWithAggregatesInput[]
    NOT?: OwnerDetailsScalarWhereWithAggregatesInput | OwnerDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OwnerDetails"> | string
    surveyId?: StringWithAggregatesFilter<"OwnerDetails"> | string
    ownerName?: StringWithAggregatesFilter<"OwnerDetails"> | string
    fatherHusbandName?: StringWithAggregatesFilter<"OwnerDetails"> | string
    mobileNo?: StringWithAggregatesFilter<"OwnerDetails"> | string
    aadhaarNo?: StringWithAggregatesFilter<"OwnerDetails"> | string
    email?: StringNullableWithAggregatesFilter<"OwnerDetails"> | string | null
    alternateMobile?: StringNullableWithAggregatesFilter<"OwnerDetails"> | string | null
    isNRI?: BoolWithAggregatesFilter<"OwnerDetails"> | boolean
    nriAddress?: StringNullableWithAggregatesFilter<"OwnerDetails"> | string | null
  }

  export type LocationDetailsWhereInput = {
    AND?: LocationDetailsWhereInput | LocationDetailsWhereInput[]
    OR?: LocationDetailsWhereInput[]
    NOT?: LocationDetailsWhereInput | LocationDetailsWhereInput[]
    id?: StringFilter<"LocationDetails"> | string
    surveyId?: StringFilter<"LocationDetails"> | string
    latitude?: FloatFilter<"LocationDetails"> | number
    longitude?: FloatFilter<"LocationDetails"> | number
    assessmentYear?: StringFilter<"LocationDetails"> | string
    roadTypeId?: StringFilter<"LocationDetails"> | string
    constructionYear?: StringFilter<"LocationDetails"> | string
    constructionTypeId?: StringFilter<"LocationDetails"> | string
    landmark?: StringFilter<"LocationDetails"> | string
    address?: StringFilter<"LocationDetails"> | string
    newWardNo?: StringFilter<"LocationDetails"> | string
    plotArea?: FloatFilter<"LocationDetails"> | number
    builtUpArea?: FloatFilter<"LocationDetails"> | number
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
    roadType?: XOR<RoadTypeMappingRelationFilter, RoadTypeMappingWhereInput>
    constructionType?: XOR<ConstructionTypeMappingRelationFilter, ConstructionTypeMappingWhereInput>
  }

  export type LocationDetailsOrderByWithRelationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    assessmentYear?: SortOrder
    roadTypeId?: SortOrder
    constructionYear?: SortOrder
    constructionTypeId?: SortOrder
    landmark?: SortOrder
    address?: SortOrder
    newWardNo?: SortOrder
    plotArea?: SortOrder
    builtUpArea?: SortOrder
    survey?: SurveyOrderByWithRelationInput
    roadType?: RoadTypeMappingOrderByWithRelationInput
    constructionType?: ConstructionTypeMappingOrderByWithRelationInput
  }

  export type LocationDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    surveyId?: string
    AND?: LocationDetailsWhereInput | LocationDetailsWhereInput[]
    OR?: LocationDetailsWhereInput[]
    NOT?: LocationDetailsWhereInput | LocationDetailsWhereInput[]
    latitude?: FloatFilter<"LocationDetails"> | number
    longitude?: FloatFilter<"LocationDetails"> | number
    assessmentYear?: StringFilter<"LocationDetails"> | string
    roadTypeId?: StringFilter<"LocationDetails"> | string
    constructionYear?: StringFilter<"LocationDetails"> | string
    constructionTypeId?: StringFilter<"LocationDetails"> | string
    landmark?: StringFilter<"LocationDetails"> | string
    address?: StringFilter<"LocationDetails"> | string
    newWardNo?: StringFilter<"LocationDetails"> | string
    plotArea?: FloatFilter<"LocationDetails"> | number
    builtUpArea?: FloatFilter<"LocationDetails"> | number
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
    roadType?: XOR<RoadTypeMappingRelationFilter, RoadTypeMappingWhereInput>
    constructionType?: XOR<ConstructionTypeMappingRelationFilter, ConstructionTypeMappingWhereInput>
  }, "id" | "surveyId">

  export type LocationDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    assessmentYear?: SortOrder
    roadTypeId?: SortOrder
    constructionYear?: SortOrder
    constructionTypeId?: SortOrder
    landmark?: SortOrder
    address?: SortOrder
    newWardNo?: SortOrder
    plotArea?: SortOrder
    builtUpArea?: SortOrder
    _count?: LocationDetailsCountOrderByAggregateInput
    _avg?: LocationDetailsAvgOrderByAggregateInput
    _max?: LocationDetailsMaxOrderByAggregateInput
    _min?: LocationDetailsMinOrderByAggregateInput
    _sum?: LocationDetailsSumOrderByAggregateInput
  }

  export type LocationDetailsScalarWhereWithAggregatesInput = {
    AND?: LocationDetailsScalarWhereWithAggregatesInput | LocationDetailsScalarWhereWithAggregatesInput[]
    OR?: LocationDetailsScalarWhereWithAggregatesInput[]
    NOT?: LocationDetailsScalarWhereWithAggregatesInput | LocationDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LocationDetails"> | string
    surveyId?: StringWithAggregatesFilter<"LocationDetails"> | string
    latitude?: FloatWithAggregatesFilter<"LocationDetails"> | number
    longitude?: FloatWithAggregatesFilter<"LocationDetails"> | number
    assessmentYear?: StringWithAggregatesFilter<"LocationDetails"> | string
    roadTypeId?: StringWithAggregatesFilter<"LocationDetails"> | string
    constructionYear?: StringWithAggregatesFilter<"LocationDetails"> | string
    constructionTypeId?: StringWithAggregatesFilter<"LocationDetails"> | string
    landmark?: StringWithAggregatesFilter<"LocationDetails"> | string
    address?: StringWithAggregatesFilter<"LocationDetails"> | string
    newWardNo?: StringWithAggregatesFilter<"LocationDetails"> | string
    plotArea?: FloatWithAggregatesFilter<"LocationDetails"> | number
    builtUpArea?: FloatWithAggregatesFilter<"LocationDetails"> | number
  }

  export type OtherDetailsWhereInput = {
    AND?: OtherDetailsWhereInput | OtherDetailsWhereInput[]
    OR?: OtherDetailsWhereInput[]
    NOT?: OtherDetailsWhereInput | OtherDetailsWhereInput[]
    id?: StringFilter<"OtherDetails"> | string
    surveyId?: StringFilter<"OtherDetails"> | string
    rainHarvesting?: BoolFilter<"OtherDetails"> | boolean
    waterSupply?: StringFilter<"OtherDetails"> | string
    sewerageLine?: StringFilter<"OtherDetails"> | string
    parkingType?: StringFilter<"OtherDetails"> | string
    parkingArea?: FloatNullableFilter<"OtherDetails"> | number | null
    isCommercial?: BoolFilter<"OtherDetails"> | boolean
    commercialArea?: FloatNullableFilter<"OtherDetails"> | number | null
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
  }

  export type OtherDetailsOrderByWithRelationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    rainHarvesting?: SortOrder
    waterSupply?: SortOrder
    sewerageLine?: SortOrder
    parkingType?: SortOrder
    parkingArea?: SortOrderInput | SortOrder
    isCommercial?: SortOrder
    commercialArea?: SortOrderInput | SortOrder
    survey?: SurveyOrderByWithRelationInput
  }

  export type OtherDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    surveyId?: string
    AND?: OtherDetailsWhereInput | OtherDetailsWhereInput[]
    OR?: OtherDetailsWhereInput[]
    NOT?: OtherDetailsWhereInput | OtherDetailsWhereInput[]
    rainHarvesting?: BoolFilter<"OtherDetails"> | boolean
    waterSupply?: StringFilter<"OtherDetails"> | string
    sewerageLine?: StringFilter<"OtherDetails"> | string
    parkingType?: StringFilter<"OtherDetails"> | string
    parkingArea?: FloatNullableFilter<"OtherDetails"> | number | null
    isCommercial?: BoolFilter<"OtherDetails"> | boolean
    commercialArea?: FloatNullableFilter<"OtherDetails"> | number | null
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
  }, "id" | "surveyId">

  export type OtherDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    rainHarvesting?: SortOrder
    waterSupply?: SortOrder
    sewerageLine?: SortOrder
    parkingType?: SortOrder
    parkingArea?: SortOrderInput | SortOrder
    isCommercial?: SortOrder
    commercialArea?: SortOrderInput | SortOrder
    _count?: OtherDetailsCountOrderByAggregateInput
    _avg?: OtherDetailsAvgOrderByAggregateInput
    _max?: OtherDetailsMaxOrderByAggregateInput
    _min?: OtherDetailsMinOrderByAggregateInput
    _sum?: OtherDetailsSumOrderByAggregateInput
  }

  export type OtherDetailsScalarWhereWithAggregatesInput = {
    AND?: OtherDetailsScalarWhereWithAggregatesInput | OtherDetailsScalarWhereWithAggregatesInput[]
    OR?: OtherDetailsScalarWhereWithAggregatesInput[]
    NOT?: OtherDetailsScalarWhereWithAggregatesInput | OtherDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OtherDetails"> | string
    surveyId?: StringWithAggregatesFilter<"OtherDetails"> | string
    rainHarvesting?: BoolWithAggregatesFilter<"OtherDetails"> | boolean
    waterSupply?: StringWithAggregatesFilter<"OtherDetails"> | string
    sewerageLine?: StringWithAggregatesFilter<"OtherDetails"> | string
    parkingType?: StringWithAggregatesFilter<"OtherDetails"> | string
    parkingArea?: FloatNullableWithAggregatesFilter<"OtherDetails"> | number | null
    isCommercial?: BoolWithAggregatesFilter<"OtherDetails"> | boolean
    commercialArea?: FloatNullableWithAggregatesFilter<"OtherDetails"> | number | null
  }

  export type FloorDetailsWhereInput = {
    AND?: FloorDetailsWhereInput | FloorDetailsWhereInput[]
    OR?: FloorDetailsWhereInput[]
    NOT?: FloorDetailsWhereInput | FloorDetailsWhereInput[]
    id?: StringFilter<"FloorDetails"> | string
    surveyId?: StringFilter<"FloorDetails"> | string
    floorNo?: IntFilter<"FloorDetails"> | number
    floorType?: StringFilter<"FloorDetails"> | string
    details?: StringFilter<"FloorDetails"> | string
    area?: FloatFilter<"FloorDetails"> | number
    usage?: StringFilter<"FloorDetails"> | string
    isRented?: BoolFilter<"FloorDetails"> | boolean
    rentAmount?: FloatNullableFilter<"FloorDetails"> | number | null
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
  }

  export type FloorDetailsOrderByWithRelationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    floorNo?: SortOrder
    floorType?: SortOrder
    details?: SortOrder
    area?: SortOrder
    usage?: SortOrder
    isRented?: SortOrder
    rentAmount?: SortOrderInput | SortOrder
    survey?: SurveyOrderByWithRelationInput
  }

  export type FloorDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FloorDetailsWhereInput | FloorDetailsWhereInput[]
    OR?: FloorDetailsWhereInput[]
    NOT?: FloorDetailsWhereInput | FloorDetailsWhereInput[]
    surveyId?: StringFilter<"FloorDetails"> | string
    floorNo?: IntFilter<"FloorDetails"> | number
    floorType?: StringFilter<"FloorDetails"> | string
    details?: StringFilter<"FloorDetails"> | string
    area?: FloatFilter<"FloorDetails"> | number
    usage?: StringFilter<"FloorDetails"> | string
    isRented?: BoolFilter<"FloorDetails"> | boolean
    rentAmount?: FloatNullableFilter<"FloorDetails"> | number | null
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
  }, "id">

  export type FloorDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    floorNo?: SortOrder
    floorType?: SortOrder
    details?: SortOrder
    area?: SortOrder
    usage?: SortOrder
    isRented?: SortOrder
    rentAmount?: SortOrderInput | SortOrder
    _count?: FloorDetailsCountOrderByAggregateInput
    _avg?: FloorDetailsAvgOrderByAggregateInput
    _max?: FloorDetailsMaxOrderByAggregateInput
    _min?: FloorDetailsMinOrderByAggregateInput
    _sum?: FloorDetailsSumOrderByAggregateInput
  }

  export type FloorDetailsScalarWhereWithAggregatesInput = {
    AND?: FloorDetailsScalarWhereWithAggregatesInput | FloorDetailsScalarWhereWithAggregatesInput[]
    OR?: FloorDetailsScalarWhereWithAggregatesInput[]
    NOT?: FloorDetailsScalarWhereWithAggregatesInput | FloorDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FloorDetails"> | string
    surveyId?: StringWithAggregatesFilter<"FloorDetails"> | string
    floorNo?: IntWithAggregatesFilter<"FloorDetails"> | number
    floorType?: StringWithAggregatesFilter<"FloorDetails"> | string
    details?: StringWithAggregatesFilter<"FloorDetails"> | string
    area?: FloatWithAggregatesFilter<"FloorDetails"> | number
    usage?: StringWithAggregatesFilter<"FloorDetails"> | string
    isRented?: BoolWithAggregatesFilter<"FloorDetails"> | boolean
    rentAmount?: FloatNullableWithAggregatesFilter<"FloorDetails"> | number | null
  }

  export type PropertyAssessmentWhereInput = {
    AND?: PropertyAssessmentWhereInput | PropertyAssessmentWhereInput[]
    OR?: PropertyAssessmentWhereInput[]
    NOT?: PropertyAssessmentWhereInput | PropertyAssessmentWhereInput[]
    id?: StringFilter<"PropertyAssessment"> | string
    surveyId?: StringFilter<"PropertyAssessment"> | string
    categoryId?: StringFilter<"PropertyAssessment"> | string
    subCategoryId?: StringFilter<"PropertyAssessment"> | string
    annualRent?: FloatFilter<"PropertyAssessment"> | number
    marketValue?: FloatFilter<"PropertyAssessment"> | number
    assessedValue?: FloatFilter<"PropertyAssessment"> | number
    taxAmount?: FloatFilter<"PropertyAssessment"> | number
    remarks?: StringNullableFilter<"PropertyAssessment"> | string | null
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
    category?: XOR<NRPropCategoryMappingRelationFilter, NRPropCategoryMappingWhereInput>
    subCategory?: XOR<NRPropSubCategoryMappingRelationFilter, NRPropSubCategoryMappingWhereInput>
  }

  export type PropertyAssessmentOrderByWithRelationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    categoryId?: SortOrder
    subCategoryId?: SortOrder
    annualRent?: SortOrder
    marketValue?: SortOrder
    assessedValue?: SortOrder
    taxAmount?: SortOrder
    remarks?: SortOrderInput | SortOrder
    survey?: SurveyOrderByWithRelationInput
    category?: NRPropCategoryMappingOrderByWithRelationInput
    subCategory?: NRPropSubCategoryMappingOrderByWithRelationInput
  }

  export type PropertyAssessmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    surveyId?: string
    AND?: PropertyAssessmentWhereInput | PropertyAssessmentWhereInput[]
    OR?: PropertyAssessmentWhereInput[]
    NOT?: PropertyAssessmentWhereInput | PropertyAssessmentWhereInput[]
    categoryId?: StringFilter<"PropertyAssessment"> | string
    subCategoryId?: StringFilter<"PropertyAssessment"> | string
    annualRent?: FloatFilter<"PropertyAssessment"> | number
    marketValue?: FloatFilter<"PropertyAssessment"> | number
    assessedValue?: FloatFilter<"PropertyAssessment"> | number
    taxAmount?: FloatFilter<"PropertyAssessment"> | number
    remarks?: StringNullableFilter<"PropertyAssessment"> | string | null
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
    category?: XOR<NRPropCategoryMappingRelationFilter, NRPropCategoryMappingWhereInput>
    subCategory?: XOR<NRPropSubCategoryMappingRelationFilter, NRPropSubCategoryMappingWhereInput>
  }, "id" | "surveyId">

  export type PropertyAssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    categoryId?: SortOrder
    subCategoryId?: SortOrder
    annualRent?: SortOrder
    marketValue?: SortOrder
    assessedValue?: SortOrder
    taxAmount?: SortOrder
    remarks?: SortOrderInput | SortOrder
    _count?: PropertyAssessmentCountOrderByAggregateInput
    _avg?: PropertyAssessmentAvgOrderByAggregateInput
    _max?: PropertyAssessmentMaxOrderByAggregateInput
    _min?: PropertyAssessmentMinOrderByAggregateInput
    _sum?: PropertyAssessmentSumOrderByAggregateInput
  }

  export type PropertyAssessmentScalarWhereWithAggregatesInput = {
    AND?: PropertyAssessmentScalarWhereWithAggregatesInput | PropertyAssessmentScalarWhereWithAggregatesInput[]
    OR?: PropertyAssessmentScalarWhereWithAggregatesInput[]
    NOT?: PropertyAssessmentScalarWhereWithAggregatesInput | PropertyAssessmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyAssessment"> | string
    surveyId?: StringWithAggregatesFilter<"PropertyAssessment"> | string
    categoryId?: StringWithAggregatesFilter<"PropertyAssessment"> | string
    subCategoryId?: StringWithAggregatesFilter<"PropertyAssessment"> | string
    annualRent?: FloatWithAggregatesFilter<"PropertyAssessment"> | number
    marketValue?: FloatWithAggregatesFilter<"PropertyAssessment"> | number
    assessedValue?: FloatWithAggregatesFilter<"PropertyAssessment"> | number
    taxAmount?: FloatWithAggregatesFilter<"PropertyAssessment"> | number
    remarks?: StringNullableWithAggregatesFilter<"PropertyAssessment"> | string | null
  }

  export type QCRecordWhereInput = {
    AND?: QCRecordWhereInput | QCRecordWhereInput[]
    OR?: QCRecordWhereInput[]
    NOT?: QCRecordWhereInput | QCRecordWhereInput[]
    id?: StringFilter<"QCRecord"> | string
    surveyId?: StringFilter<"QCRecord"> | string
    qcOfficerId?: StringFilter<"QCRecord"> | string
    status?: StringFilter<"QCRecord"> | string
    remarks?: StringNullableFilter<"QCRecord"> | string | null
    qcDate?: DateTimeFilter<"QCRecord"> | Date | string
    createdAt?: DateTimeFilter<"QCRecord"> | Date | string
    updatedAt?: DateTimeFilter<"QCRecord"> | Date | string
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
    qcOfficer?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type QCRecordOrderByWithRelationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    qcOfficerId?: SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    qcDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    survey?: SurveyOrderByWithRelationInput
    qcOfficer?: UserOrderByWithRelationInput
  }

  export type QCRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    surveyId?: string
    AND?: QCRecordWhereInput | QCRecordWhereInput[]
    OR?: QCRecordWhereInput[]
    NOT?: QCRecordWhereInput | QCRecordWhereInput[]
    qcOfficerId?: StringFilter<"QCRecord"> | string
    status?: StringFilter<"QCRecord"> | string
    remarks?: StringNullableFilter<"QCRecord"> | string | null
    qcDate?: DateTimeFilter<"QCRecord"> | Date | string
    createdAt?: DateTimeFilter<"QCRecord"> | Date | string
    updatedAt?: DateTimeFilter<"QCRecord"> | Date | string
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
    qcOfficer?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "surveyId">

  export type QCRecordOrderByWithAggregationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    qcOfficerId?: SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    qcDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QCRecordCountOrderByAggregateInput
    _max?: QCRecordMaxOrderByAggregateInput
    _min?: QCRecordMinOrderByAggregateInput
  }

  export type QCRecordScalarWhereWithAggregatesInput = {
    AND?: QCRecordScalarWhereWithAggregatesInput | QCRecordScalarWhereWithAggregatesInput[]
    OR?: QCRecordScalarWhereWithAggregatesInput[]
    NOT?: QCRecordScalarWhereWithAggregatesInput | QCRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QCRecord"> | string
    surveyId?: StringWithAggregatesFilter<"QCRecord"> | string
    qcOfficerId?: StringWithAggregatesFilter<"QCRecord"> | string
    status?: StringWithAggregatesFilter<"QCRecord"> | string
    remarks?: StringNullableWithAggregatesFilter<"QCRecord"> | string | null
    qcDate?: DateTimeWithAggregatesFilter<"QCRecord"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"QCRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QCRecord"> | Date | string
  }

  export type PropertyAttachmentWhereInput = {
    AND?: PropertyAttachmentWhereInput | PropertyAttachmentWhereInput[]
    OR?: PropertyAttachmentWhereInput[]
    NOT?: PropertyAttachmentWhereInput | PropertyAttachmentWhereInput[]
    id?: StringFilter<"PropertyAttachment"> | string
    surveyId?: StringFilter<"PropertyAttachment"> | string
    type?: StringFilter<"PropertyAttachment"> | string
    url?: StringFilter<"PropertyAttachment"> | string
    description?: StringNullableFilter<"PropertyAttachment"> | string | null
    createdAt?: DateTimeFilter<"PropertyAttachment"> | Date | string
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
  }

  export type PropertyAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    survey?: SurveyOrderByWithRelationInput
  }

  export type PropertyAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyAttachmentWhereInput | PropertyAttachmentWhereInput[]
    OR?: PropertyAttachmentWhereInput[]
    NOT?: PropertyAttachmentWhereInput | PropertyAttachmentWhereInput[]
    surveyId?: StringFilter<"PropertyAttachment"> | string
    type?: StringFilter<"PropertyAttachment"> | string
    url?: StringFilter<"PropertyAttachment"> | string
    description?: StringNullableFilter<"PropertyAttachment"> | string | null
    createdAt?: DateTimeFilter<"PropertyAttachment"> | Date | string
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
  }, "id">

  export type PropertyAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PropertyAttachmentCountOrderByAggregateInput
    _max?: PropertyAttachmentMaxOrderByAggregateInput
    _min?: PropertyAttachmentMinOrderByAggregateInput
  }

  export type PropertyAttachmentScalarWhereWithAggregatesInput = {
    AND?: PropertyAttachmentScalarWhereWithAggregatesInput | PropertyAttachmentScalarWhereWithAggregatesInput[]
    OR?: PropertyAttachmentScalarWhereWithAggregatesInput[]
    NOT?: PropertyAttachmentScalarWhereWithAggregatesInput | PropertyAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyAttachment"> | string
    surveyId?: StringWithAggregatesFilter<"PropertyAttachment"> | string
    type?: StringWithAggregatesFilter<"PropertyAttachment"> | string
    url?: StringWithAggregatesFilter<"PropertyAttachment"> | string
    description?: StringNullableWithAggregatesFilter<"PropertyAttachment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PropertyAttachment"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    password: string
    role: string
    phoneNumber: string
    assignedWards?: UserCreateassignedWardsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    surveys?: SurveyCreateNestedManyWithoutSurveyorInput
    qcRecords?: QCRecordCreateNestedManyWithoutQcOfficerInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    password: string
    role: string
    phoneNumber: string
    assignedWards?: UserCreateassignedWardsInput | string[]
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSurveyorInput
    qcRecords?: QCRecordUncheckedCreateNestedManyWithoutQcOfficerInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    assignedWards?: UserUpdateassignedWardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    surveys?: SurveyUpdateManyWithoutSurveyorNestedInput
    qcRecords?: QCRecordUpdateManyWithoutQcOfficerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    assignedWards?: UserUpdateassignedWardsInput | string[]
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSurveyorNestedInput
    qcRecords?: QCRecordUncheckedUpdateManyWithoutQcOfficerNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    password: string
    role: string
    phoneNumber: string
    assignedWards?: UserCreateassignedWardsInput | string[]
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    assignedWards?: UserUpdateassignedWardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    assignedWards?: UserUpdateassignedWardsInput | string[]
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ULBCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: ZoneCreateNestedManyWithoutUlbInput
    surveys?: SurveyCreateNestedManyWithoutUlbInput
  }

  export type ULBUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: ZoneUncheckedCreateNestedManyWithoutUlbInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutUlbInput
  }

  export type ULBUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: ZoneUpdateManyWithoutUlbNestedInput
    surveys?: SurveyUpdateManyWithoutUlbNestedInput
  }

  export type ULBUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: ZoneUncheckedUpdateManyWithoutUlbNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutUlbNestedInput
  }

  export type ULBCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ULBUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ULBUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneCreateInput = {
    id?: string
    name: string
    ulb: ULBCreateNestedOneWithoutZonesInput
    wards?: WardCreateNestedManyWithoutZoneInput
    surveys?: SurveyCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateInput = {
    id?: string
    name: string
    ulbId: string
    wards?: WardUncheckedCreateNestedManyWithoutZoneInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ulb?: ULBUpdateOneRequiredWithoutZonesNestedInput
    wards?: WardUpdateManyWithoutZoneNestedInput
    surveys?: SurveyUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    wards?: WardUncheckedUpdateManyWithoutZoneNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ZoneCreateManyInput = {
    id?: string
    name: string
    ulbId: string
  }

  export type ZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
  }

  export type WardCreateInput = {
    id?: string
    name: string
    zone: ZoneCreateNestedOneWithoutWardsInput
    mohallas?: MohallaCreateNestedManyWithoutWardInput
    surveys?: SurveyCreateNestedManyWithoutWardInput
  }

  export type WardUncheckedCreateInput = {
    id?: string
    name: string
    zoneId: string
    mohallas?: MohallaUncheckedCreateNestedManyWithoutWardInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    zone?: ZoneUpdateOneRequiredWithoutWardsNestedInput
    mohallas?: MohallaUpdateManyWithoutWardNestedInput
    surveys?: SurveyUpdateManyWithoutWardNestedInput
  }

  export type WardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    mohallas?: MohallaUncheckedUpdateManyWithoutWardNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutWardNestedInput
  }

  export type WardCreateManyInput = {
    id?: string
    name: string
    zoneId: string
  }

  export type WardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
  }

  export type MohallaCreateInput = {
    id?: string
    name: string
    ward: WardCreateNestedOneWithoutMohallasInput
    surveys?: SurveyCreateNestedManyWithoutMohallaInput
  }

  export type MohallaUncheckedCreateInput = {
    id?: string
    name: string
    wardId: string
    surveys?: SurveyUncheckedCreateNestedManyWithoutMohallaInput
  }

  export type MohallaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ward?: WardUpdateOneRequiredWithoutMohallasNestedInput
    surveys?: SurveyUpdateManyWithoutMohallaNestedInput
  }

  export type MohallaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    surveys?: SurveyUncheckedUpdateManyWithoutMohallaNestedInput
  }

  export type MohallaCreateManyInput = {
    id?: string
    name: string
    wardId: string
  }

  export type MohallaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MohallaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyResponseTypeCreateInput = {
    id?: string
    code: string
    description: string
    surveys?: PropertyDetailsCreateNestedManyWithoutResponseTypeInput
  }

  export type PropertyResponseTypeUncheckedCreateInput = {
    id?: string
    code: string
    description: string
    surveys?: PropertyDetailsUncheckedCreateNestedManyWithoutResponseTypeInput
  }

  export type PropertyResponseTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    surveys?: PropertyDetailsUpdateManyWithoutResponseTypeNestedInput
  }

  export type PropertyResponseTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    surveys?: PropertyDetailsUncheckedUpdateManyWithoutResponseTypeNestedInput
  }

  export type PropertyResponseTypeCreateManyInput = {
    id?: string
    code: string
    description: string
  }

  export type PropertyResponseTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyResponseTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RoadTypeMappingCreateInput = {
    id?: string
    code: string
    description: string
    locations?: LocationDetailsCreateNestedManyWithoutRoadTypeInput
  }

  export type RoadTypeMappingUncheckedCreateInput = {
    id?: string
    code: string
    description: string
    locations?: LocationDetailsUncheckedCreateNestedManyWithoutRoadTypeInput
  }

  export type RoadTypeMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    locations?: LocationDetailsUpdateManyWithoutRoadTypeNestedInput
  }

  export type RoadTypeMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    locations?: LocationDetailsUncheckedUpdateManyWithoutRoadTypeNestedInput
  }

  export type RoadTypeMappingCreateManyInput = {
    id?: string
    code: string
    description: string
  }

  export type RoadTypeMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RoadTypeMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ConstructionTypeMappingCreateInput = {
    id?: string
    code: string
    description: string
    locations?: LocationDetailsCreateNestedManyWithoutConstructionTypeInput
  }

  export type ConstructionTypeMappingUncheckedCreateInput = {
    id?: string
    code: string
    description: string
    locations?: LocationDetailsUncheckedCreateNestedManyWithoutConstructionTypeInput
  }

  export type ConstructionTypeMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    locations?: LocationDetailsUpdateManyWithoutConstructionTypeNestedInput
  }

  export type ConstructionTypeMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    locations?: LocationDetailsUncheckedUpdateManyWithoutConstructionTypeNestedInput
  }

  export type ConstructionTypeMappingCreateManyInput = {
    id?: string
    code: string
    description: string
  }

  export type ConstructionTypeMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ConstructionTypeMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type NRPropCategoryMappingCreateInput = {
    id?: string
    code: string
    description: string
    subCategories?: NRPropSubCategoryMappingCreateNestedManyWithoutCategoryInput
    assessments?: PropertyAssessmentCreateNestedManyWithoutCategoryInput
  }

  export type NRPropCategoryMappingUncheckedCreateInput = {
    id?: string
    code: string
    description: string
    subCategories?: NRPropSubCategoryMappingUncheckedCreateNestedManyWithoutCategoryInput
    assessments?: PropertyAssessmentUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type NRPropCategoryMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subCategories?: NRPropSubCategoryMappingUpdateManyWithoutCategoryNestedInput
    assessments?: PropertyAssessmentUpdateManyWithoutCategoryNestedInput
  }

  export type NRPropCategoryMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subCategories?: NRPropSubCategoryMappingUncheckedUpdateManyWithoutCategoryNestedInput
    assessments?: PropertyAssessmentUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type NRPropCategoryMappingCreateManyInput = {
    id?: string
    code: string
    description: string
  }

  export type NRPropCategoryMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type NRPropCategoryMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type NRPropSubCategoryMappingCreateInput = {
    id?: string
    code: string
    description: string
    category: NRPropCategoryMappingCreateNestedOneWithoutSubCategoriesInput
    assessments?: PropertyAssessmentCreateNestedManyWithoutSubCategoryInput
  }

  export type NRPropSubCategoryMappingUncheckedCreateInput = {
    id?: string
    code: string
    description: string
    categoryId: string
    assessments?: PropertyAssessmentUncheckedCreateNestedManyWithoutSubCategoryInput
  }

  export type NRPropSubCategoryMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NRPropCategoryMappingUpdateOneRequiredWithoutSubCategoriesNestedInput
    assessments?: PropertyAssessmentUpdateManyWithoutSubCategoryNestedInput
  }

  export type NRPropSubCategoryMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    assessments?: PropertyAssessmentUncheckedUpdateManyWithoutSubCategoryNestedInput
  }

  export type NRPropSubCategoryMappingCreateManyInput = {
    id?: string
    code: string
    description: string
    categoryId: string
  }

  export type NRPropSubCategoryMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type NRPropSubCategoryMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyCreateInput = {
    id?: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyor: UserCreateNestedOneWithoutSurveysInput
    ulb: ULBCreateNestedOneWithoutSurveysInput
    zone: ZoneCreateNestedOneWithoutSurveysInput
    ward: WardCreateNestedOneWithoutSurveysInput
    mohalla: MohallaCreateNestedOneWithoutSurveysInput
    property?: PropertyDetailsCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateInput = {
    id?: string
    surveyorId: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyDetailsUncheckedCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsUncheckedCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsUncheckedCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsUncheckedCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsUncheckedCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentUncheckedCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordUncheckedCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyor?: UserUpdateOneRequiredWithoutSurveysNestedInput
    ulb?: ULBUpdateOneRequiredWithoutSurveysNestedInput
    zone?: ZoneUpdateOneRequiredWithoutSurveysNestedInput
    ward?: WardUpdateOneRequiredWithoutSurveysNestedInput
    mohalla?: MohallaUpdateOneRequiredWithoutSurveysNestedInput
    property?: PropertyDetailsUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUncheckedUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUncheckedUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyCreateManyInput = {
    id?: string
    surveyorId: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyDetailsCreateInput = {
    id?: string
    houseNumber: string
    electricityNo: string
    wardSewerageNo: string
    respondentName: string
    isRented?: boolean
    rentAmount?: number | null
    tenantName?: string | null
    tenantMobile?: string | null
    tenantAadhaar?: string | null
    survey: SurveyCreateNestedOneWithoutPropertyInput
    responseType: PropertyResponseTypeCreateNestedOneWithoutSurveysInput
  }

  export type PropertyDetailsUncheckedCreateInput = {
    id?: string
    surveyId: string
    responseTypeId: string
    houseNumber: string
    electricityNo: string
    wardSewerageNo: string
    respondentName: string
    isRented?: boolean
    rentAmount?: number | null
    tenantName?: string | null
    tenantMobile?: string | null
    tenantAadhaar?: string | null
  }

  export type PropertyDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    electricityNo?: StringFieldUpdateOperationsInput | string
    wardSewerageNo?: StringFieldUpdateOperationsInput | string
    respondentName?: StringFieldUpdateOperationsInput | string
    isRented?: BoolFieldUpdateOperationsInput | boolean
    rentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantName?: NullableStringFieldUpdateOperationsInput | string | null
    tenantMobile?: NullableStringFieldUpdateOperationsInput | string | null
    tenantAadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    survey?: SurveyUpdateOneRequiredWithoutPropertyNestedInput
    responseType?: PropertyResponseTypeUpdateOneRequiredWithoutSurveysNestedInput
  }

  export type PropertyDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    responseTypeId?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    electricityNo?: StringFieldUpdateOperationsInput | string
    wardSewerageNo?: StringFieldUpdateOperationsInput | string
    respondentName?: StringFieldUpdateOperationsInput | string
    isRented?: BoolFieldUpdateOperationsInput | boolean
    rentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantName?: NullableStringFieldUpdateOperationsInput | string | null
    tenantMobile?: NullableStringFieldUpdateOperationsInput | string | null
    tenantAadhaar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyDetailsCreateManyInput = {
    id?: string
    surveyId: string
    responseTypeId: string
    houseNumber: string
    electricityNo: string
    wardSewerageNo: string
    respondentName: string
    isRented?: boolean
    rentAmount?: number | null
    tenantName?: string | null
    tenantMobile?: string | null
    tenantAadhaar?: string | null
  }

  export type PropertyDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    electricityNo?: StringFieldUpdateOperationsInput | string
    wardSewerageNo?: StringFieldUpdateOperationsInput | string
    respondentName?: StringFieldUpdateOperationsInput | string
    isRented?: BoolFieldUpdateOperationsInput | boolean
    rentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantName?: NullableStringFieldUpdateOperationsInput | string | null
    tenantMobile?: NullableStringFieldUpdateOperationsInput | string | null
    tenantAadhaar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    responseTypeId?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    electricityNo?: StringFieldUpdateOperationsInput | string
    wardSewerageNo?: StringFieldUpdateOperationsInput | string
    respondentName?: StringFieldUpdateOperationsInput | string
    isRented?: BoolFieldUpdateOperationsInput | boolean
    rentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantName?: NullableStringFieldUpdateOperationsInput | string | null
    tenantMobile?: NullableStringFieldUpdateOperationsInput | string | null
    tenantAadhaar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OwnerDetailsCreateInput = {
    id?: string
    ownerName: string
    fatherHusbandName: string
    mobileNo: string
    aadhaarNo: string
    email?: string | null
    alternateMobile?: string | null
    isNRI?: boolean
    nriAddress?: string | null
    survey: SurveyCreateNestedOneWithoutOwnerInput
  }

  export type OwnerDetailsUncheckedCreateInput = {
    id?: string
    surveyId: string
    ownerName: string
    fatherHusbandName: string
    mobileNo: string
    aadhaarNo: string
    email?: string | null
    alternateMobile?: string | null
    isNRI?: boolean
    nriAddress?: string | null
  }

  export type OwnerDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    fatherHusbandName?: StringFieldUpdateOperationsInput | string
    mobileNo?: StringFieldUpdateOperationsInput | string
    aadhaarNo?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    alternateMobile?: NullableStringFieldUpdateOperationsInput | string | null
    isNRI?: BoolFieldUpdateOperationsInput | boolean
    nriAddress?: NullableStringFieldUpdateOperationsInput | string | null
    survey?: SurveyUpdateOneRequiredWithoutOwnerNestedInput
  }

  export type OwnerDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    fatherHusbandName?: StringFieldUpdateOperationsInput | string
    mobileNo?: StringFieldUpdateOperationsInput | string
    aadhaarNo?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    alternateMobile?: NullableStringFieldUpdateOperationsInput | string | null
    isNRI?: BoolFieldUpdateOperationsInput | boolean
    nriAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OwnerDetailsCreateManyInput = {
    id?: string
    surveyId: string
    ownerName: string
    fatherHusbandName: string
    mobileNo: string
    aadhaarNo: string
    email?: string | null
    alternateMobile?: string | null
    isNRI?: boolean
    nriAddress?: string | null
  }

  export type OwnerDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    fatherHusbandName?: StringFieldUpdateOperationsInput | string
    mobileNo?: StringFieldUpdateOperationsInput | string
    aadhaarNo?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    alternateMobile?: NullableStringFieldUpdateOperationsInput | string | null
    isNRI?: BoolFieldUpdateOperationsInput | boolean
    nriAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OwnerDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    fatherHusbandName?: StringFieldUpdateOperationsInput | string
    mobileNo?: StringFieldUpdateOperationsInput | string
    aadhaarNo?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    alternateMobile?: NullableStringFieldUpdateOperationsInput | string | null
    isNRI?: BoolFieldUpdateOperationsInput | boolean
    nriAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationDetailsCreateInput = {
    id?: string
    latitude: number
    longitude: number
    assessmentYear: string
    constructionYear: string
    landmark: string
    address: string
    newWardNo: string
    plotArea: number
    builtUpArea: number
    survey: SurveyCreateNestedOneWithoutLocationInput
    roadType: RoadTypeMappingCreateNestedOneWithoutLocationsInput
    constructionType: ConstructionTypeMappingCreateNestedOneWithoutLocationsInput
  }

  export type LocationDetailsUncheckedCreateInput = {
    id?: string
    surveyId: string
    latitude: number
    longitude: number
    assessmentYear: string
    roadTypeId: string
    constructionYear: string
    constructionTypeId: string
    landmark: string
    address: string
    newWardNo: string
    plotArea: number
    builtUpArea: number
  }

  export type LocationDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    assessmentYear?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    landmark?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    newWardNo?: StringFieldUpdateOperationsInput | string
    plotArea?: FloatFieldUpdateOperationsInput | number
    builtUpArea?: FloatFieldUpdateOperationsInput | number
    survey?: SurveyUpdateOneRequiredWithoutLocationNestedInput
    roadType?: RoadTypeMappingUpdateOneRequiredWithoutLocationsNestedInput
    constructionType?: ConstructionTypeMappingUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type LocationDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    assessmentYear?: StringFieldUpdateOperationsInput | string
    roadTypeId?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    landmark?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    newWardNo?: StringFieldUpdateOperationsInput | string
    plotArea?: FloatFieldUpdateOperationsInput | number
    builtUpArea?: FloatFieldUpdateOperationsInput | number
  }

  export type LocationDetailsCreateManyInput = {
    id?: string
    surveyId: string
    latitude: number
    longitude: number
    assessmentYear: string
    roadTypeId: string
    constructionYear: string
    constructionTypeId: string
    landmark: string
    address: string
    newWardNo: string
    plotArea: number
    builtUpArea: number
  }

  export type LocationDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    assessmentYear?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    landmark?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    newWardNo?: StringFieldUpdateOperationsInput | string
    plotArea?: FloatFieldUpdateOperationsInput | number
    builtUpArea?: FloatFieldUpdateOperationsInput | number
  }

  export type LocationDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    assessmentYear?: StringFieldUpdateOperationsInput | string
    roadTypeId?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    landmark?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    newWardNo?: StringFieldUpdateOperationsInput | string
    plotArea?: FloatFieldUpdateOperationsInput | number
    builtUpArea?: FloatFieldUpdateOperationsInput | number
  }

  export type OtherDetailsCreateInput = {
    id?: string
    rainHarvesting: boolean
    waterSupply: string
    sewerageLine: string
    parkingType: string
    parkingArea?: number | null
    isCommercial?: boolean
    commercialArea?: number | null
    survey: SurveyCreateNestedOneWithoutOtherInput
  }

  export type OtherDetailsUncheckedCreateInput = {
    id?: string
    surveyId: string
    rainHarvesting: boolean
    waterSupply: string
    sewerageLine: string
    parkingType: string
    parkingArea?: number | null
    isCommercial?: boolean
    commercialArea?: number | null
  }

  export type OtherDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHarvesting?: BoolFieldUpdateOperationsInput | boolean
    waterSupply?: StringFieldUpdateOperationsInput | string
    sewerageLine?: StringFieldUpdateOperationsInput | string
    parkingType?: StringFieldUpdateOperationsInput | string
    parkingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    isCommercial?: BoolFieldUpdateOperationsInput | boolean
    commercialArea?: NullableFloatFieldUpdateOperationsInput | number | null
    survey?: SurveyUpdateOneRequiredWithoutOtherNestedInput
  }

  export type OtherDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    rainHarvesting?: BoolFieldUpdateOperationsInput | boolean
    waterSupply?: StringFieldUpdateOperationsInput | string
    sewerageLine?: StringFieldUpdateOperationsInput | string
    parkingType?: StringFieldUpdateOperationsInput | string
    parkingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    isCommercial?: BoolFieldUpdateOperationsInput | boolean
    commercialArea?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OtherDetailsCreateManyInput = {
    id?: string
    surveyId: string
    rainHarvesting: boolean
    waterSupply: string
    sewerageLine: string
    parkingType: string
    parkingArea?: number | null
    isCommercial?: boolean
    commercialArea?: number | null
  }

  export type OtherDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHarvesting?: BoolFieldUpdateOperationsInput | boolean
    waterSupply?: StringFieldUpdateOperationsInput | string
    sewerageLine?: StringFieldUpdateOperationsInput | string
    parkingType?: StringFieldUpdateOperationsInput | string
    parkingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    isCommercial?: BoolFieldUpdateOperationsInput | boolean
    commercialArea?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OtherDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    rainHarvesting?: BoolFieldUpdateOperationsInput | boolean
    waterSupply?: StringFieldUpdateOperationsInput | string
    sewerageLine?: StringFieldUpdateOperationsInput | string
    parkingType?: StringFieldUpdateOperationsInput | string
    parkingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    isCommercial?: BoolFieldUpdateOperationsInput | boolean
    commercialArea?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type FloorDetailsCreateInput = {
    id?: string
    floorNo: number
    floorType: string
    details: string
    area: number
    usage: string
    isRented?: boolean
    rentAmount?: number | null
    survey: SurveyCreateNestedOneWithoutFloorsInput
  }

  export type FloorDetailsUncheckedCreateInput = {
    id?: string
    surveyId: string
    floorNo: number
    floorType: string
    details: string
    area: number
    usage: string
    isRented?: boolean
    rentAmount?: number | null
  }

  export type FloorDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    floorNo?: IntFieldUpdateOperationsInput | number
    floorType?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    usage?: StringFieldUpdateOperationsInput | string
    isRented?: BoolFieldUpdateOperationsInput | boolean
    rentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    survey?: SurveyUpdateOneRequiredWithoutFloorsNestedInput
  }

  export type FloorDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    floorNo?: IntFieldUpdateOperationsInput | number
    floorType?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    usage?: StringFieldUpdateOperationsInput | string
    isRented?: BoolFieldUpdateOperationsInput | boolean
    rentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type FloorDetailsCreateManyInput = {
    id?: string
    surveyId: string
    floorNo: number
    floorType: string
    details: string
    area: number
    usage: string
    isRented?: boolean
    rentAmount?: number | null
  }

  export type FloorDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    floorNo?: IntFieldUpdateOperationsInput | number
    floorType?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    usage?: StringFieldUpdateOperationsInput | string
    isRented?: BoolFieldUpdateOperationsInput | boolean
    rentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type FloorDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    floorNo?: IntFieldUpdateOperationsInput | number
    floorType?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    usage?: StringFieldUpdateOperationsInput | string
    isRented?: BoolFieldUpdateOperationsInput | boolean
    rentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PropertyAssessmentCreateInput = {
    id?: string
    annualRent: number
    marketValue: number
    assessedValue: number
    taxAmount: number
    remarks?: string | null
    survey: SurveyCreateNestedOneWithoutAssessmentInput
    category: NRPropCategoryMappingCreateNestedOneWithoutAssessmentsInput
    subCategory: NRPropSubCategoryMappingCreateNestedOneWithoutAssessmentsInput
  }

  export type PropertyAssessmentUncheckedCreateInput = {
    id?: string
    surveyId: string
    categoryId: string
    subCategoryId: string
    annualRent: number
    marketValue: number
    assessedValue: number
    taxAmount: number
    remarks?: string | null
  }

  export type PropertyAssessmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    annualRent?: FloatFieldUpdateOperationsInput | number
    marketValue?: FloatFieldUpdateOperationsInput | number
    assessedValue?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    survey?: SurveyUpdateOneRequiredWithoutAssessmentNestedInput
    category?: NRPropCategoryMappingUpdateOneRequiredWithoutAssessmentsNestedInput
    subCategory?: NRPropSubCategoryMappingUpdateOneRequiredWithoutAssessmentsNestedInput
  }

  export type PropertyAssessmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: StringFieldUpdateOperationsInput | string
    annualRent?: FloatFieldUpdateOperationsInput | number
    marketValue?: FloatFieldUpdateOperationsInput | number
    assessedValue?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyAssessmentCreateManyInput = {
    id?: string
    surveyId: string
    categoryId: string
    subCategoryId: string
    annualRent: number
    marketValue: number
    assessedValue: number
    taxAmount: number
    remarks?: string | null
  }

  export type PropertyAssessmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    annualRent?: FloatFieldUpdateOperationsInput | number
    marketValue?: FloatFieldUpdateOperationsInput | number
    assessedValue?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyAssessmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: StringFieldUpdateOperationsInput | string
    annualRent?: FloatFieldUpdateOperationsInput | number
    marketValue?: FloatFieldUpdateOperationsInput | number
    assessedValue?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QCRecordCreateInput = {
    id?: string
    status: string
    remarks?: string | null
    qcDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    survey: SurveyCreateNestedOneWithoutQcRecordInput
    qcOfficer: UserCreateNestedOneWithoutQcRecordsInput
  }

  export type QCRecordUncheckedCreateInput = {
    id?: string
    surveyId: string
    qcOfficerId: string
    status: string
    remarks?: string | null
    qcDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QCRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    qcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    survey?: SurveyUpdateOneRequiredWithoutQcRecordNestedInput
    qcOfficer?: UserUpdateOneRequiredWithoutQcRecordsNestedInput
  }

  export type QCRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    qcOfficerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    qcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QCRecordCreateManyInput = {
    id?: string
    surveyId: string
    qcOfficerId: string
    status: string
    remarks?: string | null
    qcDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QCRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    qcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QCRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    qcOfficerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    qcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAttachmentCreateInput = {
    id?: string
    type: string
    url: string
    description?: string | null
    createdAt?: Date | string
    survey: SurveyCreateNestedOneWithoutAttachmentsInput
  }

  export type PropertyAttachmentUncheckedCreateInput = {
    id?: string
    surveyId: string
    type: string
    url: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PropertyAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    survey?: SurveyUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type PropertyAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAttachmentCreateManyInput = {
    id?: string
    surveyId: string
    type: string
    url: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PropertyAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SurveyListRelationFilter = {
    every?: SurveyWhereInput
    some?: SurveyWhereInput
    none?: SurveyWhereInput
  }

  export type QCRecordListRelationFilter = {
    every?: QCRecordWhereInput
    some?: QCRecordWhereInput
    none?: QCRecordWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QCRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phoneNumber?: SortOrder
    assignedWards?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phoneNumber?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phoneNumber?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoneListRelationFilter = {
    every?: ZoneWhereInput
    some?: ZoneWhereInput
    none?: ZoneWhereInput
  }

  export type ZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ULBCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ULBMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ULBMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ULBRelationFilter = {
    is?: ULBWhereInput
    isNot?: ULBWhereInput
  }

  export type WardListRelationFilter = {
    every?: WardWhereInput
    some?: WardWhereInput
    none?: WardWhereInput
  }

  export type WardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZoneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ulbId?: SortOrder
  }

  export type ZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ulbId?: SortOrder
  }

  export type ZoneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ulbId?: SortOrder
  }

  export type ZoneRelationFilter = {
    is?: ZoneWhereInput
    isNot?: ZoneWhereInput
  }

  export type MohallaListRelationFilter = {
    every?: MohallaWhereInput
    some?: MohallaWhereInput
    none?: MohallaWhereInput
  }

  export type MohallaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WardCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    zoneId?: SortOrder
  }

  export type WardMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    zoneId?: SortOrder
  }

  export type WardMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    zoneId?: SortOrder
  }

  export type WardRelationFilter = {
    is?: WardWhereInput
    isNot?: WardWhereInput
  }

  export type MohallaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    wardId?: SortOrder
  }

  export type MohallaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    wardId?: SortOrder
  }

  export type MohallaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    wardId?: SortOrder
  }

  export type PropertyDetailsListRelationFilter = {
    every?: PropertyDetailsWhereInput
    some?: PropertyDetailsWhereInput
    none?: PropertyDetailsWhereInput
  }

  export type PropertyDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyResponseTypeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type PropertyResponseTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type PropertyResponseTypeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type LocationDetailsListRelationFilter = {
    every?: LocationDetailsWhereInput
    some?: LocationDetailsWhereInput
    none?: LocationDetailsWhereInput
  }

  export type LocationDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoadTypeMappingCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type RoadTypeMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type RoadTypeMappingMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type ConstructionTypeMappingCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type ConstructionTypeMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type ConstructionTypeMappingMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type NRPropSubCategoryMappingListRelationFilter = {
    every?: NRPropSubCategoryMappingWhereInput
    some?: NRPropSubCategoryMappingWhereInput
    none?: NRPropSubCategoryMappingWhereInput
  }

  export type PropertyAssessmentListRelationFilter = {
    every?: PropertyAssessmentWhereInput
    some?: PropertyAssessmentWhereInput
    none?: PropertyAssessmentWhereInput
  }

  export type NRPropSubCategoryMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyAssessmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NRPropCategoryMappingCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type NRPropCategoryMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type NRPropCategoryMappingMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type NRPropCategoryMappingRelationFilter = {
    is?: NRPropCategoryMappingWhereInput
    isNot?: NRPropCategoryMappingWhereInput
  }

  export type NRPropSubCategoryMappingCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
  }

  export type NRPropSubCategoryMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
  }

  export type NRPropSubCategoryMappingMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
  }

  export type EnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type MohallaRelationFilter = {
    is?: MohallaWhereInput
    isNot?: MohallaWhereInput
  }

  export type PropertyDetailsNullableRelationFilter = {
    is?: PropertyDetailsWhereInput | null
    isNot?: PropertyDetailsWhereInput | null
  }

  export type OwnerDetailsNullableRelationFilter = {
    is?: OwnerDetailsWhereInput | null
    isNot?: OwnerDetailsWhereInput | null
  }

  export type LocationDetailsNullableRelationFilter = {
    is?: LocationDetailsWhereInput | null
    isNot?: LocationDetailsWhereInput | null
  }

  export type OtherDetailsNullableRelationFilter = {
    is?: OtherDetailsWhereInput | null
    isNot?: OtherDetailsWhereInput | null
  }

  export type FloorDetailsListRelationFilter = {
    every?: FloorDetailsWhereInput
    some?: FloorDetailsWhereInput
    none?: FloorDetailsWhereInput
  }

  export type PropertyAssessmentNullableRelationFilter = {
    is?: PropertyAssessmentWhereInput | null
    isNot?: PropertyAssessmentWhereInput | null
  }

  export type QCRecordNullableRelationFilter = {
    is?: QCRecordWhereInput | null
    isNot?: QCRecordWhereInput | null
  }

  export type PropertyAttachmentListRelationFilter = {
    every?: PropertyAttachmentWhereInput
    some?: PropertyAttachmentWhereInput
    none?: PropertyAttachmentWhereInput
  }

  export type FloorDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyCountOrderByAggregateInput = {
    id?: SortOrder
    surveyorId?: SortOrder
    ulbId?: SortOrder
    zoneId?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    dateOfEntry?: SortOrder
    gisId?: SortOrder
    mapId?: SortOrder
    subGisId?: SortOrder
    propertyType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyMaxOrderByAggregateInput = {
    id?: SortOrder
    surveyorId?: SortOrder
    ulbId?: SortOrder
    zoneId?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    dateOfEntry?: SortOrder
    gisId?: SortOrder
    mapId?: SortOrder
    subGisId?: SortOrder
    propertyType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyMinOrderByAggregateInput = {
    id?: SortOrder
    surveyorId?: SortOrder
    ulbId?: SortOrder
    zoneId?: SortOrder
    wardId?: SortOrder
    mohallaId?: SortOrder
    dateOfEntry?: SortOrder
    gisId?: SortOrder
    mapId?: SortOrder
    subGisId?: SortOrder
    propertyType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type SurveyRelationFilter = {
    is?: SurveyWhereInput
    isNot?: SurveyWhereInput
  }

  export type PropertyResponseTypeRelationFilter = {
    is?: PropertyResponseTypeWhereInput
    isNot?: PropertyResponseTypeWhereInput
  }

  export type PropertyDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    responseTypeId?: SortOrder
    houseNumber?: SortOrder
    electricityNo?: SortOrder
    wardSewerageNo?: SortOrder
    respondentName?: SortOrder
    isRented?: SortOrder
    rentAmount?: SortOrder
    tenantName?: SortOrder
    tenantMobile?: SortOrder
    tenantAadhaar?: SortOrder
  }

  export type PropertyDetailsAvgOrderByAggregateInput = {
    rentAmount?: SortOrder
  }

  export type PropertyDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    responseTypeId?: SortOrder
    houseNumber?: SortOrder
    electricityNo?: SortOrder
    wardSewerageNo?: SortOrder
    respondentName?: SortOrder
    isRented?: SortOrder
    rentAmount?: SortOrder
    tenantName?: SortOrder
    tenantMobile?: SortOrder
    tenantAadhaar?: SortOrder
  }

  export type PropertyDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    responseTypeId?: SortOrder
    houseNumber?: SortOrder
    electricityNo?: SortOrder
    wardSewerageNo?: SortOrder
    respondentName?: SortOrder
    isRented?: SortOrder
    rentAmount?: SortOrder
    tenantName?: SortOrder
    tenantMobile?: SortOrder
    tenantAadhaar?: SortOrder
  }

  export type PropertyDetailsSumOrderByAggregateInput = {
    rentAmount?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type OwnerDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    ownerName?: SortOrder
    fatherHusbandName?: SortOrder
    mobileNo?: SortOrder
    aadhaarNo?: SortOrder
    email?: SortOrder
    alternateMobile?: SortOrder
    isNRI?: SortOrder
    nriAddress?: SortOrder
  }

  export type OwnerDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    ownerName?: SortOrder
    fatherHusbandName?: SortOrder
    mobileNo?: SortOrder
    aadhaarNo?: SortOrder
    email?: SortOrder
    alternateMobile?: SortOrder
    isNRI?: SortOrder
    nriAddress?: SortOrder
  }

  export type OwnerDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    ownerName?: SortOrder
    fatherHusbandName?: SortOrder
    mobileNo?: SortOrder
    aadhaarNo?: SortOrder
    email?: SortOrder
    alternateMobile?: SortOrder
    isNRI?: SortOrder
    nriAddress?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RoadTypeMappingRelationFilter = {
    is?: RoadTypeMappingWhereInput
    isNot?: RoadTypeMappingWhereInput
  }

  export type ConstructionTypeMappingRelationFilter = {
    is?: ConstructionTypeMappingWhereInput
    isNot?: ConstructionTypeMappingWhereInput
  }

  export type LocationDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    assessmentYear?: SortOrder
    roadTypeId?: SortOrder
    constructionYear?: SortOrder
    constructionTypeId?: SortOrder
    landmark?: SortOrder
    address?: SortOrder
    newWardNo?: SortOrder
    plotArea?: SortOrder
    builtUpArea?: SortOrder
  }

  export type LocationDetailsAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    plotArea?: SortOrder
    builtUpArea?: SortOrder
  }

  export type LocationDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    assessmentYear?: SortOrder
    roadTypeId?: SortOrder
    constructionYear?: SortOrder
    constructionTypeId?: SortOrder
    landmark?: SortOrder
    address?: SortOrder
    newWardNo?: SortOrder
    plotArea?: SortOrder
    builtUpArea?: SortOrder
  }

  export type LocationDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    assessmentYear?: SortOrder
    roadTypeId?: SortOrder
    constructionYear?: SortOrder
    constructionTypeId?: SortOrder
    landmark?: SortOrder
    address?: SortOrder
    newWardNo?: SortOrder
    plotArea?: SortOrder
    builtUpArea?: SortOrder
  }

  export type LocationDetailsSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    plotArea?: SortOrder
    builtUpArea?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type OtherDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    rainHarvesting?: SortOrder
    waterSupply?: SortOrder
    sewerageLine?: SortOrder
    parkingType?: SortOrder
    parkingArea?: SortOrder
    isCommercial?: SortOrder
    commercialArea?: SortOrder
  }

  export type OtherDetailsAvgOrderByAggregateInput = {
    parkingArea?: SortOrder
    commercialArea?: SortOrder
  }

  export type OtherDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    rainHarvesting?: SortOrder
    waterSupply?: SortOrder
    sewerageLine?: SortOrder
    parkingType?: SortOrder
    parkingArea?: SortOrder
    isCommercial?: SortOrder
    commercialArea?: SortOrder
  }

  export type OtherDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    rainHarvesting?: SortOrder
    waterSupply?: SortOrder
    sewerageLine?: SortOrder
    parkingType?: SortOrder
    parkingArea?: SortOrder
    isCommercial?: SortOrder
    commercialArea?: SortOrder
  }

  export type OtherDetailsSumOrderByAggregateInput = {
    parkingArea?: SortOrder
    commercialArea?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloorDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    floorNo?: SortOrder
    floorType?: SortOrder
    details?: SortOrder
    area?: SortOrder
    usage?: SortOrder
    isRented?: SortOrder
    rentAmount?: SortOrder
  }

  export type FloorDetailsAvgOrderByAggregateInput = {
    floorNo?: SortOrder
    area?: SortOrder
    rentAmount?: SortOrder
  }

  export type FloorDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    floorNo?: SortOrder
    floorType?: SortOrder
    details?: SortOrder
    area?: SortOrder
    usage?: SortOrder
    isRented?: SortOrder
    rentAmount?: SortOrder
  }

  export type FloorDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    floorNo?: SortOrder
    floorType?: SortOrder
    details?: SortOrder
    area?: SortOrder
    usage?: SortOrder
    isRented?: SortOrder
    rentAmount?: SortOrder
  }

  export type FloorDetailsSumOrderByAggregateInput = {
    floorNo?: SortOrder
    area?: SortOrder
    rentAmount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NRPropSubCategoryMappingRelationFilter = {
    is?: NRPropSubCategoryMappingWhereInput
    isNot?: NRPropSubCategoryMappingWhereInput
  }

  export type PropertyAssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    categoryId?: SortOrder
    subCategoryId?: SortOrder
    annualRent?: SortOrder
    marketValue?: SortOrder
    assessedValue?: SortOrder
    taxAmount?: SortOrder
    remarks?: SortOrder
  }

  export type PropertyAssessmentAvgOrderByAggregateInput = {
    annualRent?: SortOrder
    marketValue?: SortOrder
    assessedValue?: SortOrder
    taxAmount?: SortOrder
  }

  export type PropertyAssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    categoryId?: SortOrder
    subCategoryId?: SortOrder
    annualRent?: SortOrder
    marketValue?: SortOrder
    assessedValue?: SortOrder
    taxAmount?: SortOrder
    remarks?: SortOrder
  }

  export type PropertyAssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    categoryId?: SortOrder
    subCategoryId?: SortOrder
    annualRent?: SortOrder
    marketValue?: SortOrder
    assessedValue?: SortOrder
    taxAmount?: SortOrder
    remarks?: SortOrder
  }

  export type PropertyAssessmentSumOrderByAggregateInput = {
    annualRent?: SortOrder
    marketValue?: SortOrder
    assessedValue?: SortOrder
    taxAmount?: SortOrder
  }

  export type QCRecordCountOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    qcOfficerId?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    qcDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QCRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    qcOfficerId?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    qcDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QCRecordMinOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    qcOfficerId?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    qcDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type UserCreateassignedWardsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCreatedUsersInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SurveyCreateNestedManyWithoutSurveyorInput = {
    create?: XOR<SurveyCreateWithoutSurveyorInput, SurveyUncheckedCreateWithoutSurveyorInput> | SurveyCreateWithoutSurveyorInput[] | SurveyUncheckedCreateWithoutSurveyorInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutSurveyorInput | SurveyCreateOrConnectWithoutSurveyorInput[]
    createMany?: SurveyCreateManySurveyorInputEnvelope
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
  }

  export type QCRecordCreateNestedManyWithoutQcOfficerInput = {
    create?: XOR<QCRecordCreateWithoutQcOfficerInput, QCRecordUncheckedCreateWithoutQcOfficerInput> | QCRecordCreateWithoutQcOfficerInput[] | QCRecordUncheckedCreateWithoutQcOfficerInput[]
    connectOrCreate?: QCRecordCreateOrConnectWithoutQcOfficerInput | QCRecordCreateOrConnectWithoutQcOfficerInput[]
    createMany?: QCRecordCreateManyQcOfficerInputEnvelope
    connect?: QCRecordWhereUniqueInput | QCRecordWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SurveyUncheckedCreateNestedManyWithoutSurveyorInput = {
    create?: XOR<SurveyCreateWithoutSurveyorInput, SurveyUncheckedCreateWithoutSurveyorInput> | SurveyCreateWithoutSurveyorInput[] | SurveyUncheckedCreateWithoutSurveyorInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutSurveyorInput | SurveyCreateOrConnectWithoutSurveyorInput[]
    createMany?: SurveyCreateManySurveyorInputEnvelope
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
  }

  export type QCRecordUncheckedCreateNestedManyWithoutQcOfficerInput = {
    create?: XOR<QCRecordCreateWithoutQcOfficerInput, QCRecordUncheckedCreateWithoutQcOfficerInput> | QCRecordCreateWithoutQcOfficerInput[] | QCRecordUncheckedCreateWithoutQcOfficerInput[]
    connectOrCreate?: QCRecordCreateOrConnectWithoutQcOfficerInput | QCRecordCreateOrConnectWithoutQcOfficerInput[]
    createMany?: QCRecordCreateManyQcOfficerInputEnvelope
    connect?: QCRecordWhereUniqueInput | QCRecordWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UserUpdateassignedWardsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneWithoutCreatedUsersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    upsert?: UserUpsertWithoutCreatedUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedUsersInput, UserUpdateWithoutCreatedUsersInput>, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SurveyUpdateManyWithoutSurveyorNestedInput = {
    create?: XOR<SurveyCreateWithoutSurveyorInput, SurveyUncheckedCreateWithoutSurveyorInput> | SurveyCreateWithoutSurveyorInput[] | SurveyUncheckedCreateWithoutSurveyorInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutSurveyorInput | SurveyCreateOrConnectWithoutSurveyorInput[]
    upsert?: SurveyUpsertWithWhereUniqueWithoutSurveyorInput | SurveyUpsertWithWhereUniqueWithoutSurveyorInput[]
    createMany?: SurveyCreateManySurveyorInputEnvelope
    set?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    disconnect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    delete?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    update?: SurveyUpdateWithWhereUniqueWithoutSurveyorInput | SurveyUpdateWithWhereUniqueWithoutSurveyorInput[]
    updateMany?: SurveyUpdateManyWithWhereWithoutSurveyorInput | SurveyUpdateManyWithWhereWithoutSurveyorInput[]
    deleteMany?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
  }

  export type QCRecordUpdateManyWithoutQcOfficerNestedInput = {
    create?: XOR<QCRecordCreateWithoutQcOfficerInput, QCRecordUncheckedCreateWithoutQcOfficerInput> | QCRecordCreateWithoutQcOfficerInput[] | QCRecordUncheckedCreateWithoutQcOfficerInput[]
    connectOrCreate?: QCRecordCreateOrConnectWithoutQcOfficerInput | QCRecordCreateOrConnectWithoutQcOfficerInput[]
    upsert?: QCRecordUpsertWithWhereUniqueWithoutQcOfficerInput | QCRecordUpsertWithWhereUniqueWithoutQcOfficerInput[]
    createMany?: QCRecordCreateManyQcOfficerInputEnvelope
    set?: QCRecordWhereUniqueInput | QCRecordWhereUniqueInput[]
    disconnect?: QCRecordWhereUniqueInput | QCRecordWhereUniqueInput[]
    delete?: QCRecordWhereUniqueInput | QCRecordWhereUniqueInput[]
    connect?: QCRecordWhereUniqueInput | QCRecordWhereUniqueInput[]
    update?: QCRecordUpdateWithWhereUniqueWithoutQcOfficerInput | QCRecordUpdateWithWhereUniqueWithoutQcOfficerInput[]
    updateMany?: QCRecordUpdateManyWithWhereWithoutQcOfficerInput | QCRecordUpdateManyWithWhereWithoutQcOfficerInput[]
    deleteMany?: QCRecordScalarWhereInput | QCRecordScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SurveyUncheckedUpdateManyWithoutSurveyorNestedInput = {
    create?: XOR<SurveyCreateWithoutSurveyorInput, SurveyUncheckedCreateWithoutSurveyorInput> | SurveyCreateWithoutSurveyorInput[] | SurveyUncheckedCreateWithoutSurveyorInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutSurveyorInput | SurveyCreateOrConnectWithoutSurveyorInput[]
    upsert?: SurveyUpsertWithWhereUniqueWithoutSurveyorInput | SurveyUpsertWithWhereUniqueWithoutSurveyorInput[]
    createMany?: SurveyCreateManySurveyorInputEnvelope
    set?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    disconnect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    delete?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    update?: SurveyUpdateWithWhereUniqueWithoutSurveyorInput | SurveyUpdateWithWhereUniqueWithoutSurveyorInput[]
    updateMany?: SurveyUpdateManyWithWhereWithoutSurveyorInput | SurveyUpdateManyWithWhereWithoutSurveyorInput[]
    deleteMany?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
  }

  export type QCRecordUncheckedUpdateManyWithoutQcOfficerNestedInput = {
    create?: XOR<QCRecordCreateWithoutQcOfficerInput, QCRecordUncheckedCreateWithoutQcOfficerInput> | QCRecordCreateWithoutQcOfficerInput[] | QCRecordUncheckedCreateWithoutQcOfficerInput[]
    connectOrCreate?: QCRecordCreateOrConnectWithoutQcOfficerInput | QCRecordCreateOrConnectWithoutQcOfficerInput[]
    upsert?: QCRecordUpsertWithWhereUniqueWithoutQcOfficerInput | QCRecordUpsertWithWhereUniqueWithoutQcOfficerInput[]
    createMany?: QCRecordCreateManyQcOfficerInputEnvelope
    set?: QCRecordWhereUniqueInput | QCRecordWhereUniqueInput[]
    disconnect?: QCRecordWhereUniqueInput | QCRecordWhereUniqueInput[]
    delete?: QCRecordWhereUniqueInput | QCRecordWhereUniqueInput[]
    connect?: QCRecordWhereUniqueInput | QCRecordWhereUniqueInput[]
    update?: QCRecordUpdateWithWhereUniqueWithoutQcOfficerInput | QCRecordUpdateWithWhereUniqueWithoutQcOfficerInput[]
    updateMany?: QCRecordUpdateManyWithWhereWithoutQcOfficerInput | QCRecordUpdateManyWithWhereWithoutQcOfficerInput[]
    deleteMany?: QCRecordScalarWhereInput | QCRecordScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type ZoneCreateNestedManyWithoutUlbInput = {
    create?: XOR<ZoneCreateWithoutUlbInput, ZoneUncheckedCreateWithoutUlbInput> | ZoneCreateWithoutUlbInput[] | ZoneUncheckedCreateWithoutUlbInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutUlbInput | ZoneCreateOrConnectWithoutUlbInput[]
    createMany?: ZoneCreateManyUlbInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type SurveyCreateNestedManyWithoutUlbInput = {
    create?: XOR<SurveyCreateWithoutUlbInput, SurveyUncheckedCreateWithoutUlbInput> | SurveyCreateWithoutUlbInput[] | SurveyUncheckedCreateWithoutUlbInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutUlbInput | SurveyCreateOrConnectWithoutUlbInput[]
    createMany?: SurveyCreateManyUlbInputEnvelope
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
  }

  export type ZoneUncheckedCreateNestedManyWithoutUlbInput = {
    create?: XOR<ZoneCreateWithoutUlbInput, ZoneUncheckedCreateWithoutUlbInput> | ZoneCreateWithoutUlbInput[] | ZoneUncheckedCreateWithoutUlbInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutUlbInput | ZoneCreateOrConnectWithoutUlbInput[]
    createMany?: ZoneCreateManyUlbInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type SurveyUncheckedCreateNestedManyWithoutUlbInput = {
    create?: XOR<SurveyCreateWithoutUlbInput, SurveyUncheckedCreateWithoutUlbInput> | SurveyCreateWithoutUlbInput[] | SurveyUncheckedCreateWithoutUlbInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutUlbInput | SurveyCreateOrConnectWithoutUlbInput[]
    createMany?: SurveyCreateManyUlbInputEnvelope
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
  }

  export type ZoneUpdateManyWithoutUlbNestedInput = {
    create?: XOR<ZoneCreateWithoutUlbInput, ZoneUncheckedCreateWithoutUlbInput> | ZoneCreateWithoutUlbInput[] | ZoneUncheckedCreateWithoutUlbInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutUlbInput | ZoneCreateOrConnectWithoutUlbInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutUlbInput | ZoneUpsertWithWhereUniqueWithoutUlbInput[]
    createMany?: ZoneCreateManyUlbInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutUlbInput | ZoneUpdateWithWhereUniqueWithoutUlbInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutUlbInput | ZoneUpdateManyWithWhereWithoutUlbInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type SurveyUpdateManyWithoutUlbNestedInput = {
    create?: XOR<SurveyCreateWithoutUlbInput, SurveyUncheckedCreateWithoutUlbInput> | SurveyCreateWithoutUlbInput[] | SurveyUncheckedCreateWithoutUlbInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutUlbInput | SurveyCreateOrConnectWithoutUlbInput[]
    upsert?: SurveyUpsertWithWhereUniqueWithoutUlbInput | SurveyUpsertWithWhereUniqueWithoutUlbInput[]
    createMany?: SurveyCreateManyUlbInputEnvelope
    set?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    disconnect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    delete?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    update?: SurveyUpdateWithWhereUniqueWithoutUlbInput | SurveyUpdateWithWhereUniqueWithoutUlbInput[]
    updateMany?: SurveyUpdateManyWithWhereWithoutUlbInput | SurveyUpdateManyWithWhereWithoutUlbInput[]
    deleteMany?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
  }

  export type ZoneUncheckedUpdateManyWithoutUlbNestedInput = {
    create?: XOR<ZoneCreateWithoutUlbInput, ZoneUncheckedCreateWithoutUlbInput> | ZoneCreateWithoutUlbInput[] | ZoneUncheckedCreateWithoutUlbInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutUlbInput | ZoneCreateOrConnectWithoutUlbInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutUlbInput | ZoneUpsertWithWhereUniqueWithoutUlbInput[]
    createMany?: ZoneCreateManyUlbInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutUlbInput | ZoneUpdateWithWhereUniqueWithoutUlbInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutUlbInput | ZoneUpdateManyWithWhereWithoutUlbInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type SurveyUncheckedUpdateManyWithoutUlbNestedInput = {
    create?: XOR<SurveyCreateWithoutUlbInput, SurveyUncheckedCreateWithoutUlbInput> | SurveyCreateWithoutUlbInput[] | SurveyUncheckedCreateWithoutUlbInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutUlbInput | SurveyCreateOrConnectWithoutUlbInput[]
    upsert?: SurveyUpsertWithWhereUniqueWithoutUlbInput | SurveyUpsertWithWhereUniqueWithoutUlbInput[]
    createMany?: SurveyCreateManyUlbInputEnvelope
    set?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    disconnect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    delete?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    update?: SurveyUpdateWithWhereUniqueWithoutUlbInput | SurveyUpdateWithWhereUniqueWithoutUlbInput[]
    updateMany?: SurveyUpdateManyWithWhereWithoutUlbInput | SurveyUpdateManyWithWhereWithoutUlbInput[]
    deleteMany?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
  }

  export type ULBCreateNestedOneWithoutZonesInput = {
    create?: XOR<ULBCreateWithoutZonesInput, ULBUncheckedCreateWithoutZonesInput>
    connectOrCreate?: ULBCreateOrConnectWithoutZonesInput
    connect?: ULBWhereUniqueInput
  }

  export type WardCreateNestedManyWithoutZoneInput = {
    create?: XOR<WardCreateWithoutZoneInput, WardUncheckedCreateWithoutZoneInput> | WardCreateWithoutZoneInput[] | WardUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: WardCreateOrConnectWithoutZoneInput | WardCreateOrConnectWithoutZoneInput[]
    createMany?: WardCreateManyZoneInputEnvelope
    connect?: WardWhereUniqueInput | WardWhereUniqueInput[]
  }

  export type SurveyCreateNestedManyWithoutZoneInput = {
    create?: XOR<SurveyCreateWithoutZoneInput, SurveyUncheckedCreateWithoutZoneInput> | SurveyCreateWithoutZoneInput[] | SurveyUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutZoneInput | SurveyCreateOrConnectWithoutZoneInput[]
    createMany?: SurveyCreateManyZoneInputEnvelope
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
  }

  export type WardUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<WardCreateWithoutZoneInput, WardUncheckedCreateWithoutZoneInput> | WardCreateWithoutZoneInput[] | WardUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: WardCreateOrConnectWithoutZoneInput | WardCreateOrConnectWithoutZoneInput[]
    createMany?: WardCreateManyZoneInputEnvelope
    connect?: WardWhereUniqueInput | WardWhereUniqueInput[]
  }

  export type SurveyUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<SurveyCreateWithoutZoneInput, SurveyUncheckedCreateWithoutZoneInput> | SurveyCreateWithoutZoneInput[] | SurveyUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutZoneInput | SurveyCreateOrConnectWithoutZoneInput[]
    createMany?: SurveyCreateManyZoneInputEnvelope
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
  }

  export type ULBUpdateOneRequiredWithoutZonesNestedInput = {
    create?: XOR<ULBCreateWithoutZonesInput, ULBUncheckedCreateWithoutZonesInput>
    connectOrCreate?: ULBCreateOrConnectWithoutZonesInput
    upsert?: ULBUpsertWithoutZonesInput
    connect?: ULBWhereUniqueInput
    update?: XOR<XOR<ULBUpdateToOneWithWhereWithoutZonesInput, ULBUpdateWithoutZonesInput>, ULBUncheckedUpdateWithoutZonesInput>
  }

  export type WardUpdateManyWithoutZoneNestedInput = {
    create?: XOR<WardCreateWithoutZoneInput, WardUncheckedCreateWithoutZoneInput> | WardCreateWithoutZoneInput[] | WardUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: WardCreateOrConnectWithoutZoneInput | WardCreateOrConnectWithoutZoneInput[]
    upsert?: WardUpsertWithWhereUniqueWithoutZoneInput | WardUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: WardCreateManyZoneInputEnvelope
    set?: WardWhereUniqueInput | WardWhereUniqueInput[]
    disconnect?: WardWhereUniqueInput | WardWhereUniqueInput[]
    delete?: WardWhereUniqueInput | WardWhereUniqueInput[]
    connect?: WardWhereUniqueInput | WardWhereUniqueInput[]
    update?: WardUpdateWithWhereUniqueWithoutZoneInput | WardUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: WardUpdateManyWithWhereWithoutZoneInput | WardUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: WardScalarWhereInput | WardScalarWhereInput[]
  }

  export type SurveyUpdateManyWithoutZoneNestedInput = {
    create?: XOR<SurveyCreateWithoutZoneInput, SurveyUncheckedCreateWithoutZoneInput> | SurveyCreateWithoutZoneInput[] | SurveyUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutZoneInput | SurveyCreateOrConnectWithoutZoneInput[]
    upsert?: SurveyUpsertWithWhereUniqueWithoutZoneInput | SurveyUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: SurveyCreateManyZoneInputEnvelope
    set?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    disconnect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    delete?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    update?: SurveyUpdateWithWhereUniqueWithoutZoneInput | SurveyUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: SurveyUpdateManyWithWhereWithoutZoneInput | SurveyUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
  }

  export type WardUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<WardCreateWithoutZoneInput, WardUncheckedCreateWithoutZoneInput> | WardCreateWithoutZoneInput[] | WardUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: WardCreateOrConnectWithoutZoneInput | WardCreateOrConnectWithoutZoneInput[]
    upsert?: WardUpsertWithWhereUniqueWithoutZoneInput | WardUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: WardCreateManyZoneInputEnvelope
    set?: WardWhereUniqueInput | WardWhereUniqueInput[]
    disconnect?: WardWhereUniqueInput | WardWhereUniqueInput[]
    delete?: WardWhereUniqueInput | WardWhereUniqueInput[]
    connect?: WardWhereUniqueInput | WardWhereUniqueInput[]
    update?: WardUpdateWithWhereUniqueWithoutZoneInput | WardUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: WardUpdateManyWithWhereWithoutZoneInput | WardUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: WardScalarWhereInput | WardScalarWhereInput[]
  }

  export type SurveyUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<SurveyCreateWithoutZoneInput, SurveyUncheckedCreateWithoutZoneInput> | SurveyCreateWithoutZoneInput[] | SurveyUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutZoneInput | SurveyCreateOrConnectWithoutZoneInput[]
    upsert?: SurveyUpsertWithWhereUniqueWithoutZoneInput | SurveyUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: SurveyCreateManyZoneInputEnvelope
    set?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    disconnect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    delete?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    update?: SurveyUpdateWithWhereUniqueWithoutZoneInput | SurveyUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: SurveyUpdateManyWithWhereWithoutZoneInput | SurveyUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
  }

  export type ZoneCreateNestedOneWithoutWardsInput = {
    create?: XOR<ZoneCreateWithoutWardsInput, ZoneUncheckedCreateWithoutWardsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutWardsInput
    connect?: ZoneWhereUniqueInput
  }

  export type MohallaCreateNestedManyWithoutWardInput = {
    create?: XOR<MohallaCreateWithoutWardInput, MohallaUncheckedCreateWithoutWardInput> | MohallaCreateWithoutWardInput[] | MohallaUncheckedCreateWithoutWardInput[]
    connectOrCreate?: MohallaCreateOrConnectWithoutWardInput | MohallaCreateOrConnectWithoutWardInput[]
    createMany?: MohallaCreateManyWardInputEnvelope
    connect?: MohallaWhereUniqueInput | MohallaWhereUniqueInput[]
  }

  export type SurveyCreateNestedManyWithoutWardInput = {
    create?: XOR<SurveyCreateWithoutWardInput, SurveyUncheckedCreateWithoutWardInput> | SurveyCreateWithoutWardInput[] | SurveyUncheckedCreateWithoutWardInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutWardInput | SurveyCreateOrConnectWithoutWardInput[]
    createMany?: SurveyCreateManyWardInputEnvelope
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
  }

  export type MohallaUncheckedCreateNestedManyWithoutWardInput = {
    create?: XOR<MohallaCreateWithoutWardInput, MohallaUncheckedCreateWithoutWardInput> | MohallaCreateWithoutWardInput[] | MohallaUncheckedCreateWithoutWardInput[]
    connectOrCreate?: MohallaCreateOrConnectWithoutWardInput | MohallaCreateOrConnectWithoutWardInput[]
    createMany?: MohallaCreateManyWardInputEnvelope
    connect?: MohallaWhereUniqueInput | MohallaWhereUniqueInput[]
  }

  export type SurveyUncheckedCreateNestedManyWithoutWardInput = {
    create?: XOR<SurveyCreateWithoutWardInput, SurveyUncheckedCreateWithoutWardInput> | SurveyCreateWithoutWardInput[] | SurveyUncheckedCreateWithoutWardInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutWardInput | SurveyCreateOrConnectWithoutWardInput[]
    createMany?: SurveyCreateManyWardInputEnvelope
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
  }

  export type ZoneUpdateOneRequiredWithoutWardsNestedInput = {
    create?: XOR<ZoneCreateWithoutWardsInput, ZoneUncheckedCreateWithoutWardsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutWardsInput
    upsert?: ZoneUpsertWithoutWardsInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutWardsInput, ZoneUpdateWithoutWardsInput>, ZoneUncheckedUpdateWithoutWardsInput>
  }

  export type MohallaUpdateManyWithoutWardNestedInput = {
    create?: XOR<MohallaCreateWithoutWardInput, MohallaUncheckedCreateWithoutWardInput> | MohallaCreateWithoutWardInput[] | MohallaUncheckedCreateWithoutWardInput[]
    connectOrCreate?: MohallaCreateOrConnectWithoutWardInput | MohallaCreateOrConnectWithoutWardInput[]
    upsert?: MohallaUpsertWithWhereUniqueWithoutWardInput | MohallaUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: MohallaCreateManyWardInputEnvelope
    set?: MohallaWhereUniqueInput | MohallaWhereUniqueInput[]
    disconnect?: MohallaWhereUniqueInput | MohallaWhereUniqueInput[]
    delete?: MohallaWhereUniqueInput | MohallaWhereUniqueInput[]
    connect?: MohallaWhereUniqueInput | MohallaWhereUniqueInput[]
    update?: MohallaUpdateWithWhereUniqueWithoutWardInput | MohallaUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: MohallaUpdateManyWithWhereWithoutWardInput | MohallaUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: MohallaScalarWhereInput | MohallaScalarWhereInput[]
  }

  export type SurveyUpdateManyWithoutWardNestedInput = {
    create?: XOR<SurveyCreateWithoutWardInput, SurveyUncheckedCreateWithoutWardInput> | SurveyCreateWithoutWardInput[] | SurveyUncheckedCreateWithoutWardInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutWardInput | SurveyCreateOrConnectWithoutWardInput[]
    upsert?: SurveyUpsertWithWhereUniqueWithoutWardInput | SurveyUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: SurveyCreateManyWardInputEnvelope
    set?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    disconnect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    delete?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    update?: SurveyUpdateWithWhereUniqueWithoutWardInput | SurveyUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: SurveyUpdateManyWithWhereWithoutWardInput | SurveyUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
  }

  export type MohallaUncheckedUpdateManyWithoutWardNestedInput = {
    create?: XOR<MohallaCreateWithoutWardInput, MohallaUncheckedCreateWithoutWardInput> | MohallaCreateWithoutWardInput[] | MohallaUncheckedCreateWithoutWardInput[]
    connectOrCreate?: MohallaCreateOrConnectWithoutWardInput | MohallaCreateOrConnectWithoutWardInput[]
    upsert?: MohallaUpsertWithWhereUniqueWithoutWardInput | MohallaUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: MohallaCreateManyWardInputEnvelope
    set?: MohallaWhereUniqueInput | MohallaWhereUniqueInput[]
    disconnect?: MohallaWhereUniqueInput | MohallaWhereUniqueInput[]
    delete?: MohallaWhereUniqueInput | MohallaWhereUniqueInput[]
    connect?: MohallaWhereUniqueInput | MohallaWhereUniqueInput[]
    update?: MohallaUpdateWithWhereUniqueWithoutWardInput | MohallaUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: MohallaUpdateManyWithWhereWithoutWardInput | MohallaUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: MohallaScalarWhereInput | MohallaScalarWhereInput[]
  }

  export type SurveyUncheckedUpdateManyWithoutWardNestedInput = {
    create?: XOR<SurveyCreateWithoutWardInput, SurveyUncheckedCreateWithoutWardInput> | SurveyCreateWithoutWardInput[] | SurveyUncheckedCreateWithoutWardInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutWardInput | SurveyCreateOrConnectWithoutWardInput[]
    upsert?: SurveyUpsertWithWhereUniqueWithoutWardInput | SurveyUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: SurveyCreateManyWardInputEnvelope
    set?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    disconnect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    delete?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    update?: SurveyUpdateWithWhereUniqueWithoutWardInput | SurveyUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: SurveyUpdateManyWithWhereWithoutWardInput | SurveyUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
  }

  export type WardCreateNestedOneWithoutMohallasInput = {
    create?: XOR<WardCreateWithoutMohallasInput, WardUncheckedCreateWithoutMohallasInput>
    connectOrCreate?: WardCreateOrConnectWithoutMohallasInput
    connect?: WardWhereUniqueInput
  }

  export type SurveyCreateNestedManyWithoutMohallaInput = {
    create?: XOR<SurveyCreateWithoutMohallaInput, SurveyUncheckedCreateWithoutMohallaInput> | SurveyCreateWithoutMohallaInput[] | SurveyUncheckedCreateWithoutMohallaInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutMohallaInput | SurveyCreateOrConnectWithoutMohallaInput[]
    createMany?: SurveyCreateManyMohallaInputEnvelope
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
  }

  export type SurveyUncheckedCreateNestedManyWithoutMohallaInput = {
    create?: XOR<SurveyCreateWithoutMohallaInput, SurveyUncheckedCreateWithoutMohallaInput> | SurveyCreateWithoutMohallaInput[] | SurveyUncheckedCreateWithoutMohallaInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutMohallaInput | SurveyCreateOrConnectWithoutMohallaInput[]
    createMany?: SurveyCreateManyMohallaInputEnvelope
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
  }

  export type WardUpdateOneRequiredWithoutMohallasNestedInput = {
    create?: XOR<WardCreateWithoutMohallasInput, WardUncheckedCreateWithoutMohallasInput>
    connectOrCreate?: WardCreateOrConnectWithoutMohallasInput
    upsert?: WardUpsertWithoutMohallasInput
    connect?: WardWhereUniqueInput
    update?: XOR<XOR<WardUpdateToOneWithWhereWithoutMohallasInput, WardUpdateWithoutMohallasInput>, WardUncheckedUpdateWithoutMohallasInput>
  }

  export type SurveyUpdateManyWithoutMohallaNestedInput = {
    create?: XOR<SurveyCreateWithoutMohallaInput, SurveyUncheckedCreateWithoutMohallaInput> | SurveyCreateWithoutMohallaInput[] | SurveyUncheckedCreateWithoutMohallaInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutMohallaInput | SurveyCreateOrConnectWithoutMohallaInput[]
    upsert?: SurveyUpsertWithWhereUniqueWithoutMohallaInput | SurveyUpsertWithWhereUniqueWithoutMohallaInput[]
    createMany?: SurveyCreateManyMohallaInputEnvelope
    set?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    disconnect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    delete?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    update?: SurveyUpdateWithWhereUniqueWithoutMohallaInput | SurveyUpdateWithWhereUniqueWithoutMohallaInput[]
    updateMany?: SurveyUpdateManyWithWhereWithoutMohallaInput | SurveyUpdateManyWithWhereWithoutMohallaInput[]
    deleteMany?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
  }

  export type SurveyUncheckedUpdateManyWithoutMohallaNestedInput = {
    create?: XOR<SurveyCreateWithoutMohallaInput, SurveyUncheckedCreateWithoutMohallaInput> | SurveyCreateWithoutMohallaInput[] | SurveyUncheckedCreateWithoutMohallaInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutMohallaInput | SurveyCreateOrConnectWithoutMohallaInput[]
    upsert?: SurveyUpsertWithWhereUniqueWithoutMohallaInput | SurveyUpsertWithWhereUniqueWithoutMohallaInput[]
    createMany?: SurveyCreateManyMohallaInputEnvelope
    set?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    disconnect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    delete?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    update?: SurveyUpdateWithWhereUniqueWithoutMohallaInput | SurveyUpdateWithWhereUniqueWithoutMohallaInput[]
    updateMany?: SurveyUpdateManyWithWhereWithoutMohallaInput | SurveyUpdateManyWithWhereWithoutMohallaInput[]
    deleteMany?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
  }

  export type PropertyDetailsCreateNestedManyWithoutResponseTypeInput = {
    create?: XOR<PropertyDetailsCreateWithoutResponseTypeInput, PropertyDetailsUncheckedCreateWithoutResponseTypeInput> | PropertyDetailsCreateWithoutResponseTypeInput[] | PropertyDetailsUncheckedCreateWithoutResponseTypeInput[]
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutResponseTypeInput | PropertyDetailsCreateOrConnectWithoutResponseTypeInput[]
    createMany?: PropertyDetailsCreateManyResponseTypeInputEnvelope
    connect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
  }

  export type PropertyDetailsUncheckedCreateNestedManyWithoutResponseTypeInput = {
    create?: XOR<PropertyDetailsCreateWithoutResponseTypeInput, PropertyDetailsUncheckedCreateWithoutResponseTypeInput> | PropertyDetailsCreateWithoutResponseTypeInput[] | PropertyDetailsUncheckedCreateWithoutResponseTypeInput[]
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutResponseTypeInput | PropertyDetailsCreateOrConnectWithoutResponseTypeInput[]
    createMany?: PropertyDetailsCreateManyResponseTypeInputEnvelope
    connect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
  }

  export type PropertyDetailsUpdateManyWithoutResponseTypeNestedInput = {
    create?: XOR<PropertyDetailsCreateWithoutResponseTypeInput, PropertyDetailsUncheckedCreateWithoutResponseTypeInput> | PropertyDetailsCreateWithoutResponseTypeInput[] | PropertyDetailsUncheckedCreateWithoutResponseTypeInput[]
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutResponseTypeInput | PropertyDetailsCreateOrConnectWithoutResponseTypeInput[]
    upsert?: PropertyDetailsUpsertWithWhereUniqueWithoutResponseTypeInput | PropertyDetailsUpsertWithWhereUniqueWithoutResponseTypeInput[]
    createMany?: PropertyDetailsCreateManyResponseTypeInputEnvelope
    set?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    disconnect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    delete?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    connect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    update?: PropertyDetailsUpdateWithWhereUniqueWithoutResponseTypeInput | PropertyDetailsUpdateWithWhereUniqueWithoutResponseTypeInput[]
    updateMany?: PropertyDetailsUpdateManyWithWhereWithoutResponseTypeInput | PropertyDetailsUpdateManyWithWhereWithoutResponseTypeInput[]
    deleteMany?: PropertyDetailsScalarWhereInput | PropertyDetailsScalarWhereInput[]
  }

  export type PropertyDetailsUncheckedUpdateManyWithoutResponseTypeNestedInput = {
    create?: XOR<PropertyDetailsCreateWithoutResponseTypeInput, PropertyDetailsUncheckedCreateWithoutResponseTypeInput> | PropertyDetailsCreateWithoutResponseTypeInput[] | PropertyDetailsUncheckedCreateWithoutResponseTypeInput[]
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutResponseTypeInput | PropertyDetailsCreateOrConnectWithoutResponseTypeInput[]
    upsert?: PropertyDetailsUpsertWithWhereUniqueWithoutResponseTypeInput | PropertyDetailsUpsertWithWhereUniqueWithoutResponseTypeInput[]
    createMany?: PropertyDetailsCreateManyResponseTypeInputEnvelope
    set?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    disconnect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    delete?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    connect?: PropertyDetailsWhereUniqueInput | PropertyDetailsWhereUniqueInput[]
    update?: PropertyDetailsUpdateWithWhereUniqueWithoutResponseTypeInput | PropertyDetailsUpdateWithWhereUniqueWithoutResponseTypeInput[]
    updateMany?: PropertyDetailsUpdateManyWithWhereWithoutResponseTypeInput | PropertyDetailsUpdateManyWithWhereWithoutResponseTypeInput[]
    deleteMany?: PropertyDetailsScalarWhereInput | PropertyDetailsScalarWhereInput[]
  }

  export type LocationDetailsCreateNestedManyWithoutRoadTypeInput = {
    create?: XOR<LocationDetailsCreateWithoutRoadTypeInput, LocationDetailsUncheckedCreateWithoutRoadTypeInput> | LocationDetailsCreateWithoutRoadTypeInput[] | LocationDetailsUncheckedCreateWithoutRoadTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutRoadTypeInput | LocationDetailsCreateOrConnectWithoutRoadTypeInput[]
    createMany?: LocationDetailsCreateManyRoadTypeInputEnvelope
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
  }

  export type LocationDetailsUncheckedCreateNestedManyWithoutRoadTypeInput = {
    create?: XOR<LocationDetailsCreateWithoutRoadTypeInput, LocationDetailsUncheckedCreateWithoutRoadTypeInput> | LocationDetailsCreateWithoutRoadTypeInput[] | LocationDetailsUncheckedCreateWithoutRoadTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutRoadTypeInput | LocationDetailsCreateOrConnectWithoutRoadTypeInput[]
    createMany?: LocationDetailsCreateManyRoadTypeInputEnvelope
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
  }

  export type LocationDetailsUpdateManyWithoutRoadTypeNestedInput = {
    create?: XOR<LocationDetailsCreateWithoutRoadTypeInput, LocationDetailsUncheckedCreateWithoutRoadTypeInput> | LocationDetailsCreateWithoutRoadTypeInput[] | LocationDetailsUncheckedCreateWithoutRoadTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutRoadTypeInput | LocationDetailsCreateOrConnectWithoutRoadTypeInput[]
    upsert?: LocationDetailsUpsertWithWhereUniqueWithoutRoadTypeInput | LocationDetailsUpsertWithWhereUniqueWithoutRoadTypeInput[]
    createMany?: LocationDetailsCreateManyRoadTypeInputEnvelope
    set?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    disconnect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    delete?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    update?: LocationDetailsUpdateWithWhereUniqueWithoutRoadTypeInput | LocationDetailsUpdateWithWhereUniqueWithoutRoadTypeInput[]
    updateMany?: LocationDetailsUpdateManyWithWhereWithoutRoadTypeInput | LocationDetailsUpdateManyWithWhereWithoutRoadTypeInput[]
    deleteMany?: LocationDetailsScalarWhereInput | LocationDetailsScalarWhereInput[]
  }

  export type LocationDetailsUncheckedUpdateManyWithoutRoadTypeNestedInput = {
    create?: XOR<LocationDetailsCreateWithoutRoadTypeInput, LocationDetailsUncheckedCreateWithoutRoadTypeInput> | LocationDetailsCreateWithoutRoadTypeInput[] | LocationDetailsUncheckedCreateWithoutRoadTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutRoadTypeInput | LocationDetailsCreateOrConnectWithoutRoadTypeInput[]
    upsert?: LocationDetailsUpsertWithWhereUniqueWithoutRoadTypeInput | LocationDetailsUpsertWithWhereUniqueWithoutRoadTypeInput[]
    createMany?: LocationDetailsCreateManyRoadTypeInputEnvelope
    set?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    disconnect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    delete?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    update?: LocationDetailsUpdateWithWhereUniqueWithoutRoadTypeInput | LocationDetailsUpdateWithWhereUniqueWithoutRoadTypeInput[]
    updateMany?: LocationDetailsUpdateManyWithWhereWithoutRoadTypeInput | LocationDetailsUpdateManyWithWhereWithoutRoadTypeInput[]
    deleteMany?: LocationDetailsScalarWhereInput | LocationDetailsScalarWhereInput[]
  }

  export type LocationDetailsCreateNestedManyWithoutConstructionTypeInput = {
    create?: XOR<LocationDetailsCreateWithoutConstructionTypeInput, LocationDetailsUncheckedCreateWithoutConstructionTypeInput> | LocationDetailsCreateWithoutConstructionTypeInput[] | LocationDetailsUncheckedCreateWithoutConstructionTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutConstructionTypeInput | LocationDetailsCreateOrConnectWithoutConstructionTypeInput[]
    createMany?: LocationDetailsCreateManyConstructionTypeInputEnvelope
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
  }

  export type LocationDetailsUncheckedCreateNestedManyWithoutConstructionTypeInput = {
    create?: XOR<LocationDetailsCreateWithoutConstructionTypeInput, LocationDetailsUncheckedCreateWithoutConstructionTypeInput> | LocationDetailsCreateWithoutConstructionTypeInput[] | LocationDetailsUncheckedCreateWithoutConstructionTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutConstructionTypeInput | LocationDetailsCreateOrConnectWithoutConstructionTypeInput[]
    createMany?: LocationDetailsCreateManyConstructionTypeInputEnvelope
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
  }

  export type LocationDetailsUpdateManyWithoutConstructionTypeNestedInput = {
    create?: XOR<LocationDetailsCreateWithoutConstructionTypeInput, LocationDetailsUncheckedCreateWithoutConstructionTypeInput> | LocationDetailsCreateWithoutConstructionTypeInput[] | LocationDetailsUncheckedCreateWithoutConstructionTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutConstructionTypeInput | LocationDetailsCreateOrConnectWithoutConstructionTypeInput[]
    upsert?: LocationDetailsUpsertWithWhereUniqueWithoutConstructionTypeInput | LocationDetailsUpsertWithWhereUniqueWithoutConstructionTypeInput[]
    createMany?: LocationDetailsCreateManyConstructionTypeInputEnvelope
    set?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    disconnect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    delete?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    update?: LocationDetailsUpdateWithWhereUniqueWithoutConstructionTypeInput | LocationDetailsUpdateWithWhereUniqueWithoutConstructionTypeInput[]
    updateMany?: LocationDetailsUpdateManyWithWhereWithoutConstructionTypeInput | LocationDetailsUpdateManyWithWhereWithoutConstructionTypeInput[]
    deleteMany?: LocationDetailsScalarWhereInput | LocationDetailsScalarWhereInput[]
  }

  export type LocationDetailsUncheckedUpdateManyWithoutConstructionTypeNestedInput = {
    create?: XOR<LocationDetailsCreateWithoutConstructionTypeInput, LocationDetailsUncheckedCreateWithoutConstructionTypeInput> | LocationDetailsCreateWithoutConstructionTypeInput[] | LocationDetailsUncheckedCreateWithoutConstructionTypeInput[]
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutConstructionTypeInput | LocationDetailsCreateOrConnectWithoutConstructionTypeInput[]
    upsert?: LocationDetailsUpsertWithWhereUniqueWithoutConstructionTypeInput | LocationDetailsUpsertWithWhereUniqueWithoutConstructionTypeInput[]
    createMany?: LocationDetailsCreateManyConstructionTypeInputEnvelope
    set?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    disconnect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    delete?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    connect?: LocationDetailsWhereUniqueInput | LocationDetailsWhereUniqueInput[]
    update?: LocationDetailsUpdateWithWhereUniqueWithoutConstructionTypeInput | LocationDetailsUpdateWithWhereUniqueWithoutConstructionTypeInput[]
    updateMany?: LocationDetailsUpdateManyWithWhereWithoutConstructionTypeInput | LocationDetailsUpdateManyWithWhereWithoutConstructionTypeInput[]
    deleteMany?: LocationDetailsScalarWhereInput | LocationDetailsScalarWhereInput[]
  }

  export type NRPropSubCategoryMappingCreateNestedManyWithoutCategoryInput = {
    create?: XOR<NRPropSubCategoryMappingCreateWithoutCategoryInput, NRPropSubCategoryMappingUncheckedCreateWithoutCategoryInput> | NRPropSubCategoryMappingCreateWithoutCategoryInput[] | NRPropSubCategoryMappingUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: NRPropSubCategoryMappingCreateOrConnectWithoutCategoryInput | NRPropSubCategoryMappingCreateOrConnectWithoutCategoryInput[]
    createMany?: NRPropSubCategoryMappingCreateManyCategoryInputEnvelope
    connect?: NRPropSubCategoryMappingWhereUniqueInput | NRPropSubCategoryMappingWhereUniqueInput[]
  }

  export type PropertyAssessmentCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PropertyAssessmentCreateWithoutCategoryInput, PropertyAssessmentUncheckedCreateWithoutCategoryInput> | PropertyAssessmentCreateWithoutCategoryInput[] | PropertyAssessmentUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PropertyAssessmentCreateOrConnectWithoutCategoryInput | PropertyAssessmentCreateOrConnectWithoutCategoryInput[]
    createMany?: PropertyAssessmentCreateManyCategoryInputEnvelope
    connect?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
  }

  export type NRPropSubCategoryMappingUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<NRPropSubCategoryMappingCreateWithoutCategoryInput, NRPropSubCategoryMappingUncheckedCreateWithoutCategoryInput> | NRPropSubCategoryMappingCreateWithoutCategoryInput[] | NRPropSubCategoryMappingUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: NRPropSubCategoryMappingCreateOrConnectWithoutCategoryInput | NRPropSubCategoryMappingCreateOrConnectWithoutCategoryInput[]
    createMany?: NRPropSubCategoryMappingCreateManyCategoryInputEnvelope
    connect?: NRPropSubCategoryMappingWhereUniqueInput | NRPropSubCategoryMappingWhereUniqueInput[]
  }

  export type PropertyAssessmentUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PropertyAssessmentCreateWithoutCategoryInput, PropertyAssessmentUncheckedCreateWithoutCategoryInput> | PropertyAssessmentCreateWithoutCategoryInput[] | PropertyAssessmentUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PropertyAssessmentCreateOrConnectWithoutCategoryInput | PropertyAssessmentCreateOrConnectWithoutCategoryInput[]
    createMany?: PropertyAssessmentCreateManyCategoryInputEnvelope
    connect?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
  }

  export type NRPropSubCategoryMappingUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<NRPropSubCategoryMappingCreateWithoutCategoryInput, NRPropSubCategoryMappingUncheckedCreateWithoutCategoryInput> | NRPropSubCategoryMappingCreateWithoutCategoryInput[] | NRPropSubCategoryMappingUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: NRPropSubCategoryMappingCreateOrConnectWithoutCategoryInput | NRPropSubCategoryMappingCreateOrConnectWithoutCategoryInput[]
    upsert?: NRPropSubCategoryMappingUpsertWithWhereUniqueWithoutCategoryInput | NRPropSubCategoryMappingUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: NRPropSubCategoryMappingCreateManyCategoryInputEnvelope
    set?: NRPropSubCategoryMappingWhereUniqueInput | NRPropSubCategoryMappingWhereUniqueInput[]
    disconnect?: NRPropSubCategoryMappingWhereUniqueInput | NRPropSubCategoryMappingWhereUniqueInput[]
    delete?: NRPropSubCategoryMappingWhereUniqueInput | NRPropSubCategoryMappingWhereUniqueInput[]
    connect?: NRPropSubCategoryMappingWhereUniqueInput | NRPropSubCategoryMappingWhereUniqueInput[]
    update?: NRPropSubCategoryMappingUpdateWithWhereUniqueWithoutCategoryInput | NRPropSubCategoryMappingUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: NRPropSubCategoryMappingUpdateManyWithWhereWithoutCategoryInput | NRPropSubCategoryMappingUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: NRPropSubCategoryMappingScalarWhereInput | NRPropSubCategoryMappingScalarWhereInput[]
  }

  export type PropertyAssessmentUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PropertyAssessmentCreateWithoutCategoryInput, PropertyAssessmentUncheckedCreateWithoutCategoryInput> | PropertyAssessmentCreateWithoutCategoryInput[] | PropertyAssessmentUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PropertyAssessmentCreateOrConnectWithoutCategoryInput | PropertyAssessmentCreateOrConnectWithoutCategoryInput[]
    upsert?: PropertyAssessmentUpsertWithWhereUniqueWithoutCategoryInput | PropertyAssessmentUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PropertyAssessmentCreateManyCategoryInputEnvelope
    set?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
    disconnect?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
    delete?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
    connect?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
    update?: PropertyAssessmentUpdateWithWhereUniqueWithoutCategoryInput | PropertyAssessmentUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PropertyAssessmentUpdateManyWithWhereWithoutCategoryInput | PropertyAssessmentUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PropertyAssessmentScalarWhereInput | PropertyAssessmentScalarWhereInput[]
  }

  export type NRPropSubCategoryMappingUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<NRPropSubCategoryMappingCreateWithoutCategoryInput, NRPropSubCategoryMappingUncheckedCreateWithoutCategoryInput> | NRPropSubCategoryMappingCreateWithoutCategoryInput[] | NRPropSubCategoryMappingUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: NRPropSubCategoryMappingCreateOrConnectWithoutCategoryInput | NRPropSubCategoryMappingCreateOrConnectWithoutCategoryInput[]
    upsert?: NRPropSubCategoryMappingUpsertWithWhereUniqueWithoutCategoryInput | NRPropSubCategoryMappingUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: NRPropSubCategoryMappingCreateManyCategoryInputEnvelope
    set?: NRPropSubCategoryMappingWhereUniqueInput | NRPropSubCategoryMappingWhereUniqueInput[]
    disconnect?: NRPropSubCategoryMappingWhereUniqueInput | NRPropSubCategoryMappingWhereUniqueInput[]
    delete?: NRPropSubCategoryMappingWhereUniqueInput | NRPropSubCategoryMappingWhereUniqueInput[]
    connect?: NRPropSubCategoryMappingWhereUniqueInput | NRPropSubCategoryMappingWhereUniqueInput[]
    update?: NRPropSubCategoryMappingUpdateWithWhereUniqueWithoutCategoryInput | NRPropSubCategoryMappingUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: NRPropSubCategoryMappingUpdateManyWithWhereWithoutCategoryInput | NRPropSubCategoryMappingUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: NRPropSubCategoryMappingScalarWhereInput | NRPropSubCategoryMappingScalarWhereInput[]
  }

  export type PropertyAssessmentUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PropertyAssessmentCreateWithoutCategoryInput, PropertyAssessmentUncheckedCreateWithoutCategoryInput> | PropertyAssessmentCreateWithoutCategoryInput[] | PropertyAssessmentUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PropertyAssessmentCreateOrConnectWithoutCategoryInput | PropertyAssessmentCreateOrConnectWithoutCategoryInput[]
    upsert?: PropertyAssessmentUpsertWithWhereUniqueWithoutCategoryInput | PropertyAssessmentUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PropertyAssessmentCreateManyCategoryInputEnvelope
    set?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
    disconnect?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
    delete?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
    connect?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
    update?: PropertyAssessmentUpdateWithWhereUniqueWithoutCategoryInput | PropertyAssessmentUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PropertyAssessmentUpdateManyWithWhereWithoutCategoryInput | PropertyAssessmentUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PropertyAssessmentScalarWhereInput | PropertyAssessmentScalarWhereInput[]
  }

  export type NRPropCategoryMappingCreateNestedOneWithoutSubCategoriesInput = {
    create?: XOR<NRPropCategoryMappingCreateWithoutSubCategoriesInput, NRPropCategoryMappingUncheckedCreateWithoutSubCategoriesInput>
    connectOrCreate?: NRPropCategoryMappingCreateOrConnectWithoutSubCategoriesInput
    connect?: NRPropCategoryMappingWhereUniqueInput
  }

  export type PropertyAssessmentCreateNestedManyWithoutSubCategoryInput = {
    create?: XOR<PropertyAssessmentCreateWithoutSubCategoryInput, PropertyAssessmentUncheckedCreateWithoutSubCategoryInput> | PropertyAssessmentCreateWithoutSubCategoryInput[] | PropertyAssessmentUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: PropertyAssessmentCreateOrConnectWithoutSubCategoryInput | PropertyAssessmentCreateOrConnectWithoutSubCategoryInput[]
    createMany?: PropertyAssessmentCreateManySubCategoryInputEnvelope
    connect?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
  }

  export type PropertyAssessmentUncheckedCreateNestedManyWithoutSubCategoryInput = {
    create?: XOR<PropertyAssessmentCreateWithoutSubCategoryInput, PropertyAssessmentUncheckedCreateWithoutSubCategoryInput> | PropertyAssessmentCreateWithoutSubCategoryInput[] | PropertyAssessmentUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: PropertyAssessmentCreateOrConnectWithoutSubCategoryInput | PropertyAssessmentCreateOrConnectWithoutSubCategoryInput[]
    createMany?: PropertyAssessmentCreateManySubCategoryInputEnvelope
    connect?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
  }

  export type NRPropCategoryMappingUpdateOneRequiredWithoutSubCategoriesNestedInput = {
    create?: XOR<NRPropCategoryMappingCreateWithoutSubCategoriesInput, NRPropCategoryMappingUncheckedCreateWithoutSubCategoriesInput>
    connectOrCreate?: NRPropCategoryMappingCreateOrConnectWithoutSubCategoriesInput
    upsert?: NRPropCategoryMappingUpsertWithoutSubCategoriesInput
    connect?: NRPropCategoryMappingWhereUniqueInput
    update?: XOR<XOR<NRPropCategoryMappingUpdateToOneWithWhereWithoutSubCategoriesInput, NRPropCategoryMappingUpdateWithoutSubCategoriesInput>, NRPropCategoryMappingUncheckedUpdateWithoutSubCategoriesInput>
  }

  export type PropertyAssessmentUpdateManyWithoutSubCategoryNestedInput = {
    create?: XOR<PropertyAssessmentCreateWithoutSubCategoryInput, PropertyAssessmentUncheckedCreateWithoutSubCategoryInput> | PropertyAssessmentCreateWithoutSubCategoryInput[] | PropertyAssessmentUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: PropertyAssessmentCreateOrConnectWithoutSubCategoryInput | PropertyAssessmentCreateOrConnectWithoutSubCategoryInput[]
    upsert?: PropertyAssessmentUpsertWithWhereUniqueWithoutSubCategoryInput | PropertyAssessmentUpsertWithWhereUniqueWithoutSubCategoryInput[]
    createMany?: PropertyAssessmentCreateManySubCategoryInputEnvelope
    set?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
    disconnect?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
    delete?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
    connect?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
    update?: PropertyAssessmentUpdateWithWhereUniqueWithoutSubCategoryInput | PropertyAssessmentUpdateWithWhereUniqueWithoutSubCategoryInput[]
    updateMany?: PropertyAssessmentUpdateManyWithWhereWithoutSubCategoryInput | PropertyAssessmentUpdateManyWithWhereWithoutSubCategoryInput[]
    deleteMany?: PropertyAssessmentScalarWhereInput | PropertyAssessmentScalarWhereInput[]
  }

  export type PropertyAssessmentUncheckedUpdateManyWithoutSubCategoryNestedInput = {
    create?: XOR<PropertyAssessmentCreateWithoutSubCategoryInput, PropertyAssessmentUncheckedCreateWithoutSubCategoryInput> | PropertyAssessmentCreateWithoutSubCategoryInput[] | PropertyAssessmentUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: PropertyAssessmentCreateOrConnectWithoutSubCategoryInput | PropertyAssessmentCreateOrConnectWithoutSubCategoryInput[]
    upsert?: PropertyAssessmentUpsertWithWhereUniqueWithoutSubCategoryInput | PropertyAssessmentUpsertWithWhereUniqueWithoutSubCategoryInput[]
    createMany?: PropertyAssessmentCreateManySubCategoryInputEnvelope
    set?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
    disconnect?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
    delete?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
    connect?: PropertyAssessmentWhereUniqueInput | PropertyAssessmentWhereUniqueInput[]
    update?: PropertyAssessmentUpdateWithWhereUniqueWithoutSubCategoryInput | PropertyAssessmentUpdateWithWhereUniqueWithoutSubCategoryInput[]
    updateMany?: PropertyAssessmentUpdateManyWithWhereWithoutSubCategoryInput | PropertyAssessmentUpdateManyWithWhereWithoutSubCategoryInput[]
    deleteMany?: PropertyAssessmentScalarWhereInput | PropertyAssessmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSurveysInput = {
    create?: XOR<UserCreateWithoutSurveysInput, UserUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: UserCreateOrConnectWithoutSurveysInput
    connect?: UserWhereUniqueInput
  }

  export type ULBCreateNestedOneWithoutSurveysInput = {
    create?: XOR<ULBCreateWithoutSurveysInput, ULBUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: ULBCreateOrConnectWithoutSurveysInput
    connect?: ULBWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutSurveysInput = {
    create?: XOR<ZoneCreateWithoutSurveysInput, ZoneUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutSurveysInput
    connect?: ZoneWhereUniqueInput
  }

  export type WardCreateNestedOneWithoutSurveysInput = {
    create?: XOR<WardCreateWithoutSurveysInput, WardUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: WardCreateOrConnectWithoutSurveysInput
    connect?: WardWhereUniqueInput
  }

  export type MohallaCreateNestedOneWithoutSurveysInput = {
    create?: XOR<MohallaCreateWithoutSurveysInput, MohallaUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: MohallaCreateOrConnectWithoutSurveysInput
    connect?: MohallaWhereUniqueInput
  }

  export type PropertyDetailsCreateNestedOneWithoutSurveyInput = {
    create?: XOR<PropertyDetailsCreateWithoutSurveyInput, PropertyDetailsUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutSurveyInput
    connect?: PropertyDetailsWhereUniqueInput
  }

  export type OwnerDetailsCreateNestedOneWithoutSurveyInput = {
    create?: XOR<OwnerDetailsCreateWithoutSurveyInput, OwnerDetailsUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: OwnerDetailsCreateOrConnectWithoutSurveyInput
    connect?: OwnerDetailsWhereUniqueInput
  }

  export type LocationDetailsCreateNestedOneWithoutSurveyInput = {
    create?: XOR<LocationDetailsCreateWithoutSurveyInput, LocationDetailsUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutSurveyInput
    connect?: LocationDetailsWhereUniqueInput
  }

  export type OtherDetailsCreateNestedOneWithoutSurveyInput = {
    create?: XOR<OtherDetailsCreateWithoutSurveyInput, OtherDetailsUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: OtherDetailsCreateOrConnectWithoutSurveyInput
    connect?: OtherDetailsWhereUniqueInput
  }

  export type FloorDetailsCreateNestedManyWithoutSurveyInput = {
    create?: XOR<FloorDetailsCreateWithoutSurveyInput, FloorDetailsUncheckedCreateWithoutSurveyInput> | FloorDetailsCreateWithoutSurveyInput[] | FloorDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: FloorDetailsCreateOrConnectWithoutSurveyInput | FloorDetailsCreateOrConnectWithoutSurveyInput[]
    createMany?: FloorDetailsCreateManySurveyInputEnvelope
    connect?: FloorDetailsWhereUniqueInput | FloorDetailsWhereUniqueInput[]
  }

  export type PropertyAssessmentCreateNestedOneWithoutSurveyInput = {
    create?: XOR<PropertyAssessmentCreateWithoutSurveyInput, PropertyAssessmentUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: PropertyAssessmentCreateOrConnectWithoutSurveyInput
    connect?: PropertyAssessmentWhereUniqueInput
  }

  export type QCRecordCreateNestedOneWithoutSurveyInput = {
    create?: XOR<QCRecordCreateWithoutSurveyInput, QCRecordUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: QCRecordCreateOrConnectWithoutSurveyInput
    connect?: QCRecordWhereUniqueInput
  }

  export type PropertyAttachmentCreateNestedManyWithoutSurveyInput = {
    create?: XOR<PropertyAttachmentCreateWithoutSurveyInput, PropertyAttachmentUncheckedCreateWithoutSurveyInput> | PropertyAttachmentCreateWithoutSurveyInput[] | PropertyAttachmentUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: PropertyAttachmentCreateOrConnectWithoutSurveyInput | PropertyAttachmentCreateOrConnectWithoutSurveyInput[]
    createMany?: PropertyAttachmentCreateManySurveyInputEnvelope
    connect?: PropertyAttachmentWhereUniqueInput | PropertyAttachmentWhereUniqueInput[]
  }

  export type PropertyDetailsUncheckedCreateNestedOneWithoutSurveyInput = {
    create?: XOR<PropertyDetailsCreateWithoutSurveyInput, PropertyDetailsUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutSurveyInput
    connect?: PropertyDetailsWhereUniqueInput
  }

  export type OwnerDetailsUncheckedCreateNestedOneWithoutSurveyInput = {
    create?: XOR<OwnerDetailsCreateWithoutSurveyInput, OwnerDetailsUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: OwnerDetailsCreateOrConnectWithoutSurveyInput
    connect?: OwnerDetailsWhereUniqueInput
  }

  export type LocationDetailsUncheckedCreateNestedOneWithoutSurveyInput = {
    create?: XOR<LocationDetailsCreateWithoutSurveyInput, LocationDetailsUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutSurveyInput
    connect?: LocationDetailsWhereUniqueInput
  }

  export type OtherDetailsUncheckedCreateNestedOneWithoutSurveyInput = {
    create?: XOR<OtherDetailsCreateWithoutSurveyInput, OtherDetailsUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: OtherDetailsCreateOrConnectWithoutSurveyInput
    connect?: OtherDetailsWhereUniqueInput
  }

  export type FloorDetailsUncheckedCreateNestedManyWithoutSurveyInput = {
    create?: XOR<FloorDetailsCreateWithoutSurveyInput, FloorDetailsUncheckedCreateWithoutSurveyInput> | FloorDetailsCreateWithoutSurveyInput[] | FloorDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: FloorDetailsCreateOrConnectWithoutSurveyInput | FloorDetailsCreateOrConnectWithoutSurveyInput[]
    createMany?: FloorDetailsCreateManySurveyInputEnvelope
    connect?: FloorDetailsWhereUniqueInput | FloorDetailsWhereUniqueInput[]
  }

  export type PropertyAssessmentUncheckedCreateNestedOneWithoutSurveyInput = {
    create?: XOR<PropertyAssessmentCreateWithoutSurveyInput, PropertyAssessmentUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: PropertyAssessmentCreateOrConnectWithoutSurveyInput
    connect?: PropertyAssessmentWhereUniqueInput
  }

  export type QCRecordUncheckedCreateNestedOneWithoutSurveyInput = {
    create?: XOR<QCRecordCreateWithoutSurveyInput, QCRecordUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: QCRecordCreateOrConnectWithoutSurveyInput
    connect?: QCRecordWhereUniqueInput
  }

  export type PropertyAttachmentUncheckedCreateNestedManyWithoutSurveyInput = {
    create?: XOR<PropertyAttachmentCreateWithoutSurveyInput, PropertyAttachmentUncheckedCreateWithoutSurveyInput> | PropertyAttachmentCreateWithoutSurveyInput[] | PropertyAttachmentUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: PropertyAttachmentCreateOrConnectWithoutSurveyInput | PropertyAttachmentCreateOrConnectWithoutSurveyInput[]
    createMany?: PropertyAttachmentCreateManySurveyInputEnvelope
    connect?: PropertyAttachmentWhereUniqueInput | PropertyAttachmentWhereUniqueInput[]
  }

  export type EnumPropertyTypeFieldUpdateOperationsInput = {
    set?: $Enums.PropertyType
  }

  export type UserUpdateOneRequiredWithoutSurveysNestedInput = {
    create?: XOR<UserCreateWithoutSurveysInput, UserUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: UserCreateOrConnectWithoutSurveysInput
    upsert?: UserUpsertWithoutSurveysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSurveysInput, UserUpdateWithoutSurveysInput>, UserUncheckedUpdateWithoutSurveysInput>
  }

  export type ULBUpdateOneRequiredWithoutSurveysNestedInput = {
    create?: XOR<ULBCreateWithoutSurveysInput, ULBUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: ULBCreateOrConnectWithoutSurveysInput
    upsert?: ULBUpsertWithoutSurveysInput
    connect?: ULBWhereUniqueInput
    update?: XOR<XOR<ULBUpdateToOneWithWhereWithoutSurveysInput, ULBUpdateWithoutSurveysInput>, ULBUncheckedUpdateWithoutSurveysInput>
  }

  export type ZoneUpdateOneRequiredWithoutSurveysNestedInput = {
    create?: XOR<ZoneCreateWithoutSurveysInput, ZoneUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutSurveysInput
    upsert?: ZoneUpsertWithoutSurveysInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutSurveysInput, ZoneUpdateWithoutSurveysInput>, ZoneUncheckedUpdateWithoutSurveysInput>
  }

  export type WardUpdateOneRequiredWithoutSurveysNestedInput = {
    create?: XOR<WardCreateWithoutSurveysInput, WardUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: WardCreateOrConnectWithoutSurveysInput
    upsert?: WardUpsertWithoutSurveysInput
    connect?: WardWhereUniqueInput
    update?: XOR<XOR<WardUpdateToOneWithWhereWithoutSurveysInput, WardUpdateWithoutSurveysInput>, WardUncheckedUpdateWithoutSurveysInput>
  }

  export type MohallaUpdateOneRequiredWithoutSurveysNestedInput = {
    create?: XOR<MohallaCreateWithoutSurveysInput, MohallaUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: MohallaCreateOrConnectWithoutSurveysInput
    upsert?: MohallaUpsertWithoutSurveysInput
    connect?: MohallaWhereUniqueInput
    update?: XOR<XOR<MohallaUpdateToOneWithWhereWithoutSurveysInput, MohallaUpdateWithoutSurveysInput>, MohallaUncheckedUpdateWithoutSurveysInput>
  }

  export type PropertyDetailsUpdateOneWithoutSurveyNestedInput = {
    create?: XOR<PropertyDetailsCreateWithoutSurveyInput, PropertyDetailsUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutSurveyInput
    upsert?: PropertyDetailsUpsertWithoutSurveyInput
    disconnect?: PropertyDetailsWhereInput | boolean
    delete?: PropertyDetailsWhereInput | boolean
    connect?: PropertyDetailsWhereUniqueInput
    update?: XOR<XOR<PropertyDetailsUpdateToOneWithWhereWithoutSurveyInput, PropertyDetailsUpdateWithoutSurveyInput>, PropertyDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type OwnerDetailsUpdateOneWithoutSurveyNestedInput = {
    create?: XOR<OwnerDetailsCreateWithoutSurveyInput, OwnerDetailsUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: OwnerDetailsCreateOrConnectWithoutSurveyInput
    upsert?: OwnerDetailsUpsertWithoutSurveyInput
    disconnect?: OwnerDetailsWhereInput | boolean
    delete?: OwnerDetailsWhereInput | boolean
    connect?: OwnerDetailsWhereUniqueInput
    update?: XOR<XOR<OwnerDetailsUpdateToOneWithWhereWithoutSurveyInput, OwnerDetailsUpdateWithoutSurveyInput>, OwnerDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type LocationDetailsUpdateOneWithoutSurveyNestedInput = {
    create?: XOR<LocationDetailsCreateWithoutSurveyInput, LocationDetailsUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutSurveyInput
    upsert?: LocationDetailsUpsertWithoutSurveyInput
    disconnect?: LocationDetailsWhereInput | boolean
    delete?: LocationDetailsWhereInput | boolean
    connect?: LocationDetailsWhereUniqueInput
    update?: XOR<XOR<LocationDetailsUpdateToOneWithWhereWithoutSurveyInput, LocationDetailsUpdateWithoutSurveyInput>, LocationDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type OtherDetailsUpdateOneWithoutSurveyNestedInput = {
    create?: XOR<OtherDetailsCreateWithoutSurveyInput, OtherDetailsUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: OtherDetailsCreateOrConnectWithoutSurveyInput
    upsert?: OtherDetailsUpsertWithoutSurveyInput
    disconnect?: OtherDetailsWhereInput | boolean
    delete?: OtherDetailsWhereInput | boolean
    connect?: OtherDetailsWhereUniqueInput
    update?: XOR<XOR<OtherDetailsUpdateToOneWithWhereWithoutSurveyInput, OtherDetailsUpdateWithoutSurveyInput>, OtherDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type FloorDetailsUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<FloorDetailsCreateWithoutSurveyInput, FloorDetailsUncheckedCreateWithoutSurveyInput> | FloorDetailsCreateWithoutSurveyInput[] | FloorDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: FloorDetailsCreateOrConnectWithoutSurveyInput | FloorDetailsCreateOrConnectWithoutSurveyInput[]
    upsert?: FloorDetailsUpsertWithWhereUniqueWithoutSurveyInput | FloorDetailsUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: FloorDetailsCreateManySurveyInputEnvelope
    set?: FloorDetailsWhereUniqueInput | FloorDetailsWhereUniqueInput[]
    disconnect?: FloorDetailsWhereUniqueInput | FloorDetailsWhereUniqueInput[]
    delete?: FloorDetailsWhereUniqueInput | FloorDetailsWhereUniqueInput[]
    connect?: FloorDetailsWhereUniqueInput | FloorDetailsWhereUniqueInput[]
    update?: FloorDetailsUpdateWithWhereUniqueWithoutSurveyInput | FloorDetailsUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: FloorDetailsUpdateManyWithWhereWithoutSurveyInput | FloorDetailsUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: FloorDetailsScalarWhereInput | FloorDetailsScalarWhereInput[]
  }

  export type PropertyAssessmentUpdateOneWithoutSurveyNestedInput = {
    create?: XOR<PropertyAssessmentCreateWithoutSurveyInput, PropertyAssessmentUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: PropertyAssessmentCreateOrConnectWithoutSurveyInput
    upsert?: PropertyAssessmentUpsertWithoutSurveyInput
    disconnect?: PropertyAssessmentWhereInput | boolean
    delete?: PropertyAssessmentWhereInput | boolean
    connect?: PropertyAssessmentWhereUniqueInput
    update?: XOR<XOR<PropertyAssessmentUpdateToOneWithWhereWithoutSurveyInput, PropertyAssessmentUpdateWithoutSurveyInput>, PropertyAssessmentUncheckedUpdateWithoutSurveyInput>
  }

  export type QCRecordUpdateOneWithoutSurveyNestedInput = {
    create?: XOR<QCRecordCreateWithoutSurveyInput, QCRecordUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: QCRecordCreateOrConnectWithoutSurveyInput
    upsert?: QCRecordUpsertWithoutSurveyInput
    disconnect?: QCRecordWhereInput | boolean
    delete?: QCRecordWhereInput | boolean
    connect?: QCRecordWhereUniqueInput
    update?: XOR<XOR<QCRecordUpdateToOneWithWhereWithoutSurveyInput, QCRecordUpdateWithoutSurveyInput>, QCRecordUncheckedUpdateWithoutSurveyInput>
  }

  export type PropertyAttachmentUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<PropertyAttachmentCreateWithoutSurveyInput, PropertyAttachmentUncheckedCreateWithoutSurveyInput> | PropertyAttachmentCreateWithoutSurveyInput[] | PropertyAttachmentUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: PropertyAttachmentCreateOrConnectWithoutSurveyInput | PropertyAttachmentCreateOrConnectWithoutSurveyInput[]
    upsert?: PropertyAttachmentUpsertWithWhereUniqueWithoutSurveyInput | PropertyAttachmentUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: PropertyAttachmentCreateManySurveyInputEnvelope
    set?: PropertyAttachmentWhereUniqueInput | PropertyAttachmentWhereUniqueInput[]
    disconnect?: PropertyAttachmentWhereUniqueInput | PropertyAttachmentWhereUniqueInput[]
    delete?: PropertyAttachmentWhereUniqueInput | PropertyAttachmentWhereUniqueInput[]
    connect?: PropertyAttachmentWhereUniqueInput | PropertyAttachmentWhereUniqueInput[]
    update?: PropertyAttachmentUpdateWithWhereUniqueWithoutSurveyInput | PropertyAttachmentUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: PropertyAttachmentUpdateManyWithWhereWithoutSurveyInput | PropertyAttachmentUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: PropertyAttachmentScalarWhereInput | PropertyAttachmentScalarWhereInput[]
  }

  export type PropertyDetailsUncheckedUpdateOneWithoutSurveyNestedInput = {
    create?: XOR<PropertyDetailsCreateWithoutSurveyInput, PropertyDetailsUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: PropertyDetailsCreateOrConnectWithoutSurveyInput
    upsert?: PropertyDetailsUpsertWithoutSurveyInput
    disconnect?: PropertyDetailsWhereInput | boolean
    delete?: PropertyDetailsWhereInput | boolean
    connect?: PropertyDetailsWhereUniqueInput
    update?: XOR<XOR<PropertyDetailsUpdateToOneWithWhereWithoutSurveyInput, PropertyDetailsUpdateWithoutSurveyInput>, PropertyDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type OwnerDetailsUncheckedUpdateOneWithoutSurveyNestedInput = {
    create?: XOR<OwnerDetailsCreateWithoutSurveyInput, OwnerDetailsUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: OwnerDetailsCreateOrConnectWithoutSurveyInput
    upsert?: OwnerDetailsUpsertWithoutSurveyInput
    disconnect?: OwnerDetailsWhereInput | boolean
    delete?: OwnerDetailsWhereInput | boolean
    connect?: OwnerDetailsWhereUniqueInput
    update?: XOR<XOR<OwnerDetailsUpdateToOneWithWhereWithoutSurveyInput, OwnerDetailsUpdateWithoutSurveyInput>, OwnerDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type LocationDetailsUncheckedUpdateOneWithoutSurveyNestedInput = {
    create?: XOR<LocationDetailsCreateWithoutSurveyInput, LocationDetailsUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: LocationDetailsCreateOrConnectWithoutSurveyInput
    upsert?: LocationDetailsUpsertWithoutSurveyInput
    disconnect?: LocationDetailsWhereInput | boolean
    delete?: LocationDetailsWhereInput | boolean
    connect?: LocationDetailsWhereUniqueInput
    update?: XOR<XOR<LocationDetailsUpdateToOneWithWhereWithoutSurveyInput, LocationDetailsUpdateWithoutSurveyInput>, LocationDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type OtherDetailsUncheckedUpdateOneWithoutSurveyNestedInput = {
    create?: XOR<OtherDetailsCreateWithoutSurveyInput, OtherDetailsUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: OtherDetailsCreateOrConnectWithoutSurveyInput
    upsert?: OtherDetailsUpsertWithoutSurveyInput
    disconnect?: OtherDetailsWhereInput | boolean
    delete?: OtherDetailsWhereInput | boolean
    connect?: OtherDetailsWhereUniqueInput
    update?: XOR<XOR<OtherDetailsUpdateToOneWithWhereWithoutSurveyInput, OtherDetailsUpdateWithoutSurveyInput>, OtherDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type FloorDetailsUncheckedUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<FloorDetailsCreateWithoutSurveyInput, FloorDetailsUncheckedCreateWithoutSurveyInput> | FloorDetailsCreateWithoutSurveyInput[] | FloorDetailsUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: FloorDetailsCreateOrConnectWithoutSurveyInput | FloorDetailsCreateOrConnectWithoutSurveyInput[]
    upsert?: FloorDetailsUpsertWithWhereUniqueWithoutSurveyInput | FloorDetailsUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: FloorDetailsCreateManySurveyInputEnvelope
    set?: FloorDetailsWhereUniqueInput | FloorDetailsWhereUniqueInput[]
    disconnect?: FloorDetailsWhereUniqueInput | FloorDetailsWhereUniqueInput[]
    delete?: FloorDetailsWhereUniqueInput | FloorDetailsWhereUniqueInput[]
    connect?: FloorDetailsWhereUniqueInput | FloorDetailsWhereUniqueInput[]
    update?: FloorDetailsUpdateWithWhereUniqueWithoutSurveyInput | FloorDetailsUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: FloorDetailsUpdateManyWithWhereWithoutSurveyInput | FloorDetailsUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: FloorDetailsScalarWhereInput | FloorDetailsScalarWhereInput[]
  }

  export type PropertyAssessmentUncheckedUpdateOneWithoutSurveyNestedInput = {
    create?: XOR<PropertyAssessmentCreateWithoutSurveyInput, PropertyAssessmentUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: PropertyAssessmentCreateOrConnectWithoutSurveyInput
    upsert?: PropertyAssessmentUpsertWithoutSurveyInput
    disconnect?: PropertyAssessmentWhereInput | boolean
    delete?: PropertyAssessmentWhereInput | boolean
    connect?: PropertyAssessmentWhereUniqueInput
    update?: XOR<XOR<PropertyAssessmentUpdateToOneWithWhereWithoutSurveyInput, PropertyAssessmentUpdateWithoutSurveyInput>, PropertyAssessmentUncheckedUpdateWithoutSurveyInput>
  }

  export type QCRecordUncheckedUpdateOneWithoutSurveyNestedInput = {
    create?: XOR<QCRecordCreateWithoutSurveyInput, QCRecordUncheckedCreateWithoutSurveyInput>
    connectOrCreate?: QCRecordCreateOrConnectWithoutSurveyInput
    upsert?: QCRecordUpsertWithoutSurveyInput
    disconnect?: QCRecordWhereInput | boolean
    delete?: QCRecordWhereInput | boolean
    connect?: QCRecordWhereUniqueInput
    update?: XOR<XOR<QCRecordUpdateToOneWithWhereWithoutSurveyInput, QCRecordUpdateWithoutSurveyInput>, QCRecordUncheckedUpdateWithoutSurveyInput>
  }

  export type PropertyAttachmentUncheckedUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<PropertyAttachmentCreateWithoutSurveyInput, PropertyAttachmentUncheckedCreateWithoutSurveyInput> | PropertyAttachmentCreateWithoutSurveyInput[] | PropertyAttachmentUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: PropertyAttachmentCreateOrConnectWithoutSurveyInput | PropertyAttachmentCreateOrConnectWithoutSurveyInput[]
    upsert?: PropertyAttachmentUpsertWithWhereUniqueWithoutSurveyInput | PropertyAttachmentUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: PropertyAttachmentCreateManySurveyInputEnvelope
    set?: PropertyAttachmentWhereUniqueInput | PropertyAttachmentWhereUniqueInput[]
    disconnect?: PropertyAttachmentWhereUniqueInput | PropertyAttachmentWhereUniqueInput[]
    delete?: PropertyAttachmentWhereUniqueInput | PropertyAttachmentWhereUniqueInput[]
    connect?: PropertyAttachmentWhereUniqueInput | PropertyAttachmentWhereUniqueInput[]
    update?: PropertyAttachmentUpdateWithWhereUniqueWithoutSurveyInput | PropertyAttachmentUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: PropertyAttachmentUpdateManyWithWhereWithoutSurveyInput | PropertyAttachmentUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: PropertyAttachmentScalarWhereInput | PropertyAttachmentScalarWhereInput[]
  }

  export type SurveyCreateNestedOneWithoutPropertyInput = {
    create?: XOR<SurveyCreateWithoutPropertyInput, SurveyUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutPropertyInput
    connect?: SurveyWhereUniqueInput
  }

  export type PropertyResponseTypeCreateNestedOneWithoutSurveysInput = {
    create?: XOR<PropertyResponseTypeCreateWithoutSurveysInput, PropertyResponseTypeUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: PropertyResponseTypeCreateOrConnectWithoutSurveysInput
    connect?: PropertyResponseTypeWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SurveyUpdateOneRequiredWithoutPropertyNestedInput = {
    create?: XOR<SurveyCreateWithoutPropertyInput, SurveyUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutPropertyInput
    upsert?: SurveyUpsertWithoutPropertyInput
    connect?: SurveyWhereUniqueInput
    update?: XOR<XOR<SurveyUpdateToOneWithWhereWithoutPropertyInput, SurveyUpdateWithoutPropertyInput>, SurveyUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyResponseTypeUpdateOneRequiredWithoutSurveysNestedInput = {
    create?: XOR<PropertyResponseTypeCreateWithoutSurveysInput, PropertyResponseTypeUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: PropertyResponseTypeCreateOrConnectWithoutSurveysInput
    upsert?: PropertyResponseTypeUpsertWithoutSurveysInput
    connect?: PropertyResponseTypeWhereUniqueInput
    update?: XOR<XOR<PropertyResponseTypeUpdateToOneWithWhereWithoutSurveysInput, PropertyResponseTypeUpdateWithoutSurveysInput>, PropertyResponseTypeUncheckedUpdateWithoutSurveysInput>
  }

  export type SurveyCreateNestedOneWithoutOwnerInput = {
    create?: XOR<SurveyCreateWithoutOwnerInput, SurveyUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutOwnerInput
    connect?: SurveyWhereUniqueInput
  }

  export type SurveyUpdateOneRequiredWithoutOwnerNestedInput = {
    create?: XOR<SurveyCreateWithoutOwnerInput, SurveyUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutOwnerInput
    upsert?: SurveyUpsertWithoutOwnerInput
    connect?: SurveyWhereUniqueInput
    update?: XOR<XOR<SurveyUpdateToOneWithWhereWithoutOwnerInput, SurveyUpdateWithoutOwnerInput>, SurveyUncheckedUpdateWithoutOwnerInput>
  }

  export type SurveyCreateNestedOneWithoutLocationInput = {
    create?: XOR<SurveyCreateWithoutLocationInput, SurveyUncheckedCreateWithoutLocationInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutLocationInput
    connect?: SurveyWhereUniqueInput
  }

  export type RoadTypeMappingCreateNestedOneWithoutLocationsInput = {
    create?: XOR<RoadTypeMappingCreateWithoutLocationsInput, RoadTypeMappingUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: RoadTypeMappingCreateOrConnectWithoutLocationsInput
    connect?: RoadTypeMappingWhereUniqueInput
  }

  export type ConstructionTypeMappingCreateNestedOneWithoutLocationsInput = {
    create?: XOR<ConstructionTypeMappingCreateWithoutLocationsInput, ConstructionTypeMappingUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: ConstructionTypeMappingCreateOrConnectWithoutLocationsInput
    connect?: ConstructionTypeMappingWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SurveyUpdateOneRequiredWithoutLocationNestedInput = {
    create?: XOR<SurveyCreateWithoutLocationInput, SurveyUncheckedCreateWithoutLocationInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutLocationInput
    upsert?: SurveyUpsertWithoutLocationInput
    connect?: SurveyWhereUniqueInput
    update?: XOR<XOR<SurveyUpdateToOneWithWhereWithoutLocationInput, SurveyUpdateWithoutLocationInput>, SurveyUncheckedUpdateWithoutLocationInput>
  }

  export type RoadTypeMappingUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<RoadTypeMappingCreateWithoutLocationsInput, RoadTypeMappingUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: RoadTypeMappingCreateOrConnectWithoutLocationsInput
    upsert?: RoadTypeMappingUpsertWithoutLocationsInput
    connect?: RoadTypeMappingWhereUniqueInput
    update?: XOR<XOR<RoadTypeMappingUpdateToOneWithWhereWithoutLocationsInput, RoadTypeMappingUpdateWithoutLocationsInput>, RoadTypeMappingUncheckedUpdateWithoutLocationsInput>
  }

  export type ConstructionTypeMappingUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<ConstructionTypeMappingCreateWithoutLocationsInput, ConstructionTypeMappingUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: ConstructionTypeMappingCreateOrConnectWithoutLocationsInput
    upsert?: ConstructionTypeMappingUpsertWithoutLocationsInput
    connect?: ConstructionTypeMappingWhereUniqueInput
    update?: XOR<XOR<ConstructionTypeMappingUpdateToOneWithWhereWithoutLocationsInput, ConstructionTypeMappingUpdateWithoutLocationsInput>, ConstructionTypeMappingUncheckedUpdateWithoutLocationsInput>
  }

  export type SurveyCreateNestedOneWithoutOtherInput = {
    create?: XOR<SurveyCreateWithoutOtherInput, SurveyUncheckedCreateWithoutOtherInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutOtherInput
    connect?: SurveyWhereUniqueInput
  }

  export type SurveyUpdateOneRequiredWithoutOtherNestedInput = {
    create?: XOR<SurveyCreateWithoutOtherInput, SurveyUncheckedCreateWithoutOtherInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutOtherInput
    upsert?: SurveyUpsertWithoutOtherInput
    connect?: SurveyWhereUniqueInput
    update?: XOR<XOR<SurveyUpdateToOneWithWhereWithoutOtherInput, SurveyUpdateWithoutOtherInput>, SurveyUncheckedUpdateWithoutOtherInput>
  }

  export type SurveyCreateNestedOneWithoutFloorsInput = {
    create?: XOR<SurveyCreateWithoutFloorsInput, SurveyUncheckedCreateWithoutFloorsInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutFloorsInput
    connect?: SurveyWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SurveyUpdateOneRequiredWithoutFloorsNestedInput = {
    create?: XOR<SurveyCreateWithoutFloorsInput, SurveyUncheckedCreateWithoutFloorsInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutFloorsInput
    upsert?: SurveyUpsertWithoutFloorsInput
    connect?: SurveyWhereUniqueInput
    update?: XOR<XOR<SurveyUpdateToOneWithWhereWithoutFloorsInput, SurveyUpdateWithoutFloorsInput>, SurveyUncheckedUpdateWithoutFloorsInput>
  }

  export type SurveyCreateNestedOneWithoutAssessmentInput = {
    create?: XOR<SurveyCreateWithoutAssessmentInput, SurveyUncheckedCreateWithoutAssessmentInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutAssessmentInput
    connect?: SurveyWhereUniqueInput
  }

  export type NRPropCategoryMappingCreateNestedOneWithoutAssessmentsInput = {
    create?: XOR<NRPropCategoryMappingCreateWithoutAssessmentsInput, NRPropCategoryMappingUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: NRPropCategoryMappingCreateOrConnectWithoutAssessmentsInput
    connect?: NRPropCategoryMappingWhereUniqueInput
  }

  export type NRPropSubCategoryMappingCreateNestedOneWithoutAssessmentsInput = {
    create?: XOR<NRPropSubCategoryMappingCreateWithoutAssessmentsInput, NRPropSubCategoryMappingUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: NRPropSubCategoryMappingCreateOrConnectWithoutAssessmentsInput
    connect?: NRPropSubCategoryMappingWhereUniqueInput
  }

  export type SurveyUpdateOneRequiredWithoutAssessmentNestedInput = {
    create?: XOR<SurveyCreateWithoutAssessmentInput, SurveyUncheckedCreateWithoutAssessmentInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutAssessmentInput
    upsert?: SurveyUpsertWithoutAssessmentInput
    connect?: SurveyWhereUniqueInput
    update?: XOR<XOR<SurveyUpdateToOneWithWhereWithoutAssessmentInput, SurveyUpdateWithoutAssessmentInput>, SurveyUncheckedUpdateWithoutAssessmentInput>
  }

  export type NRPropCategoryMappingUpdateOneRequiredWithoutAssessmentsNestedInput = {
    create?: XOR<NRPropCategoryMappingCreateWithoutAssessmentsInput, NRPropCategoryMappingUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: NRPropCategoryMappingCreateOrConnectWithoutAssessmentsInput
    upsert?: NRPropCategoryMappingUpsertWithoutAssessmentsInput
    connect?: NRPropCategoryMappingWhereUniqueInput
    update?: XOR<XOR<NRPropCategoryMappingUpdateToOneWithWhereWithoutAssessmentsInput, NRPropCategoryMappingUpdateWithoutAssessmentsInput>, NRPropCategoryMappingUncheckedUpdateWithoutAssessmentsInput>
  }

  export type NRPropSubCategoryMappingUpdateOneRequiredWithoutAssessmentsNestedInput = {
    create?: XOR<NRPropSubCategoryMappingCreateWithoutAssessmentsInput, NRPropSubCategoryMappingUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: NRPropSubCategoryMappingCreateOrConnectWithoutAssessmentsInput
    upsert?: NRPropSubCategoryMappingUpsertWithoutAssessmentsInput
    connect?: NRPropSubCategoryMappingWhereUniqueInput
    update?: XOR<XOR<NRPropSubCategoryMappingUpdateToOneWithWhereWithoutAssessmentsInput, NRPropSubCategoryMappingUpdateWithoutAssessmentsInput>, NRPropSubCategoryMappingUncheckedUpdateWithoutAssessmentsInput>
  }

  export type SurveyCreateNestedOneWithoutQcRecordInput = {
    create?: XOR<SurveyCreateWithoutQcRecordInput, SurveyUncheckedCreateWithoutQcRecordInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutQcRecordInput
    connect?: SurveyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQcRecordsInput = {
    create?: XOR<UserCreateWithoutQcRecordsInput, UserUncheckedCreateWithoutQcRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQcRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type SurveyUpdateOneRequiredWithoutQcRecordNestedInput = {
    create?: XOR<SurveyCreateWithoutQcRecordInput, SurveyUncheckedCreateWithoutQcRecordInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutQcRecordInput
    upsert?: SurveyUpsertWithoutQcRecordInput
    connect?: SurveyWhereUniqueInput
    update?: XOR<XOR<SurveyUpdateToOneWithWhereWithoutQcRecordInput, SurveyUpdateWithoutQcRecordInput>, SurveyUncheckedUpdateWithoutQcRecordInput>
  }

  export type UserUpdateOneRequiredWithoutQcRecordsNestedInput = {
    create?: XOR<UserCreateWithoutQcRecordsInput, UserUncheckedCreateWithoutQcRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQcRecordsInput
    upsert?: UserUpsertWithoutQcRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQcRecordsInput, UserUpdateWithoutQcRecordsInput>, UserUncheckedUpdateWithoutQcRecordsInput>
  }

  export type SurveyCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<SurveyCreateWithoutAttachmentsInput, SurveyUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutAttachmentsInput
    connect?: SurveyWhereUniqueInput
  }

  export type SurveyUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<SurveyCreateWithoutAttachmentsInput, SurveyUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutAttachmentsInput
    upsert?: SurveyUpsertWithoutAttachmentsInput
    connect?: SurveyWhereUniqueInput
    update?: XOR<XOR<SurveyUpdateToOneWithWhereWithoutAttachmentsInput, SurveyUpdateWithoutAttachmentsInput>, SurveyUncheckedUpdateWithoutAttachmentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UserCreateWithoutCreatedUsersInput = {
    id?: string
    username: string
    password: string
    role: string
    phoneNumber: string
    assignedWards?: UserCreateassignedWardsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    surveys?: SurveyCreateNestedManyWithoutSurveyorInput
    qcRecords?: QCRecordCreateNestedManyWithoutQcOfficerInput
  }

  export type UserUncheckedCreateWithoutCreatedUsersInput = {
    id?: string
    username: string
    password: string
    role: string
    phoneNumber: string
    assignedWards?: UserCreateassignedWardsInput | string[]
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSurveyorInput
    qcRecords?: QCRecordUncheckedCreateNestedManyWithoutQcOfficerInput
  }

  export type UserCreateOrConnectWithoutCreatedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
  }

  export type UserCreateWithoutCreatedByInput = {
    id?: string
    username: string
    password: string
    role: string
    phoneNumber: string
    assignedWards?: UserCreateassignedWardsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    surveys?: SurveyCreateNestedManyWithoutSurveyorInput
    qcRecords?: QCRecordCreateNestedManyWithoutQcOfficerInput
  }

  export type UserUncheckedCreateWithoutCreatedByInput = {
    id?: string
    username: string
    password: string
    role: string
    phoneNumber: string
    assignedWards?: UserCreateassignedWardsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSurveyorInput
    qcRecords?: QCRecordUncheckedCreateNestedManyWithoutQcOfficerInput
  }

  export type UserCreateOrConnectWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserCreateManyCreatedByInputEnvelope = {
    data: UserCreateManyCreatedByInput | UserCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SurveyCreateWithoutSurveyorInput = {
    id?: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ulb: ULBCreateNestedOneWithoutSurveysInput
    zone: ZoneCreateNestedOneWithoutSurveysInput
    ward: WardCreateNestedOneWithoutSurveysInput
    mohalla: MohallaCreateNestedOneWithoutSurveysInput
    property?: PropertyDetailsCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutSurveyorInput = {
    id?: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyDetailsUncheckedCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsUncheckedCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsUncheckedCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsUncheckedCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsUncheckedCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentUncheckedCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordUncheckedCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutSurveyorInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutSurveyorInput, SurveyUncheckedCreateWithoutSurveyorInput>
  }

  export type SurveyCreateManySurveyorInputEnvelope = {
    data: SurveyCreateManySurveyorInput | SurveyCreateManySurveyorInput[]
    skipDuplicates?: boolean
  }

  export type QCRecordCreateWithoutQcOfficerInput = {
    id?: string
    status: string
    remarks?: string | null
    qcDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    survey: SurveyCreateNestedOneWithoutQcRecordInput
  }

  export type QCRecordUncheckedCreateWithoutQcOfficerInput = {
    id?: string
    surveyId: string
    status: string
    remarks?: string | null
    qcDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QCRecordCreateOrConnectWithoutQcOfficerInput = {
    where: QCRecordWhereUniqueInput
    create: XOR<QCRecordCreateWithoutQcOfficerInput, QCRecordUncheckedCreateWithoutQcOfficerInput>
  }

  export type QCRecordCreateManyQcOfficerInputEnvelope = {
    data: QCRecordCreateManyQcOfficerInput | QCRecordCreateManyQcOfficerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedUsersInput = {
    update: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    assignedWards?: UserUpdateassignedWardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    surveys?: SurveyUpdateManyWithoutSurveyorNestedInput
    qcRecords?: QCRecordUpdateManyWithoutQcOfficerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    assignedWards?: UserUpdateassignedWardsInput | string[]
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSurveyorNestedInput
    qcRecords?: QCRecordUncheckedUpdateManyWithoutQcOfficerNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
  }

  export type UserUpdateManyWithWhereWithoutCreatedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    phoneNumber?: StringFilter<"User"> | string
    assignedWards?: StringNullableListFilter<"User">
    createdById?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type SurveyUpsertWithWhereUniqueWithoutSurveyorInput = {
    where: SurveyWhereUniqueInput
    update: XOR<SurveyUpdateWithoutSurveyorInput, SurveyUncheckedUpdateWithoutSurveyorInput>
    create: XOR<SurveyCreateWithoutSurveyorInput, SurveyUncheckedCreateWithoutSurveyorInput>
  }

  export type SurveyUpdateWithWhereUniqueWithoutSurveyorInput = {
    where: SurveyWhereUniqueInput
    data: XOR<SurveyUpdateWithoutSurveyorInput, SurveyUncheckedUpdateWithoutSurveyorInput>
  }

  export type SurveyUpdateManyWithWhereWithoutSurveyorInput = {
    where: SurveyScalarWhereInput
    data: XOR<SurveyUpdateManyMutationInput, SurveyUncheckedUpdateManyWithoutSurveyorInput>
  }

  export type SurveyScalarWhereInput = {
    AND?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
    OR?: SurveyScalarWhereInput[]
    NOT?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
    id?: StringFilter<"Survey"> | string
    surveyorId?: StringFilter<"Survey"> | string
    ulbId?: StringFilter<"Survey"> | string
    zoneId?: StringFilter<"Survey"> | string
    wardId?: StringFilter<"Survey"> | string
    mohallaId?: StringFilter<"Survey"> | string
    dateOfEntry?: DateTimeFilter<"Survey"> | Date | string
    gisId?: StringFilter<"Survey"> | string
    mapId?: StringFilter<"Survey"> | string
    subGisId?: StringFilter<"Survey"> | string
    propertyType?: EnumPropertyTypeFilter<"Survey"> | $Enums.PropertyType
    status?: StringFilter<"Survey"> | string
    createdAt?: DateTimeFilter<"Survey"> | Date | string
    updatedAt?: DateTimeFilter<"Survey"> | Date | string
  }

  export type QCRecordUpsertWithWhereUniqueWithoutQcOfficerInput = {
    where: QCRecordWhereUniqueInput
    update: XOR<QCRecordUpdateWithoutQcOfficerInput, QCRecordUncheckedUpdateWithoutQcOfficerInput>
    create: XOR<QCRecordCreateWithoutQcOfficerInput, QCRecordUncheckedCreateWithoutQcOfficerInput>
  }

  export type QCRecordUpdateWithWhereUniqueWithoutQcOfficerInput = {
    where: QCRecordWhereUniqueInput
    data: XOR<QCRecordUpdateWithoutQcOfficerInput, QCRecordUncheckedUpdateWithoutQcOfficerInput>
  }

  export type QCRecordUpdateManyWithWhereWithoutQcOfficerInput = {
    where: QCRecordScalarWhereInput
    data: XOR<QCRecordUpdateManyMutationInput, QCRecordUncheckedUpdateManyWithoutQcOfficerInput>
  }

  export type QCRecordScalarWhereInput = {
    AND?: QCRecordScalarWhereInput | QCRecordScalarWhereInput[]
    OR?: QCRecordScalarWhereInput[]
    NOT?: QCRecordScalarWhereInput | QCRecordScalarWhereInput[]
    id?: StringFilter<"QCRecord"> | string
    surveyId?: StringFilter<"QCRecord"> | string
    qcOfficerId?: StringFilter<"QCRecord"> | string
    status?: StringFilter<"QCRecord"> | string
    remarks?: StringNullableFilter<"QCRecord"> | string | null
    qcDate?: DateTimeFilter<"QCRecord"> | Date | string
    createdAt?: DateTimeFilter<"QCRecord"> | Date | string
    updatedAt?: DateTimeFilter<"QCRecord"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    username: string
    password: string
    role: string
    phoneNumber: string
    assignedWards?: UserCreateassignedWardsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    surveys?: SurveyCreateNestedManyWithoutSurveyorInput
    qcRecords?: QCRecordCreateNestedManyWithoutQcOfficerInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    username: string
    password: string
    role: string
    phoneNumber: string
    assignedWards?: UserCreateassignedWardsInput | string[]
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSurveyorInput
    qcRecords?: QCRecordUncheckedCreateNestedManyWithoutQcOfficerInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    assignedWards?: UserUpdateassignedWardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    surveys?: SurveyUpdateManyWithoutSurveyorNestedInput
    qcRecords?: QCRecordUpdateManyWithoutQcOfficerNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    assignedWards?: UserUpdateassignedWardsInput | string[]
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSurveyorNestedInput
    qcRecords?: QCRecordUncheckedUpdateManyWithoutQcOfficerNestedInput
  }

  export type ZoneCreateWithoutUlbInput = {
    id?: string
    name: string
    wards?: WardCreateNestedManyWithoutZoneInput
    surveys?: SurveyCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutUlbInput = {
    id?: string
    name: string
    wards?: WardUncheckedCreateNestedManyWithoutZoneInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutUlbInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutUlbInput, ZoneUncheckedCreateWithoutUlbInput>
  }

  export type ZoneCreateManyUlbInputEnvelope = {
    data: ZoneCreateManyUlbInput | ZoneCreateManyUlbInput[]
    skipDuplicates?: boolean
  }

  export type SurveyCreateWithoutUlbInput = {
    id?: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyor: UserCreateNestedOneWithoutSurveysInput
    zone: ZoneCreateNestedOneWithoutSurveysInput
    ward: WardCreateNestedOneWithoutSurveysInput
    mohalla: MohallaCreateNestedOneWithoutSurveysInput
    property?: PropertyDetailsCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutUlbInput = {
    id?: string
    surveyorId: string
    zoneId: string
    wardId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyDetailsUncheckedCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsUncheckedCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsUncheckedCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsUncheckedCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsUncheckedCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentUncheckedCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordUncheckedCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutUlbInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutUlbInput, SurveyUncheckedCreateWithoutUlbInput>
  }

  export type SurveyCreateManyUlbInputEnvelope = {
    data: SurveyCreateManyUlbInput | SurveyCreateManyUlbInput[]
    skipDuplicates?: boolean
  }

  export type ZoneUpsertWithWhereUniqueWithoutUlbInput = {
    where: ZoneWhereUniqueInput
    update: XOR<ZoneUpdateWithoutUlbInput, ZoneUncheckedUpdateWithoutUlbInput>
    create: XOR<ZoneCreateWithoutUlbInput, ZoneUncheckedCreateWithoutUlbInput>
  }

  export type ZoneUpdateWithWhereUniqueWithoutUlbInput = {
    where: ZoneWhereUniqueInput
    data: XOR<ZoneUpdateWithoutUlbInput, ZoneUncheckedUpdateWithoutUlbInput>
  }

  export type ZoneUpdateManyWithWhereWithoutUlbInput = {
    where: ZoneScalarWhereInput
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyWithoutUlbInput>
  }

  export type ZoneScalarWhereInput = {
    AND?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
    OR?: ZoneScalarWhereInput[]
    NOT?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
    id?: StringFilter<"Zone"> | string
    name?: StringFilter<"Zone"> | string
    ulbId?: StringFilter<"Zone"> | string
  }

  export type SurveyUpsertWithWhereUniqueWithoutUlbInput = {
    where: SurveyWhereUniqueInput
    update: XOR<SurveyUpdateWithoutUlbInput, SurveyUncheckedUpdateWithoutUlbInput>
    create: XOR<SurveyCreateWithoutUlbInput, SurveyUncheckedCreateWithoutUlbInput>
  }

  export type SurveyUpdateWithWhereUniqueWithoutUlbInput = {
    where: SurveyWhereUniqueInput
    data: XOR<SurveyUpdateWithoutUlbInput, SurveyUncheckedUpdateWithoutUlbInput>
  }

  export type SurveyUpdateManyWithWhereWithoutUlbInput = {
    where: SurveyScalarWhereInput
    data: XOR<SurveyUpdateManyMutationInput, SurveyUncheckedUpdateManyWithoutUlbInput>
  }

  export type ULBCreateWithoutZonesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveys?: SurveyCreateNestedManyWithoutUlbInput
  }

  export type ULBUncheckedCreateWithoutZonesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveys?: SurveyUncheckedCreateNestedManyWithoutUlbInput
  }

  export type ULBCreateOrConnectWithoutZonesInput = {
    where: ULBWhereUniqueInput
    create: XOR<ULBCreateWithoutZonesInput, ULBUncheckedCreateWithoutZonesInput>
  }

  export type WardCreateWithoutZoneInput = {
    id?: string
    name: string
    mohallas?: MohallaCreateNestedManyWithoutWardInput
    surveys?: SurveyCreateNestedManyWithoutWardInput
  }

  export type WardUncheckedCreateWithoutZoneInput = {
    id?: string
    name: string
    mohallas?: MohallaUncheckedCreateNestedManyWithoutWardInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardCreateOrConnectWithoutZoneInput = {
    where: WardWhereUniqueInput
    create: XOR<WardCreateWithoutZoneInput, WardUncheckedCreateWithoutZoneInput>
  }

  export type WardCreateManyZoneInputEnvelope = {
    data: WardCreateManyZoneInput | WardCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type SurveyCreateWithoutZoneInput = {
    id?: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyor: UserCreateNestedOneWithoutSurveysInput
    ulb: ULBCreateNestedOneWithoutSurveysInput
    ward: WardCreateNestedOneWithoutSurveysInput
    mohalla: MohallaCreateNestedOneWithoutSurveysInput
    property?: PropertyDetailsCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutZoneInput = {
    id?: string
    surveyorId: string
    ulbId: string
    wardId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyDetailsUncheckedCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsUncheckedCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsUncheckedCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsUncheckedCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsUncheckedCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentUncheckedCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordUncheckedCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutZoneInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutZoneInput, SurveyUncheckedCreateWithoutZoneInput>
  }

  export type SurveyCreateManyZoneInputEnvelope = {
    data: SurveyCreateManyZoneInput | SurveyCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type ULBUpsertWithoutZonesInput = {
    update: XOR<ULBUpdateWithoutZonesInput, ULBUncheckedUpdateWithoutZonesInput>
    create: XOR<ULBCreateWithoutZonesInput, ULBUncheckedCreateWithoutZonesInput>
    where?: ULBWhereInput
  }

  export type ULBUpdateToOneWithWhereWithoutZonesInput = {
    where?: ULBWhereInput
    data: XOR<ULBUpdateWithoutZonesInput, ULBUncheckedUpdateWithoutZonesInput>
  }

  export type ULBUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveys?: SurveyUpdateManyWithoutUlbNestedInput
  }

  export type ULBUncheckedUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveys?: SurveyUncheckedUpdateManyWithoutUlbNestedInput
  }

  export type WardUpsertWithWhereUniqueWithoutZoneInput = {
    where: WardWhereUniqueInput
    update: XOR<WardUpdateWithoutZoneInput, WardUncheckedUpdateWithoutZoneInput>
    create: XOR<WardCreateWithoutZoneInput, WardUncheckedCreateWithoutZoneInput>
  }

  export type WardUpdateWithWhereUniqueWithoutZoneInput = {
    where: WardWhereUniqueInput
    data: XOR<WardUpdateWithoutZoneInput, WardUncheckedUpdateWithoutZoneInput>
  }

  export type WardUpdateManyWithWhereWithoutZoneInput = {
    where: WardScalarWhereInput
    data: XOR<WardUpdateManyMutationInput, WardUncheckedUpdateManyWithoutZoneInput>
  }

  export type WardScalarWhereInput = {
    AND?: WardScalarWhereInput | WardScalarWhereInput[]
    OR?: WardScalarWhereInput[]
    NOT?: WardScalarWhereInput | WardScalarWhereInput[]
    id?: StringFilter<"Ward"> | string
    name?: StringFilter<"Ward"> | string
    zoneId?: StringFilter<"Ward"> | string
  }

  export type SurveyUpsertWithWhereUniqueWithoutZoneInput = {
    where: SurveyWhereUniqueInput
    update: XOR<SurveyUpdateWithoutZoneInput, SurveyUncheckedUpdateWithoutZoneInput>
    create: XOR<SurveyCreateWithoutZoneInput, SurveyUncheckedCreateWithoutZoneInput>
  }

  export type SurveyUpdateWithWhereUniqueWithoutZoneInput = {
    where: SurveyWhereUniqueInput
    data: XOR<SurveyUpdateWithoutZoneInput, SurveyUncheckedUpdateWithoutZoneInput>
  }

  export type SurveyUpdateManyWithWhereWithoutZoneInput = {
    where: SurveyScalarWhereInput
    data: XOR<SurveyUpdateManyMutationInput, SurveyUncheckedUpdateManyWithoutZoneInput>
  }

  export type ZoneCreateWithoutWardsInput = {
    id?: string
    name: string
    ulb: ULBCreateNestedOneWithoutZonesInput
    surveys?: SurveyCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutWardsInput = {
    id?: string
    name: string
    ulbId: string
    surveys?: SurveyUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutWardsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutWardsInput, ZoneUncheckedCreateWithoutWardsInput>
  }

  export type MohallaCreateWithoutWardInput = {
    id?: string
    name: string
    surveys?: SurveyCreateNestedManyWithoutMohallaInput
  }

  export type MohallaUncheckedCreateWithoutWardInput = {
    id?: string
    name: string
    surveys?: SurveyUncheckedCreateNestedManyWithoutMohallaInput
  }

  export type MohallaCreateOrConnectWithoutWardInput = {
    where: MohallaWhereUniqueInput
    create: XOR<MohallaCreateWithoutWardInput, MohallaUncheckedCreateWithoutWardInput>
  }

  export type MohallaCreateManyWardInputEnvelope = {
    data: MohallaCreateManyWardInput | MohallaCreateManyWardInput[]
    skipDuplicates?: boolean
  }

  export type SurveyCreateWithoutWardInput = {
    id?: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyor: UserCreateNestedOneWithoutSurveysInput
    ulb: ULBCreateNestedOneWithoutSurveysInput
    zone: ZoneCreateNestedOneWithoutSurveysInput
    mohalla: MohallaCreateNestedOneWithoutSurveysInput
    property?: PropertyDetailsCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutWardInput = {
    id?: string
    surveyorId: string
    ulbId: string
    zoneId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyDetailsUncheckedCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsUncheckedCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsUncheckedCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsUncheckedCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsUncheckedCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentUncheckedCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordUncheckedCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutWardInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutWardInput, SurveyUncheckedCreateWithoutWardInput>
  }

  export type SurveyCreateManyWardInputEnvelope = {
    data: SurveyCreateManyWardInput | SurveyCreateManyWardInput[]
    skipDuplicates?: boolean
  }

  export type ZoneUpsertWithoutWardsInput = {
    update: XOR<ZoneUpdateWithoutWardsInput, ZoneUncheckedUpdateWithoutWardsInput>
    create: XOR<ZoneCreateWithoutWardsInput, ZoneUncheckedCreateWithoutWardsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutWardsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutWardsInput, ZoneUncheckedUpdateWithoutWardsInput>
  }

  export type ZoneUpdateWithoutWardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ulb?: ULBUpdateOneRequiredWithoutZonesNestedInput
    surveys?: SurveyUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutWardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    surveys?: SurveyUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type MohallaUpsertWithWhereUniqueWithoutWardInput = {
    where: MohallaWhereUniqueInput
    update: XOR<MohallaUpdateWithoutWardInput, MohallaUncheckedUpdateWithoutWardInput>
    create: XOR<MohallaCreateWithoutWardInput, MohallaUncheckedCreateWithoutWardInput>
  }

  export type MohallaUpdateWithWhereUniqueWithoutWardInput = {
    where: MohallaWhereUniqueInput
    data: XOR<MohallaUpdateWithoutWardInput, MohallaUncheckedUpdateWithoutWardInput>
  }

  export type MohallaUpdateManyWithWhereWithoutWardInput = {
    where: MohallaScalarWhereInput
    data: XOR<MohallaUpdateManyMutationInput, MohallaUncheckedUpdateManyWithoutWardInput>
  }

  export type MohallaScalarWhereInput = {
    AND?: MohallaScalarWhereInput | MohallaScalarWhereInput[]
    OR?: MohallaScalarWhereInput[]
    NOT?: MohallaScalarWhereInput | MohallaScalarWhereInput[]
    id?: StringFilter<"Mohalla"> | string
    name?: StringFilter<"Mohalla"> | string
    wardId?: StringFilter<"Mohalla"> | string
  }

  export type SurveyUpsertWithWhereUniqueWithoutWardInput = {
    where: SurveyWhereUniqueInput
    update: XOR<SurveyUpdateWithoutWardInput, SurveyUncheckedUpdateWithoutWardInput>
    create: XOR<SurveyCreateWithoutWardInput, SurveyUncheckedCreateWithoutWardInput>
  }

  export type SurveyUpdateWithWhereUniqueWithoutWardInput = {
    where: SurveyWhereUniqueInput
    data: XOR<SurveyUpdateWithoutWardInput, SurveyUncheckedUpdateWithoutWardInput>
  }

  export type SurveyUpdateManyWithWhereWithoutWardInput = {
    where: SurveyScalarWhereInput
    data: XOR<SurveyUpdateManyMutationInput, SurveyUncheckedUpdateManyWithoutWardInput>
  }

  export type WardCreateWithoutMohallasInput = {
    id?: string
    name: string
    zone: ZoneCreateNestedOneWithoutWardsInput
    surveys?: SurveyCreateNestedManyWithoutWardInput
  }

  export type WardUncheckedCreateWithoutMohallasInput = {
    id?: string
    name: string
    zoneId: string
    surveys?: SurveyUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardCreateOrConnectWithoutMohallasInput = {
    where: WardWhereUniqueInput
    create: XOR<WardCreateWithoutMohallasInput, WardUncheckedCreateWithoutMohallasInput>
  }

  export type SurveyCreateWithoutMohallaInput = {
    id?: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyor: UserCreateNestedOneWithoutSurveysInput
    ulb: ULBCreateNestedOneWithoutSurveysInput
    zone: ZoneCreateNestedOneWithoutSurveysInput
    ward: WardCreateNestedOneWithoutSurveysInput
    property?: PropertyDetailsCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutMohallaInput = {
    id?: string
    surveyorId: string
    ulbId: string
    zoneId: string
    wardId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyDetailsUncheckedCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsUncheckedCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsUncheckedCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsUncheckedCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsUncheckedCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentUncheckedCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordUncheckedCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutMohallaInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutMohallaInput, SurveyUncheckedCreateWithoutMohallaInput>
  }

  export type SurveyCreateManyMohallaInputEnvelope = {
    data: SurveyCreateManyMohallaInput | SurveyCreateManyMohallaInput[]
    skipDuplicates?: boolean
  }

  export type WardUpsertWithoutMohallasInput = {
    update: XOR<WardUpdateWithoutMohallasInput, WardUncheckedUpdateWithoutMohallasInput>
    create: XOR<WardCreateWithoutMohallasInput, WardUncheckedCreateWithoutMohallasInput>
    where?: WardWhereInput
  }

  export type WardUpdateToOneWithWhereWithoutMohallasInput = {
    where?: WardWhereInput
    data: XOR<WardUpdateWithoutMohallasInput, WardUncheckedUpdateWithoutMohallasInput>
  }

  export type WardUpdateWithoutMohallasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    zone?: ZoneUpdateOneRequiredWithoutWardsNestedInput
    surveys?: SurveyUpdateManyWithoutWardNestedInput
  }

  export type WardUncheckedUpdateWithoutMohallasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    surveys?: SurveyUncheckedUpdateManyWithoutWardNestedInput
  }

  export type SurveyUpsertWithWhereUniqueWithoutMohallaInput = {
    where: SurveyWhereUniqueInput
    update: XOR<SurveyUpdateWithoutMohallaInput, SurveyUncheckedUpdateWithoutMohallaInput>
    create: XOR<SurveyCreateWithoutMohallaInput, SurveyUncheckedCreateWithoutMohallaInput>
  }

  export type SurveyUpdateWithWhereUniqueWithoutMohallaInput = {
    where: SurveyWhereUniqueInput
    data: XOR<SurveyUpdateWithoutMohallaInput, SurveyUncheckedUpdateWithoutMohallaInput>
  }

  export type SurveyUpdateManyWithWhereWithoutMohallaInput = {
    where: SurveyScalarWhereInput
    data: XOR<SurveyUpdateManyMutationInput, SurveyUncheckedUpdateManyWithoutMohallaInput>
  }

  export type PropertyDetailsCreateWithoutResponseTypeInput = {
    id?: string
    houseNumber: string
    electricityNo: string
    wardSewerageNo: string
    respondentName: string
    isRented?: boolean
    rentAmount?: number | null
    tenantName?: string | null
    tenantMobile?: string | null
    tenantAadhaar?: string | null
    survey: SurveyCreateNestedOneWithoutPropertyInput
  }

  export type PropertyDetailsUncheckedCreateWithoutResponseTypeInput = {
    id?: string
    surveyId: string
    houseNumber: string
    electricityNo: string
    wardSewerageNo: string
    respondentName: string
    isRented?: boolean
    rentAmount?: number | null
    tenantName?: string | null
    tenantMobile?: string | null
    tenantAadhaar?: string | null
  }

  export type PropertyDetailsCreateOrConnectWithoutResponseTypeInput = {
    where: PropertyDetailsWhereUniqueInput
    create: XOR<PropertyDetailsCreateWithoutResponseTypeInput, PropertyDetailsUncheckedCreateWithoutResponseTypeInput>
  }

  export type PropertyDetailsCreateManyResponseTypeInputEnvelope = {
    data: PropertyDetailsCreateManyResponseTypeInput | PropertyDetailsCreateManyResponseTypeInput[]
    skipDuplicates?: boolean
  }

  export type PropertyDetailsUpsertWithWhereUniqueWithoutResponseTypeInput = {
    where: PropertyDetailsWhereUniqueInput
    update: XOR<PropertyDetailsUpdateWithoutResponseTypeInput, PropertyDetailsUncheckedUpdateWithoutResponseTypeInput>
    create: XOR<PropertyDetailsCreateWithoutResponseTypeInput, PropertyDetailsUncheckedCreateWithoutResponseTypeInput>
  }

  export type PropertyDetailsUpdateWithWhereUniqueWithoutResponseTypeInput = {
    where: PropertyDetailsWhereUniqueInput
    data: XOR<PropertyDetailsUpdateWithoutResponseTypeInput, PropertyDetailsUncheckedUpdateWithoutResponseTypeInput>
  }

  export type PropertyDetailsUpdateManyWithWhereWithoutResponseTypeInput = {
    where: PropertyDetailsScalarWhereInput
    data: XOR<PropertyDetailsUpdateManyMutationInput, PropertyDetailsUncheckedUpdateManyWithoutResponseTypeInput>
  }

  export type PropertyDetailsScalarWhereInput = {
    AND?: PropertyDetailsScalarWhereInput | PropertyDetailsScalarWhereInput[]
    OR?: PropertyDetailsScalarWhereInput[]
    NOT?: PropertyDetailsScalarWhereInput | PropertyDetailsScalarWhereInput[]
    id?: StringFilter<"PropertyDetails"> | string
    surveyId?: StringFilter<"PropertyDetails"> | string
    responseTypeId?: StringFilter<"PropertyDetails"> | string
    houseNumber?: StringFilter<"PropertyDetails"> | string
    electricityNo?: StringFilter<"PropertyDetails"> | string
    wardSewerageNo?: StringFilter<"PropertyDetails"> | string
    respondentName?: StringFilter<"PropertyDetails"> | string
    isRented?: BoolFilter<"PropertyDetails"> | boolean
    rentAmount?: FloatNullableFilter<"PropertyDetails"> | number | null
    tenantName?: StringNullableFilter<"PropertyDetails"> | string | null
    tenantMobile?: StringNullableFilter<"PropertyDetails"> | string | null
    tenantAadhaar?: StringNullableFilter<"PropertyDetails"> | string | null
  }

  export type LocationDetailsCreateWithoutRoadTypeInput = {
    id?: string
    latitude: number
    longitude: number
    assessmentYear: string
    constructionYear: string
    landmark: string
    address: string
    newWardNo: string
    plotArea: number
    builtUpArea: number
    survey: SurveyCreateNestedOneWithoutLocationInput
    constructionType: ConstructionTypeMappingCreateNestedOneWithoutLocationsInput
  }

  export type LocationDetailsUncheckedCreateWithoutRoadTypeInput = {
    id?: string
    surveyId: string
    latitude: number
    longitude: number
    assessmentYear: string
    constructionYear: string
    constructionTypeId: string
    landmark: string
    address: string
    newWardNo: string
    plotArea: number
    builtUpArea: number
  }

  export type LocationDetailsCreateOrConnectWithoutRoadTypeInput = {
    where: LocationDetailsWhereUniqueInput
    create: XOR<LocationDetailsCreateWithoutRoadTypeInput, LocationDetailsUncheckedCreateWithoutRoadTypeInput>
  }

  export type LocationDetailsCreateManyRoadTypeInputEnvelope = {
    data: LocationDetailsCreateManyRoadTypeInput | LocationDetailsCreateManyRoadTypeInput[]
    skipDuplicates?: boolean
  }

  export type LocationDetailsUpsertWithWhereUniqueWithoutRoadTypeInput = {
    where: LocationDetailsWhereUniqueInput
    update: XOR<LocationDetailsUpdateWithoutRoadTypeInput, LocationDetailsUncheckedUpdateWithoutRoadTypeInput>
    create: XOR<LocationDetailsCreateWithoutRoadTypeInput, LocationDetailsUncheckedCreateWithoutRoadTypeInput>
  }

  export type LocationDetailsUpdateWithWhereUniqueWithoutRoadTypeInput = {
    where: LocationDetailsWhereUniqueInput
    data: XOR<LocationDetailsUpdateWithoutRoadTypeInput, LocationDetailsUncheckedUpdateWithoutRoadTypeInput>
  }

  export type LocationDetailsUpdateManyWithWhereWithoutRoadTypeInput = {
    where: LocationDetailsScalarWhereInput
    data: XOR<LocationDetailsUpdateManyMutationInput, LocationDetailsUncheckedUpdateManyWithoutRoadTypeInput>
  }

  export type LocationDetailsScalarWhereInput = {
    AND?: LocationDetailsScalarWhereInput | LocationDetailsScalarWhereInput[]
    OR?: LocationDetailsScalarWhereInput[]
    NOT?: LocationDetailsScalarWhereInput | LocationDetailsScalarWhereInput[]
    id?: StringFilter<"LocationDetails"> | string
    surveyId?: StringFilter<"LocationDetails"> | string
    latitude?: FloatFilter<"LocationDetails"> | number
    longitude?: FloatFilter<"LocationDetails"> | number
    assessmentYear?: StringFilter<"LocationDetails"> | string
    roadTypeId?: StringFilter<"LocationDetails"> | string
    constructionYear?: StringFilter<"LocationDetails"> | string
    constructionTypeId?: StringFilter<"LocationDetails"> | string
    landmark?: StringFilter<"LocationDetails"> | string
    address?: StringFilter<"LocationDetails"> | string
    newWardNo?: StringFilter<"LocationDetails"> | string
    plotArea?: FloatFilter<"LocationDetails"> | number
    builtUpArea?: FloatFilter<"LocationDetails"> | number
  }

  export type LocationDetailsCreateWithoutConstructionTypeInput = {
    id?: string
    latitude: number
    longitude: number
    assessmentYear: string
    constructionYear: string
    landmark: string
    address: string
    newWardNo: string
    plotArea: number
    builtUpArea: number
    survey: SurveyCreateNestedOneWithoutLocationInput
    roadType: RoadTypeMappingCreateNestedOneWithoutLocationsInput
  }

  export type LocationDetailsUncheckedCreateWithoutConstructionTypeInput = {
    id?: string
    surveyId: string
    latitude: number
    longitude: number
    assessmentYear: string
    roadTypeId: string
    constructionYear: string
    landmark: string
    address: string
    newWardNo: string
    plotArea: number
    builtUpArea: number
  }

  export type LocationDetailsCreateOrConnectWithoutConstructionTypeInput = {
    where: LocationDetailsWhereUniqueInput
    create: XOR<LocationDetailsCreateWithoutConstructionTypeInput, LocationDetailsUncheckedCreateWithoutConstructionTypeInput>
  }

  export type LocationDetailsCreateManyConstructionTypeInputEnvelope = {
    data: LocationDetailsCreateManyConstructionTypeInput | LocationDetailsCreateManyConstructionTypeInput[]
    skipDuplicates?: boolean
  }

  export type LocationDetailsUpsertWithWhereUniqueWithoutConstructionTypeInput = {
    where: LocationDetailsWhereUniqueInput
    update: XOR<LocationDetailsUpdateWithoutConstructionTypeInput, LocationDetailsUncheckedUpdateWithoutConstructionTypeInput>
    create: XOR<LocationDetailsCreateWithoutConstructionTypeInput, LocationDetailsUncheckedCreateWithoutConstructionTypeInput>
  }

  export type LocationDetailsUpdateWithWhereUniqueWithoutConstructionTypeInput = {
    where: LocationDetailsWhereUniqueInput
    data: XOR<LocationDetailsUpdateWithoutConstructionTypeInput, LocationDetailsUncheckedUpdateWithoutConstructionTypeInput>
  }

  export type LocationDetailsUpdateManyWithWhereWithoutConstructionTypeInput = {
    where: LocationDetailsScalarWhereInput
    data: XOR<LocationDetailsUpdateManyMutationInput, LocationDetailsUncheckedUpdateManyWithoutConstructionTypeInput>
  }

  export type NRPropSubCategoryMappingCreateWithoutCategoryInput = {
    id?: string
    code: string
    description: string
    assessments?: PropertyAssessmentCreateNestedManyWithoutSubCategoryInput
  }

  export type NRPropSubCategoryMappingUncheckedCreateWithoutCategoryInput = {
    id?: string
    code: string
    description: string
    assessments?: PropertyAssessmentUncheckedCreateNestedManyWithoutSubCategoryInput
  }

  export type NRPropSubCategoryMappingCreateOrConnectWithoutCategoryInput = {
    where: NRPropSubCategoryMappingWhereUniqueInput
    create: XOR<NRPropSubCategoryMappingCreateWithoutCategoryInput, NRPropSubCategoryMappingUncheckedCreateWithoutCategoryInput>
  }

  export type NRPropSubCategoryMappingCreateManyCategoryInputEnvelope = {
    data: NRPropSubCategoryMappingCreateManyCategoryInput | NRPropSubCategoryMappingCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type PropertyAssessmentCreateWithoutCategoryInput = {
    id?: string
    annualRent: number
    marketValue: number
    assessedValue: number
    taxAmount: number
    remarks?: string | null
    survey: SurveyCreateNestedOneWithoutAssessmentInput
    subCategory: NRPropSubCategoryMappingCreateNestedOneWithoutAssessmentsInput
  }

  export type PropertyAssessmentUncheckedCreateWithoutCategoryInput = {
    id?: string
    surveyId: string
    subCategoryId: string
    annualRent: number
    marketValue: number
    assessedValue: number
    taxAmount: number
    remarks?: string | null
  }

  export type PropertyAssessmentCreateOrConnectWithoutCategoryInput = {
    where: PropertyAssessmentWhereUniqueInput
    create: XOR<PropertyAssessmentCreateWithoutCategoryInput, PropertyAssessmentUncheckedCreateWithoutCategoryInput>
  }

  export type PropertyAssessmentCreateManyCategoryInputEnvelope = {
    data: PropertyAssessmentCreateManyCategoryInput | PropertyAssessmentCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type NRPropSubCategoryMappingUpsertWithWhereUniqueWithoutCategoryInput = {
    where: NRPropSubCategoryMappingWhereUniqueInput
    update: XOR<NRPropSubCategoryMappingUpdateWithoutCategoryInput, NRPropSubCategoryMappingUncheckedUpdateWithoutCategoryInput>
    create: XOR<NRPropSubCategoryMappingCreateWithoutCategoryInput, NRPropSubCategoryMappingUncheckedCreateWithoutCategoryInput>
  }

  export type NRPropSubCategoryMappingUpdateWithWhereUniqueWithoutCategoryInput = {
    where: NRPropSubCategoryMappingWhereUniqueInput
    data: XOR<NRPropSubCategoryMappingUpdateWithoutCategoryInput, NRPropSubCategoryMappingUncheckedUpdateWithoutCategoryInput>
  }

  export type NRPropSubCategoryMappingUpdateManyWithWhereWithoutCategoryInput = {
    where: NRPropSubCategoryMappingScalarWhereInput
    data: XOR<NRPropSubCategoryMappingUpdateManyMutationInput, NRPropSubCategoryMappingUncheckedUpdateManyWithoutCategoryInput>
  }

  export type NRPropSubCategoryMappingScalarWhereInput = {
    AND?: NRPropSubCategoryMappingScalarWhereInput | NRPropSubCategoryMappingScalarWhereInput[]
    OR?: NRPropSubCategoryMappingScalarWhereInput[]
    NOT?: NRPropSubCategoryMappingScalarWhereInput | NRPropSubCategoryMappingScalarWhereInput[]
    id?: StringFilter<"NRPropSubCategoryMapping"> | string
    code?: StringFilter<"NRPropSubCategoryMapping"> | string
    description?: StringFilter<"NRPropSubCategoryMapping"> | string
    categoryId?: StringFilter<"NRPropSubCategoryMapping"> | string
  }

  export type PropertyAssessmentUpsertWithWhereUniqueWithoutCategoryInput = {
    where: PropertyAssessmentWhereUniqueInput
    update: XOR<PropertyAssessmentUpdateWithoutCategoryInput, PropertyAssessmentUncheckedUpdateWithoutCategoryInput>
    create: XOR<PropertyAssessmentCreateWithoutCategoryInput, PropertyAssessmentUncheckedCreateWithoutCategoryInput>
  }

  export type PropertyAssessmentUpdateWithWhereUniqueWithoutCategoryInput = {
    where: PropertyAssessmentWhereUniqueInput
    data: XOR<PropertyAssessmentUpdateWithoutCategoryInput, PropertyAssessmentUncheckedUpdateWithoutCategoryInput>
  }

  export type PropertyAssessmentUpdateManyWithWhereWithoutCategoryInput = {
    where: PropertyAssessmentScalarWhereInput
    data: XOR<PropertyAssessmentUpdateManyMutationInput, PropertyAssessmentUncheckedUpdateManyWithoutCategoryInput>
  }

  export type PropertyAssessmentScalarWhereInput = {
    AND?: PropertyAssessmentScalarWhereInput | PropertyAssessmentScalarWhereInput[]
    OR?: PropertyAssessmentScalarWhereInput[]
    NOT?: PropertyAssessmentScalarWhereInput | PropertyAssessmentScalarWhereInput[]
    id?: StringFilter<"PropertyAssessment"> | string
    surveyId?: StringFilter<"PropertyAssessment"> | string
    categoryId?: StringFilter<"PropertyAssessment"> | string
    subCategoryId?: StringFilter<"PropertyAssessment"> | string
    annualRent?: FloatFilter<"PropertyAssessment"> | number
    marketValue?: FloatFilter<"PropertyAssessment"> | number
    assessedValue?: FloatFilter<"PropertyAssessment"> | number
    taxAmount?: FloatFilter<"PropertyAssessment"> | number
    remarks?: StringNullableFilter<"PropertyAssessment"> | string | null
  }

  export type NRPropCategoryMappingCreateWithoutSubCategoriesInput = {
    id?: string
    code: string
    description: string
    assessments?: PropertyAssessmentCreateNestedManyWithoutCategoryInput
  }

  export type NRPropCategoryMappingUncheckedCreateWithoutSubCategoriesInput = {
    id?: string
    code: string
    description: string
    assessments?: PropertyAssessmentUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type NRPropCategoryMappingCreateOrConnectWithoutSubCategoriesInput = {
    where: NRPropCategoryMappingWhereUniqueInput
    create: XOR<NRPropCategoryMappingCreateWithoutSubCategoriesInput, NRPropCategoryMappingUncheckedCreateWithoutSubCategoriesInput>
  }

  export type PropertyAssessmentCreateWithoutSubCategoryInput = {
    id?: string
    annualRent: number
    marketValue: number
    assessedValue: number
    taxAmount: number
    remarks?: string | null
    survey: SurveyCreateNestedOneWithoutAssessmentInput
    category: NRPropCategoryMappingCreateNestedOneWithoutAssessmentsInput
  }

  export type PropertyAssessmentUncheckedCreateWithoutSubCategoryInput = {
    id?: string
    surveyId: string
    categoryId: string
    annualRent: number
    marketValue: number
    assessedValue: number
    taxAmount: number
    remarks?: string | null
  }

  export type PropertyAssessmentCreateOrConnectWithoutSubCategoryInput = {
    where: PropertyAssessmentWhereUniqueInput
    create: XOR<PropertyAssessmentCreateWithoutSubCategoryInput, PropertyAssessmentUncheckedCreateWithoutSubCategoryInput>
  }

  export type PropertyAssessmentCreateManySubCategoryInputEnvelope = {
    data: PropertyAssessmentCreateManySubCategoryInput | PropertyAssessmentCreateManySubCategoryInput[]
    skipDuplicates?: boolean
  }

  export type NRPropCategoryMappingUpsertWithoutSubCategoriesInput = {
    update: XOR<NRPropCategoryMappingUpdateWithoutSubCategoriesInput, NRPropCategoryMappingUncheckedUpdateWithoutSubCategoriesInput>
    create: XOR<NRPropCategoryMappingCreateWithoutSubCategoriesInput, NRPropCategoryMappingUncheckedCreateWithoutSubCategoriesInput>
    where?: NRPropCategoryMappingWhereInput
  }

  export type NRPropCategoryMappingUpdateToOneWithWhereWithoutSubCategoriesInput = {
    where?: NRPropCategoryMappingWhereInput
    data: XOR<NRPropCategoryMappingUpdateWithoutSubCategoriesInput, NRPropCategoryMappingUncheckedUpdateWithoutSubCategoriesInput>
  }

  export type NRPropCategoryMappingUpdateWithoutSubCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    assessments?: PropertyAssessmentUpdateManyWithoutCategoryNestedInput
  }

  export type NRPropCategoryMappingUncheckedUpdateWithoutSubCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    assessments?: PropertyAssessmentUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type PropertyAssessmentUpsertWithWhereUniqueWithoutSubCategoryInput = {
    where: PropertyAssessmentWhereUniqueInput
    update: XOR<PropertyAssessmentUpdateWithoutSubCategoryInput, PropertyAssessmentUncheckedUpdateWithoutSubCategoryInput>
    create: XOR<PropertyAssessmentCreateWithoutSubCategoryInput, PropertyAssessmentUncheckedCreateWithoutSubCategoryInput>
  }

  export type PropertyAssessmentUpdateWithWhereUniqueWithoutSubCategoryInput = {
    where: PropertyAssessmentWhereUniqueInput
    data: XOR<PropertyAssessmentUpdateWithoutSubCategoryInput, PropertyAssessmentUncheckedUpdateWithoutSubCategoryInput>
  }

  export type PropertyAssessmentUpdateManyWithWhereWithoutSubCategoryInput = {
    where: PropertyAssessmentScalarWhereInput
    data: XOR<PropertyAssessmentUpdateManyMutationInput, PropertyAssessmentUncheckedUpdateManyWithoutSubCategoryInput>
  }

  export type UserCreateWithoutSurveysInput = {
    id?: string
    username: string
    password: string
    role: string
    phoneNumber: string
    assignedWards?: UserCreateassignedWardsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    qcRecords?: QCRecordCreateNestedManyWithoutQcOfficerInput
  }

  export type UserUncheckedCreateWithoutSurveysInput = {
    id?: string
    username: string
    password: string
    role: string
    phoneNumber: string
    assignedWards?: UserCreateassignedWardsInput | string[]
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    qcRecords?: QCRecordUncheckedCreateNestedManyWithoutQcOfficerInput
  }

  export type UserCreateOrConnectWithoutSurveysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSurveysInput, UserUncheckedCreateWithoutSurveysInput>
  }

  export type ULBCreateWithoutSurveysInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: ZoneCreateNestedManyWithoutUlbInput
  }

  export type ULBUncheckedCreateWithoutSurveysInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: ZoneUncheckedCreateNestedManyWithoutUlbInput
  }

  export type ULBCreateOrConnectWithoutSurveysInput = {
    where: ULBWhereUniqueInput
    create: XOR<ULBCreateWithoutSurveysInput, ULBUncheckedCreateWithoutSurveysInput>
  }

  export type ZoneCreateWithoutSurveysInput = {
    id?: string
    name: string
    ulb: ULBCreateNestedOneWithoutZonesInput
    wards?: WardCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutSurveysInput = {
    id?: string
    name: string
    ulbId: string
    wards?: WardUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutSurveysInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutSurveysInput, ZoneUncheckedCreateWithoutSurveysInput>
  }

  export type WardCreateWithoutSurveysInput = {
    id?: string
    name: string
    zone: ZoneCreateNestedOneWithoutWardsInput
    mohallas?: MohallaCreateNestedManyWithoutWardInput
  }

  export type WardUncheckedCreateWithoutSurveysInput = {
    id?: string
    name: string
    zoneId: string
    mohallas?: MohallaUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardCreateOrConnectWithoutSurveysInput = {
    where: WardWhereUniqueInput
    create: XOR<WardCreateWithoutSurveysInput, WardUncheckedCreateWithoutSurveysInput>
  }

  export type MohallaCreateWithoutSurveysInput = {
    id?: string
    name: string
    ward: WardCreateNestedOneWithoutMohallasInput
  }

  export type MohallaUncheckedCreateWithoutSurveysInput = {
    id?: string
    name: string
    wardId: string
  }

  export type MohallaCreateOrConnectWithoutSurveysInput = {
    where: MohallaWhereUniqueInput
    create: XOR<MohallaCreateWithoutSurveysInput, MohallaUncheckedCreateWithoutSurveysInput>
  }

  export type PropertyDetailsCreateWithoutSurveyInput = {
    id?: string
    houseNumber: string
    electricityNo: string
    wardSewerageNo: string
    respondentName: string
    isRented?: boolean
    rentAmount?: number | null
    tenantName?: string | null
    tenantMobile?: string | null
    tenantAadhaar?: string | null
    responseType: PropertyResponseTypeCreateNestedOneWithoutSurveysInput
  }

  export type PropertyDetailsUncheckedCreateWithoutSurveyInput = {
    id?: string
    responseTypeId: string
    houseNumber: string
    electricityNo: string
    wardSewerageNo: string
    respondentName: string
    isRented?: boolean
    rentAmount?: number | null
    tenantName?: string | null
    tenantMobile?: string | null
    tenantAadhaar?: string | null
  }

  export type PropertyDetailsCreateOrConnectWithoutSurveyInput = {
    where: PropertyDetailsWhereUniqueInput
    create: XOR<PropertyDetailsCreateWithoutSurveyInput, PropertyDetailsUncheckedCreateWithoutSurveyInput>
  }

  export type OwnerDetailsCreateWithoutSurveyInput = {
    id?: string
    ownerName: string
    fatherHusbandName: string
    mobileNo: string
    aadhaarNo: string
    email?: string | null
    alternateMobile?: string | null
    isNRI?: boolean
    nriAddress?: string | null
  }

  export type OwnerDetailsUncheckedCreateWithoutSurveyInput = {
    id?: string
    ownerName: string
    fatherHusbandName: string
    mobileNo: string
    aadhaarNo: string
    email?: string | null
    alternateMobile?: string | null
    isNRI?: boolean
    nriAddress?: string | null
  }

  export type OwnerDetailsCreateOrConnectWithoutSurveyInput = {
    where: OwnerDetailsWhereUniqueInput
    create: XOR<OwnerDetailsCreateWithoutSurveyInput, OwnerDetailsUncheckedCreateWithoutSurveyInput>
  }

  export type LocationDetailsCreateWithoutSurveyInput = {
    id?: string
    latitude: number
    longitude: number
    assessmentYear: string
    constructionYear: string
    landmark: string
    address: string
    newWardNo: string
    plotArea: number
    builtUpArea: number
    roadType: RoadTypeMappingCreateNestedOneWithoutLocationsInput
    constructionType: ConstructionTypeMappingCreateNestedOneWithoutLocationsInput
  }

  export type LocationDetailsUncheckedCreateWithoutSurveyInput = {
    id?: string
    latitude: number
    longitude: number
    assessmentYear: string
    roadTypeId: string
    constructionYear: string
    constructionTypeId: string
    landmark: string
    address: string
    newWardNo: string
    plotArea: number
    builtUpArea: number
  }

  export type LocationDetailsCreateOrConnectWithoutSurveyInput = {
    where: LocationDetailsWhereUniqueInput
    create: XOR<LocationDetailsCreateWithoutSurveyInput, LocationDetailsUncheckedCreateWithoutSurveyInput>
  }

  export type OtherDetailsCreateWithoutSurveyInput = {
    id?: string
    rainHarvesting: boolean
    waterSupply: string
    sewerageLine: string
    parkingType: string
    parkingArea?: number | null
    isCommercial?: boolean
    commercialArea?: number | null
  }

  export type OtherDetailsUncheckedCreateWithoutSurveyInput = {
    id?: string
    rainHarvesting: boolean
    waterSupply: string
    sewerageLine: string
    parkingType: string
    parkingArea?: number | null
    isCommercial?: boolean
    commercialArea?: number | null
  }

  export type OtherDetailsCreateOrConnectWithoutSurveyInput = {
    where: OtherDetailsWhereUniqueInput
    create: XOR<OtherDetailsCreateWithoutSurveyInput, OtherDetailsUncheckedCreateWithoutSurveyInput>
  }

  export type FloorDetailsCreateWithoutSurveyInput = {
    id?: string
    floorNo: number
    floorType: string
    details: string
    area: number
    usage: string
    isRented?: boolean
    rentAmount?: number | null
  }

  export type FloorDetailsUncheckedCreateWithoutSurveyInput = {
    id?: string
    floorNo: number
    floorType: string
    details: string
    area: number
    usage: string
    isRented?: boolean
    rentAmount?: number | null
  }

  export type FloorDetailsCreateOrConnectWithoutSurveyInput = {
    where: FloorDetailsWhereUniqueInput
    create: XOR<FloorDetailsCreateWithoutSurveyInput, FloorDetailsUncheckedCreateWithoutSurveyInput>
  }

  export type FloorDetailsCreateManySurveyInputEnvelope = {
    data: FloorDetailsCreateManySurveyInput | FloorDetailsCreateManySurveyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyAssessmentCreateWithoutSurveyInput = {
    id?: string
    annualRent: number
    marketValue: number
    assessedValue: number
    taxAmount: number
    remarks?: string | null
    category: NRPropCategoryMappingCreateNestedOneWithoutAssessmentsInput
    subCategory: NRPropSubCategoryMappingCreateNestedOneWithoutAssessmentsInput
  }

  export type PropertyAssessmentUncheckedCreateWithoutSurveyInput = {
    id?: string
    categoryId: string
    subCategoryId: string
    annualRent: number
    marketValue: number
    assessedValue: number
    taxAmount: number
    remarks?: string | null
  }

  export type PropertyAssessmentCreateOrConnectWithoutSurveyInput = {
    where: PropertyAssessmentWhereUniqueInput
    create: XOR<PropertyAssessmentCreateWithoutSurveyInput, PropertyAssessmentUncheckedCreateWithoutSurveyInput>
  }

  export type QCRecordCreateWithoutSurveyInput = {
    id?: string
    status: string
    remarks?: string | null
    qcDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    qcOfficer: UserCreateNestedOneWithoutQcRecordsInput
  }

  export type QCRecordUncheckedCreateWithoutSurveyInput = {
    id?: string
    qcOfficerId: string
    status: string
    remarks?: string | null
    qcDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QCRecordCreateOrConnectWithoutSurveyInput = {
    where: QCRecordWhereUniqueInput
    create: XOR<QCRecordCreateWithoutSurveyInput, QCRecordUncheckedCreateWithoutSurveyInput>
  }

  export type PropertyAttachmentCreateWithoutSurveyInput = {
    id?: string
    type: string
    url: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PropertyAttachmentUncheckedCreateWithoutSurveyInput = {
    id?: string
    type: string
    url: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PropertyAttachmentCreateOrConnectWithoutSurveyInput = {
    where: PropertyAttachmentWhereUniqueInput
    create: XOR<PropertyAttachmentCreateWithoutSurveyInput, PropertyAttachmentUncheckedCreateWithoutSurveyInput>
  }

  export type PropertyAttachmentCreateManySurveyInputEnvelope = {
    data: PropertyAttachmentCreateManySurveyInput | PropertyAttachmentCreateManySurveyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSurveysInput = {
    update: XOR<UserUpdateWithoutSurveysInput, UserUncheckedUpdateWithoutSurveysInput>
    create: XOR<UserCreateWithoutSurveysInput, UserUncheckedCreateWithoutSurveysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSurveysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSurveysInput, UserUncheckedUpdateWithoutSurveysInput>
  }

  export type UserUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    assignedWards?: UserUpdateassignedWardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    qcRecords?: QCRecordUpdateManyWithoutQcOfficerNestedInput
  }

  export type UserUncheckedUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    assignedWards?: UserUpdateassignedWardsInput | string[]
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    qcRecords?: QCRecordUncheckedUpdateManyWithoutQcOfficerNestedInput
  }

  export type ULBUpsertWithoutSurveysInput = {
    update: XOR<ULBUpdateWithoutSurveysInput, ULBUncheckedUpdateWithoutSurveysInput>
    create: XOR<ULBCreateWithoutSurveysInput, ULBUncheckedCreateWithoutSurveysInput>
    where?: ULBWhereInput
  }

  export type ULBUpdateToOneWithWhereWithoutSurveysInput = {
    where?: ULBWhereInput
    data: XOR<ULBUpdateWithoutSurveysInput, ULBUncheckedUpdateWithoutSurveysInput>
  }

  export type ULBUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: ZoneUpdateManyWithoutUlbNestedInput
  }

  export type ULBUncheckedUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: ZoneUncheckedUpdateManyWithoutUlbNestedInput
  }

  export type ZoneUpsertWithoutSurveysInput = {
    update: XOR<ZoneUpdateWithoutSurveysInput, ZoneUncheckedUpdateWithoutSurveysInput>
    create: XOR<ZoneCreateWithoutSurveysInput, ZoneUncheckedCreateWithoutSurveysInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutSurveysInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutSurveysInput, ZoneUncheckedUpdateWithoutSurveysInput>
  }

  export type ZoneUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ulb?: ULBUpdateOneRequiredWithoutZonesNestedInput
    wards?: WardUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    wards?: WardUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type WardUpsertWithoutSurveysInput = {
    update: XOR<WardUpdateWithoutSurveysInput, WardUncheckedUpdateWithoutSurveysInput>
    create: XOR<WardCreateWithoutSurveysInput, WardUncheckedCreateWithoutSurveysInput>
    where?: WardWhereInput
  }

  export type WardUpdateToOneWithWhereWithoutSurveysInput = {
    where?: WardWhereInput
    data: XOR<WardUpdateWithoutSurveysInput, WardUncheckedUpdateWithoutSurveysInput>
  }

  export type WardUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    zone?: ZoneUpdateOneRequiredWithoutWardsNestedInput
    mohallas?: MohallaUpdateManyWithoutWardNestedInput
  }

  export type WardUncheckedUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    mohallas?: MohallaUncheckedUpdateManyWithoutWardNestedInput
  }

  export type MohallaUpsertWithoutSurveysInput = {
    update: XOR<MohallaUpdateWithoutSurveysInput, MohallaUncheckedUpdateWithoutSurveysInput>
    create: XOR<MohallaCreateWithoutSurveysInput, MohallaUncheckedCreateWithoutSurveysInput>
    where?: MohallaWhereInput
  }

  export type MohallaUpdateToOneWithWhereWithoutSurveysInput = {
    where?: MohallaWhereInput
    data: XOR<MohallaUpdateWithoutSurveysInput, MohallaUncheckedUpdateWithoutSurveysInput>
  }

  export type MohallaUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ward?: WardUpdateOneRequiredWithoutMohallasNestedInput
  }

  export type MohallaUncheckedUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyDetailsUpsertWithoutSurveyInput = {
    update: XOR<PropertyDetailsUpdateWithoutSurveyInput, PropertyDetailsUncheckedUpdateWithoutSurveyInput>
    create: XOR<PropertyDetailsCreateWithoutSurveyInput, PropertyDetailsUncheckedCreateWithoutSurveyInput>
    where?: PropertyDetailsWhereInput
  }

  export type PropertyDetailsUpdateToOneWithWhereWithoutSurveyInput = {
    where?: PropertyDetailsWhereInput
    data: XOR<PropertyDetailsUpdateWithoutSurveyInput, PropertyDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type PropertyDetailsUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    electricityNo?: StringFieldUpdateOperationsInput | string
    wardSewerageNo?: StringFieldUpdateOperationsInput | string
    respondentName?: StringFieldUpdateOperationsInput | string
    isRented?: BoolFieldUpdateOperationsInput | boolean
    rentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantName?: NullableStringFieldUpdateOperationsInput | string | null
    tenantMobile?: NullableStringFieldUpdateOperationsInput | string | null
    tenantAadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    responseType?: PropertyResponseTypeUpdateOneRequiredWithoutSurveysNestedInput
  }

  export type PropertyDetailsUncheckedUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseTypeId?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    electricityNo?: StringFieldUpdateOperationsInput | string
    wardSewerageNo?: StringFieldUpdateOperationsInput | string
    respondentName?: StringFieldUpdateOperationsInput | string
    isRented?: BoolFieldUpdateOperationsInput | boolean
    rentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantName?: NullableStringFieldUpdateOperationsInput | string | null
    tenantMobile?: NullableStringFieldUpdateOperationsInput | string | null
    tenantAadhaar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OwnerDetailsUpsertWithoutSurveyInput = {
    update: XOR<OwnerDetailsUpdateWithoutSurveyInput, OwnerDetailsUncheckedUpdateWithoutSurveyInput>
    create: XOR<OwnerDetailsCreateWithoutSurveyInput, OwnerDetailsUncheckedCreateWithoutSurveyInput>
    where?: OwnerDetailsWhereInput
  }

  export type OwnerDetailsUpdateToOneWithWhereWithoutSurveyInput = {
    where?: OwnerDetailsWhereInput
    data: XOR<OwnerDetailsUpdateWithoutSurveyInput, OwnerDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type OwnerDetailsUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    fatherHusbandName?: StringFieldUpdateOperationsInput | string
    mobileNo?: StringFieldUpdateOperationsInput | string
    aadhaarNo?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    alternateMobile?: NullableStringFieldUpdateOperationsInput | string | null
    isNRI?: BoolFieldUpdateOperationsInput | boolean
    nriAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OwnerDetailsUncheckedUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    fatherHusbandName?: StringFieldUpdateOperationsInput | string
    mobileNo?: StringFieldUpdateOperationsInput | string
    aadhaarNo?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    alternateMobile?: NullableStringFieldUpdateOperationsInput | string | null
    isNRI?: BoolFieldUpdateOperationsInput | boolean
    nriAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationDetailsUpsertWithoutSurveyInput = {
    update: XOR<LocationDetailsUpdateWithoutSurveyInput, LocationDetailsUncheckedUpdateWithoutSurveyInput>
    create: XOR<LocationDetailsCreateWithoutSurveyInput, LocationDetailsUncheckedCreateWithoutSurveyInput>
    where?: LocationDetailsWhereInput
  }

  export type LocationDetailsUpdateToOneWithWhereWithoutSurveyInput = {
    where?: LocationDetailsWhereInput
    data: XOR<LocationDetailsUpdateWithoutSurveyInput, LocationDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type LocationDetailsUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    assessmentYear?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    landmark?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    newWardNo?: StringFieldUpdateOperationsInput | string
    plotArea?: FloatFieldUpdateOperationsInput | number
    builtUpArea?: FloatFieldUpdateOperationsInput | number
    roadType?: RoadTypeMappingUpdateOneRequiredWithoutLocationsNestedInput
    constructionType?: ConstructionTypeMappingUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type LocationDetailsUncheckedUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    assessmentYear?: StringFieldUpdateOperationsInput | string
    roadTypeId?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    landmark?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    newWardNo?: StringFieldUpdateOperationsInput | string
    plotArea?: FloatFieldUpdateOperationsInput | number
    builtUpArea?: FloatFieldUpdateOperationsInput | number
  }

  export type OtherDetailsUpsertWithoutSurveyInput = {
    update: XOR<OtherDetailsUpdateWithoutSurveyInput, OtherDetailsUncheckedUpdateWithoutSurveyInput>
    create: XOR<OtherDetailsCreateWithoutSurveyInput, OtherDetailsUncheckedCreateWithoutSurveyInput>
    where?: OtherDetailsWhereInput
  }

  export type OtherDetailsUpdateToOneWithWhereWithoutSurveyInput = {
    where?: OtherDetailsWhereInput
    data: XOR<OtherDetailsUpdateWithoutSurveyInput, OtherDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type OtherDetailsUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHarvesting?: BoolFieldUpdateOperationsInput | boolean
    waterSupply?: StringFieldUpdateOperationsInput | string
    sewerageLine?: StringFieldUpdateOperationsInput | string
    parkingType?: StringFieldUpdateOperationsInput | string
    parkingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    isCommercial?: BoolFieldUpdateOperationsInput | boolean
    commercialArea?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OtherDetailsUncheckedUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHarvesting?: BoolFieldUpdateOperationsInput | boolean
    waterSupply?: StringFieldUpdateOperationsInput | string
    sewerageLine?: StringFieldUpdateOperationsInput | string
    parkingType?: StringFieldUpdateOperationsInput | string
    parkingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    isCommercial?: BoolFieldUpdateOperationsInput | boolean
    commercialArea?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type FloorDetailsUpsertWithWhereUniqueWithoutSurveyInput = {
    where: FloorDetailsWhereUniqueInput
    update: XOR<FloorDetailsUpdateWithoutSurveyInput, FloorDetailsUncheckedUpdateWithoutSurveyInput>
    create: XOR<FloorDetailsCreateWithoutSurveyInput, FloorDetailsUncheckedCreateWithoutSurveyInput>
  }

  export type FloorDetailsUpdateWithWhereUniqueWithoutSurveyInput = {
    where: FloorDetailsWhereUniqueInput
    data: XOR<FloorDetailsUpdateWithoutSurveyInput, FloorDetailsUncheckedUpdateWithoutSurveyInput>
  }

  export type FloorDetailsUpdateManyWithWhereWithoutSurveyInput = {
    where: FloorDetailsScalarWhereInput
    data: XOR<FloorDetailsUpdateManyMutationInput, FloorDetailsUncheckedUpdateManyWithoutSurveyInput>
  }

  export type FloorDetailsScalarWhereInput = {
    AND?: FloorDetailsScalarWhereInput | FloorDetailsScalarWhereInput[]
    OR?: FloorDetailsScalarWhereInput[]
    NOT?: FloorDetailsScalarWhereInput | FloorDetailsScalarWhereInput[]
    id?: StringFilter<"FloorDetails"> | string
    surveyId?: StringFilter<"FloorDetails"> | string
    floorNo?: IntFilter<"FloorDetails"> | number
    floorType?: StringFilter<"FloorDetails"> | string
    details?: StringFilter<"FloorDetails"> | string
    area?: FloatFilter<"FloorDetails"> | number
    usage?: StringFilter<"FloorDetails"> | string
    isRented?: BoolFilter<"FloorDetails"> | boolean
    rentAmount?: FloatNullableFilter<"FloorDetails"> | number | null
  }

  export type PropertyAssessmentUpsertWithoutSurveyInput = {
    update: XOR<PropertyAssessmentUpdateWithoutSurveyInput, PropertyAssessmentUncheckedUpdateWithoutSurveyInput>
    create: XOR<PropertyAssessmentCreateWithoutSurveyInput, PropertyAssessmentUncheckedCreateWithoutSurveyInput>
    where?: PropertyAssessmentWhereInput
  }

  export type PropertyAssessmentUpdateToOneWithWhereWithoutSurveyInput = {
    where?: PropertyAssessmentWhereInput
    data: XOR<PropertyAssessmentUpdateWithoutSurveyInput, PropertyAssessmentUncheckedUpdateWithoutSurveyInput>
  }

  export type PropertyAssessmentUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    annualRent?: FloatFieldUpdateOperationsInput | number
    marketValue?: FloatFieldUpdateOperationsInput | number
    assessedValue?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NRPropCategoryMappingUpdateOneRequiredWithoutAssessmentsNestedInput
    subCategory?: NRPropSubCategoryMappingUpdateOneRequiredWithoutAssessmentsNestedInput
  }

  export type PropertyAssessmentUncheckedUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: StringFieldUpdateOperationsInput | string
    annualRent?: FloatFieldUpdateOperationsInput | number
    marketValue?: FloatFieldUpdateOperationsInput | number
    assessedValue?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QCRecordUpsertWithoutSurveyInput = {
    update: XOR<QCRecordUpdateWithoutSurveyInput, QCRecordUncheckedUpdateWithoutSurveyInput>
    create: XOR<QCRecordCreateWithoutSurveyInput, QCRecordUncheckedCreateWithoutSurveyInput>
    where?: QCRecordWhereInput
  }

  export type QCRecordUpdateToOneWithWhereWithoutSurveyInput = {
    where?: QCRecordWhereInput
    data: XOR<QCRecordUpdateWithoutSurveyInput, QCRecordUncheckedUpdateWithoutSurveyInput>
  }

  export type QCRecordUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    qcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qcOfficer?: UserUpdateOneRequiredWithoutQcRecordsNestedInput
  }

  export type QCRecordUncheckedUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    qcOfficerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    qcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAttachmentUpsertWithWhereUniqueWithoutSurveyInput = {
    where: PropertyAttachmentWhereUniqueInput
    update: XOR<PropertyAttachmentUpdateWithoutSurveyInput, PropertyAttachmentUncheckedUpdateWithoutSurveyInput>
    create: XOR<PropertyAttachmentCreateWithoutSurveyInput, PropertyAttachmentUncheckedCreateWithoutSurveyInput>
  }

  export type PropertyAttachmentUpdateWithWhereUniqueWithoutSurveyInput = {
    where: PropertyAttachmentWhereUniqueInput
    data: XOR<PropertyAttachmentUpdateWithoutSurveyInput, PropertyAttachmentUncheckedUpdateWithoutSurveyInput>
  }

  export type PropertyAttachmentUpdateManyWithWhereWithoutSurveyInput = {
    where: PropertyAttachmentScalarWhereInput
    data: XOR<PropertyAttachmentUpdateManyMutationInput, PropertyAttachmentUncheckedUpdateManyWithoutSurveyInput>
  }

  export type PropertyAttachmentScalarWhereInput = {
    AND?: PropertyAttachmentScalarWhereInput | PropertyAttachmentScalarWhereInput[]
    OR?: PropertyAttachmentScalarWhereInput[]
    NOT?: PropertyAttachmentScalarWhereInput | PropertyAttachmentScalarWhereInput[]
    id?: StringFilter<"PropertyAttachment"> | string
    surveyId?: StringFilter<"PropertyAttachment"> | string
    type?: StringFilter<"PropertyAttachment"> | string
    url?: StringFilter<"PropertyAttachment"> | string
    description?: StringNullableFilter<"PropertyAttachment"> | string | null
    createdAt?: DateTimeFilter<"PropertyAttachment"> | Date | string
  }

  export type SurveyCreateWithoutPropertyInput = {
    id?: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyor: UserCreateNestedOneWithoutSurveysInput
    ulb: ULBCreateNestedOneWithoutSurveysInput
    zone: ZoneCreateNestedOneWithoutSurveysInput
    ward: WardCreateNestedOneWithoutSurveysInput
    mohalla: MohallaCreateNestedOneWithoutSurveysInput
    owner?: OwnerDetailsCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutPropertyInput = {
    id?: string
    surveyorId: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: OwnerDetailsUncheckedCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsUncheckedCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsUncheckedCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsUncheckedCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentUncheckedCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordUncheckedCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutPropertyInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutPropertyInput, SurveyUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyResponseTypeCreateWithoutSurveysInput = {
    id?: string
    code: string
    description: string
  }

  export type PropertyResponseTypeUncheckedCreateWithoutSurveysInput = {
    id?: string
    code: string
    description: string
  }

  export type PropertyResponseTypeCreateOrConnectWithoutSurveysInput = {
    where: PropertyResponseTypeWhereUniqueInput
    create: XOR<PropertyResponseTypeCreateWithoutSurveysInput, PropertyResponseTypeUncheckedCreateWithoutSurveysInput>
  }

  export type SurveyUpsertWithoutPropertyInput = {
    update: XOR<SurveyUpdateWithoutPropertyInput, SurveyUncheckedUpdateWithoutPropertyInput>
    create: XOR<SurveyCreateWithoutPropertyInput, SurveyUncheckedCreateWithoutPropertyInput>
    where?: SurveyWhereInput
  }

  export type SurveyUpdateToOneWithWhereWithoutPropertyInput = {
    where?: SurveyWhereInput
    data: XOR<SurveyUpdateWithoutPropertyInput, SurveyUncheckedUpdateWithoutPropertyInput>
  }

  export type SurveyUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyor?: UserUpdateOneRequiredWithoutSurveysNestedInput
    ulb?: ULBUpdateOneRequiredWithoutSurveysNestedInput
    zone?: ZoneUpdateOneRequiredWithoutSurveysNestedInput
    ward?: WardUpdateOneRequiredWithoutSurveysNestedInput
    mohalla?: MohallaUpdateOneRequiredWithoutSurveysNestedInput
    owner?: OwnerDetailsUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUncheckedUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUncheckedUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type PropertyResponseTypeUpsertWithoutSurveysInput = {
    update: XOR<PropertyResponseTypeUpdateWithoutSurveysInput, PropertyResponseTypeUncheckedUpdateWithoutSurveysInput>
    create: XOR<PropertyResponseTypeCreateWithoutSurveysInput, PropertyResponseTypeUncheckedCreateWithoutSurveysInput>
    where?: PropertyResponseTypeWhereInput
  }

  export type PropertyResponseTypeUpdateToOneWithWhereWithoutSurveysInput = {
    where?: PropertyResponseTypeWhereInput
    data: XOR<PropertyResponseTypeUpdateWithoutSurveysInput, PropertyResponseTypeUncheckedUpdateWithoutSurveysInput>
  }

  export type PropertyResponseTypeUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyResponseTypeUncheckedUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyCreateWithoutOwnerInput = {
    id?: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyor: UserCreateNestedOneWithoutSurveysInput
    ulb: ULBCreateNestedOneWithoutSurveysInput
    zone: ZoneCreateNestedOneWithoutSurveysInput
    ward: WardCreateNestedOneWithoutSurveysInput
    mohalla: MohallaCreateNestedOneWithoutSurveysInput
    property?: PropertyDetailsCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutOwnerInput = {
    id?: string
    surveyorId: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyDetailsUncheckedCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsUncheckedCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsUncheckedCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsUncheckedCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentUncheckedCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordUncheckedCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutOwnerInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutOwnerInput, SurveyUncheckedCreateWithoutOwnerInput>
  }

  export type SurveyUpsertWithoutOwnerInput = {
    update: XOR<SurveyUpdateWithoutOwnerInput, SurveyUncheckedUpdateWithoutOwnerInput>
    create: XOR<SurveyCreateWithoutOwnerInput, SurveyUncheckedCreateWithoutOwnerInput>
    where?: SurveyWhereInput
  }

  export type SurveyUpdateToOneWithWhereWithoutOwnerInput = {
    where?: SurveyWhereInput
    data: XOR<SurveyUpdateWithoutOwnerInput, SurveyUncheckedUpdateWithoutOwnerInput>
  }

  export type SurveyUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyor?: UserUpdateOneRequiredWithoutSurveysNestedInput
    ulb?: ULBUpdateOneRequiredWithoutSurveysNestedInput
    zone?: ZoneUpdateOneRequiredWithoutSurveysNestedInput
    ward?: WardUpdateOneRequiredWithoutSurveysNestedInput
    mohalla?: MohallaUpdateOneRequiredWithoutSurveysNestedInput
    property?: PropertyDetailsUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUncheckedUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUncheckedUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyCreateWithoutLocationInput = {
    id?: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyor: UserCreateNestedOneWithoutSurveysInput
    ulb: ULBCreateNestedOneWithoutSurveysInput
    zone: ZoneCreateNestedOneWithoutSurveysInput
    ward: WardCreateNestedOneWithoutSurveysInput
    mohalla: MohallaCreateNestedOneWithoutSurveysInput
    property?: PropertyDetailsCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutLocationInput = {
    id?: string
    surveyorId: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyDetailsUncheckedCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsUncheckedCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsUncheckedCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsUncheckedCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentUncheckedCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordUncheckedCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutLocationInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutLocationInput, SurveyUncheckedCreateWithoutLocationInput>
  }

  export type RoadTypeMappingCreateWithoutLocationsInput = {
    id?: string
    code: string
    description: string
  }

  export type RoadTypeMappingUncheckedCreateWithoutLocationsInput = {
    id?: string
    code: string
    description: string
  }

  export type RoadTypeMappingCreateOrConnectWithoutLocationsInput = {
    where: RoadTypeMappingWhereUniqueInput
    create: XOR<RoadTypeMappingCreateWithoutLocationsInput, RoadTypeMappingUncheckedCreateWithoutLocationsInput>
  }

  export type ConstructionTypeMappingCreateWithoutLocationsInput = {
    id?: string
    code: string
    description: string
  }

  export type ConstructionTypeMappingUncheckedCreateWithoutLocationsInput = {
    id?: string
    code: string
    description: string
  }

  export type ConstructionTypeMappingCreateOrConnectWithoutLocationsInput = {
    where: ConstructionTypeMappingWhereUniqueInput
    create: XOR<ConstructionTypeMappingCreateWithoutLocationsInput, ConstructionTypeMappingUncheckedCreateWithoutLocationsInput>
  }

  export type SurveyUpsertWithoutLocationInput = {
    update: XOR<SurveyUpdateWithoutLocationInput, SurveyUncheckedUpdateWithoutLocationInput>
    create: XOR<SurveyCreateWithoutLocationInput, SurveyUncheckedCreateWithoutLocationInput>
    where?: SurveyWhereInput
  }

  export type SurveyUpdateToOneWithWhereWithoutLocationInput = {
    where?: SurveyWhereInput
    data: XOR<SurveyUpdateWithoutLocationInput, SurveyUncheckedUpdateWithoutLocationInput>
  }

  export type SurveyUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyor?: UserUpdateOneRequiredWithoutSurveysNestedInput
    ulb?: ULBUpdateOneRequiredWithoutSurveysNestedInput
    zone?: ZoneUpdateOneRequiredWithoutSurveysNestedInput
    ward?: WardUpdateOneRequiredWithoutSurveysNestedInput
    mohalla?: MohallaUpdateOneRequiredWithoutSurveysNestedInput
    property?: PropertyDetailsUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUncheckedUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUncheckedUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type RoadTypeMappingUpsertWithoutLocationsInput = {
    update: XOR<RoadTypeMappingUpdateWithoutLocationsInput, RoadTypeMappingUncheckedUpdateWithoutLocationsInput>
    create: XOR<RoadTypeMappingCreateWithoutLocationsInput, RoadTypeMappingUncheckedCreateWithoutLocationsInput>
    where?: RoadTypeMappingWhereInput
  }

  export type RoadTypeMappingUpdateToOneWithWhereWithoutLocationsInput = {
    where?: RoadTypeMappingWhereInput
    data: XOR<RoadTypeMappingUpdateWithoutLocationsInput, RoadTypeMappingUncheckedUpdateWithoutLocationsInput>
  }

  export type RoadTypeMappingUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RoadTypeMappingUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ConstructionTypeMappingUpsertWithoutLocationsInput = {
    update: XOR<ConstructionTypeMappingUpdateWithoutLocationsInput, ConstructionTypeMappingUncheckedUpdateWithoutLocationsInput>
    create: XOR<ConstructionTypeMappingCreateWithoutLocationsInput, ConstructionTypeMappingUncheckedCreateWithoutLocationsInput>
    where?: ConstructionTypeMappingWhereInput
  }

  export type ConstructionTypeMappingUpdateToOneWithWhereWithoutLocationsInput = {
    where?: ConstructionTypeMappingWhereInput
    data: XOR<ConstructionTypeMappingUpdateWithoutLocationsInput, ConstructionTypeMappingUncheckedUpdateWithoutLocationsInput>
  }

  export type ConstructionTypeMappingUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ConstructionTypeMappingUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyCreateWithoutOtherInput = {
    id?: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyor: UserCreateNestedOneWithoutSurveysInput
    ulb: ULBCreateNestedOneWithoutSurveysInput
    zone: ZoneCreateNestedOneWithoutSurveysInput
    ward: WardCreateNestedOneWithoutSurveysInput
    mohalla: MohallaCreateNestedOneWithoutSurveysInput
    property?: PropertyDetailsCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutOtherInput = {
    id?: string
    surveyorId: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyDetailsUncheckedCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsUncheckedCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsUncheckedCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsUncheckedCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentUncheckedCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordUncheckedCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutOtherInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutOtherInput, SurveyUncheckedCreateWithoutOtherInput>
  }

  export type SurveyUpsertWithoutOtherInput = {
    update: XOR<SurveyUpdateWithoutOtherInput, SurveyUncheckedUpdateWithoutOtherInput>
    create: XOR<SurveyCreateWithoutOtherInput, SurveyUncheckedCreateWithoutOtherInput>
    where?: SurveyWhereInput
  }

  export type SurveyUpdateToOneWithWhereWithoutOtherInput = {
    where?: SurveyWhereInput
    data: XOR<SurveyUpdateWithoutOtherInput, SurveyUncheckedUpdateWithoutOtherInput>
  }

  export type SurveyUpdateWithoutOtherInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyor?: UserUpdateOneRequiredWithoutSurveysNestedInput
    ulb?: ULBUpdateOneRequiredWithoutSurveysNestedInput
    zone?: ZoneUpdateOneRequiredWithoutSurveysNestedInput
    ward?: WardUpdateOneRequiredWithoutSurveysNestedInput
    mohalla?: MohallaUpdateOneRequiredWithoutSurveysNestedInput
    property?: PropertyDetailsUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutOtherInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUncheckedUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUncheckedUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyCreateWithoutFloorsInput = {
    id?: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyor: UserCreateNestedOneWithoutSurveysInput
    ulb: ULBCreateNestedOneWithoutSurveysInput
    zone: ZoneCreateNestedOneWithoutSurveysInput
    ward: WardCreateNestedOneWithoutSurveysInput
    mohalla: MohallaCreateNestedOneWithoutSurveysInput
    property?: PropertyDetailsCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsCreateNestedOneWithoutSurveyInput
    assessment?: PropertyAssessmentCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutFloorsInput = {
    id?: string
    surveyorId: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyDetailsUncheckedCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsUncheckedCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsUncheckedCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsUncheckedCreateNestedOneWithoutSurveyInput
    assessment?: PropertyAssessmentUncheckedCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordUncheckedCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutFloorsInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutFloorsInput, SurveyUncheckedCreateWithoutFloorsInput>
  }

  export type SurveyUpsertWithoutFloorsInput = {
    update: XOR<SurveyUpdateWithoutFloorsInput, SurveyUncheckedUpdateWithoutFloorsInput>
    create: XOR<SurveyCreateWithoutFloorsInput, SurveyUncheckedCreateWithoutFloorsInput>
    where?: SurveyWhereInput
  }

  export type SurveyUpdateToOneWithWhereWithoutFloorsInput = {
    where?: SurveyWhereInput
    data: XOR<SurveyUpdateWithoutFloorsInput, SurveyUncheckedUpdateWithoutFloorsInput>
  }

  export type SurveyUpdateWithoutFloorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyor?: UserUpdateOneRequiredWithoutSurveysNestedInput
    ulb?: ULBUpdateOneRequiredWithoutSurveysNestedInput
    zone?: ZoneUpdateOneRequiredWithoutSurveysNestedInput
    ward?: WardUpdateOneRequiredWithoutSurveysNestedInput
    mohalla?: MohallaUpdateOneRequiredWithoutSurveysNestedInput
    property?: PropertyDetailsUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUpdateOneWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutFloorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUncheckedUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUncheckedUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyCreateWithoutAssessmentInput = {
    id?: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyor: UserCreateNestedOneWithoutSurveysInput
    ulb: ULBCreateNestedOneWithoutSurveysInput
    zone: ZoneCreateNestedOneWithoutSurveysInput
    ward: WardCreateNestedOneWithoutSurveysInput
    mohalla: MohallaCreateNestedOneWithoutSurveysInput
    property?: PropertyDetailsCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsCreateNestedManyWithoutSurveyInput
    qcRecord?: QCRecordCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutAssessmentInput = {
    id?: string
    surveyorId: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyDetailsUncheckedCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsUncheckedCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsUncheckedCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsUncheckedCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsUncheckedCreateNestedManyWithoutSurveyInput
    qcRecord?: QCRecordUncheckedCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutAssessmentInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutAssessmentInput, SurveyUncheckedCreateWithoutAssessmentInput>
  }

  export type NRPropCategoryMappingCreateWithoutAssessmentsInput = {
    id?: string
    code: string
    description: string
    subCategories?: NRPropSubCategoryMappingCreateNestedManyWithoutCategoryInput
  }

  export type NRPropCategoryMappingUncheckedCreateWithoutAssessmentsInput = {
    id?: string
    code: string
    description: string
    subCategories?: NRPropSubCategoryMappingUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type NRPropCategoryMappingCreateOrConnectWithoutAssessmentsInput = {
    where: NRPropCategoryMappingWhereUniqueInput
    create: XOR<NRPropCategoryMappingCreateWithoutAssessmentsInput, NRPropCategoryMappingUncheckedCreateWithoutAssessmentsInput>
  }

  export type NRPropSubCategoryMappingCreateWithoutAssessmentsInput = {
    id?: string
    code: string
    description: string
    category: NRPropCategoryMappingCreateNestedOneWithoutSubCategoriesInput
  }

  export type NRPropSubCategoryMappingUncheckedCreateWithoutAssessmentsInput = {
    id?: string
    code: string
    description: string
    categoryId: string
  }

  export type NRPropSubCategoryMappingCreateOrConnectWithoutAssessmentsInput = {
    where: NRPropSubCategoryMappingWhereUniqueInput
    create: XOR<NRPropSubCategoryMappingCreateWithoutAssessmentsInput, NRPropSubCategoryMappingUncheckedCreateWithoutAssessmentsInput>
  }

  export type SurveyUpsertWithoutAssessmentInput = {
    update: XOR<SurveyUpdateWithoutAssessmentInput, SurveyUncheckedUpdateWithoutAssessmentInput>
    create: XOR<SurveyCreateWithoutAssessmentInput, SurveyUncheckedCreateWithoutAssessmentInput>
    where?: SurveyWhereInput
  }

  export type SurveyUpdateToOneWithWhereWithoutAssessmentInput = {
    where?: SurveyWhereInput
    data: XOR<SurveyUpdateWithoutAssessmentInput, SurveyUncheckedUpdateWithoutAssessmentInput>
  }

  export type SurveyUpdateWithoutAssessmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyor?: UserUpdateOneRequiredWithoutSurveysNestedInput
    ulb?: ULBUpdateOneRequiredWithoutSurveysNestedInput
    zone?: ZoneUpdateOneRequiredWithoutSurveysNestedInput
    ward?: WardUpdateOneRequiredWithoutSurveysNestedInput
    mohalla?: MohallaUpdateOneRequiredWithoutSurveysNestedInput
    property?: PropertyDetailsUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUpdateManyWithoutSurveyNestedInput
    qcRecord?: QCRecordUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutAssessmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    qcRecord?: QCRecordUncheckedUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type NRPropCategoryMappingUpsertWithoutAssessmentsInput = {
    update: XOR<NRPropCategoryMappingUpdateWithoutAssessmentsInput, NRPropCategoryMappingUncheckedUpdateWithoutAssessmentsInput>
    create: XOR<NRPropCategoryMappingCreateWithoutAssessmentsInput, NRPropCategoryMappingUncheckedCreateWithoutAssessmentsInput>
    where?: NRPropCategoryMappingWhereInput
  }

  export type NRPropCategoryMappingUpdateToOneWithWhereWithoutAssessmentsInput = {
    where?: NRPropCategoryMappingWhereInput
    data: XOR<NRPropCategoryMappingUpdateWithoutAssessmentsInput, NRPropCategoryMappingUncheckedUpdateWithoutAssessmentsInput>
  }

  export type NRPropCategoryMappingUpdateWithoutAssessmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subCategories?: NRPropSubCategoryMappingUpdateManyWithoutCategoryNestedInput
  }

  export type NRPropCategoryMappingUncheckedUpdateWithoutAssessmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subCategories?: NRPropSubCategoryMappingUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type NRPropSubCategoryMappingUpsertWithoutAssessmentsInput = {
    update: XOR<NRPropSubCategoryMappingUpdateWithoutAssessmentsInput, NRPropSubCategoryMappingUncheckedUpdateWithoutAssessmentsInput>
    create: XOR<NRPropSubCategoryMappingCreateWithoutAssessmentsInput, NRPropSubCategoryMappingUncheckedCreateWithoutAssessmentsInput>
    where?: NRPropSubCategoryMappingWhereInput
  }

  export type NRPropSubCategoryMappingUpdateToOneWithWhereWithoutAssessmentsInput = {
    where?: NRPropSubCategoryMappingWhereInput
    data: XOR<NRPropSubCategoryMappingUpdateWithoutAssessmentsInput, NRPropSubCategoryMappingUncheckedUpdateWithoutAssessmentsInput>
  }

  export type NRPropSubCategoryMappingUpdateWithoutAssessmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NRPropCategoryMappingUpdateOneRequiredWithoutSubCategoriesNestedInput
  }

  export type NRPropSubCategoryMappingUncheckedUpdateWithoutAssessmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyCreateWithoutQcRecordInput = {
    id?: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyor: UserCreateNestedOneWithoutSurveysInput
    ulb: ULBCreateNestedOneWithoutSurveysInput
    zone: ZoneCreateNestedOneWithoutSurveysInput
    ward: WardCreateNestedOneWithoutSurveysInput
    mohalla: MohallaCreateNestedOneWithoutSurveysInput
    property?: PropertyDetailsCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutQcRecordInput = {
    id?: string
    surveyorId: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyDetailsUncheckedCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsUncheckedCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsUncheckedCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsUncheckedCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsUncheckedCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentUncheckedCreateNestedOneWithoutSurveyInput
    attachments?: PropertyAttachmentUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutQcRecordInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutQcRecordInput, SurveyUncheckedCreateWithoutQcRecordInput>
  }

  export type UserCreateWithoutQcRecordsInput = {
    id?: string
    username: string
    password: string
    role: string
    phoneNumber: string
    assignedWards?: UserCreateassignedWardsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    surveys?: SurveyCreateNestedManyWithoutSurveyorInput
  }

  export type UserUncheckedCreateWithoutQcRecordsInput = {
    id?: string
    username: string
    password: string
    role: string
    phoneNumber: string
    assignedWards?: UserCreateassignedWardsInput | string[]
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSurveyorInput
  }

  export type UserCreateOrConnectWithoutQcRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQcRecordsInput, UserUncheckedCreateWithoutQcRecordsInput>
  }

  export type SurveyUpsertWithoutQcRecordInput = {
    update: XOR<SurveyUpdateWithoutQcRecordInput, SurveyUncheckedUpdateWithoutQcRecordInput>
    create: XOR<SurveyCreateWithoutQcRecordInput, SurveyUncheckedCreateWithoutQcRecordInput>
    where?: SurveyWhereInput
  }

  export type SurveyUpdateToOneWithWhereWithoutQcRecordInput = {
    where?: SurveyWhereInput
    data: XOR<SurveyUpdateWithoutQcRecordInput, SurveyUncheckedUpdateWithoutQcRecordInput>
  }

  export type SurveyUpdateWithoutQcRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyor?: UserUpdateOneRequiredWithoutSurveysNestedInput
    ulb?: ULBUpdateOneRequiredWithoutSurveysNestedInput
    zone?: ZoneUpdateOneRequiredWithoutSurveysNestedInput
    ward?: WardUpdateOneRequiredWithoutSurveysNestedInput
    mohalla?: MohallaUpdateOneRequiredWithoutSurveysNestedInput
    property?: PropertyDetailsUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutQcRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUncheckedUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type UserUpsertWithoutQcRecordsInput = {
    update: XOR<UserUpdateWithoutQcRecordsInput, UserUncheckedUpdateWithoutQcRecordsInput>
    create: XOR<UserCreateWithoutQcRecordsInput, UserUncheckedCreateWithoutQcRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQcRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQcRecordsInput, UserUncheckedUpdateWithoutQcRecordsInput>
  }

  export type UserUpdateWithoutQcRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    assignedWards?: UserUpdateassignedWardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    surveys?: SurveyUpdateManyWithoutSurveyorNestedInput
  }

  export type UserUncheckedUpdateWithoutQcRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    assignedWards?: UserUpdateassignedWardsInput | string[]
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSurveyorNestedInput
  }

  export type SurveyCreateWithoutAttachmentsInput = {
    id?: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyor: UserCreateNestedOneWithoutSurveysInput
    ulb: ULBCreateNestedOneWithoutSurveysInput
    zone: ZoneCreateNestedOneWithoutSurveysInput
    ward: WardCreateNestedOneWithoutSurveysInput
    mohalla: MohallaCreateNestedOneWithoutSurveysInput
    property?: PropertyDetailsCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordCreateNestedOneWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    surveyorId: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyDetailsUncheckedCreateNestedOneWithoutSurveyInput
    owner?: OwnerDetailsUncheckedCreateNestedOneWithoutSurveyInput
    location?: LocationDetailsUncheckedCreateNestedOneWithoutSurveyInput
    other?: OtherDetailsUncheckedCreateNestedOneWithoutSurveyInput
    floors?: FloorDetailsUncheckedCreateNestedManyWithoutSurveyInput
    assessment?: PropertyAssessmentUncheckedCreateNestedOneWithoutSurveyInput
    qcRecord?: QCRecordUncheckedCreateNestedOneWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutAttachmentsInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutAttachmentsInput, SurveyUncheckedCreateWithoutAttachmentsInput>
  }

  export type SurveyUpsertWithoutAttachmentsInput = {
    update: XOR<SurveyUpdateWithoutAttachmentsInput, SurveyUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<SurveyCreateWithoutAttachmentsInput, SurveyUncheckedCreateWithoutAttachmentsInput>
    where?: SurveyWhereInput
  }

  export type SurveyUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: SurveyWhereInput
    data: XOR<SurveyUpdateWithoutAttachmentsInput, SurveyUncheckedUpdateWithoutAttachmentsInput>
  }

  export type SurveyUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyor?: UserUpdateOneRequiredWithoutSurveysNestedInput
    ulb?: ULBUpdateOneRequiredWithoutSurveysNestedInput
    zone?: ZoneUpdateOneRequiredWithoutSurveysNestedInput
    ward?: WardUpdateOneRequiredWithoutSurveysNestedInput
    mohalla?: MohallaUpdateOneRequiredWithoutSurveysNestedInput
    property?: PropertyDetailsUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUpdateOneWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUncheckedUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUncheckedUpdateOneWithoutSurveyNestedInput
  }

  export type UserCreateManyCreatedByInput = {
    id?: string
    username: string
    password: string
    role: string
    phoneNumber: string
    assignedWards?: UserCreateassignedWardsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyCreateManySurveyorInput = {
    id?: string
    ulbId: string
    zoneId: string
    wardId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QCRecordCreateManyQcOfficerInput = {
    id?: string
    surveyId: string
    status: string
    remarks?: string | null
    qcDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    assignedWards?: UserUpdateassignedWardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    surveys?: SurveyUpdateManyWithoutSurveyorNestedInput
    qcRecords?: QCRecordUpdateManyWithoutQcOfficerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    assignedWards?: UserUpdateassignedWardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSurveyorNestedInput
    qcRecords?: QCRecordUncheckedUpdateManyWithoutQcOfficerNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    assignedWards?: UserUpdateassignedWardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyUpdateWithoutSurveyorInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ulb?: ULBUpdateOneRequiredWithoutSurveysNestedInput
    zone?: ZoneUpdateOneRequiredWithoutSurveysNestedInput
    ward?: WardUpdateOneRequiredWithoutSurveysNestedInput
    mohalla?: MohallaUpdateOneRequiredWithoutSurveysNestedInput
    property?: PropertyDetailsUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutSurveyorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUncheckedUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUncheckedUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateManyWithoutSurveyorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QCRecordUpdateWithoutQcOfficerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    qcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    survey?: SurveyUpdateOneRequiredWithoutQcRecordNestedInput
  }

  export type QCRecordUncheckedUpdateWithoutQcOfficerInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    qcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QCRecordUncheckedUpdateManyWithoutQcOfficerInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    qcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneCreateManyUlbInput = {
    id?: string
    name: string
  }

  export type SurveyCreateManyUlbInput = {
    id?: string
    surveyorId: string
    zoneId: string
    wardId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneUpdateWithoutUlbInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    wards?: WardUpdateManyWithoutZoneNestedInput
    surveys?: SurveyUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutUlbInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    wards?: WardUncheckedUpdateManyWithoutZoneNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateManyWithoutUlbInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyUpdateWithoutUlbInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyor?: UserUpdateOneRequiredWithoutSurveysNestedInput
    zone?: ZoneUpdateOneRequiredWithoutSurveysNestedInput
    ward?: WardUpdateOneRequiredWithoutSurveysNestedInput
    mohalla?: MohallaUpdateOneRequiredWithoutSurveysNestedInput
    property?: PropertyDetailsUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutUlbInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUncheckedUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUncheckedUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateManyWithoutUlbInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WardCreateManyZoneInput = {
    id?: string
    name: string
  }

  export type SurveyCreateManyZoneInput = {
    id?: string
    surveyorId: string
    ulbId: string
    wardId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WardUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mohallas?: MohallaUpdateManyWithoutWardNestedInput
    surveys?: SurveyUpdateManyWithoutWardNestedInput
  }

  export type WardUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mohallas?: MohallaUncheckedUpdateManyWithoutWardNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutWardNestedInput
  }

  export type WardUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyor?: UserUpdateOneRequiredWithoutSurveysNestedInput
    ulb?: ULBUpdateOneRequiredWithoutSurveysNestedInput
    ward?: WardUpdateOneRequiredWithoutSurveysNestedInput
    mohalla?: MohallaUpdateOneRequiredWithoutSurveysNestedInput
    property?: PropertyDetailsUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUncheckedUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUncheckedUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MohallaCreateManyWardInput = {
    id?: string
    name: string
  }

  export type SurveyCreateManyWardInput = {
    id?: string
    surveyorId: string
    ulbId: string
    zoneId: string
    mohallaId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MohallaUpdateWithoutWardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surveys?: SurveyUpdateManyWithoutMohallaNestedInput
  }

  export type MohallaUncheckedUpdateWithoutWardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surveys?: SurveyUncheckedUpdateManyWithoutMohallaNestedInput
  }

  export type MohallaUncheckedUpdateManyWithoutWardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyUpdateWithoutWardInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyor?: UserUpdateOneRequiredWithoutSurveysNestedInput
    ulb?: ULBUpdateOneRequiredWithoutSurveysNestedInput
    zone?: ZoneUpdateOneRequiredWithoutSurveysNestedInput
    mohalla?: MohallaUpdateOneRequiredWithoutSurveysNestedInput
    property?: PropertyDetailsUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutWardInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUncheckedUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUncheckedUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateManyWithoutWardInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    mohallaId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyCreateManyMohallaInput = {
    id?: string
    surveyorId: string
    ulbId: string
    zoneId: string
    wardId: string
    dateOfEntry: Date | string
    gisId: string
    mapId: string
    subGisId: string
    propertyType: $Enums.PropertyType
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyUpdateWithoutMohallaInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyor?: UserUpdateOneRequiredWithoutSurveysNestedInput
    ulb?: ULBUpdateOneRequiredWithoutSurveysNestedInput
    zone?: ZoneUpdateOneRequiredWithoutSurveysNestedInput
    ward?: WardUpdateOneRequiredWithoutSurveysNestedInput
    property?: PropertyDetailsUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutMohallaInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    owner?: OwnerDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    location?: LocationDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    other?: OtherDetailsUncheckedUpdateOneWithoutSurveyNestedInput
    floors?: FloorDetailsUncheckedUpdateManyWithoutSurveyNestedInput
    assessment?: PropertyAssessmentUncheckedUpdateOneWithoutSurveyNestedInput
    qcRecord?: QCRecordUncheckedUpdateOneWithoutSurveyNestedInput
    attachments?: PropertyAttachmentUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateManyWithoutMohallaInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyorId?: StringFieldUpdateOperationsInput | string
    ulbId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    dateOfEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    gisId?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    subGisId?: StringFieldUpdateOperationsInput | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyDetailsCreateManyResponseTypeInput = {
    id?: string
    surveyId: string
    houseNumber: string
    electricityNo: string
    wardSewerageNo: string
    respondentName: string
    isRented?: boolean
    rentAmount?: number | null
    tenantName?: string | null
    tenantMobile?: string | null
    tenantAadhaar?: string | null
  }

  export type PropertyDetailsUpdateWithoutResponseTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    electricityNo?: StringFieldUpdateOperationsInput | string
    wardSewerageNo?: StringFieldUpdateOperationsInput | string
    respondentName?: StringFieldUpdateOperationsInput | string
    isRented?: BoolFieldUpdateOperationsInput | boolean
    rentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantName?: NullableStringFieldUpdateOperationsInput | string | null
    tenantMobile?: NullableStringFieldUpdateOperationsInput | string | null
    tenantAadhaar?: NullableStringFieldUpdateOperationsInput | string | null
    survey?: SurveyUpdateOneRequiredWithoutPropertyNestedInput
  }

  export type PropertyDetailsUncheckedUpdateWithoutResponseTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    electricityNo?: StringFieldUpdateOperationsInput | string
    wardSewerageNo?: StringFieldUpdateOperationsInput | string
    respondentName?: StringFieldUpdateOperationsInput | string
    isRented?: BoolFieldUpdateOperationsInput | boolean
    rentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantName?: NullableStringFieldUpdateOperationsInput | string | null
    tenantMobile?: NullableStringFieldUpdateOperationsInput | string | null
    tenantAadhaar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyDetailsUncheckedUpdateManyWithoutResponseTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    electricityNo?: StringFieldUpdateOperationsInput | string
    wardSewerageNo?: StringFieldUpdateOperationsInput | string
    respondentName?: StringFieldUpdateOperationsInput | string
    isRented?: BoolFieldUpdateOperationsInput | boolean
    rentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantName?: NullableStringFieldUpdateOperationsInput | string | null
    tenantMobile?: NullableStringFieldUpdateOperationsInput | string | null
    tenantAadhaar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationDetailsCreateManyRoadTypeInput = {
    id?: string
    surveyId: string
    latitude: number
    longitude: number
    assessmentYear: string
    constructionYear: string
    constructionTypeId: string
    landmark: string
    address: string
    newWardNo: string
    plotArea: number
    builtUpArea: number
  }

  export type LocationDetailsUpdateWithoutRoadTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    assessmentYear?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    landmark?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    newWardNo?: StringFieldUpdateOperationsInput | string
    plotArea?: FloatFieldUpdateOperationsInput | number
    builtUpArea?: FloatFieldUpdateOperationsInput | number
    survey?: SurveyUpdateOneRequiredWithoutLocationNestedInput
    constructionType?: ConstructionTypeMappingUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type LocationDetailsUncheckedUpdateWithoutRoadTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    assessmentYear?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    landmark?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    newWardNo?: StringFieldUpdateOperationsInput | string
    plotArea?: FloatFieldUpdateOperationsInput | number
    builtUpArea?: FloatFieldUpdateOperationsInput | number
  }

  export type LocationDetailsUncheckedUpdateManyWithoutRoadTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    assessmentYear?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    constructionTypeId?: StringFieldUpdateOperationsInput | string
    landmark?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    newWardNo?: StringFieldUpdateOperationsInput | string
    plotArea?: FloatFieldUpdateOperationsInput | number
    builtUpArea?: FloatFieldUpdateOperationsInput | number
  }

  export type LocationDetailsCreateManyConstructionTypeInput = {
    id?: string
    surveyId: string
    latitude: number
    longitude: number
    assessmentYear: string
    roadTypeId: string
    constructionYear: string
    landmark: string
    address: string
    newWardNo: string
    plotArea: number
    builtUpArea: number
  }

  export type LocationDetailsUpdateWithoutConstructionTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    assessmentYear?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    landmark?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    newWardNo?: StringFieldUpdateOperationsInput | string
    plotArea?: FloatFieldUpdateOperationsInput | number
    builtUpArea?: FloatFieldUpdateOperationsInput | number
    survey?: SurveyUpdateOneRequiredWithoutLocationNestedInput
    roadType?: RoadTypeMappingUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type LocationDetailsUncheckedUpdateWithoutConstructionTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    assessmentYear?: StringFieldUpdateOperationsInput | string
    roadTypeId?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    landmark?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    newWardNo?: StringFieldUpdateOperationsInput | string
    plotArea?: FloatFieldUpdateOperationsInput | number
    builtUpArea?: FloatFieldUpdateOperationsInput | number
  }

  export type LocationDetailsUncheckedUpdateManyWithoutConstructionTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    assessmentYear?: StringFieldUpdateOperationsInput | string
    roadTypeId?: StringFieldUpdateOperationsInput | string
    constructionYear?: StringFieldUpdateOperationsInput | string
    landmark?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    newWardNo?: StringFieldUpdateOperationsInput | string
    plotArea?: FloatFieldUpdateOperationsInput | number
    builtUpArea?: FloatFieldUpdateOperationsInput | number
  }

  export type NRPropSubCategoryMappingCreateManyCategoryInput = {
    id?: string
    code: string
    description: string
  }

  export type PropertyAssessmentCreateManyCategoryInput = {
    id?: string
    surveyId: string
    subCategoryId: string
    annualRent: number
    marketValue: number
    assessedValue: number
    taxAmount: number
    remarks?: string | null
  }

  export type NRPropSubCategoryMappingUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    assessments?: PropertyAssessmentUpdateManyWithoutSubCategoryNestedInput
  }

  export type NRPropSubCategoryMappingUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    assessments?: PropertyAssessmentUncheckedUpdateManyWithoutSubCategoryNestedInput
  }

  export type NRPropSubCategoryMappingUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyAssessmentUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    annualRent?: FloatFieldUpdateOperationsInput | number
    marketValue?: FloatFieldUpdateOperationsInput | number
    assessedValue?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    survey?: SurveyUpdateOneRequiredWithoutAssessmentNestedInput
    subCategory?: NRPropSubCategoryMappingUpdateOneRequiredWithoutAssessmentsNestedInput
  }

  export type PropertyAssessmentUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: StringFieldUpdateOperationsInput | string
    annualRent?: FloatFieldUpdateOperationsInput | number
    marketValue?: FloatFieldUpdateOperationsInput | number
    assessedValue?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyAssessmentUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: StringFieldUpdateOperationsInput | string
    annualRent?: FloatFieldUpdateOperationsInput | number
    marketValue?: FloatFieldUpdateOperationsInput | number
    assessedValue?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyAssessmentCreateManySubCategoryInput = {
    id?: string
    surveyId: string
    categoryId: string
    annualRent: number
    marketValue: number
    assessedValue: number
    taxAmount: number
    remarks?: string | null
  }

  export type PropertyAssessmentUpdateWithoutSubCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    annualRent?: FloatFieldUpdateOperationsInput | number
    marketValue?: FloatFieldUpdateOperationsInput | number
    assessedValue?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    survey?: SurveyUpdateOneRequiredWithoutAssessmentNestedInput
    category?: NRPropCategoryMappingUpdateOneRequiredWithoutAssessmentsNestedInput
  }

  export type PropertyAssessmentUncheckedUpdateWithoutSubCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    annualRent?: FloatFieldUpdateOperationsInput | number
    marketValue?: FloatFieldUpdateOperationsInput | number
    assessedValue?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyAssessmentUncheckedUpdateManyWithoutSubCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    annualRent?: FloatFieldUpdateOperationsInput | number
    marketValue?: FloatFieldUpdateOperationsInput | number
    assessedValue?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FloorDetailsCreateManySurveyInput = {
    id?: string
    floorNo: number
    floorType: string
    details: string
    area: number
    usage: string
    isRented?: boolean
    rentAmount?: number | null
  }

  export type PropertyAttachmentCreateManySurveyInput = {
    id?: string
    type: string
    url: string
    description?: string | null
    createdAt?: Date | string
  }

  export type FloorDetailsUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    floorNo?: IntFieldUpdateOperationsInput | number
    floorType?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    usage?: StringFieldUpdateOperationsInput | string
    isRented?: BoolFieldUpdateOperationsInput | boolean
    rentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type FloorDetailsUncheckedUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    floorNo?: IntFieldUpdateOperationsInput | number
    floorType?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    usage?: StringFieldUpdateOperationsInput | string
    isRented?: BoolFieldUpdateOperationsInput | boolean
    rentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type FloorDetailsUncheckedUpdateManyWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    floorNo?: IntFieldUpdateOperationsInput | number
    floorType?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    usage?: StringFieldUpdateOperationsInput | string
    isRented?: BoolFieldUpdateOperationsInput | boolean
    rentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PropertyAttachmentUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAttachmentUncheckedUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAttachmentUncheckedUpdateManyWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ULBCountOutputTypeDefaultArgs instead
     */
    export type ULBCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ULBCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZoneCountOutputTypeDefaultArgs instead
     */
    export type ZoneCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZoneCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WardCountOutputTypeDefaultArgs instead
     */
    export type WardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MohallaCountOutputTypeDefaultArgs instead
     */
    export type MohallaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MohallaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyResponseTypeCountOutputTypeDefaultArgs instead
     */
    export type PropertyResponseTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyResponseTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadTypeMappingCountOutputTypeDefaultArgs instead
     */
    export type RoadTypeMappingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadTypeMappingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConstructionTypeMappingCountOutputTypeDefaultArgs instead
     */
    export type ConstructionTypeMappingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConstructionTypeMappingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NRPropCategoryMappingCountOutputTypeDefaultArgs instead
     */
    export type NRPropCategoryMappingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NRPropCategoryMappingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NRPropSubCategoryMappingCountOutputTypeDefaultArgs instead
     */
    export type NRPropSubCategoryMappingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NRPropSubCategoryMappingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SurveyCountOutputTypeDefaultArgs instead
     */
    export type SurveyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SurveyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ULBDefaultArgs instead
     */
    export type ULBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ULBDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZoneDefaultArgs instead
     */
    export type ZoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZoneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WardDefaultArgs instead
     */
    export type WardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MohallaDefaultArgs instead
     */
    export type MohallaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MohallaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyResponseTypeDefaultArgs instead
     */
    export type PropertyResponseTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyResponseTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadTypeMappingDefaultArgs instead
     */
    export type RoadTypeMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadTypeMappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConstructionTypeMappingDefaultArgs instead
     */
    export type ConstructionTypeMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConstructionTypeMappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NRPropCategoryMappingDefaultArgs instead
     */
    export type NRPropCategoryMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NRPropCategoryMappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NRPropSubCategoryMappingDefaultArgs instead
     */
    export type NRPropSubCategoryMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NRPropSubCategoryMappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SurveyDefaultArgs instead
     */
    export type SurveyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SurveyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyDetailsDefaultArgs instead
     */
    export type PropertyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OwnerDetailsDefaultArgs instead
     */
    export type OwnerDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OwnerDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationDetailsDefaultArgs instead
     */
    export type LocationDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OtherDetailsDefaultArgs instead
     */
    export type OtherDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OtherDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FloorDetailsDefaultArgs instead
     */
    export type FloorDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FloorDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyAssessmentDefaultArgs instead
     */
    export type PropertyAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyAssessmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QCRecordDefaultArgs instead
     */
    export type QCRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QCRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyAttachmentDefaultArgs instead
     */
    export type PropertyAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyAttachmentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}